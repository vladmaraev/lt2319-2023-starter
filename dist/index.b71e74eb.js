// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"2oZg2":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "5c1b77e3b71e74eb";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"h7u1C":[function(require,module,exports) {
var _xstate = require("xstate");
var _speechstate = require("speechstate");
const azureCredentials = {
    endpoint: "https://northeurope.api.cognitive.microsoft.com/sts/v1.0/issuetoken",
    key: "9cd3cbcc05da4e198c3ba6b680d52ec4"
};
const settings = {
    azureCredentials: azureCredentials,
    asrDefaultCompleteTimeout: 0,
    locale: "en-US",
    asrDefaultNoInputTimeout: 5000,
    ttsDefaultVoice: "en-US-EricNeural"
};
// helper functions
const say = (text)=>({ context })=>{
        context.spstRef.send({
            type: "SPEAK",
            value: {
                utterance: text
            }
        });
    };
const listen = ()=>({ context })=>context.spstRef.send({
            type: "LISTEN"
        });
//interface Grammar {
//  [index: string]: {
//    entities: {
//      [index: string]: string;
//    };
//   },
//  };
//movie ticket booking --> slots: movie name, date, showtime [extra: num of tickets, seat number]
// This function converts the input sentence to lowecase, removes any period at the end of the sentence and splits it
// into an array of words (wordsInSent). If target word in sentence --> True, else --> False
//const checkWordExists = (targetWord: string, inputSentence: string) => {
//  const wordsInSent = inputSentence.toLowerCase().replace(/\.$/g, "").split(/\s+/);
//  console.log(targetWord, wordsInSent);
//  return wordsInSent.includes(targetWord);
//};
//const grammar2 = {
//    entities: {
//      movie: "titanic",
//      date: "friday",
//      showtime: "7:00",
//    },
//  }
const grammar = {
    entities: {
        movie: [
            "barbie",
            "titanic",
            "avatar"
        ],
        date: [
            "tonight",
            "tomorrow",
            "friday"
        ],
        showtime: [
            "7:00",
            "7 pm",
            "10:00"
        ]
    }
};
//var list = grammar.entities.movie;
//for (var elem of list) {
//  console.log(elem);
//}
//const checkWordExists2 = (entity: string, inputSentence: string) => {
//  const cleanedInput = inputSentence.toLowerCase().replace(/\.$/g, "").split(/\s+/);
//  console.log(cleanedInput)
//  var listEntity = grammar2.entities[entity];
//  for (var word of listEntity) {
//    //const cleanedInput = inputSentence.toLowerCase().replace(/\.$/g, "");
//    for (var token of cleanedInput) {
//      if (word.match(token)) {
//        return true;
//    }
//    }
//  }
//
//  return false;
//  //if (word in grammar.entities[entity]) {
//    //const matchingWord = grammar.entities[entity].find(word =>
//      //cleanedInput.includes(word.toLowerCase())
//    //);
//    
//    //return true;
//  //}
//  //return false; // Return false if the entity is not found or no matching word
//};
//const checkWordExists3 = (entity: string, inputSentence: string, returnWord = false) => {
//  const cleanedInput = inputSentence.toLowerCase().replace(/\.$/g, "").split(/\s+/);
//  const entityList = grammar.entities[entity];
//  let matchingWord = "";
//
//  for (const word of cleanedInput) {
//    if (entityList.includes(word)) {
//      matchingWord = word
//      console.log(entity, matchingWord)
//    }
//  }
//  if (returnWord && matchingWord) {
//    return [true, matchingWord]; // Return the matching word if found
//  } else if (matchingWord) {
//    return true;
//  }
//  return false;
//};
const checkWordExists = (entity, inputSentence)=>{
    const cleanedInput = inputSentence.toLowerCase().replace(/\.$/g, "").split(/\s+/);
    const entityList = grammar.entities[entity];
    for (const word of cleanedInput){
        console.log("word: ", word);
        if (entityList.includes(word)) return true;
    }
    return false;
};
console.log(checkWordExists("movie", "I love Barbie."));
// machine
const dmMachine = (0, _xstate.createMachine)({
    id: "root",
    type: "parallel",
    states: {
        DialogueManager: {
            initial: "Prepare",
            states: {
                Prepare: {
                    on: {
                        ASRTTS_READY: "Ready"
                    },
                    entry: [
                        (0, _xstate.assign)({
                            spstRef: ({ spawn })=>{
                                return spawn((0, _speechstate.speechstate), {
                                    input: {
                                        settings: settings
                                    }
                                });
                            }
                        })
                    ]
                },
                Ready: {
                    initial: "Greeting",
                    states: {
                        Greeting: {
                            entry: "speak.greeting",
                            on: {
                                SPEAK_COMPLETE: "Ask"
                            }
                        },
                        //HowCanIHelp: {
                        //  entry: say("How can I help you?"),
                        //  on: { SPEAK_COMPLETE: "Ask" },
                        //},
                        Ask: {
                            entry: listen(),
                            on: {
                                RECOGNISED: [
                                    {
                                        // All slots together
                                        target: "AllSlots",
                                        guard: ({ event })=>checkWordExists("movie", event.value[0].utterance) && checkWordExists("date", event.value[0].utterance) && checkWordExists("showtime", event.value[0].utterance),
                                        actions: (0, _xstate.assign)({
                                            Movie: ({ context })=>grammar.entities.movie,
                                            Date: ({ context })=>grammar.entities.date,
                                            Showtime: ({ context })=>grammar.entities.showtime
                                        })
                                    },
                                    {
                                        target: "MissingMovie",
                                        guard: ({ event })=>!checkWordExists("movie", event.value[0].utterance),
                                        actions: (0, _xstate.assign)({
                                            Date: ({ event })=>{
                                                if (checkWordExists("date", event.value[0].utterance)) return grammar.entities.date;
                                            },
                                            Showtime: ({ event })=>{
                                                if (checkWordExists("showtime", event.value[0].utterance)) return grammar.entities.showtime;
                                            }
                                        })
                                    },
                                    {
                                        target: "MissingDate",
                                        guard: ({ event })=>!checkWordExists("date", event.value[0].utterance),
                                        actions: (0, _xstate.assign)({
                                            Movie: ({ event })=>{
                                                if (checkWordExists("movie", event.value[0].utterance)) return grammar.entities.movie;
                                            },
                                            Showtime: ({ event })=>{
                                                if (checkWordExists("showtime", event.value[0].utterance)) return grammar.entities.showtime;
                                            }
                                        })
                                    },
                                    {
                                        target: "MissingShowtime",
                                        guard: ({ event })=>!checkWordExists("showtime", event.value[0].utterance),
                                        actions: (0, _xstate.assign)({
                                            Movie: ({ event })=>{
                                                if (checkWordExists("movie", event.value[0].utterance)) return grammar.entities.movie;
                                            },
                                            Date: ({ event })=>{
                                                if (checkWordExists("date", event.value[0].utterance)) return grammar.entities.date;
                                            }
                                        })
                                    }
                                ]
                            }
                        },
                        AllSlots: {
                            entry: ({ context })=>{
                                context.spstRef.send({
                                    type: "SPEAK",
                                    value: {
                                        utterance: `Sure! I will book a ticket for ${context.Movie} on ${context.Date} at ${context.Showtime}`
                                    }
                                });
                            }
                        },
                        MissingMovie: {
                            entry: (0, _xstate.raise)({
                                type: "FILL_MOVIE"
                            })
                        },
                        MissingDate: {
                            entry: (0, _xstate.raise)({
                                type: "FILL_DATE"
                            })
                        },
                        MissingShowtime: {
                            entry: (0, _xstate.raise)({
                                type: "FILL_SHOWTIME"
                            })
                        },
                        IdleEnd: {}
                    }
                }
            }
        },
        SlotMovie: {
            initial: "Idle",
            states: {
                Idle: {
                    on: {
                        FILL_MOVIE: "Greeting"
                    }
                },
                Greeting: {
                    entry: ({ context })=>{
                        context.spstRef.send({
                            type: "SPEAK",
                            value: {
                                utterance: "What movie do you want to watch?"
                            }
                        });
                    },
                    on: {
                        SPEAK_COMPLETE: "Ask"
                    }
                },
                Ask: {
                    entry: listen(),
                    on: {
                        RECOGNISED: [
                            {
                                target: "#root.DialogueManager.Ready.AllSlots",
                                guard: ({ event, context })=>checkWordExists("movie", event.value[0].utterance) && (!!context.Date || checkWordExists("date", event.value[0].utterance)) && (!!context.Showtime || checkWordExists("showtime", event.value[0].utterance)),
                                actions: (0, _xstate.assign)({
                                    Movie: ()=>grammar.entities.movie,
                                    Date: ({ event, context })=>{
                                        if (context.Date) return context.Date;
                                        else if (checkWordExists("date", event.value[0].utterance)) return grammar.entities.date;
                                    },
                                    Showtime: ({ event, context })=>{
                                        if (context.Showtime) return context.Showtime;
                                        else if (checkWordExists("showtime", event.value[0].utterance)) return grammar.entities.showtime;
                                    }
                                })
                            },
                            {
                                target: "#root.SlotDate.Greeting",
                                guard: ({ event, context })=>checkWordExists("movie", event.value[0].utterance) && !context.Date && !checkWordExists("date", event.value[0].utterance),
                                actions: (0, _xstate.assign)({
                                    Movie: ({ context })=>grammar.entities.movie
                                })
                            },
                            {
                                target: "#root.SlotShowtime.Greeting",
                                guard: ({ event, context })=>checkWordExists("movie", event.value[0].utterance) && !context.Showtime,
                                actions: (0, _xstate.assign)({
                                    Movie: ({ context })=>grammar.entities.movie,
                                    Date: ({ event, context })=>{
                                        if (context.Date) return context.Date;
                                        else if (checkWordExists("date", event.value[0].utterance)) return grammar.entities.date;
                                    }
                                })
                            }
                        ]
                    }
                }
            }
        },
        SlotDate: {
            initial: "Idle",
            states: {
                Idle: {
                    on: {
                        FILL_DATE: "Greeting"
                    }
                },
                Greeting: {
                    entry: ({ context })=>{
                        context.spstRef.send({
                            type: "SPEAK",
                            value: {
                                utterance: "When do you want to go to the cinema?"
                            }
                        });
                    },
                    on: {
                        SPEAK_COMPLETE: "Ask"
                    }
                },
                Ask: {
                    entry: listen(),
                    on: {
                        RECOGNISED: [
                            {
                                target: "#root.DialogueManager.Ready.AllSlots",
                                guard: ({ event, context })=>checkWordExists("date", event.value[0].utterance) && !!context.Movie && (!!context.Showtime || checkWordExists("showtime", event.value[0].utterance)),
                                actions: (0, _xstate.assign)({
                                    Date: ({ context })=>grammar.entities.date,
                                    Showtime: ({ event, context })=>{
                                        if (context.Showtime) return context.Showtime;
                                        else if (checkWordExists("showtime", event.value[0].utterance)) return grammar.entities.showtime;
                                    }
                                })
                            },
                            {
                                target: "#root.SlotShowtime.Greeting",
                                guard: ({ event })=>checkWordExists("date", event.value[0].utterance) && !checkWordExists("showtime", event.value[0].utterance),
                                actions: (0, _xstate.assign)({
                                    Date: ({ context })=>grammar.entities.date
                                })
                            }
                        ]
                    }
                }
            }
        },
        SlotShowtime: {
            initial: "Idle",
            states: {
                Idle: {
                    on: {
                        FILL_SHOWTIME: "Greeting"
                    }
                },
                Greeting: {
                    entry: ({ context })=>{
                        context.spstRef.send({
                            type: "SPEAK",
                            value: {
                                utterance: `What time do you want to watch ${context.Movie} on ${context.Date}?`
                            }
                        });
                        console.log(context.Movie);
                    },
                    on: {
                        SPEAK_COMPLETE: "Ask"
                    }
                },
                Ask: {
                    entry: listen(),
                    on: {
                        RECOGNISED: {
                            target: "#root.DialogueManager.Ready.AllSlots",
                            guard: ({ event, context })=>checkWordExists("showtime", event.value[0].utterance) && !!context.Movie && !!context.Date,
                            actions: (0, _xstate.assign)({
                                Showtime: ({ context })=>grammar.entities.showtime
                            })
                        }
                    }
                }
            }
        },
        GUI: {
            initial: "PageLoaded",
            states: {
                PageLoaded: {
                    entry: "gui.PageLoaded",
                    on: {
                        CLICK: {
                            target: "Inactive",
                            actions: "prepare"
                        }
                    }
                },
                Inactive: {
                    entry: "gui.Inactive",
                    on: {
                        ASRTTS_READY: "Active"
                    }
                },
                Active: {
                    initial: "Idle",
                    states: {
                        Idle: {
                            entry: "gui.Idle",
                            on: {
                                TTS_STARTED: "Speaking",
                                ASR_STARTED: "Listening"
                            }
                        },
                        Speaking: {
                            entry: "gui.Speaking",
                            on: {
                                SPEAK_COMPLETE: "Idle"
                            }
                        },
                        Listening: {
                            entry: "gui.Listening",
                            on: {
                                RECOGNISED: "Idle"
                            }
                        }
                    }
                }
            }
        }
    }
}, {
    // custom actions
    actions: {
        prepare: ({ context })=>context.spstRef.send({
                type: "PREPARE"
            }),
        // saveLastResult:
        "speak.greeting": ({ context })=>{
            context.spstRef.send({
                type: "SPEAK",
                value: {
                    utterance: "Hi there! How can I help you?"
                }
            });
        },
        //"speak.how-can-I-help": ({ context }) =>
        //  context.spstRef.send({
        //    type: "SPEAK",
        //    value: { utterance: "How can I help you?" },
        //  }),
        "gui.PageLoaded": ({})=>{
            document.getElementById("button").innerText = "Click to start!";
        },
        "gui.Inactive": ({})=>{
            document.getElementById("button").innerText = "Inactive";
        },
        "gui.Idle": ({})=>{
            document.getElementById("button").innerText = "Idle";
        },
        "gui.Speaking": ({})=>{
            document.getElementById("button").innerText = "Speaking...";
        },
        "gui.Listening": ({})=>{
            document.getElementById("button").innerText = "Listening...";
        }
    }
});
const actor = (0, _xstate.createActor)(dmMachine).start();
document.getElementById("button").onclick = ()=>actor.send({
        type: "CLICK"
    });
actor.subscribe((state)=>{
    console.log(state.value);
});

},{"xstate":"591uE","speechstate":"6b8aX"}],"591uE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Actor", ()=>(0, _actionsBf7F6679EsmJs.M));
parcelHelpers.export(exports, "ActorStatus", ()=>(0, _actionsBf7F6679EsmJs.O));
parcelHelpers.export(exports, "ConstantPrefix", ()=>(0, _actionsBf7F6679EsmJs.a7));
parcelHelpers.export(exports, "InterpreterStatus", ()=>(0, _actionsBf7F6679EsmJs.P));
parcelHelpers.export(exports, "SpecialTargets", ()=>(0, _actionsBf7F6679EsmJs.a8));
parcelHelpers.export(exports, "State", ()=>(0, _actionsBf7F6679EsmJs.p));
parcelHelpers.export(exports, "and", ()=>(0, _actionsBf7F6679EsmJs.a5));
parcelHelpers.export(exports, "assign", ()=>(0, _actionsBf7F6679EsmJs.y));
parcelHelpers.export(exports, "cancel", ()=>(0, _actionsBf7F6679EsmJs.R));
parcelHelpers.export(exports, "choose", ()=>(0, _actionsBf7F6679EsmJs.T));
parcelHelpers.export(exports, "createActor", ()=>(0, _actionsBf7F6679EsmJs.G));
parcelHelpers.export(exports, "doneInvoke", ()=>(0, _actionsBf7F6679EsmJs.Q));
parcelHelpers.export(exports, "forwardTo", ()=>(0, _actionsBf7F6679EsmJs.K));
parcelHelpers.export(exports, "fromCallback", ()=>(0, _actionsBf7F6679EsmJs.a0));
parcelHelpers.export(exports, "fromEventObservable", ()=>(0, _actionsBf7F6679EsmJs.a1));
parcelHelpers.export(exports, "fromObservable", ()=>(0, _actionsBf7F6679EsmJs.$));
parcelHelpers.export(exports, "fromPromise", ()=>(0, _actionsBf7F6679EsmJs._));
parcelHelpers.export(exports, "fromTransition", ()=>(0, _actionsBf7F6679EsmJs.a2));
parcelHelpers.export(exports, "getStateNodes", ()=>(0, _actionsBf7F6679EsmJs.n));
parcelHelpers.export(exports, "interpret", ()=>(0, _actionsBf7F6679EsmJs.L));
parcelHelpers.export(exports, "log", ()=>(0, _actionsBf7F6679EsmJs.U));
parcelHelpers.export(exports, "matchesState", ()=>(0, _actionsBf7F6679EsmJs.H));
parcelHelpers.export(exports, "not", ()=>(0, _actionsBf7F6679EsmJs.a4));
parcelHelpers.export(exports, "or", ()=>(0, _actionsBf7F6679EsmJs.a6));
parcelHelpers.export(exports, "pathToStateValue", ()=>(0, _actionsBf7F6679EsmJs.Y));
parcelHelpers.export(exports, "pure", ()=>(0, _actionsBf7F6679EsmJs.V));
parcelHelpers.export(exports, "raise", ()=>(0, _actionsBf7F6679EsmJs.W));
parcelHelpers.export(exports, "sendParent", ()=>(0, _actionsBf7F6679EsmJs.J));
parcelHelpers.export(exports, "sendTo", ()=>(0, _actionsBf7F6679EsmJs.I));
parcelHelpers.export(exports, "stateIn", ()=>(0, _actionsBf7F6679EsmJs.a3));
parcelHelpers.export(exports, "stop", ()=>(0, _actionsBf7F6679EsmJs.X));
parcelHelpers.export(exports, "toObserver", ()=>(0, _actionsBf7F6679EsmJs.Z));
parcelHelpers.export(exports, "SimulatedClock", ()=>SimulatedClock);
parcelHelpers.export(exports, "StateMachine", ()=>StateMachine);
parcelHelpers.export(exports, "StateNode", ()=>StateNode);
parcelHelpers.export(exports, "createMachine", ()=>createMachine);
parcelHelpers.export(exports, "mapState", ()=>mapState);
parcelHelpers.export(exports, "waitFor", ()=>waitFor);
var _actionsBf7F6679EsmJs = require("./actions-bf7f6679.esm.js");
var _xstateDevEsmJs = require("../dev/dist/xstate-dev.esm.js");
const EMPTY_OBJECT = {};
const toSerializableActon = (action)=>{
    if (typeof action === "string") return {
        type: action
    };
    if (typeof action === "function") {
        if ("resolve" in action) return {
            type: action.type
        };
        return {
            type: action.name
        };
    }
    return action;
};
class StateNode {
    /**
   * The relative key of the state node, which represents its location in the overall state value.
   */ /**
   * The unique ID of the state node.
   */ /**
   * The type of this state node:
   *
   *  - `'atomic'` - no child state nodes
   *  - `'compound'` - nested child state nodes (XOR)
   *  - `'parallel'` - orthogonal nested child state nodes (AND)
   *  - `'history'` - history state node
   *  - `'final'` - final state node
   */ /**
   * The string path from the root machine node to this node.
   */ /**
   * The child state nodes.
   */ /**
   * The type of history on this state node. Can be:
   *
   *  - `'shallow'` - recalls only top-level historical state value
   *  - `'deep'` - recalls historical state value at all levels
   */ /**
   * The action(s) to be executed upon entering the state node.
   */ /**
   * The action(s) to be executed upon exiting the state node.
   */ /**
   * The parent state node.
   */ /**
   * The root machine node.
   */ /**
   * The meta data associated with this state node, which will be returned in State instances.
   */ /**
   * The output data sent with the "done.state._id_" event if this is a final state node.
   */ /**
   * The order this state node appears. Corresponds to the implicit document order.
   */ constructor(/**
   * The raw config used to create the machine.
   */ config, options){
        this.config = config;
        this.key = void 0;
        this.id = void 0;
        this.type = void 0;
        this.path = void 0;
        this.states = void 0;
        this.history = void 0;
        this.entry = void 0;
        this.exit = void 0;
        this.parent = void 0;
        this.machine = void 0;
        this.meta = void 0;
        this.output = void 0;
        this.order = -1;
        this.description = void 0;
        this.tags = [];
        this.transitions = void 0;
        this.always = void 0;
        this.parent = options._parent;
        this.key = options._key;
        this.machine = options._machine;
        this.path = this.parent ? this.parent.path.concat(this.key) : [];
        this.id = this.config.id || [
            this.machine.id,
            ...this.path
        ].join((0, _actionsBf7F6679EsmJs.S));
        this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic");
        this.description = this.config.description;
        this.order = this.machine.idMap.size;
        this.machine.idMap.set(this.id, this);
        this.states = this.config.states ? (0, _actionsBf7F6679EsmJs.m)(this.config.states, (stateConfig, key)=>{
            const stateNode = new StateNode(stateConfig, {
                _parent: this,
                _key: key,
                _machine: this.machine
            });
            return stateNode;
        }) : EMPTY_OBJECT;
        if (this.type === "compound" && !this.config.initial) throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
        // History config
        this.history = this.config.history === true ? "shallow" : this.config.history || false;
        this.entry = (0, _actionsBf7F6679EsmJs.t)(this.config.entry).slice();
        this.exit = (0, _actionsBf7F6679EsmJs.t)(this.config.exit).slice();
        this.meta = this.config.meta;
        this.output = this.type === "final" ? this.config.output : undefined;
        this.tags = (0, _actionsBf7F6679EsmJs.t)(config.tags).slice();
    }
    _initialize() {
        this.transitions = (0, _actionsBf7F6679EsmJs.f)(this);
        if (this.config.always) this.always = (0, _actionsBf7F6679EsmJs.a)(this.config.always).map((t)=>(0, _actionsBf7F6679EsmJs.b)(this, (0, _actionsBf7F6679EsmJs.N), t));
        Object.keys(this.states).forEach((key)=>{
            this.states[key]._initialize();
        });
    }
    /**
   * The well-structured state node definition.
   */ get definition() {
        return {
            id: this.id,
            key: this.key,
            version: this.machine.version,
            type: this.type,
            initial: this.initial ? {
                target: this.initial.target,
                source: this,
                actions: this.initial.actions.map(toSerializableActon),
                eventType: null,
                reenter: false,
                toJSON: ()=>({
                        target: this.initial.target.map((t)=>`#${t.id}`),
                        source: `#${this.id}`,
                        actions: this.initial.actions.map(toSerializableActon),
                        eventType: null
                    })
            } : undefined,
            history: this.history,
            states: (0, _actionsBf7F6679EsmJs.m)(this.states, (state)=>{
                return state.definition;
            }),
            on: this.on,
            transitions: [
                ...this.transitions.values()
            ].flat().map((t)=>({
                    ...t,
                    actions: t.actions.map(toSerializableActon)
                })),
            entry: this.entry.map(toSerializableActon),
            exit: this.exit.map(toSerializableActon),
            meta: this.meta,
            order: this.order || -1,
            output: this.output,
            invoke: this.invoke,
            description: this.description,
            tags: this.tags
        };
    }
    toJSON() {
        return this.definition;
    }
    /**
   * The logic invoked as actors by this state node.
   */ get invoke() {
        return (0, _actionsBf7F6679EsmJs.c)(this, "invoke", ()=>(0, _actionsBf7F6679EsmJs.t)(this.config.invoke).map((invocable, i)=>{
                const generatedId = (0, _actionsBf7F6679EsmJs.g)(this.id, i);
                const invokeConfig = (0, _actionsBf7F6679EsmJs.k)(invocable, generatedId);
                const resolvedId = invokeConfig.id || generatedId;
                const src = invokeConfig.src;
                const { systemId } = invokeConfig;
                // TODO: resolving should not happen here
                const resolvedSrc = typeof src === "string" ? src : !("type" in src) ? resolvedId : src;
                if (!this.machine.implementations.actors[resolvedId] && typeof src !== "string" && !("type" in src)) this.machine.implementations.actors = {
                    ...this.machine.implementations.actors,
                    // TODO: this should accept `src` as-is
                    [resolvedId]: src
                };
                return {
                    ...invokeConfig,
                    src: resolvedSrc,
                    id: resolvedId,
                    systemId: systemId,
                    toJSON () {
                        const { onDone, onError, ...invokeDefValues } = invokeConfig;
                        return {
                            ...invokeDefValues,
                            type: "xstate.invoke",
                            src: resolvedSrc,
                            id: resolvedId
                        };
                    }
                };
            }));
    }
    /**
   * The mapping of events to transitions.
   */ get on() {
        return (0, _actionsBf7F6679EsmJs.c)(this, "on", ()=>{
            const transitions = this.transitions;
            return [
                ...transitions
            ].flatMap(([descriptor, t])=>t.map((t)=>[
                        descriptor,
                        t
                    ])).reduce((map, [descriptor, transition])=>{
                map[descriptor] = map[descriptor] || [];
                map[descriptor].push(transition);
                return map;
            }, {});
        });
    }
    get after() {
        return (0, _actionsBf7F6679EsmJs.c)(this, "delayedTransitions", ()=>(0, _actionsBf7F6679EsmJs.h)(this));
    }
    get initial() {
        return (0, _actionsBf7F6679EsmJs.c)(this, "initial", ()=>(0, _actionsBf7F6679EsmJs.i)(this, this.config.initial || []));
    }
    next(state, event) {
        const eventType = event.type;
        const actions = [];
        let selectedTransition;
        const candidates = (0, _actionsBf7F6679EsmJs.c)(this, `candidates-${eventType}`, ()=>(0, _actionsBf7F6679EsmJs.j)(this, eventType));
        for (const candidate of candidates){
            const { guard } = candidate;
            const resolvedContext = state.context;
            let guardPassed = false;
            try {
                guardPassed = !guard || (0, _actionsBf7F6679EsmJs.e)(guard, resolvedContext, event, state);
            } catch (err) {
                throw new Error(`Unable to evaluate guard '${guard.type}' in transition for event '${eventType}' in state node '${this.id}':\n${err.message}`);
            }
            if (guardPassed) {
                actions.push(...candidate.actions);
                selectedTransition = candidate;
                break;
            }
        }
        return selectedTransition ? [
            selectedTransition
        ] : undefined;
    }
    /**
   * The target state value of the history state node, if it exists. This represents the
   * default state value to transition to if no history value exists yet.
   */ get target() {
        if (this.type === "history") {
            const historyConfig = this.config;
            return historyConfig.target;
        }
        return undefined;
    }
    /**
   * All the state node IDs of this state node and its descendant state nodes.
   */ get stateIds() {
        const childStateIds = (0, _actionsBf7F6679EsmJs.d)(Object.keys(this.states).map((stateKey)=>{
            return this.states[stateKey].stateIds;
        }));
        return [
            this.id
        ].concat(childStateIds);
    }
    /**
   * All the event types accepted by this state node and its descendants.
   */ get events() {
        return (0, _actionsBf7F6679EsmJs.c)(this, "events", ()=>{
            const { states } = this;
            const events = new Set(this.ownEvents);
            if (states) for (const stateId of Object.keys(states)){
                const state = states[stateId];
                if (state.states) for (const event of state.events)events.add(`${event}`);
            }
            return Array.from(events);
        });
    }
    /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */ get ownEvents() {
        const events = new Set([
            ...this.transitions.keys()
        ].filter((descriptor)=>{
            return this.transitions.get(descriptor).some((transition)=>!(!transition.target && !transition.actions.length && !transition.reenter));
        }));
        return Array.from(events);
    }
}
const STATE_IDENTIFIER = "#";
class StateMachine {
    /**
   * The machine's own version.
   */ constructor(/**
   * The raw config used to create the machine.
   */ config, implementations){
        this.config = config;
        this.version = void 0;
        this.implementations = void 0;
        this.types = void 0;
        this.__xstatenode = true;
        this.idMap = new Map();
        this.root = void 0;
        this.id = void 0;
        this.states = void 0;
        this.events = void 0;
        this.__TContext = void 0;
        this.__TEvent = void 0;
        this.__TAction = void 0;
        this.__TActor = void 0;
        this.__TInput = void 0;
        this.__TOutput = void 0;
        this.__TResolvedTypesMeta = void 0;
        this.id = config.id || "(machine)";
        this.implementations = {
            actors: implementations?.actors ?? {},
            actions: implementations?.actions ?? {},
            delays: implementations?.delays ?? {},
            guards: implementations?.guards ?? {}
        };
        this.version = this.config.version;
        this.types = this.config.types ?? {};
        this.transition = this.transition.bind(this);
        this.root = new StateNode(config, {
            _key: this.id,
            _machine: this
        });
        this.root._initialize();
        this.states = this.root.states; // TODO: remove!
        this.events = this.root.events;
    }
    /**
   * Clones this state machine with the provided implementations
   * and merges the `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)
   *  to recursively merge with the existing options.
   *
   * @returns A new `StateMachine` instance with the provided implementations.
   */ provide(implementations) {
        const { actions, guards, actors, delays } = this.implementations;
        return new StateMachine(this.config, {
            actions: {
                ...actions,
                ...implementations.actions
            },
            guards: {
                ...guards,
                ...implementations.guards
            },
            actors: {
                ...actors,
                ...implementations.actors
            },
            delays: {
                ...delays,
                ...implementations.delays
            }
        });
    }
    /**
   * Resolves the given `state` to a new `State` instance relative to this machine.
   *
   * This ensures that `.nextEvents` represent the correct values.
   *
   * @param state The state to resolve
   */ resolveState(state) {
        const configurationSet = (0, _actionsBf7F6679EsmJs.l)((0, _actionsBf7F6679EsmJs.n)(this.root, state.value));
        const configuration = Array.from(configurationSet);
        return this.createState({
            ...state,
            value: (0, _actionsBf7F6679EsmJs.r)(this.root, state.value),
            configuration,
            done: (0, _actionsBf7F6679EsmJs.o)(configuration)
        });
    }
    resolveStateValue(stateValue, ...[context]) {
        const resolvedStateValue = (0, _actionsBf7F6679EsmJs.r)(this.root, stateValue);
        return this.resolveState((0, _actionsBf7F6679EsmJs.p).from(resolvedStateValue, context, this));
    }
    /**
   * Determines the next state given the current `state` and received `event`.
   * Calculates a full macrostep from all microsteps.
   *
   * @param state The current State instance or state value
   * @param event The received event
   */ transition(state, event, actorCtx) {
        // TODO: handle error events in a better way
        if ((0, _actionsBf7F6679EsmJs.q)(event) && !state.nextEvents.some((nextEvent)=>nextEvent === event.type)) return (0, _actionsBf7F6679EsmJs.s)(state, {
            error: event.data
        });
        const { state: nextState } = (0, _actionsBf7F6679EsmJs.u)(state, event, actorCtx);
        return nextState;
    }
    /**
   * Determines the next state given the current `state` and `event`.
   * Calculates a microstep.
   *
   * @param state The current state
   * @param event The received event
   */ microstep(state, event, actorCtx) {
        return (0, _actionsBf7F6679EsmJs.u)(state, event, actorCtx).microstates;
    }
    getTransitionData(state, event) {
        return (0, _actionsBf7F6679EsmJs.v)(this.root, state.value, state, event) || [];
    }
    /**
   * The initial state _before_ evaluating any microsteps.
   * This "pre-initial" state is provided to initial actions executed in the initial state.
   */ getPreInitialState(actorCtx, initEvent) {
        const { context } = this.config;
        const preInitial = this.resolveState(this.createState({
            value: {},
            // TODO: this is computed in state constructor
            context: typeof context !== "function" && context ? context : {},
            meta: undefined,
            configuration: (0, _actionsBf7F6679EsmJs.w)(this.root),
            children: {}
        }));
        if (typeof context === "function") {
            const assignment = ({ spawn, event })=>context({
                    spawn,
                    input: event.input
                });
            return (0, _actionsBf7F6679EsmJs.x)([
                (0, _actionsBf7F6679EsmJs.y)(assignment)
            ], initEvent, preInitial, actorCtx);
        }
        return preInitial;
    }
    /**
   * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.
   */ getInitialState(actorCtx, input) {
        const initEvent = (0, _actionsBf7F6679EsmJs.z)(input); // TODO: fix;
        const preInitialState = this.getPreInitialState(actorCtx, initEvent);
        const nextState = (0, _actionsBf7F6679EsmJs.A)([
            {
                target: [
                    ...preInitialState.configuration
                ].filter((0, _actionsBf7F6679EsmJs.B)),
                source: this.root,
                reenter: true,
                actions: [],
                eventType: null,
                toJSON: null // TODO: fix
            }
        ], preInitialState, actorCtx, initEvent, true);
        const { state: macroState } = (0, _actionsBf7F6679EsmJs.u)(nextState, initEvent, actorCtx);
        return macroState;
    }
    start(state) {
        Object.values(state.children).forEach((child)=>{
            if (child.status === 0) child.start?.();
        });
    }
    getStateNodeById(stateId) {
        const fullPath = stateId.split((0, _actionsBf7F6679EsmJs.S));
        const relativePath = fullPath.slice(1);
        const resolvedStateId = (0, _actionsBf7F6679EsmJs.C)(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];
        const stateNode = this.idMap.get(resolvedStateId);
        if (!stateNode) throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);
        return (0, _actionsBf7F6679EsmJs.D)(stateNode, relativePath);
    }
    get definition() {
        return this.root.definition;
    }
    toJSON() {
        return this.definition;
    }
    getPersistedState(state) {
        return (0, _actionsBf7F6679EsmJs.E)(state);
    }
    createState(stateConfig) {
        return stateConfig instanceof (0, _actionsBf7F6679EsmJs.p) ? stateConfig : new (0, _actionsBf7F6679EsmJs.p)(stateConfig, this);
    }
    getStatus(state) {
        return state.error ? {
            status: "error",
            data: state.error
        } : state.done ? {
            status: "done",
            data: state.output
        } : {
            status: "active"
        };
    }
    restoreState(state, _actorCtx) {
        const children = {};
        Object.keys(state.children).forEach((actorId)=>{
            const actorData = state.children[actorId];
            const childState = actorData.state;
            const src = actorData.src;
            const logic = src ? (0, _actionsBf7F6679EsmJs.F)(this.implementations.actors[src])?.src : undefined;
            if (!logic) return;
            const actorState = logic.restoreState?.(childState, _actorCtx);
            const actorRef = (0, _actionsBf7F6679EsmJs.G)(logic, {
                id: actorId,
                state: actorState
            });
            children[actorId] = actorRef;
        });
        const restoredState = this.createState(new (0, _actionsBf7F6679EsmJs.p)({
            ...state,
            children
        }, this));
        // TODO: DRY this up
        restoredState.configuration.forEach((stateNode)=>{
            if (stateNode.invoke) stateNode.invoke.forEach((invokeConfig)=>{
                const { id, src } = invokeConfig;
                if (children[id]) return;
                const referenced = (0, _actionsBf7F6679EsmJs.F)(this.implementations.actors[src]);
                if (referenced) {
                    const actorRef = (0, _actionsBf7F6679EsmJs.G)(referenced.src, {
                        id,
                        parent: _actorCtx?.self,
                        input: "input" in invokeConfig ? invokeConfig.input : referenced.input
                    });
                    children[id] = actorRef;
                }
            });
        });
        return restoredState;
    }
}
function createMachine(config, implementations) {
    return new StateMachine(config, implementations);
}
function mapState(stateMap, stateId) {
    let foundStateId;
    for (const mappedStateId of Object.keys(stateMap))if ((0, _actionsBf7F6679EsmJs.H)(mappedStateId, stateId) && (!foundStateId || stateId.length > foundStateId.length)) foundStateId = mappedStateId;
    return stateMap[foundStateId];
}
class SimulatedClock {
    constructor(){
        this.timeouts = new Map();
        this._now = 0;
        this._id = 0;
    }
    now() {
        return this._now;
    }
    getId() {
        return this._id++;
    }
    setTimeout(fn, timeout) {
        const id = this.getId();
        this.timeouts.set(id, {
            start: this.now(),
            timeout,
            fn
        });
        return id;
    }
    clearTimeout(id) {
        this.timeouts.delete(id);
    }
    set(time) {
        if (this._now > time) throw new Error("Unable to travel back in time");
        this._now = time;
        this.flushTimeouts();
    }
    flushTimeouts() {
        [
            ...this.timeouts
        ].sort(([_idA, timeoutA], [_idB, timeoutB])=>{
            const endA = timeoutA.start + timeoutA.timeout;
            const endB = timeoutB.start + timeoutB.timeout;
            return endB > endA ? -1 : 1;
        }).forEach(([id, timeout])=>{
            if (this.now() - timeout.start >= timeout.timeout) {
                this.timeouts.delete(id);
                timeout.fn.call(null);
            }
        });
    }
    increment(ms) {
        this._now += ms;
        this.flushTimeouts();
    }
}
const defaultWaitForOptions = {
    timeout: 10000 // 10 seconds
};
/**
 * Subscribes to an actor ref and waits for its emitted value to satisfy
 * a predicate, and then resolves with that value.
 * Will throw if the desired state is not reached after a timeout
 * (defaults to 10 seconds).
 *
 * @example
 * ```js
 * const state = await waitFor(someService, state => {
 *   return state.hasTag('loaded');
 * });
 *
 * state.hasTag('loaded'); // true
 * ```
 *
 * @param actorRef The actor ref to subscribe to
 * @param predicate Determines if a value matches the condition to wait for
 * @param options
 * @returns A promise that eventually resolves to the emitted value
 * that matches the condition
 */ function waitFor(actorRef, predicate, options) {
    const resolvedOptions = {
        ...defaultWaitForOptions,
        ...options
    };
    return new Promise((res, rej)=>{
        let done = false;
        const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(()=>{
            sub.unsubscribe();
            rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));
        }, resolvedOptions.timeout);
        const dispose = ()=>{
            clearTimeout(handle);
            done = true;
            sub?.unsubscribe();
        };
        function checkEmitted(emitted) {
            if (predicate(emitted)) {
                dispose();
                res(emitted);
            }
        }
        let sub; // avoid TDZ when disposing synchronously
        // See if the current snapshot already matches the predicate
        checkEmitted(actorRef.getSnapshot());
        if (done) return;
        sub = actorRef.subscribe({
            next: checkEmitted,
            error: (err)=>{
                dispose();
                rej(err);
            },
            complete: ()=>{
                dispose();
                rej(new Error(`Actor terminated without satisfying predicate`));
            }
        });
        if (done) sub.unsubscribe();
    });
}

},{"./actions-bf7f6679.esm.js":"9GCwv","../dev/dist/xstate-dev.esm.js":"2CXSV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9GCwv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$", ()=>fromObservable);
parcelHelpers.export(exports, "A", ()=>microstep);
parcelHelpers.export(exports, "B", ()=>isAtomicStateNode);
parcelHelpers.export(exports, "C", ()=>isStateId);
parcelHelpers.export(exports, "D", ()=>getStateNodeByPath);
parcelHelpers.export(exports, "E", ()=>getPersistedState);
parcelHelpers.export(exports, "F", ()=>resolveReferencedActor);
parcelHelpers.export(exports, "G", ()=>createActor);
parcelHelpers.export(exports, "H", ()=>matchesState);
parcelHelpers.export(exports, "I", ()=>sendTo);
parcelHelpers.export(exports, "J", ()=>sendParent);
parcelHelpers.export(exports, "K", ()=>forwardTo);
parcelHelpers.export(exports, "L", ()=>interpret);
parcelHelpers.export(exports, "M", ()=>Actor);
parcelHelpers.export(exports, "N", ()=>NULL_EVENT);
parcelHelpers.export(exports, "O", ()=>ActorStatus);
parcelHelpers.export(exports, "P", ()=>InterpreterStatus);
parcelHelpers.export(exports, "Q", ()=>doneInvoke);
parcelHelpers.export(exports, "R", ()=>cancel);
parcelHelpers.export(exports, "S", ()=>STATE_DELIMITER);
parcelHelpers.export(exports, "T", ()=>choose);
parcelHelpers.export(exports, "U", ()=>log);
parcelHelpers.export(exports, "V", ()=>pure);
parcelHelpers.export(exports, "W", ()=>raise);
parcelHelpers.export(exports, "X", ()=>stop);
parcelHelpers.export(exports, "Y", ()=>pathToStateValue);
parcelHelpers.export(exports, "Z", ()=>toObserver);
parcelHelpers.export(exports, "_", ()=>fromPromise);
parcelHelpers.export(exports, "a", ()=>toTransitionConfigArray);
parcelHelpers.export(exports, "a0", ()=>fromCallback);
parcelHelpers.export(exports, "a1", ()=>fromEventObservable);
parcelHelpers.export(exports, "a2", ()=>fromTransition);
parcelHelpers.export(exports, "a3", ()=>stateIn);
parcelHelpers.export(exports, "a4", ()=>not);
parcelHelpers.export(exports, "a5", ()=>and);
parcelHelpers.export(exports, "a6", ()=>or);
parcelHelpers.export(exports, "a7", ()=>ConstantPrefix);
parcelHelpers.export(exports, "a8", ()=>SpecialTargets);
parcelHelpers.export(exports, "a9", ()=>startSignalType);
parcelHelpers.export(exports, "aa", ()=>stopSignalType);
parcelHelpers.export(exports, "ab", ()=>startSignal);
parcelHelpers.export(exports, "ac", ()=>stopSignal);
parcelHelpers.export(exports, "ad", ()=>isSignal);
parcelHelpers.export(exports, "ae", ()=>isActorRef);
parcelHelpers.export(exports, "af", ()=>toActorRef);
parcelHelpers.export(exports, "ag", ()=>createEmptyActor);
parcelHelpers.export(exports, "ah", ()=>toGuardDefinition);
parcelHelpers.export(exports, "ai", ()=>constantPrefixes);
parcelHelpers.export(exports, "aj", ()=>after);
parcelHelpers.export(exports, "ak", ()=>done);
parcelHelpers.export(exports, "al", ()=>error);
parcelHelpers.export(exports, "am", ()=>escalate);
parcelHelpers.export(exports, "b", ()=>formatTransition);
parcelHelpers.export(exports, "c", ()=>memo);
parcelHelpers.export(exports, "d", ()=>flatten);
parcelHelpers.export(exports, "e", ()=>evaluateGuard);
parcelHelpers.export(exports, "f", ()=>formatTransitions);
parcelHelpers.export(exports, "g", ()=>createInvokeId);
parcelHelpers.export(exports, "h", ()=>getDelayedTransitions);
parcelHelpers.export(exports, "i", ()=>formatInitialTransition);
parcelHelpers.export(exports, "j", ()=>getCandidates);
parcelHelpers.export(exports, "k", ()=>toInvokeConfig);
parcelHelpers.export(exports, "l", ()=>getConfiguration);
parcelHelpers.export(exports, "m", ()=>mapValues);
parcelHelpers.export(exports, "n", ()=>getStateNodes);
parcelHelpers.export(exports, "o", ()=>isInFinalState);
parcelHelpers.export(exports, "p", ()=>State);
parcelHelpers.export(exports, "q", ()=>isErrorEvent);
parcelHelpers.export(exports, "r", ()=>resolveStateValue);
parcelHelpers.export(exports, "s", ()=>cloneState);
parcelHelpers.export(exports, "t", ()=>toArray);
parcelHelpers.export(exports, "u", ()=>macrostep);
parcelHelpers.export(exports, "v", ()=>transitionNode);
parcelHelpers.export(exports, "w", ()=>getInitialConfiguration);
parcelHelpers.export(exports, "x", ()=>resolveActionsAndContext);
parcelHelpers.export(exports, "y", ()=>assign);
parcelHelpers.export(exports, "z", ()=>createInitEvent);
var _xstateDevEsmJs = require("../dev/dist/xstate-dev.esm.js");
/**
 * `T | unknown` reduces to `unknown` and that can be problematic when it comes to contextual typing.
 * It especially is a problem when the union has a function member, like here:
 *
 * ```ts
 * declare function test(cbOrVal: ((arg: number) => unknown) | unknown): void;
 * test((arg) => {}) // oops, implicit any
 * ```
 *
 * This type can be used to avoid this problem. This union represents the same value space as `unknown`.
 */ // https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887
/**
 * The full definition of an event, with a string `type`.
 */ // TODO: do not accept machines without all implementations
// we should also accept a raw machine as actor logic here
// or just make machine actor logic
/**
 * The string or object representing the state value relative to the parent state node.
 *
 * - For a child atomic state node, this is a string, e.g., `"pending"`.
 * - For complex state nodes, this is an object, e.g., `{ success: "someChildState" }`.
 */ // TODO: remove once TS fixes this type-widening issue
// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something
let ConstantPrefix = /*#__PURE__*/ function(ConstantPrefix) {
    ConstantPrefix["After"] = "xstate.after";
    ConstantPrefix["DoneState"] = "done.state";
    ConstantPrefix["DoneInvoke"] = "done.invoke";
    ConstantPrefix["ErrorExecution"] = "error.execution";
    ConstantPrefix["ErrorCommunication"] = "error.communication";
    ConstantPrefix["ErrorPlatform"] = "error.platform";
    ConstantPrefix["ErrorCustom"] = "xstate.error";
    return ConstantPrefix;
}({});
let SpecialTargets = /*#__PURE__*/ function(SpecialTargets) {
    SpecialTargets["Parent"] = "#_parent";
    SpecialTargets["Internal"] = "#_internal";
    return SpecialTargets;
}({});
const after$1 = ConstantPrefix.After;
const doneState = ConstantPrefix.DoneState;
const errorExecution = ConstantPrefix.ErrorExecution;
const errorPlatform = ConstantPrefix.ErrorPlatform;
const error$1 = ConstantPrefix.ErrorCustom;
var constantPrefixes = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    after: after$1,
    doneState: doneState,
    errorExecution: errorExecution,
    errorPlatform: errorPlatform,
    error: error$1
});
const STATE_DELIMITER = ".";
const TARGETLESS_KEY = "";
const NULL_EVENT = "";
const STATE_IDENTIFIER = "#";
const WILDCARD = "*";
const INIT_TYPE = "xstate.init";
function resolve$8(actorContext, state, args, { to, event: eventOrExpr, id, delay }) {
    const delaysMap = state.machine.implementations.delays;
    if (typeof eventOrExpr === "string") throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: "${eventOrExpr}" }) instead`);
    const resolvedEvent = typeof eventOrExpr === "function" ? eventOrExpr(args) : eventOrExpr;
    let resolvedDelay;
    if (typeof delay === "string") {
        const configDelay = delaysMap && delaysMap[delay];
        resolvedDelay = typeof configDelay === "function" ? configDelay(args) : configDelay;
    } else resolvedDelay = typeof delay === "function" ? delay(args) : delay;
    const resolvedTarget = typeof to === "function" ? to(args) : to;
    let targetActorRef;
    if (typeof resolvedTarget === "string") {
        if (resolvedTarget === SpecialTargets.Parent) targetActorRef = actorContext?.self._parent;
        else if (resolvedTarget === SpecialTargets.Internal) targetActorRef = actorContext?.self;
        else if (resolvedTarget.startsWith("#_")) // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor
        // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.
        targetActorRef = state.children[resolvedTarget.slice(2)];
        else targetActorRef = state.children[resolvedTarget];
        if (!targetActorRef) throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${state.machine.id}'.`);
    } else targetActorRef = resolvedTarget || actorContext?.self;
    return [
        state,
        {
            to: targetActorRef,
            event: resolvedEvent,
            id,
            delay: resolvedDelay
        }
    ];
}
function execute$5(actorContext, params) {
    if (typeof params.delay === "number") {
        actorContext.self.delaySend(params);
        return;
    }
    const { to, event } = params;
    actorContext.defer(()=>{
        to.send(event.type === error$1 ? {
            type: `${error(actorContext.self.id)}`,
            data: event.data
        } : event);
    });
}
/**
 * Sends an event to an actor.
 *
 * @param actor The `ActorRef` to send the event to.
 * @param event The event to send, or an expression that evaluates to the event to send
 * @param options Send action options
 *  - `id` - The unique send event identifier (used with `cancel()`).
 *  - `delay` - The number of milliseconds to delay the sending of the event.
 */ function sendTo(to, eventOrExpr, options) {
    function sendTo(_) {}
    sendTo.type = "xstate.sendTo";
    sendTo.to = to;
    sendTo.event = eventOrExpr;
    sendTo.id = options?.id;
    sendTo.delay = options?.delay;
    sendTo.resolve = resolve$8;
    sendTo.execute = execute$5;
    return sendTo;
}
/**
 * Sends an event to this machine's parent.
 *
 * @param event The event to send to the parent machine.
 * @param options Options to pass into the send event.
 */ function sendParent(event, options) {
    return sendTo(SpecialTargets.Parent, event, options);
}
/**
 * Forwards (sends) an event to a specified service.
 *
 * @param target The target service to forward the event to.
 * @param options Options to pass into the send action creator.
 */ function forwardTo(target, options) {
    return sendTo(target, ({ event })=>event, options);
}
/**
 * Escalates an error by sending it as an event to this machine's parent.
 *
 * @param errorData The error data to send, or the expression function that
 * takes in the `context`, `event`, and `meta`, and returns the error data to send.
 * @param options Options to pass into the send action creator.
 */ function escalate(errorData, options) {
    return sendParent((arg)=>{
        return {
            type: error$1,
            data: typeof errorData === "function" ? errorData(arg) : errorData
        };
    }, options);
}
const cache = new WeakMap();
function memo(object, key, fn) {
    let memoizedData = cache.get(object);
    if (!memoizedData) {
        memoizedData = {
            [key]: fn()
        };
        cache.set(object, memoizedData);
    } else if (!(key in memoizedData)) memoizedData[key] = fn();
    return memoizedData[key];
}
function resolve$7(_, state, actionArgs, { sendId }) {
    const resolvedSendId = typeof sendId === "function" ? sendId(actionArgs) : sendId;
    return [
        state,
        resolvedSendId
    ];
}
function execute$4(actorContext, resolvedSendId) {
    actorContext.self.cancel(resolvedSendId);
}
/**
 * Cancels an in-flight `send(...)` action. A canceled sent action will not
 * be executed, nor will its event be sent, unless it has already been sent
 * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).
 *
 * @param sendId The `id` of the `send(...)` action to cancel.
 */ function cancel(sendId) {
    function cancel(_) {}
    cancel.type = "xstate.cancel";
    cancel.sendId = sendId;
    cancel.resolve = resolve$7;
    cancel.execute = execute$4;
    return cancel;
}
class Mailbox {
    constructor(_process){
        this._process = _process;
        this._active = false;
        this._current = null;
        this._last = null;
    }
    start() {
        this._active = true;
        this.flush();
    }
    clear() {
        // we can't set _current to null because we might be currently processing
        // and enqueue following clear shouldnt start processing the enqueued item immediately
        if (this._current) {
            this._current.next = null;
            this._last = this._current;
        }
    }
    // TODO: rethink this design
    prepend(event) {
        if (!this._current) {
            this.enqueue(event);
            return;
        }
        // we know that something is already queued up
        // so the mailbox is already flushing or it's inactive
        // therefore the only thing that we need to do is to reassign `this._current`
        this._current = {
            value: event,
            next: this._current
        };
    }
    enqueue(event) {
        const enqueued = {
            value: event,
            next: null
        };
        if (this._current) {
            this._last.next = enqueued;
            this._last = enqueued;
            return;
        }
        this._current = enqueued;
        this._last = enqueued;
        if (this._active) this.flush();
    }
    flush() {
        while(this._current){
            // atm the given _process is responsible for implementing proper try/catch handling
            // we assume here that this won't throw in a way that can affect this mailbox
            const consumed = this._current;
            this._process(consumed.value);
            // something could have been prepended in the meantime
            // so we need to be defensive here to avoid skipping over a prepended item
            if (consumed === this._current) this._current = this._current.next;
        }
        this._last = null;
    }
}
const symbolObservable = (()=>typeof Symbol === "function" && Symbol.observable || "@@observable")();
/**
 * Returns actor logic from a transition function and its initial state.
 *
 * A transition function is a function that takes the current state and an event and returns the next state.
 *
 * @param transition The transition function that returns the next state given the current state and event.
 * @param initialState The initial state of the transition function.
 * @returns Actor logic
 */ function fromTransition(transition, initialState) {
    return {
        config: transition,
        transition: (state, event, actorContext)=>{
            return transition(state, event, actorContext);
        },
        getInitialState: (_, input)=>{
            return typeof initialState === "function" ? initialState({
                input
            }) : initialState;
        },
        getSnapshot: (state)=>state,
        getPersistedState: (state)=>state,
        restoreState: (state)=>state
    };
}
function matchesState(parentStateId, childStateId) {
    const parentStateValue = toStateValue(parentStateId);
    const childStateValue = toStateValue(childStateId);
    if (typeof childStateValue === "string") {
        if (typeof parentStateValue === "string") return childStateValue === parentStateValue;
        // Parent more specific than child
        return false;
    }
    if (typeof parentStateValue === "string") return parentStateValue in childStateValue;
    return Object.keys(parentStateValue).every((key)=>{
        if (!(key in childStateValue)) return false;
        return matchesState(parentStateValue[key], childStateValue[key]);
    });
}
function toStatePath(stateId) {
    try {
        if (isArray(stateId)) return stateId;
        return stateId.toString().split(STATE_DELIMITER);
    } catch (e) {
        throw new Error(`'${stateId}' is not a valid state path.`);
    }
}
function isStateLike(state) {
    return typeof state === "object" && "value" in state && "context" in state && "event" in state;
}
function toStateValue(stateValue) {
    if (isStateLike(stateValue)) return stateValue.value;
    if (isArray(stateValue)) return pathToStateValue(stateValue);
    if (typeof stateValue !== "string") return stateValue;
    const statePath = toStatePath(stateValue);
    return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
    if (statePath.length === 1) return statePath[0];
    const value = {};
    let marker = value;
    for(let i = 0; i < statePath.length - 1; i++)if (i === statePath.length - 2) marker[statePath[i]] = statePath[i + 1];
    else {
        const previous = marker;
        marker = {};
        previous[statePath[i]] = marker;
    }
    return value;
}
function mapValues(collection, iteratee) {
    const result = {};
    const collectionKeys = Object.keys(collection);
    for(let i = 0; i < collectionKeys.length; i++){
        const key = collectionKeys[i];
        result[key] = iteratee(collection[key], key, collection, i);
    }
    return result;
}
function flatten(array) {
    return [].concat(...array);
}
function toArrayStrict(value) {
    if (isArray(value)) return value;
    return [
        value
    ];
}
function toArray(value) {
    if (value === undefined) return [];
    return toArrayStrict(value);
}
function mapContext(mapper, context, event, self) {
    if (typeof mapper === "function") return mapper({
        context,
        event,
        self
    });
    return mapper;
}
function isPromiseLike(value) {
    if (value instanceof Promise) return true;
    // Check if shape matches the Promise/A+ specification for a "thenable".
    if (value !== null && (typeof value === "function" || typeof value === "object") && typeof value.then === "function") return true;
    return false;
}
function isArray(value) {
    return Array.isArray(value);
}
function isErrorEvent(event) {
    return typeof event.type === "string" && (event.type === errorExecution || event.type.startsWith(errorPlatform));
}
function toTransitionConfigArray(configLike) {
    return toArrayStrict(configLike).map((transitionLike)=>{
        if (typeof transitionLike === "undefined" || typeof transitionLike === "string") return {
            target: transitionLike
        };
        return transitionLike;
    });
}
function normalizeTarget(target) {
    if (target === undefined || target === TARGETLESS_KEY) return undefined;
    return toArray(target);
}
function toInvokeConfig(invocable, id) {
    if (typeof invocable === "object") {
        if ("src" in invocable) return invocable;
        if ("transition" in invocable) return {
            id,
            src: invocable
        };
    }
    return {
        id,
        src: invocable
    };
}
function toObserver(nextHandler, errorHandler, completionHandler) {
    const isObserver = typeof nextHandler === "object";
    const self = isObserver ? nextHandler : undefined;
    return {
        next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),
        error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),
        complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self)
    };
}
function createInvokeId(stateNodeId, index) {
    return `${stateNodeId}:invocation[${index}]`;
}
function resolveReferencedActor(referenced) {
    return referenced ? "transition" in referenced ? {
        src: referenced,
        input: undefined
    } : referenced : undefined;
}
function fromCallback(invokeCallback) {
    return {
        config: invokeCallback,
        start: (_state, { self })=>{
            self.send({
                type: startSignalType
            });
        },
        transition: (state, event, { self, id, system })=>{
            if (event.type === startSignalType) {
                const sendBack = (eventForParent)=>{
                    if (state.canceled) return;
                    self._parent?.send(eventForParent);
                };
                const receive = (newListener)=>{
                    state.receivers.add(newListener);
                };
                state.dispose = invokeCallback({
                    input: state.input,
                    system,
                    self: self,
                    sendBack,
                    receive
                });
                if (isPromiseLike(state.dispose)) state.dispose.then((resolved)=>{
                    self._parent?.send(doneInvoke(id, resolved));
                    state.canceled = true;
                }, (errorData)=>{
                    state.canceled = true;
                    self._parent?.send(error(id, errorData));
                });
                return state;
            }
            if (event.type === stopSignalType) {
                state.canceled = true;
                if (typeof state.dispose === "function") state.dispose();
                return state;
            }
            if (isSignal(event)) // TODO: unrecognized signal
            return state;
            state.receivers.forEach((receiver)=>receiver(event));
            return state;
        },
        getInitialState: (_, input)=>{
            return {
                canceled: false,
                receivers: new Set(),
                dispose: undefined,
                input
            };
        },
        getSnapshot: ()=>undefined,
        getPersistedState: ({ input, canceled })=>({
                input,
                canceled
            })
    };
}
function fromObservable(observableCreator) {
    const nextEventType = "$$xstate.next";
    const errorEventType = "$$xstate.error";
    const completeEventType = "$$xstate.complete";
    return {
        config: observableCreator,
        transition: (state, event, { self, id, defer })=>{
            if (state.status !== "active") return state;
            switch(event.type){
                case nextEventType:
                    // match the exact timing of events sent by machines
                    // send actions are not executed immediately
                    defer(()=>{
                        self._parent?.send({
                            type: `xstate.snapshot.${id}`,
                            data: event.data
                        });
                    });
                    return {
                        ...state,
                        data: event.data
                    };
                case errorEventType:
                    return {
                        ...state,
                        status: "error",
                        input: undefined,
                        data: event.data,
                        // TODO: if we keep this as `data` we should reflect this in the type
                        subscription: undefined
                    };
                case completeEventType:
                    return {
                        ...state,
                        status: "done",
                        input: undefined,
                        subscription: undefined
                    };
                case stopSignalType:
                    state.subscription.unsubscribe();
                    return {
                        ...state,
                        status: "canceled",
                        input: undefined,
                        subscription: undefined
                    };
                default:
                    return state;
            }
        },
        getInitialState: (_, input)=>{
            return {
                subscription: undefined,
                status: "active",
                data: undefined,
                input
            };
        },
        start: (state, { self, system })=>{
            if (state.status === "done") // Do not restart a completed observable
            return;
            state.subscription = observableCreator({
                input: state.input,
                system,
                self
            }).subscribe({
                next: (value)=>{
                    self.send({
                        type: nextEventType,
                        data: value
                    });
                },
                error: (err)=>{
                    self.send({
                        type: errorEventType,
                        data: err
                    });
                },
                complete: ()=>{
                    self.send({
                        type: completeEventType
                    });
                }
            });
        },
        getSnapshot: (state)=>state.data,
        getPersistedState: ({ status, data, input })=>({
                status,
                data,
                input
            }),
        getStatus: (state)=>state,
        restoreState: (state)=>({
                ...state,
                subscription: undefined
            })
    };
}
/**
 * Creates event observable logic that listens to an observable
 * that delivers event objects.
 *
 *
 * @param lazyObservable A function that creates an observable
 * @returns Event observable logic
 */ function fromEventObservable(lazyObservable) {
    const errorEventType = "$$xstate.error";
    const completeEventType = "$$xstate.complete";
    // TODO: event types
    return {
        config: lazyObservable,
        transition: (state, event)=>{
            if (state.status !== "active") return state;
            switch(event.type){
                case errorEventType:
                    return {
                        ...state,
                        status: "error",
                        input: undefined,
                        data: event.data,
                        // TODO: if we keep this as `data` we should reflect this in the type
                        subscription: undefined
                    };
                case completeEventType:
                    return {
                        ...state,
                        status: "done",
                        input: undefined,
                        subscription: undefined
                    };
                case stopSignalType:
                    state.subscription.unsubscribe();
                    return {
                        ...state,
                        status: "canceled",
                        input: undefined,
                        subscription: undefined
                    };
                default:
                    return state;
            }
        },
        getInitialState: (_, input)=>{
            return {
                subscription: undefined,
                status: "active",
                data: undefined,
                input
            };
        },
        start: (state, { self, system })=>{
            if (state.status === "done") // Do not restart a completed observable
            return;
            state.subscription = lazyObservable({
                input: state.input,
                system,
                self
            }).subscribe({
                next: (value)=>{
                    self._parent?.send(value);
                },
                error: (err)=>{
                    self.send({
                        type: errorEventType,
                        data: err
                    });
                },
                complete: ()=>{
                    self.send({
                        type: completeEventType
                    });
                }
            });
        },
        getSnapshot: (_)=>undefined,
        getPersistedState: ({ status, data, input })=>({
                status,
                data,
                input
            }),
        getStatus: (state)=>state,
        restoreState: (state)=>({
                ...state,
                subscription: undefined
            })
    };
}
const resolveEventType = "$$xstate.resolve";
const rejectEventType = "$$xstate.reject";
function fromPromise(// TODO: add types
promiseCreator) {
    // TODO: add event types
    const logic = {
        config: promiseCreator,
        transition: (state, event)=>{
            if (state.status !== "active") return state;
            switch(event.type){
                case resolveEventType:
                    return {
                        ...state,
                        status: "done",
                        data: event.data,
                        input: undefined
                    };
                case rejectEventType:
                    return {
                        ...state,
                        status: "error",
                        data: event.data,
                        // TODO: if we keep this as `data` we should reflect this in the type
                        input: undefined
                    };
                case stopSignalType:
                    return {
                        ...state,
                        status: "canceled",
                        input: undefined
                    };
                default:
                    return state;
            }
        },
        start: (state, { self, system })=>{
            // TODO: determine how to allow customizing this so that promises
            // can be restarted if necessary
            if (state.status !== "active") return;
            const resolvedPromise = Promise.resolve(promiseCreator({
                input: state.input,
                system,
                self
            }));
            resolvedPromise.then((response)=>{
                // TODO: remove this condition once dead letter queue lands
                if (self._state.status !== "active") return;
                self.send({
                    type: resolveEventType,
                    data: response
                });
            }, (errorData)=>{
                // TODO: remove this condition once dead letter queue lands
                if (self._state.status !== "active") return;
                self.send({
                    type: rejectEventType,
                    data: errorData
                });
            });
        },
        getInitialState: (_, input)=>{
            return {
                status: "active",
                data: undefined,
                input
            };
        },
        getSnapshot: (state)=>state.data,
        getStatus: (state)=>state,
        getPersistedState: (state)=>state,
        restoreState: (state)=>state
    };
    return logic;
}
const startSignalType = "xstate.init";
const stopSignalType = "xstate.stop";
const startSignal = {
    type: "xstate.init"
};
const stopSignal = {
    type: "xstate.stop"
};
/**
 * An object that expresses the actor logic in reaction to received events,
 * as well as an optionally emitted stream of values.
 *
 * @template TReceived The received event
 * @template TSnapshot The emitted value
 */ function isSignal(event) {
    return event.type === startSignalType || event.type === stopSignalType;
}
function isActorRef(item) {
    return !!item && typeof item === "object" && typeof item.send === "function";
}
// TODO: refactor the return type, this could be written in a better way
// but it's best to avoid unneccessary breaking changes now
// @deprecated use `interpret(actorLogic)` instead
function toActorRef(actorRefLike) {
    return {
        subscribe: ()=>({
                unsubscribe: ()=>void 0
            }),
        id: "anonymous",
        sessionId: "",
        getSnapshot: ()=>undefined,
        // TODO: this isn't safe
        [symbolObservable]: function() {
            return this;
        },
        status: ActorStatus.Running,
        stop: ()=>void 0,
        ...actorRefLike
    };
}
const emptyLogic = fromTransition((_)=>undefined, undefined);
function createEmptyActor() {
    return createActor(emptyLogic);
}
/**
 * This function makes sure that unhandled errors are thrown in a separate macrotask.
 * It allows those errors to be detected by global error handlers and reported to bug tracking services
 * without interrupting our own stack of execution.
 *
 * @param err error to be thrown
 */ function reportUnhandledError(err) {
    setTimeout(()=>{
        throw err;
    });
}
function createSystem() {
    let sessionIdCounter = 0;
    const children = new Map();
    const keyedActors = new Map();
    const reverseKeyedActors = new WeakMap();
    const system = {
        _bookId: ()=>`x:${sessionIdCounter++}`,
        _register: (sessionId, actorRef)=>{
            children.set(sessionId, actorRef);
            return sessionId;
        },
        _unregister: (actorRef)=>{
            children.delete(actorRef.sessionId);
            const systemId = reverseKeyedActors.get(actorRef);
            if (systemId !== undefined) {
                keyedActors.delete(systemId);
                reverseKeyedActors.delete(actorRef);
            }
        },
        get: (systemId)=>{
            return keyedActors.get(systemId);
        },
        _set: (systemId, actorRef)=>{
            const existing = keyedActors.get(systemId);
            if (existing && existing !== actorRef) throw new Error(`Actor with system ID '${systemId}' already exists.`);
            keyedActors.set(systemId, actorRef);
            reverseKeyedActors.set(actorRef, systemId);
        }
    };
    return system;
}
let ActorStatus = /*#__PURE__*/ function(ActorStatus) {
    ActorStatus[ActorStatus["NotStarted"] = 0] = "NotStarted";
    ActorStatus[ActorStatus["Running"] = 1] = "Running";
    ActorStatus[ActorStatus["Stopped"] = 2] = "Stopped";
    return ActorStatus;
}({});
/**
 * @deprecated Use `ActorStatus` instead.
 */ const InterpreterStatus = ActorStatus;
const defaultOptions = {
    deferEvents: true,
    clock: {
        setTimeout: (fn, ms)=>{
            return setTimeout(fn, ms);
        },
        clearTimeout: (id)=>{
            return clearTimeout(id);
        }
    },
    logger: console.log.bind(console),
    devTools: false
};
class Actor {
    /**
   * The current internal state of the actor.
   */ /**
   * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.
   */ /**
   * The unique identifier for this actor relative to its parent.
   */ /**
   * Whether the service is started.
   */ // Actor Ref
    // TODO: add typings for system
    /**
   * The globally unique process ID for this invocation.
   */ /**
   * Creates a new actor instance for the given logic with the provided options, if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */ constructor(logic, options){
        this.logic = logic;
        this._state = void 0;
        this.clock = void 0;
        this.options = void 0;
        this.id = void 0;
        this.mailbox = new Mailbox(this._process.bind(this));
        this.delayedEventsMap = {};
        this.observers = new Set();
        this.logger = void 0;
        this.status = ActorStatus.NotStarted;
        this._parent = void 0;
        this.ref = void 0;
        this._actorContext = void 0;
        this._systemId = void 0;
        this.sessionId = void 0;
        this.system = void 0;
        this._doneEvent = void 0;
        this.src = void 0;
        this._deferred = [];
        const resolvedOptions = {
            ...defaultOptions,
            ...options
        };
        const { clock, logger, parent, id, systemId } = resolvedOptions;
        const self = this;
        this.system = parent?.system ?? createSystem();
        if (systemId) {
            this._systemId = systemId;
            this.system._set(systemId, this);
        }
        this.sessionId = this.system._bookId();
        this.id = id ?? this.sessionId;
        this.logger = logger;
        this.clock = clock;
        this._parent = parent;
        this.options = resolvedOptions;
        this.src = resolvedOptions.src;
        this.ref = this;
        this._actorContext = {
            self,
            id: this.id,
            sessionId: this.sessionId,
            logger: this.logger,
            defer: (fn)=>{
                this._deferred.push(fn);
            },
            system: this.system,
            stopChild: (child)=>{
                if (child._parent !== this) throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);
                child._stop();
            }
        };
        // Ensure that the send method is bound to this Actor instance
        // if destructured
        this.send = this.send.bind(this);
        this._initState();
    }
    _initState() {
        this._state = this.options.state ? this.logic.restoreState ? this.logic.restoreState(this.options.state, this._actorContext) : this.options.state : this.logic.getInitialState(this._actorContext, this.options?.input);
    }
    // array of functions to defer
    update(state) {
        // Update state
        this._state = state;
        const snapshot = this.getSnapshot();
        // Execute deferred effects
        let deferredFn;
        while(deferredFn = this._deferred.shift())deferredFn();
        for (const observer of this.observers)// TODO: should observers be notified in case of the error?
        try {
            observer.next?.(snapshot);
        } catch (err) {
            reportUnhandledError(err);
        }
        const status = this.logic.getStatus?.(state);
        switch(status?.status){
            case "done":
                this._stopProcedure();
                this._complete();
                this._doneEvent = doneInvoke(this.id, status.data);
                this._parent?.send(this._doneEvent);
                break;
            case "error":
                this._stopProcedure();
                this._error(status.data);
                this._parent?.send(error(this.id, status.data));
                break;
        }
    }
    subscribe(nextListenerOrObserver, errorListener, completeListener) {
        const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);
        if (this.status !== ActorStatus.Stopped) this.observers.add(observer);
        else try {
            observer.complete?.();
        } catch (err) {
            reportUnhandledError(err);
        }
        return {
            unsubscribe: ()=>{
                this.observers.delete(observer);
            }
        };
    }
    /**
   * Starts the Actor from the initial state
   */ start() {
        if (this.status === ActorStatus.Running) // Do not restart the service if it is already started
        return this;
        this.system._register(this.sessionId, this);
        if (this._systemId) this.system._set(this._systemId, this);
        this.status = ActorStatus.Running;
        const status = this.logic.getStatus?.(this._state);
        switch(status?.status){
            case "done":
                // a state machine can be "done" upon intialization (it could reach a final state using initial microsteps)
                // we still need to complete observers, flush deferreds etc
                this.update(this._state);
            // fallthrough
            case "error":
                // TODO: rethink cleanup of observers, mailbox, etc
                return this;
        }
        if (this.logic.start) try {
            this.logic.start(this._state, this._actorContext);
        } catch (err) {
            this._stopProcedure();
            this._error(err);
            this._parent?.send(error(this.id, err));
            return this;
        }
        // TODO: this notifies all subscribers but usually this is redundant
        // there is no real change happening here
        // we need to rethink if this needs to be refactored
        this.update(this._state);
        if (this.options.devTools) this.attachDevTools();
        this.mailbox.start();
        return this;
    }
    _process(event) {
        // TODO: reexamine what happens when an action (or a guard or smth) throws
        let nextState;
        let caughtError;
        try {
            nextState = this.logic.transition(this._state, event, this._actorContext);
        } catch (err) {
            // we wrap it in a box so we can rethrow it later even if falsy value gets caught here
            caughtError = {
                err
            };
        }
        if (caughtError) {
            const { err } = caughtError;
            this._stopProcedure();
            this._error(err);
            this._parent?.send(error(this.id, err));
            return;
        }
        this.update(nextState);
        if (event.type === stopSignalType) {
            this._stopProcedure();
            this._complete();
        }
    }
    _stop() {
        if (this.status === ActorStatus.Stopped) return this;
        this.mailbox.clear();
        if (this.status === ActorStatus.NotStarted) {
            this.status = ActorStatus.Stopped;
            return this;
        }
        this.mailbox.enqueue({
            type: stopSignalType
        });
        return this;
    }
    /**
   * Stops the Actor and unsubscribe all listeners.
   */ stop() {
        if (this._parent) throw new Error("A non-root actor cannot be stopped directly.");
        return this._stop();
    }
    _complete() {
        for (const observer of this.observers)try {
            observer.complete?.();
        } catch (err) {
            reportUnhandledError(err);
        }
        this.observers.clear();
    }
    _error(err) {
        if (!this.observers.size) {
            if (!this._parent) reportUnhandledError(err);
            return;
        }
        let reportError = false;
        for (const observer of this.observers){
            const errorListener = observer.error;
            reportError ||= !errorListener;
            try {
                errorListener?.(err);
            } catch (err2) {
                reportUnhandledError(err2);
            }
        }
        this.observers.clear();
        if (reportError) reportUnhandledError(err);
    }
    _stopProcedure() {
        if (this.status !== ActorStatus.Running) // Actor already stopped; do nothing
        return this;
        // Cancel all delayed events
        for (const key of Object.keys(this.delayedEventsMap))this.clock.clearTimeout(this.delayedEventsMap[key]);
        // TODO: mailbox.reset
        this.mailbox.clear();
        // TODO: after `stop` we must prepare ourselves for receiving events again
        // events sent *after* stop signal must be queued
        // it seems like this should be the common behavior for all of our consumers
        // so perhaps this should be unified somehow for all of them
        this.mailbox = new Mailbox(this._process.bind(this));
        this.status = ActorStatus.Stopped;
        this.system._unregister(this);
        return this;
    }
    /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */ send(event) {
        if (typeof event === "string") throw new Error(`Only event objects may be sent to actors; use .send({ type: "${event}" }) instead`);
        if (this.status === ActorStatus.Stopped) return;
        if (this.status !== ActorStatus.Running && !this.options.deferEvents) throw new Error(`Event "${event.type}" was sent to uninitialized actor "${this.id}". Make sure .start() is called for this actor, or set { deferEvents: true } in the actor options.\nEvent: ${JSON.stringify(event)}`);
        this.mailbox.enqueue(event);
    }
    // TODO: make private (and figure out a way to do this within the machine)
    delaySend({ event, id, delay, to }) {
        const timerId = this.clock.setTimeout(()=>{
            if (to) to.send(event);
            else this.send(event);
        }, delay);
        // TODO: consider the rehydration story here
        if (id) this.delayedEventsMap[id] = timerId;
    }
    // TODO: make private (and figure out a way to do this within the machine)
    cancel(sendId) {
        this.clock.clearTimeout(this.delayedEventsMap[sendId]);
        delete this.delayedEventsMap[sendId];
    }
    attachDevTools() {
        const { devTools } = this.options;
        if (devTools) {
            const resolvedDevToolsAdapter = typeof devTools === "function" ? devTools : (0, _xstateDevEsmJs.devToolsAdapter);
            resolvedDevToolsAdapter(this);
        }
    }
    toJSON() {
        return {
            id: this.id
        };
    }
    getPersistedState() {
        return this.logic.getPersistedState?.(this._state);
    }
    [symbolObservable]() {
        return this;
    }
    getSnapshot() {
        return this.logic.getSnapshot ? this.logic.getSnapshot(this._state) : this._state;
    }
}
/**
 * Creates a new `ActorRef` instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to create an actor from
 * @param options `ActorRef` options
 */ function createActor(logic, options) {
    const interpreter = new Actor(logic, options);
    return interpreter;
}
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @deprecated Use `createActor` instead
 */ const interpret = createActor;
/**
 * @deprecated Use `Actor` instead.
 */ function resolve$6(actorContext, state, actionArgs, { id, systemId, src, input }) {
    const referenced = resolveReferencedActor(state.machine.implementations.actors[src]);
    let actorRef;
    if (referenced) {
        // TODO: inline `input: undefined` should win over the referenced one
        const configuredInput = input || referenced.input;
        actorRef = createActor(referenced.src, {
            id,
            src,
            parent: actorContext?.self,
            systemId,
            input: typeof configuredInput === "function" ? configuredInput({
                context: state.context,
                event: actionArgs.event,
                self: actorContext?.self
            }) : configuredInput
        });
    }
    return [
        cloneState(state, {
            children: {
                ...state.children,
                [id]: actorRef
            }
        }),
        {
            id,
            actorRef
        }
    ];
}
function execute$3(actorContext, { id, actorRef }) {
    if (!actorRef) return;
    actorContext.defer(()=>{
        if (actorRef.status === ActorStatus.Stopped) return;
        try {
            actorRef.start?.();
        } catch (err) {
            actorContext.self.send(error(id, err));
            return;
        }
    });
}
function invoke({ id, systemId, src, input }) {
    function invoke(_) {}
    invoke.type = "xstate.invoke";
    invoke.id = id;
    invoke.systemId = systemId;
    invoke.src = src;
    invoke.input = input;
    invoke.resolve = resolve$6;
    invoke.execute = execute$3;
    return invoke;
}
function stateIn(stateValue) {
    return {
        type: "xstate.guard:in",
        params: {
            stateValue
        },
        predicate: ({ state })=>{
            if (typeof stateValue === "string" && isStateId(stateValue)) return state.configuration.some((sn)=>sn.id === stateValue.slice(1));
            return state.matches(stateValue);
        }
    };
}
function not(guard) {
    return {
        type: "xstate.boolean",
        params: {
            op: "not"
        },
        children: [
            toGuardDefinition(guard)
        ],
        predicate: ({ evaluate, guard, context, event, state })=>{
            return !evaluate(guard.children[0], context, event, state);
        }
    };
}
function and(guards) {
    return {
        type: "xstate.boolean",
        params: {
            op: "and"
        },
        children: guards.map((guard)=>toGuardDefinition(guard)),
        predicate: ({ evaluate, guard, context, event, state })=>{
            return guard.children.every((childGuard)=>{
                return evaluate(childGuard, context, event, state);
            });
        }
    };
}
function or(guards) {
    return {
        type: "xstate.boolean",
        params: {
            op: "or"
        },
        children: guards.map((guard)=>toGuardDefinition(guard)),
        predicate: ({ evaluate, guard, context, event, state })=>{
            return guard.children.some((childGuard)=>{
                return evaluate(childGuard, context, event, state);
            });
        }
    };
}
function evaluateGuard(guard, context, event, state) {
    const { machine } = state;
    const predicate = machine?.implementations?.guards?.[guard.type] ?? guard.predicate;
    if (!predicate) throw new Error(`Guard '${guard.type}' is not implemented.'.`);
    return predicate({
        context,
        event,
        state,
        guard,
        evaluate: evaluateGuard
    });
}
function toGuardDefinition(guardConfig, getPredicate) {
    // TODO: check for cycles and consider a refactor to more lazily evaluated guards
    // TODO: resolve this more recursively: https://github.com/statelyai/xstate/pull/4064#discussion_r1229915724
    if (typeof guardConfig === "string") {
        const predicateOrDef = getPredicate?.(guardConfig);
        if (typeof predicateOrDef === "function") return {
            type: guardConfig,
            predicate: predicateOrDef,
            params: {
                type: guardConfig
            }
        };
        else if (predicateOrDef) return predicateOrDef;
        else return {
            type: guardConfig,
            params: {
                type: guardConfig
            }
        };
    }
    if (typeof guardConfig === "function") return {
        type: guardConfig.name,
        predicate: guardConfig,
        params: {
            type: guardConfig.name,
            name: guardConfig.name
        }
    };
    const predicateOrDef = getPredicate?.(guardConfig.type);
    if (typeof predicateOrDef === "function") return {
        type: guardConfig.type,
        params: guardConfig.params || guardConfig,
        children: guardConfig.children?.map((childGuard)=>toGuardDefinition(childGuard, getPredicate)),
        predicate: getPredicate?.(guardConfig.type) || guardConfig.predicate
    };
    else if (predicateOrDef) return predicateOrDef;
    else return {
        type: guardConfig.type,
        params: guardConfig.params || guardConfig,
        children: guardConfig.children?.map((childGuard)=>toGuardDefinition(childGuard, getPredicate)),
        predicate: guardConfig.predicate
    };
}
function getOutput(configuration, context, event, self) {
    const machine = configuration[0].machine;
    const finalChildStateNode = configuration.find((stateNode)=>stateNode.type === "final" && stateNode.parent === machine.root);
    return finalChildStateNode && finalChildStateNode.output ? mapContext(finalChildStateNode.output, context, event, self) : undefined;
}
const isAtomicStateNode = (stateNode)=>stateNode.type === "atomic" || stateNode.type === "final";
function getChildren(stateNode) {
    return Object.values(stateNode.states).filter((sn)=>sn.type !== "history");
}
function getProperAncestors(stateNode, toStateNode) {
    const ancestors = [];
    // add all ancestors
    let m = stateNode.parent;
    while(m && m !== toStateNode){
        ancestors.push(m);
        m = m.parent;
    }
    return ancestors;
}
function getConfiguration(stateNodes) {
    const configuration = new Set(stateNodes);
    const configurationSet = new Set(stateNodes);
    const adjList = getAdjList(configurationSet);
    // add descendants
    for (const s of configuration)// if previously active, add existing child nodes
    if (s.type === "compound" && (!adjList.get(s) || !adjList.get(s).length)) getInitialStateNodes(s).forEach((sn)=>configurationSet.add(sn));
    else {
        if (s.type === "parallel") for (const child of getChildren(s)){
            if (child.type === "history") continue;
            if (!configurationSet.has(child)) for (const initialStateNode of getInitialStateNodes(child))configurationSet.add(initialStateNode);
        }
    }
    // add all ancestors
    for (const s of configurationSet){
        let m = s.parent;
        while(m){
            configurationSet.add(m);
            m = m.parent;
        }
    }
    return configurationSet;
}
function getValueFromAdj(baseNode, adjList) {
    const childStateNodes = adjList.get(baseNode);
    if (!childStateNodes) return {}; // todo: fix?
    if (baseNode.type === "compound") {
        const childStateNode = childStateNodes[0];
        if (childStateNode) {
            if (isAtomicStateNode(childStateNode)) return childStateNode.key;
        } else return {};
    }
    const stateValue = {};
    for (const childStateNode of childStateNodes)stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);
    return stateValue;
}
function getAdjList(configuration) {
    const adjList = new Map();
    for (const s of configuration){
        if (!adjList.has(s)) adjList.set(s, []);
        if (s.parent) {
            if (!adjList.has(s.parent)) adjList.set(s.parent, []);
            adjList.get(s.parent).push(s);
        }
    }
    return adjList;
}
function getStateValue(rootNode, configuration) {
    const config = getConfiguration(configuration);
    return getValueFromAdj(rootNode, getAdjList(config));
}
function isInFinalState(configuration, stateNode = configuration[0].machine.root) {
    if (stateNode.type === "compound") return getChildren(stateNode).some((s)=>s.type === "final" && configuration.includes(s));
    if (stateNode.type === "parallel") return getChildren(stateNode).every((sn)=>isInFinalState(configuration, sn));
    return false;
}
const isStateId = (str)=>str[0] === STATE_IDENTIFIER;
function getCandidates(stateNode, receivedEventType) {
    const candidates = stateNode.transitions.get(receivedEventType) || [
        ...stateNode.transitions.keys()
    ].filter((descriptor)=>{
        // check if transition is a wildcard transition,
        // which matches any non-transient events
        if (descriptor === WILDCARD) return true;
        if (!descriptor.endsWith(".*")) return false;
        const partialEventTokens = descriptor.split(".");
        const eventTokens = receivedEventType.split(".");
        for(let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++){
            const partialEventToken = partialEventTokens[tokenIndex];
            const eventToken = eventTokens[tokenIndex];
            if (partialEventToken === "*") {
                const isLastToken = tokenIndex === partialEventTokens.length - 1;
                return isLastToken;
            }
            if (partialEventToken !== eventToken) return false;
        }
        return true;
    }).sort((a, b)=>b.length - a.length).flatMap((key)=>stateNode.transitions.get(key));
    return candidates;
}
/**
 * All delayed transitions from the config.
 */ function getDelayedTransitions(stateNode) {
    const afterConfig = stateNode.config.after;
    if (!afterConfig) return [];
    const mutateEntryExit = (delay, i)=>{
        const delayRef = typeof delay === "function" ? `${stateNode.id}:delay[${i}]` : delay;
        const eventType = after(delayRef, stateNode.id);
        stateNode.entry.push(raise({
            type: eventType
        }, {
            id: eventType,
            delay
        }));
        stateNode.exit.push(cancel(eventType));
        return eventType;
    };
    const delayedTransitions = isArray(afterConfig) ? afterConfig.map((transition, i)=>{
        const eventType = mutateEntryExit(transition.delay, i);
        return {
            ...transition,
            event: eventType
        };
    }) : Object.keys(afterConfig).flatMap((delay, i)=>{
        const configTransition = afterConfig[delay];
        const resolvedTransition = typeof configTransition === "string" ? {
            target: configTransition
        } : configTransition;
        const resolvedDelay = !isNaN(+delay) ? +delay : delay;
        const eventType = mutateEntryExit(resolvedDelay, i);
        return toArray(resolvedTransition).map((transition)=>({
                ...transition,
                event: eventType,
                delay: resolvedDelay
            }));
    });
    return delayedTransitions.map((delayedTransition)=>{
        const { delay } = delayedTransition;
        return {
            ...formatTransition(stateNode, delayedTransition.event, delayedTransition),
            delay
        };
    });
}
function formatTransition(stateNode, descriptor, transitionConfig) {
    const normalizedTarget = normalizeTarget(transitionConfig.target);
    const reenter = transitionConfig.reenter ?? false;
    const { guards } = stateNode.machine.implementations;
    const target = resolveTarget(stateNode, normalizedTarget);
    const transition = {
        ...transitionConfig,
        actions: toArray(transitionConfig.actions),
        guard: transitionConfig.guard ? toGuardDefinition(transitionConfig.guard, (guardType)=>guards[guardType]) : undefined,
        target,
        source: stateNode,
        reenter,
        eventType: descriptor,
        toJSON: ()=>({
                ...transition,
                source: `#${stateNode.id}`,
                target: target ? target.map((t)=>`#${t.id}`) : undefined
            })
    };
    return transition;
}
function formatTransitions(stateNode) {
    const transitions = new Map();
    if (stateNode.config.on) for (const descriptor of Object.keys(stateNode.config.on)){
        if (descriptor === NULL_EVENT) throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
        const transitionsConfig = stateNode.config.on[descriptor];
        transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t)=>formatTransition(stateNode, descriptor, t)));
    }
    if (stateNode.config.onDone) {
        const descriptor = String(done(stateNode.id));
        transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));
    }
    for (const invokeDef of stateNode.invoke){
        if (invokeDef.onDone) {
            const descriptor = `done.invoke.${invokeDef.id}`;
            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));
        }
        if (invokeDef.onError) {
            const descriptor = `error.platform.${invokeDef.id}`;
            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t)=>formatTransition(stateNode, descriptor, t)));
        }
        if (invokeDef.onSnapshot) {
            const descriptor = `xstate.snapshot.${invokeDef.id}`;
            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t)=>formatTransition(stateNode, descriptor, t)));
        }
    }
    for (const delayedTransition of stateNode.after){
        let existing = transitions.get(delayedTransition.eventType);
        if (!existing) {
            existing = [];
            transitions.set(delayedTransition.eventType, existing);
        }
        existing.push(delayedTransition);
    }
    return transitions;
}
function formatInitialTransition(stateNode, _target) {
    if (typeof _target === "string" || isArray(_target)) {
        const targets = toArray(_target).map((t)=>{
            // Resolve state string keys (which represent children)
            // to their state node
            const descStateNode = typeof t === "string" ? isStateId(t) ? stateNode.machine.getStateNodeById(t) : stateNode.states[t] : t;
            if (!descStateNode) throw new Error(`Initial state node "${t}" not found on parent state node #${stateNode.id}`);
            if (!isDescendant(descStateNode, stateNode)) throw new Error(`Invalid initial target: state node #${descStateNode.id} is not a descendant of #${stateNode.id}`);
            return descStateNode;
        });
        const resolvedTarget = resolveTarget(stateNode, targets);
        const transition = {
            source: stateNode,
            actions: [],
            eventType: null,
            reenter: false,
            target: resolvedTarget,
            toJSON: ()=>({
                    ...transition,
                    source: `#${stateNode.id}`,
                    target: resolvedTarget ? resolvedTarget.map((t)=>`#${t.id}`) : undefined
                })
        };
        return transition;
    }
    return formatTransition(stateNode, "__INITIAL__", {
        target: toArray(_target.target).map((t)=>{
            if (typeof t === "string") return isStateId(t) ? t : `${STATE_DELIMITER}${t}`;
            return t;
        }),
        actions: _target.actions
    });
}
function resolveTarget(stateNode, targets) {
    if (targets === undefined) // an undefined target signals that the state node should not transition from that state when receiving that event
    return undefined;
    return targets.map((target)=>{
        if (typeof target !== "string") return target;
        if (isStateId(target)) return stateNode.machine.getStateNodeById(target);
        const isInternalTarget = target[0] === STATE_DELIMITER;
        // If internal target is defined on machine,
        // do not include machine key on target
        if (isInternalTarget && !stateNode.parent) return getStateNodeByPath(stateNode, target.slice(1));
        const resolvedTarget = isInternalTarget ? stateNode.key + target : target;
        if (stateNode.parent) try {
            const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);
            return targetStateNode;
        } catch (err) {
            throw new Error(`Invalid transition definition for state node '${stateNode.id}':\n${err.message}`);
        }
        else throw new Error(`Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`);
    });
}
function resolveHistoryTarget(stateNode) {
    const normalizedTarget = normalizeTarget(stateNode.target);
    if (!normalizedTarget) return stateNode.parent.initial.target;
    return normalizedTarget.map((t)=>typeof t === "string" ? getStateNodeByPath(stateNode.parent, t) : t);
}
function isHistoryNode(stateNode) {
    return stateNode.type === "history";
}
function getInitialStateNodes(stateNode) {
    const set = new Set();
    function iter(descStateNode) {
        if (set.has(descStateNode)) return;
        set.add(descStateNode);
        if (descStateNode.type === "compound") for (const targetStateNode of descStateNode.initial.target){
            for (const a of getProperAncestors(targetStateNode, stateNode))set.add(a);
            iter(targetStateNode);
        }
        else if (descStateNode.type === "parallel") for (const child of getChildren(descStateNode))iter(child);
    }
    iter(stateNode);
    return [
        ...set
    ];
}
/**
 * Returns the child state node from its relative `stateKey`, or throws.
 */ function getStateNode(stateNode, stateKey) {
    if (isStateId(stateKey)) return stateNode.machine.getStateNodeById(stateKey);
    if (!stateNode.states) throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);
    const result = stateNode.states[stateKey];
    if (!result) throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);
    return result;
}
/**
 * Returns the relative state node from the given `statePath`, or throws.
 *
 * @param statePath The string or string array relative path to the state node.
 */ function getStateNodeByPath(stateNode, statePath) {
    if (typeof statePath === "string" && isStateId(statePath)) try {
        return stateNode.machine.getStateNodeById(statePath);
    } catch (e) {
    // try individual paths
    // throw e;
    }
    const arrayStatePath = toStatePath(statePath).slice();
    let currentStateNode = stateNode;
    while(arrayStatePath.length){
        const key = arrayStatePath.shift();
        if (!key.length) break;
        currentStateNode = getStateNode(currentStateNode, key);
    }
    return currentStateNode;
}
/**
 * Returns the state nodes represented by the current state value.
 *
 * @param state The state value or State instance
 */ function getStateNodes(stateNode, state) {
    const stateValue = state instanceof State ? state.value : toStateValue(state);
    if (typeof stateValue === "string") return [
        stateNode,
        stateNode.states[stateValue]
    ];
    const childStateKeys = Object.keys(stateValue);
    const childStateNodes = childStateKeys.map((subStateKey)=>getStateNode(stateNode, subStateKey)).filter(Boolean);
    return [
        stateNode.machine.root,
        stateNode
    ].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey)=>{
        const subStateNode = getStateNode(stateNode, subStateKey);
        if (!subStateNode) return allSubStateNodes;
        const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);
        return allSubStateNodes.concat(subStateNodes);
    }, []));
}
function transitionAtomicNode(stateNode, stateValue, state, event) {
    const childStateNode = getStateNode(stateNode, stateValue);
    const next = childStateNode.next(state, event);
    if (!next || !next.length) return stateNode.next(state, event);
    return next;
}
function transitionCompoundNode(stateNode, stateValue, state, event) {
    const subStateKeys = Object.keys(stateValue);
    const childStateNode = getStateNode(stateNode, subStateKeys[0]);
    const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], state, event);
    if (!next || !next.length) return stateNode.next(state, event);
    return next;
}
function transitionParallelNode(stateNode, stateValue, state, event) {
    const allInnerTransitions = [];
    for (const subStateKey of Object.keys(stateValue)){
        const subStateValue = stateValue[subStateKey];
        if (!subStateValue) continue;
        const subStateNode = getStateNode(stateNode, subStateKey);
        const innerTransitions = transitionNode(subStateNode, subStateValue, state, event);
        if (innerTransitions) allInnerTransitions.push(...innerTransitions);
    }
    if (!allInnerTransitions.length) return stateNode.next(state, event);
    return allInnerTransitions;
}
function transitionNode(stateNode, stateValue, state, event) {
    // leaf node
    if (typeof stateValue === "string") return transitionAtomicNode(stateNode, stateValue, state, event);
    // compound node
    if (Object.keys(stateValue).length === 1) return transitionCompoundNode(stateNode, stateValue, state, event);
    // parallel node
    return transitionParallelNode(stateNode, stateValue, state, event);
}
function getHistoryNodes(stateNode) {
    return Object.keys(stateNode.states).map((key)=>stateNode.states[key]).filter((sn)=>sn.type === "history");
}
function isDescendant(childStateNode, parentStateNode) {
    let marker = childStateNode;
    while(marker.parent && marker.parent !== parentStateNode)marker = marker.parent;
    return marker.parent === parentStateNode;
}
function getPathFromRootToNode(stateNode) {
    const path = [];
    let marker = stateNode.parent;
    while(marker){
        path.unshift(marker);
        marker = marker.parent;
    }
    return path;
}
function hasIntersection(s1, s2) {
    const set1 = new Set(s1);
    const set2 = new Set(s2);
    for (const item of set1){
        if (set2.has(item)) return true;
    }
    for (const item of set2){
        if (set1.has(item)) return true;
    }
    return false;
}
function removeConflictingTransitions(enabledTransitions, configuration, historyValue) {
    const filteredTransitions = new Set();
    for (const t1 of enabledTransitions){
        let t1Preempted = false;
        const transitionsToRemove = new Set();
        for (const t2 of filteredTransitions)if (hasIntersection(computeExitSet([
            t1
        ], configuration, historyValue), computeExitSet([
            t2
        ], configuration, historyValue))) {
            if (isDescendant(t1.source, t2.source)) transitionsToRemove.add(t2);
            else {
                t1Preempted = true;
                break;
            }
        }
        if (!t1Preempted) {
            for (const t3 of transitionsToRemove)filteredTransitions.delete(t3);
            filteredTransitions.add(t1);
        }
    }
    return Array.from(filteredTransitions);
}
function findLCCA(stateNodes) {
    const [head] = stateNodes;
    let current = getPathFromRootToNode(head);
    let candidates = [];
    for (const stateNode of stateNodes){
        const path = getPathFromRootToNode(stateNode);
        candidates = current.filter((sn)=>path.includes(sn));
        current = candidates;
        candidates = [];
    }
    return current[current.length - 1];
}
function getEffectiveTargetStates(transition, historyValue) {
    if (!transition.target) return [];
    const targets = new Set();
    for (const targetNode of transition.target)if (isHistoryNode(targetNode)) {
        if (historyValue[targetNode.id]) for (const node of historyValue[targetNode.id])targets.add(node);
        else for (const node of getEffectiveTargetStates({
            target: resolveHistoryTarget(targetNode)
        }, historyValue))targets.add(node);
    } else targets.add(targetNode);
    return [
        ...targets
    ];
}
function getTransitionDomain(transition, historyValue) {
    const targetStates = getEffectiveTargetStates(transition, historyValue);
    if (!targetStates) return null;
    if (!transition.reenter && transition.source.type !== "parallel" && targetStates.every((targetStateNode)=>isDescendant(targetStateNode, transition.source))) return transition.source;
    const lcca = findLCCA(targetStates.concat(transition.source));
    return lcca;
}
function computeExitSet(transitions, configuration, historyValue) {
    const statesToExit = new Set();
    for (const t of transitions)if (t.target?.length) {
        const domain = getTransitionDomain(t, historyValue);
        for (const stateNode of configuration)if (isDescendant(stateNode, domain)) statesToExit.add(stateNode);
    }
    return [
        ...statesToExit
    ];
}
/**
 * https://www.w3.org/TR/scxml/#microstepProcedure
 *
 * @private
 * @param transitions
 * @param currentState
 * @param mutConfiguration
 */ function microstep(transitions, currentState, actorCtx, event, isInitial) {
    const mutConfiguration = new Set(currentState.configuration);
    if (!transitions.length) return currentState;
    const microstate = microstepProcedure(transitions, currentState, mutConfiguration, event, actorCtx, isInitial);
    return cloneState(microstate, {
        value: {} // TODO: make optional
    });
}
function microstepProcedure(transitions, currentState, mutConfiguration, event, actorCtx, isInitial) {
    const actions = [];
    const historyValue = {
        ...currentState.historyValue
    };
    const filteredTransitions = removeConflictingTransitions(transitions, mutConfiguration, historyValue);
    const internalQueue = [
        ...currentState._internalQueue
    ];
    // Exit states
    if (!isInitial) exitStates(filteredTransitions, mutConfiguration, historyValue, actions);
    // Execute transition content
    actions.push(...filteredTransitions.flatMap((t)=>t.actions));
    // Enter states
    enterStates(event, filteredTransitions, mutConfiguration, actions, internalQueue, currentState, historyValue, isInitial, actorCtx);
    const nextConfiguration = [
        ...mutConfiguration
    ];
    const done = isInFinalState(nextConfiguration);
    if (done) {
        const finalActions = nextConfiguration.sort((a, b)=>b.order - a.order).flatMap((state)=>state.exit);
        actions.push(...finalActions);
    }
    try {
        const nextState = resolveActionsAndContext(actions, event, currentState, actorCtx);
        const output = done ? getOutput(nextConfiguration, nextState.context, event, actorCtx.self) : undefined;
        internalQueue.push(...nextState._internalQueue);
        return cloneState(currentState, {
            configuration: nextConfiguration,
            historyValue,
            _internalQueue: internalQueue,
            context: nextState.context,
            done,
            output,
            children: nextState.children
        });
    } catch (e) {
        // TODO: Refactor this once proper error handling is implemented.
        // See https://github.com/statelyai/rfcs/pull/4
        throw e;
    }
}
function enterStates(event, filteredTransitions, mutConfiguration, actions, internalQueue, currentState, historyValue, isInitial, actorContext) {
    const statesToEnter = new Set();
    const statesForDefaultEntry = new Set();
    computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);
    // In the initial state, the root state node is "entered".
    if (isInitial) statesForDefaultEntry.add(currentState.machine.root);
    for (const stateNodeToEnter of [
        ...statesToEnter
    ].sort((a, b)=>a.order - b.order)){
        mutConfiguration.add(stateNodeToEnter);
        for (const invokeDef of stateNodeToEnter.invoke)actions.push(invoke(invokeDef));
        // Add entry actions
        actions.push(...stateNodeToEnter.entry);
        if (statesForDefaultEntry.has(stateNodeToEnter)) for (const stateNode of statesForDefaultEntry){
            const initialActions = stateNode.initial.actions;
            actions.push(...initialActions);
        }
        if (stateNodeToEnter.type === "final") {
            const parent = stateNodeToEnter.parent;
            if (!parent.parent) continue;
            internalQueue.push(done(parent.id, stateNodeToEnter.output ? mapContext(stateNodeToEnter.output, currentState.context, event, actorContext.self) : undefined));
            if (parent.parent) {
                const grandparent = parent.parent;
                if (grandparent.type === "parallel") {
                    if (getChildren(grandparent).every((parentNode)=>isInFinalState([
                            ...mutConfiguration
                        ], parentNode))) internalQueue.push(done(grandparent.id));
                }
            }
        }
    }
}
function computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {
    for (const t of transitions){
        for (const s of t.target || [])addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
        const ancestor = getTransitionDomain(t, historyValue);
        const targetStates = getEffectiveTargetStates(t, historyValue);
        for (const s of targetStates)addAncestorStatesToEnter(s, ancestor, statesToEnter, historyValue, statesForDefaultEntry);
    }
}
function addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {
    if (isHistoryNode(stateNode)) {
        if (historyValue[stateNode.id]) {
            const historyStateNodes = historyValue[stateNode.id];
            for (const s of historyStateNodes)addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
            for (const s of historyStateNodes){
                addAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
                for (const stateForDefaultEntry of statesForDefaultEntry)statesForDefaultEntry.add(stateForDefaultEntry);
            }
        } else {
            const targets = resolveHistoryTarget(stateNode);
            for (const s of targets)addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
            for (const s of targets){
                addAncestorStatesToEnter(s, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
                for (const stateForDefaultEntry of statesForDefaultEntry)statesForDefaultEntry.add(stateForDefaultEntry);
            }
        }
    } else {
        statesToEnter.add(stateNode);
        if (stateNode.type === "compound") {
            statesForDefaultEntry.add(stateNode);
            const initialStates = stateNode.initial.target;
            for (const initialState of initialStates)addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);
            for (const initialState of initialStates)addAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
        } else if (stateNode.type === "parallel") {
            for (const child of getChildren(stateNode).filter((sn)=>!isHistoryNode(sn)))if (![
                ...statesToEnter
            ].some((s)=>isDescendant(s, child))) addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);
        }
    }
}
function addAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {
    const properAncestors = getProperAncestors(stateNode, toStateNode);
    for (const anc of properAncestors){
        statesToEnter.add(anc);
        if (anc.type === "parallel") {
            for (const child of getChildren(anc).filter((sn)=>!isHistoryNode(sn)))if (![
                ...statesToEnter
            ].some((s)=>isDescendant(s, child))) addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);
        }
    }
}
function exitStates(transitions, mutConfiguration, historyValue, actions) {
    const statesToExit = computeExitSet(transitions, mutConfiguration, historyValue);
    statesToExit.sort((a, b)=>b.order - a.order);
    // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates
    for (const exitStateNode of statesToExit)for (const historyNode of getHistoryNodes(exitStateNode)){
        let predicate;
        if (historyNode.history === "deep") predicate = (sn)=>isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);
        else predicate = (sn)=>{
            return sn.parent === exitStateNode;
        };
        historyValue[historyNode.id] = Array.from(mutConfiguration).filter(predicate);
    }
    for (const s of statesToExit){
        actions.push(...s.exit, ...s.invoke.map((def)=>stop(def.id)));
        mutConfiguration.delete(s);
    }
}
function resolveActionsAndContext(actions, event, currentState, actorCtx) {
    const { machine } = currentState;
    // TODO: this `cloneState` is really just a hack to prevent infinite loops
    // we need to take another look at how internal queue is managed
    let intermediateState = cloneState(currentState, {
        _internalQueue: []
    });
    for (const action of actions){
        const isInline = typeof action === "function";
        const resolved = isInline ? action : // the existing type of `.actions` assumes non-nullable `TExpressionAction`
        // it's fine to cast this here to get a common type and lack of errors in the rest of the code
        // our logic below makes sure that we call those 2 "variants" correctly
        machine.implementations.actions[typeof action === "string" ? action : action.type];
        if (!resolved) continue;
        const args = {
            context: intermediateState.context,
            event,
            self: actorCtx?.self,
            system: actorCtx?.system,
            action: isInline ? undefined : typeof action === "string" ? {
                type: action
            } : action
        };
        if (!("resolve" in resolved)) {
            if (actorCtx?.self.status === ActorStatus.Running) resolved(args);
            else actorCtx?.defer(()=>resolved(args));
            continue;
        }
        const builtinAction = resolved;
        const [nextState, params, actions] = builtinAction.resolve(actorCtx, intermediateState, args, resolved // this holds all params
        );
        intermediateState = nextState;
        if ("execute" in resolved) {
            if (actorCtx?.self.status === ActorStatus.Running) builtinAction.execute(actorCtx, params);
            else actorCtx?.defer(builtinAction.execute.bind(null, actorCtx, params));
        }
        if (actions) intermediateState = resolveActionsAndContext(actions, event, intermediateState, actorCtx);
    }
    return intermediateState;
}
function macrostep(state, event, actorCtx) {
    let nextState = state;
    const states = [];
    // Handle stop event
    if (event.type === stopSignalType) {
        nextState = stopStep(event, nextState, actorCtx);
        states.push(nextState);
        return {
            state: nextState,
            microstates: states
        };
    }
    let nextEvent = event;
    // Assume the state is at rest (no raised events)
    // Determine the next state based on the next microstep
    if (nextEvent.type !== INIT_TYPE) {
        const transitions = selectTransitions(nextEvent, nextState);
        nextState = microstep(transitions, state, actorCtx, nextEvent, false);
        states.push(nextState);
    }
    while(!nextState.done){
        let enabledTransitions = selectEventlessTransitions(nextState, nextEvent);
        if (!enabledTransitions.length) {
            if (!nextState._internalQueue.length) break;
            else {
                nextEvent = nextState._internalQueue[0];
                const transitions = selectTransitions(nextEvent, nextState);
                nextState = microstep(transitions, nextState, actorCtx, nextEvent, false);
                nextState._internalQueue.shift();
                states.push(nextState);
            }
        } else {
            nextState = microstep(enabledTransitions, nextState, actorCtx, nextEvent, false);
            states.push(nextState);
        }
    }
    if (nextState.done) // Perform the stop step to ensure that child actors are stopped
    stopStep(nextEvent, nextState, actorCtx);
    return {
        state: nextState,
        microstates: states
    };
}
function stopStep(event, nextState, actorCtx) {
    const actions = [];
    for (const stateNode of nextState.configuration.sort((a, b)=>b.order - a.order))actions.push(...stateNode.exit);
    for (const child of Object.values(nextState.children))actions.push(stop(child));
    return resolveActionsAndContext(actions, event, nextState, actorCtx);
}
function selectTransitions(event, nextState) {
    return nextState.machine.getTransitionData(nextState, event);
}
function selectEventlessTransitions(nextState, event) {
    const enabledTransitionSet = new Set();
    const atomicStates = nextState.configuration.filter(isAtomicStateNode);
    for (const stateNode of atomicStates)loop: for (const s of [
        stateNode
    ].concat(getProperAncestors(stateNode, null))){
        if (!s.always) continue;
        for (const transition of s.always)if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {
            enabledTransitionSet.add(transition);
            break loop;
        }
    }
    return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState.configuration), nextState.historyValue);
}
/**
 * Resolves a partial state value with its full representation in the state node's machine.
 *
 * @param stateValue The partial state value to resolve.
 */ function resolveStateValue(rootNode, stateValue) {
    const configuration = getConfiguration(getStateNodes(rootNode, stateValue));
    return getStateValue(rootNode, [
        ...configuration
    ]);
}
function getInitialConfiguration(rootNode) {
    const configuration = [];
    const initialTransition = rootNode.initial;
    const statesToEnter = new Set();
    const statesForDefaultEntry = new Set([
        rootNode
    ]);
    computeEntrySet([
        initialTransition
    ], {}, statesForDefaultEntry, statesToEnter);
    for (const stateNodeToEnter of [
        ...statesToEnter
    ].sort((a, b)=>a.order - b.order))configuration.push(stateNodeToEnter);
    return configuration;
}
class State {
    /**
   * Indicates whether the state is a final state.
   */ /**
   * The output data of the top-level finite state.
   */ /**
   * The enabled state nodes representative of the state value.
   */ /**
   * An object mapping actor names to spawned/invoked actors.
   */ /**
   * Creates a new State instance for the given `stateValue` and `context`.
   * @param stateValue
   * @param context
   */ static from(stateValue, context = {}, machine) {
        if (stateValue instanceof State) {
            if (stateValue.context !== context) return new State({
                value: stateValue.value,
                context,
                meta: {},
                configuration: [],
                // TODO: fix,
                children: {}
            }, machine);
            return stateValue;
        }
        const configuration = getConfiguration(getStateNodes(machine.root, stateValue));
        return new State({
            value: stateValue,
            context,
            meta: undefined,
            configuration: Array.from(configuration),
            children: {}
        }, machine);
    }
    /**
   * Creates a new `State` instance that represents the current state of a running machine.
   *
   * @param config
   */ constructor(config, machine){
        this.machine = machine;
        this.tags = void 0;
        this.value = void 0;
        this.done = void 0;
        this.output = void 0;
        this.error = void 0;
        this.context = void 0;
        this.historyValue = {};
        this._internalQueue = void 0;
        this.configuration = void 0;
        this.children = void 0;
        this.context = config.context;
        this._internalQueue = config._internalQueue ?? [];
        this.historyValue = config.historyValue || {};
        this.matches = this.matches.bind(this);
        this.toStrings = this.toStrings.bind(this);
        this.configuration = config.configuration ?? Array.from(getConfiguration(getStateNodes(machine.root, config.value)));
        this.children = config.children;
        this.value = getStateValue(machine.root, this.configuration);
        this.tags = new Set(flatten(this.configuration.map((sn)=>sn.tags)));
        this.done = config.done ?? false;
        this.output = config.output;
        this.error = config.error;
    }
    /**
   * Returns an array of all the string leaf state node paths.
   * @param stateValue
   * @param delimiter The character(s) that separate each subpath in the string state node path.
   */ toStrings(stateValue = this.value) {
        if (typeof stateValue === "string") return [
            stateValue
        ];
        const valueKeys = Object.keys(stateValue);
        return valueKeys.concat(...valueKeys.map((key)=>this.toStrings(stateValue[key]).map((s)=>key + STATE_DELIMITER + s)));
    }
    toJSON() {
        const { configuration, tags, machine, ...jsonValues } = this;
        return {
            ...jsonValues,
            tags: Array.from(tags),
            meta: this.meta
        };
    }
    /**
   * Whether the current state value is a subset of the given parent state value.
   * @param parentStateValue
   */ matches(parentStateValue) {
        return matchesState(parentStateValue, this.value);
    }
    /**
   * Whether the current state configuration has a state node with the specified `tag`.
   * @param tag
   */ hasTag(tag) {
        return this.tags.has(tag);
    }
    /**
   * Determines whether sending the `event` will cause a non-forbidden transition
   * to be selected, even if the transitions have no actions nor
   * change the state value.
   *
   * @param event The event to test
   * @returns Whether the event will cause a transition
   */ can(event) {
        const transitionData = this.machine.getTransitionData(this, event);
        return !!transitionData?.length && // Check that at least one transition is not forbidden
        transitionData.some((t)=>t.target !== undefined || t.actions.length);
    }
    /**
   * The next events that will cause a transition from the current state.
   */ get nextEvents() {
        return memo(this, "nextEvents", ()=>{
            return [
                ...new Set(flatten([
                    ...this.configuration.map((sn)=>sn.ownEvents)
                ]))
            ];
        });
    }
    get meta() {
        return this.configuration.reduce((acc, stateNode)=>{
            if (stateNode.meta !== undefined) acc[stateNode.id] = stateNode.meta;
            return acc;
        }, {});
    }
}
function cloneState(state, config = {}) {
    return new State({
        ...state,
        ...config
    }, state.machine);
}
function getPersistedState(state) {
    const { configuration, tags, machine, children, ...jsonValues } = state;
    const childrenJson = {};
    for(const id in children)childrenJson[id] = {
        state: children[id].getPersistedState?.(),
        src: children[id].src
    };
    return {
        ...jsonValues,
        children: childrenJson
    };
}
function resolve$5(_, state, args, { actorRef }) {
    const actorRefOrString = typeof actorRef === "function" ? actorRef(args) : actorRef;
    const resolvedActorRef = typeof actorRefOrString === "string" ? state.children[actorRefOrString] : actorRefOrString;
    let children = state.children;
    if (resolvedActorRef) {
        children = {
            ...children
        };
        delete children[resolvedActorRef.id];
    }
    return [
        cloneState(state, {
            children
        }),
        resolvedActorRef
    ];
}
function execute$2(actorContext, actorRef) {
    if (!actorRef) return;
    if (actorRef.status !== ActorStatus.Running) {
        actorContext.stopChild(actorRef);
        return;
    }
    // TODO: recheck why this one has to be deferred
    actorContext.defer(()=>{
        actorContext.stopChild(actorRef);
    });
}
/**
 * Stops an actor.
 *
 * @param actorRef The actor to stop.
 */ function stop(actorRef) {
    function stop(_) {}
    stop.type = "xstate.stop";
    stop.actorRef = actorRef;
    stop.resolve = resolve$5;
    stop.execute = execute$2;
    return stop;
}
function resolve$4(_, state, actionArgs, { value, label }) {
    return [
        state,
        {
            value: typeof value === "function" ? value(actionArgs) : value,
            label
        }
    ];
}
function execute$1({ logger }, { value, label }) {
    if (label) logger(label, value);
    else logger(value);
}
/**
 *
 * @param expr The expression function to evaluate which will be logged.
 *  Takes in 2 arguments:
 *  - `ctx` - the current state context
 *  - `event` - the event that caused this action to be executed.
 * @param label The label to give to the logged expression.
 */ function log(value = ({ context, event })=>({
        context,
        event
    }), label) {
    function log(_) {}
    log.type = "xstate.log";
    log.value = value;
    log.label = label;
    log.resolve = resolve$4;
    log.execute = execute$1;
    return log;
}
function createSpawner(actorContext, { machine, context }, event, spawnedChildren) {
    const spawn = (src, options = {})=>{
        const { systemId } = options;
        if (typeof src === "string") {
            const referenced = resolveReferencedActor(machine.implementations.actors[src]);
            if (!referenced) throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);
            const input = "input" in options ? options.input : referenced.input;
            // TODO: this should also receive `src`
            const actor = createActor(referenced.src, {
                id: options.id,
                parent: actorContext.self,
                input: typeof input === "function" ? input({
                    context,
                    event,
                    self: actorContext.self
                }) : input,
                systemId
            });
            spawnedChildren[actor.id] = actor;
            return actor;
        } else // TODO: this should also receive `src`
        return createActor(src, {
            id: options.id,
            parent: actorContext.self,
            input: options.input,
            systemId
        });
    };
    return (src, options)=>{
        const actorRef = spawn(src, options); // TODO: fix types
        spawnedChildren[actorRef.id] = actorRef;
        actorContext.defer(()=>{
            if (actorRef.status === ActorStatus.Stopped) return;
            try {
                actorRef.start?.();
            } catch (err) {
                actorContext.self.send(error(actorRef.id, err));
                return;
            }
        });
        return actorRef;
    };
}
function resolve$3(actorContext, state, actionArgs, { assignment }) {
    if (!state.context) throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
    const spawnedChildren = {};
    const assignArgs = {
        context: state.context,
        event: actionArgs.event,
        action: actionArgs.action,
        spawn: createSpawner(actorContext, state, actionArgs.event, spawnedChildren),
        self: actorContext?.self,
        system: actorContext?.system
    };
    let partialUpdate = {};
    if (typeof assignment === "function") partialUpdate = assignment(assignArgs);
    else for (const key of Object.keys(assignment)){
        const propAssignment = assignment[key];
        partialUpdate[key] = typeof propAssignment === "function" ? propAssignment(assignArgs) : propAssignment;
    }
    const updatedContext = Object.assign({}, state.context, partialUpdate);
    return [
        cloneState(state, {
            context: updatedContext,
            children: Object.keys(spawnedChildren).length ? {
                ...state.children,
                ...spawnedChildren
            } : state.children
        })
    ];
}
/**
 * Updates the current context of the machine.
 *
 * @param assignment An object that represents the partial context to update.
 */ function assign(assignment) {
    function assign(_) {}
    assign.type = "xstate.assign";
    assign.assignment = assignment;
    assign.resolve = resolve$3;
    return assign;
}
function resolve$2(_, state, args, { event: eventOrExpr, id, delay }) {
    const delaysMap = state.machine.implementations.delays;
    if (typeof eventOrExpr === "string") throw new Error(`Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`);
    const resolvedEvent = typeof eventOrExpr === "function" ? eventOrExpr(args) : eventOrExpr;
    let resolvedDelay;
    if (typeof delay === "string") {
        const configDelay = delaysMap && delaysMap[delay];
        resolvedDelay = typeof configDelay === "function" ? configDelay(args) : configDelay;
    } else resolvedDelay = typeof delay === "function" ? delay(args) : delay;
    return [
        typeof resolvedDelay !== "number" ? cloneState(state, {
            _internalQueue: state._internalQueue.concat(resolvedEvent)
        }) : state,
        {
            event: resolvedEvent,
            id,
            delay: resolvedDelay
        }
    ];
}
function execute(actorContext, params) {
    if (typeof params.delay === "number") {
        actorContext.self.delaySend(params);
        return;
    }
}
/**
 * Raises an event. This places the event in the internal event queue, so that
 * the event is immediately consumed by the machine in the current step.
 *
 * @param eventType The event to raise.
 */ function raise(eventOrExpr, options) {
    function raise(_) {}
    raise.type = "xstate.raise";
    raise.event = eventOrExpr;
    raise.id = options?.id;
    raise.delay = options?.delay;
    raise.resolve = resolve$2;
    raise.execute = execute;
    return raise;
}
function resolve$1(_, state, actionArgs, { branches }) {
    const matchedActions = branches.find((condition)=>{
        const guard = condition.guard && toGuardDefinition(condition.guard, (guardType)=>state.machine.implementations.guards[guardType]);
        return !guard || evaluateGuard(guard, state.context, actionArgs.event, state);
    })?.actions;
    return [
        state,
        undefined,
        toArray(matchedActions)
    ];
}
function choose(branches) {
    function choose(_) {}
    choose.type = "xstate.choose";
    choose.branches = branches;
    choose.resolve = resolve$1;
    return choose;
}
function resolve(_, state, args, { get }) {
    return [
        state,
        undefined,
        toArray(get({
            context: args.context,
            event: args.event
        }))
    ];
}
function pure(getActions) {
    function pure(_) {}
    pure.type = "xstate.pure";
    pure.get = getActions;
    pure.resolve = resolve;
    return pure;
}
/**
 * Returns an event type that represents an implicit event that
 * is sent after the specified `delay`.
 *
 * @param delayRef The delay in milliseconds
 * @param id The state node ID where this event is handled
 */ function after(delayRef, id) {
    const idSuffix = id ? `#${id}` : "";
    return `${ConstantPrefix.After}(${delayRef})${idSuffix}`;
}
/**
 * Returns an event that represents that a final state node
 * has been reached in the parent state node.
 *
 * @param id The final state node's parent state node `id`
 * @param output The data to pass into the event
 */ function done(id, output) {
    const type = `${ConstantPrefix.DoneState}.${id}`;
    const eventObject = {
        type,
        output
    };
    eventObject.toString = ()=>type;
    return eventObject;
}
/**
 * Returns an event that represents that an invoked service has terminated.
 *
 * An invoked service is terminated when it has reached a top-level final state node,
 * but not when it is canceled.
 *
 * @param invokeId The invoked service ID
 * @param output The data to pass into the event
 */ function doneInvoke(invokeId, output) {
    const type = `${ConstantPrefix.DoneInvoke}.${invokeId}`;
    const eventObject = {
        type,
        output
    };
    eventObject.toString = ()=>type;
    return eventObject;
}
function error(id, data) {
    const type = `${ConstantPrefix.ErrorPlatform}.${id}`;
    const eventObject = {
        type,
        data
    };
    eventObject.toString = ()=>type;
    return eventObject;
}
function createInitEvent(input) {
    return {
        type: INIT_TYPE,
        input
    };
}

},{"../dev/dist/xstate-dev.esm.js":"2CXSV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2CXSV":[function(require,module,exports) {
// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "devToolsAdapter", ()=>devToolsAdapter);
parcelHelpers.export(exports, "getGlobal", ()=>getGlobal);
parcelHelpers.export(exports, "registerService", ()=>registerService);
var global = arguments[3];
function getGlobal() {
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
}
function getDevTools() {
    const w = getGlobal();
    if (!!w.__xstate__) return w.__xstate__;
    return undefined;
}
function registerService(service) {
    if (typeof window === "undefined") return;
    const devTools = getDevTools();
    if (devTools) devTools.register(service);
}
const devToolsAdapter = (service)=>{
    if (typeof window === "undefined") return;
    const devTools = getDevTools();
    if (devTools) devTools.register(service);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"6b8aX":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.speechstate = void 0;
var speechstate_1 = require("e2b66f0248edd60a");
Object.defineProperty(exports, "speechstate", {
    enumerable: true,
    get: function() {
        return speechstate_1.speechstate;
    }
});

},{"e2b66f0248edd60a":"6DsoG"}],"6DsoG":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.speechstate = void 0;
const xstate_1 = require("64a8564d1b8a963c");
const tts_1 = require("bd7ed5589421c8a7");
const asr_1 = require("628ed9f62590f619");
const speechstate = (0, xstate_1.createMachine)({
    types: {
        context: {},
        events: {}
    },
    context: ({ input })=>({
            settings: input.settings
        }),
    id: "speechstate",
    type: "parallel",
    states: {
        asrTtsSpawner: {
            initial: "idle",
            states: {
                idle: {
                    on: {
                        PREPARE: "createAudioContext"
                    }
                },
                createAudioContext: {
                    invoke: {
                        id: "createAudioContext",
                        src: "audioContext",
                        onDone: {
                            target: "spawn",
                            actions: (0, xstate_1.assign)({
                                audioContext: ({ event })=>event.output
                            })
                        }
                    }
                },
                spawn: {
                    entry: [
                        (0, xstate_1.assign)({
                            ttsRef: ({ context, spawn })=>{
                                return spawn(tts_1.ttsMachine, {
                                    input: {
                                        ttsDefaultVoice: context.settings.ttsDefaultVoice,
                                        audioContext: context.audioContext,
                                        azureCredentials: context.settings.azureCredentials
                                    }
                                });
                            }
                        }),
                        (0, xstate_1.assign)({
                            asrRef: ({ context, spawn })=>{
                                return spawn(asr_1.asrMachine, {
                                    input: {
                                        asrDefaultCompleteTimeout: context.settings.asrDefaultCompleteTimeout,
                                        asrDefaultNoInputTimeout: context.settings.asrDefaultNoInputTimeout,
                                        locale: context.settings.locale,
                                        audioContext: context.audioContext,
                                        azureCredentials: context.settings.azureCredentials
                                    }
                                });
                            }
                        })
                    ],
                    after: {
                        300000: {
                            target: "spawn"
                        }
                    }
                }
            }
        },
        asrTtsManager: {
            initial: "initialize",
            on: {
                TTS_READY: {
                    actions: ()=>console.debug("[TTS→SpSt] TTS_READY"),
                    target: ".preReady"
                },
                ASR_READY: {
                    actions: ()=>console.debug("[ASR→SpSt] ASR_READY"),
                    target: ".preReady"
                },
                // ASR_ERROR not implemented
                TTS_ERROR: {
                    actions: ()=>console.error("[TTS→SpSt] TTS_ERROR"),
                    target: ".fail"
                },
                ASR_NOINPUT: {
                    actions: [
                        ()=>console.debug("[ASR→SpSt] NOINPUT"),
                        (0, xstate_1.sendParent)({
                            type: "ASR_NOINPUT"
                        })
                    ],
                    target: ".ready"
                }
            },
            states: {
                initialize: {},
                preReady: {
                    on: {
                        TTS_READY: {
                            actions: ()=>console.debug("[TTS→SpSt] TTS_READY"),
                            target: "ready"
                        },
                        ASR_READY: {
                            actions: ()=>console.debug("[ASR→SpSt] ASR_READY"),
                            target: "ready"
                        }
                    }
                },
                ready: {
                    initial: "idle",
                    entry: [
                        ()=>console.debug("[SpSt] All ready"),
                        (0, xstate_1.sendParent)({
                            type: "ASRTTS_READY"
                        })
                    ],
                    states: {
                        idle: {
                            on: {
                                LISTEN: {
                                    target: "waitForRecogniser"
                                },
                                SPEAK: [
                                    {
                                        target: "speaking"
                                    }
                                ]
                            }
                        },
                        speaking: {
                            entry: [
                                ({ event })=>console.debug("[SpSt→TTS] SPEAK", event.value),
                                ({ context, event })=>context.ttsRef.send({
                                        type: "SPEAK",
                                        value: event.value
                                    })
                            ],
                            on: {
                                CONTROL: {
                                    actions: [
                                        ()=>console.debug("[SpSt→TTS] CONTROL"),
                                        ({ context })=>context.ttsRef.send({
                                                type: "CONTROL"
                                            })
                                    ]
                                },
                                STOP: {
                                    actions: [
                                        ()=>console.debug("[SpSt→TTS] STOP"),
                                        ({ context })=>context.ttsRef.send({
                                                type: "STOP"
                                            })
                                    ]
                                },
                                TTS_STARTED: {
                                    actions: [
                                        ()=>console.debug("[TTS→SpSt] TTS_STARTED"),
                                        (0, xstate_1.sendParent)({
                                            type: "TTS_STARTED"
                                        })
                                    ]
                                },
                                SPEAK_COMPLETE: {
                                    target: "idle",
                                    actions: [
                                        ()=>console.debug("[TTS→SpSt] SPEAK_COMPLETE"),
                                        (0, xstate_1.sendParent)({
                                            type: "SPEAK_COMPLETE"
                                        })
                                    ]
                                }
                            }
                        },
                        waitForRecogniser: {
                            entry: [
                                ({ event })=>console.debug("[SpSt→ASR] START", event.value),
                                ({ context, event })=>context.asrRef.send({
                                        type: "START",
                                        value: event.value
                                    })
                            ],
                            on: {
                                ASR_STARTED: {
                                    target: "recognising",
                                    actions: [
                                        ()=>console.debug("[ASR→SpSt] ASR_STARTED"),
                                        (0, xstate_1.sendParent)({
                                            type: "ASR_STARTED"
                                        })
                                    ]
                                }
                            }
                        },
                        recognising: {
                            on: {
                                CONTROL: {
                                    actions: [
                                        ()=>console.debug("[SpSt→ASR] CONTROL"),
                                        ({ context })=>context.asrRef.send({
                                                type: "CONTROL"
                                            })
                                    ]
                                },
                                RECOGNISED: {
                                    actions: [
                                        ({ event })=>console.debug("[ASR→SpSt] RECOGNISED", event.value),
                                        (0, xstate_1.sendParent)(({ event })=>({
                                                type: "RECOGNISED",
                                                value: event.value
                                            }))
                                    ],
                                    target: "idle"
                                }
                            }
                        }
                    }
                },
                fail: {}
            }
        }
    }
}, {
    actors: {
        audioContext: (0, xstate_1.fromPromise)(()=>{
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            navigator.mediaDevices.getUserMedia({
                audio: true
            }).then(function(stream) {
                audioContext.createMediaStreamSource(stream);
            });
            return audioContext;
        })
    },
    actions: {
    }
});
exports.speechstate = speechstate;

},{"64a8564d1b8a963c":"aP1sj","bd7ed5589421c8a7":"brbXg","628ed9f62590f619":"l7XW8"}],"aP1sj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConstantPrefix", ()=>(0, _actions5039C951EsmJs.a5));
parcelHelpers.export(exports, "Interpreter", ()=>(0, _actions5039C951EsmJs.L));
parcelHelpers.export(exports, "InterpreterStatus", ()=>(0, _actions5039C951EsmJs.M));
parcelHelpers.export(exports, "SpecialTargets", ()=>(0, _actions5039C951EsmJs.a6));
parcelHelpers.export(exports, "State", ()=>(0, _actions5039C951EsmJs.p));
parcelHelpers.export(exports, "and", ()=>(0, _actions5039C951EsmJs.a3));
parcelHelpers.export(exports, "assign", ()=>(0, _actions5039C951EsmJs.y));
parcelHelpers.export(exports, "cancel", ()=>(0, _actions5039C951EsmJs.P));
parcelHelpers.export(exports, "choose", ()=>(0, _actions5039C951EsmJs.Q));
parcelHelpers.export(exports, "doneInvoke", ()=>(0, _actions5039C951EsmJs.O));
parcelHelpers.export(exports, "forwardTo", ()=>(0, _actions5039C951EsmJs.K));
parcelHelpers.export(exports, "fromCallback", ()=>(0, _actions5039C951EsmJs._));
parcelHelpers.export(exports, "fromEventObservable", ()=>(0, _actions5039C951EsmJs.$));
parcelHelpers.export(exports, "fromObservable", ()=>(0, _actions5039C951EsmJs.Z));
parcelHelpers.export(exports, "fromPromise", ()=>(0, _actions5039C951EsmJs.Y));
parcelHelpers.export(exports, "fromTransition", ()=>(0, _actions5039C951EsmJs.a0));
parcelHelpers.export(exports, "getStateNodes", ()=>(0, _actions5039C951EsmJs.n));
parcelHelpers.export(exports, "interpret", ()=>(0, _actions5039C951EsmJs.G));
parcelHelpers.export(exports, "log", ()=>(0, _actions5039C951EsmJs.R));
parcelHelpers.export(exports, "matchesState", ()=>(0, _actions5039C951EsmJs.H));
parcelHelpers.export(exports, "not", ()=>(0, _actions5039C951EsmJs.a2));
parcelHelpers.export(exports, "or", ()=>(0, _actions5039C951EsmJs.a4));
parcelHelpers.export(exports, "pathToStateValue", ()=>(0, _actions5039C951EsmJs.W));
parcelHelpers.export(exports, "pure", ()=>(0, _actions5039C951EsmJs.T));
parcelHelpers.export(exports, "raise", ()=>(0, _actions5039C951EsmJs.U));
parcelHelpers.export(exports, "sendParent", ()=>(0, _actions5039C951EsmJs.J));
parcelHelpers.export(exports, "sendTo", ()=>(0, _actions5039C951EsmJs.I));
parcelHelpers.export(exports, "stateIn", ()=>(0, _actions5039C951EsmJs.a1));
parcelHelpers.export(exports, "stop", ()=>(0, _actions5039C951EsmJs.V));
parcelHelpers.export(exports, "toObserver", ()=>(0, _actions5039C951EsmJs.X));
parcelHelpers.export(exports, "SimulatedClock", ()=>SimulatedClock);
parcelHelpers.export(exports, "StateMachine", ()=>StateMachine);
parcelHelpers.export(exports, "StateNode", ()=>StateNode);
parcelHelpers.export(exports, "createMachine", ()=>createMachine);
parcelHelpers.export(exports, "mapState", ()=>mapState);
parcelHelpers.export(exports, "waitFor", ()=>waitFor);
var _actions5039C951EsmJs = require("./actions-5039c951.esm.js");
var _xstateDevEsmJs = require("../dev/dist/xstate-dev.esm.js");
const EMPTY_OBJECT = {};
const toSerializableActon = (action)=>{
    if (typeof action === "string") return {
        type: action
    };
    if (typeof action === "function") {
        if ("resolve" in action) return {
            type: action.type
        };
        return {
            type: action.name
        };
    }
    return action;
};
class StateNode {
    /**
   * The relative key of the state node, which represents its location in the overall state value.
   */ /**
   * The unique ID of the state node.
   */ /**
   * The type of this state node:
   *
   *  - `'atomic'` - no child state nodes
   *  - `'compound'` - nested child state nodes (XOR)
   *  - `'parallel'` - orthogonal nested child state nodes (AND)
   *  - `'history'` - history state node
   *  - `'final'` - final state node
   */ /**
   * The string path from the root machine node to this node.
   */ /**
   * The child state nodes.
   */ /**
   * The type of history on this state node. Can be:
   *
   *  - `'shallow'` - recalls only top-level historical state value
   *  - `'deep'` - recalls historical state value at all levels
   */ /**
   * The action(s) to be executed upon entering the state node.
   */ /**
   * The action(s) to be executed upon exiting the state node.
   */ /**
   * The parent state node.
   */ /**
   * The root machine node.
   */ /**
   * The meta data associated with this state node, which will be returned in State instances.
   */ /**
   * The output data sent with the "done.state._id_" event if this is a final state node.
   */ /**
   * The order this state node appears. Corresponds to the implicit document order.
   */ constructor(/**
   * The raw config used to create the machine.
   */ config, options){
        this.config = config;
        this.key = void 0;
        this.id = void 0;
        this.type = void 0;
        this.path = void 0;
        this.states = void 0;
        this.history = void 0;
        this.entry = void 0;
        this.exit = void 0;
        this.parent = void 0;
        this.machine = void 0;
        this.meta = void 0;
        this.output = void 0;
        this.order = -1;
        this.description = void 0;
        this.tags = [];
        this.transitions = void 0;
        this.always = void 0;
        this.parent = options._parent;
        this.key = options._key;
        this.machine = options._machine;
        this.path = this.parent ? this.parent.path.concat(this.key) : [];
        this.id = this.config.id || [
            this.machine.id,
            ...this.path
        ].join((0, _actions5039C951EsmJs.S));
        this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic");
        this.description = this.config.description;
        this.order = this.machine.idMap.size;
        this.machine.idMap.set(this.id, this);
        this.states = this.config.states ? (0, _actions5039C951EsmJs.m)(this.config.states, (stateConfig, key)=>{
            const stateNode = new StateNode(stateConfig, {
                _parent: this,
                _key: key,
                _machine: this.machine
            });
            return stateNode;
        }) : EMPTY_OBJECT;
        if (this.type === "compound" && !this.config.initial) throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
        // History config
        this.history = this.config.history === true ? "shallow" : this.config.history || false;
        this.entry = (0, _actions5039C951EsmJs.t)(this.config.entry);
        this.exit = (0, _actions5039C951EsmJs.t)(this.config.exit);
        this.meta = this.config.meta;
        this.output = this.type === "final" ? this.config.output : undefined;
        this.tags = (0, _actions5039C951EsmJs.t)(config.tags);
    }
    _initialize() {
        this.transitions = (0, _actions5039C951EsmJs.f)(this);
        if (this.config.always) this.always = (0, _actions5039C951EsmJs.a)(this.config.always).map((t)=>(0, _actions5039C951EsmJs.b)(this, (0, _actions5039C951EsmJs.N), t));
        Object.keys(this.states).forEach((key)=>{
            this.states[key]._initialize();
        });
    }
    /**
   * The well-structured state node definition.
   */ get definition() {
        return {
            id: this.id,
            key: this.key,
            version: this.machine.version,
            type: this.type,
            initial: this.initial ? {
                target: this.initial.target,
                source: this,
                actions: this.initial.actions.map(toSerializableActon),
                eventType: null,
                reenter: false,
                toJSON: ()=>({
                        target: this.initial.target.map((t)=>`#${t.id}`),
                        source: `#${this.id}`,
                        actions: this.initial.actions.map(toSerializableActon),
                        eventType: null
                    })
            } : undefined,
            history: this.history,
            states: (0, _actions5039C951EsmJs.m)(this.states, (state)=>{
                return state.definition;
            }),
            on: this.on,
            transitions: [
                ...this.transitions.values()
            ].flat().map((t)=>({
                    ...t,
                    actions: t.actions.map(toSerializableActon)
                })),
            entry: this.entry.map(toSerializableActon),
            exit: this.exit.map(toSerializableActon),
            meta: this.meta,
            order: this.order || -1,
            output: this.output,
            invoke: this.invoke,
            description: this.description,
            tags: this.tags
        };
    }
    toJSON() {
        return this.definition;
    }
    /**
   * The logic invoked as actors by this state node.
   */ get invoke() {
        return (0, _actions5039C951EsmJs.c)(this, "invoke", ()=>(0, _actions5039C951EsmJs.t)(this.config.invoke).map((invocable, i)=>{
                const generatedId = (0, _actions5039C951EsmJs.g)(this.id, i);
                const invokeConfig = (0, _actions5039C951EsmJs.k)(invocable, generatedId);
                const resolvedId = invokeConfig.id || generatedId;
                const src = invokeConfig.src;
                const { systemId } = invokeConfig;
                // TODO: resolving should not happen here
                const resolvedSrc = typeof src === "string" ? src : !("type" in src) ? resolvedId : src;
                if (!this.machine.implementations.actors[resolvedId] && typeof src !== "string" && !("type" in src)) this.machine.implementations.actors = {
                    ...this.machine.implementations.actors,
                    // TODO: this should accept `src` as-is
                    [resolvedId]: src
                };
                return {
                    ...invokeConfig,
                    src: resolvedSrc,
                    id: resolvedId,
                    systemId: systemId,
                    toJSON () {
                        const { onDone, onError, ...invokeDefValues } = invokeConfig;
                        return {
                            ...invokeDefValues,
                            type: "xstate.invoke",
                            src: resolvedSrc,
                            id: resolvedId
                        };
                    }
                };
            }));
    }
    /**
   * The mapping of events to transitions.
   */ get on() {
        return (0, _actions5039C951EsmJs.c)(this, "on", ()=>{
            const transitions = this.transitions;
            return [
                ...transitions
            ].flatMap(([descriptor, t])=>t.map((t)=>[
                        descriptor,
                        t
                    ])).reduce((map, [descriptor, transition])=>{
                map[descriptor] = map[descriptor] || [];
                map[descriptor].push(transition);
                return map;
            }, {});
        });
    }
    get after() {
        return (0, _actions5039C951EsmJs.c)(this, "delayedTransitions", ()=>(0, _actions5039C951EsmJs.h)(this));
    }
    get initial() {
        return (0, _actions5039C951EsmJs.c)(this, "initial", ()=>(0, _actions5039C951EsmJs.i)(this, this.config.initial || []));
    }
    next(state, event) {
        const eventType = event.type;
        const actions = [];
        let selectedTransition;
        const candidates = (0, _actions5039C951EsmJs.c)(this, `candidates-${eventType}`, ()=>(0, _actions5039C951EsmJs.j)(this, eventType));
        for (const candidate of candidates){
            const { guard } = candidate;
            const resolvedContext = state.context;
            let guardPassed = false;
            try {
                guardPassed = !guard || (0, _actions5039C951EsmJs.e)(guard, resolvedContext, event, state);
            } catch (err) {
                throw new Error(`Unable to evaluate guard '${guard.type}' in transition for event '${eventType}' in state node '${this.id}':\n${err.message}`);
            }
            if (guardPassed) {
                actions.push(...candidate.actions);
                selectedTransition = candidate;
                break;
            }
        }
        return selectedTransition ? [
            selectedTransition
        ] : undefined;
    }
    /**
   * The target state value of the history state node, if it exists. This represents the
   * default state value to transition to if no history value exists yet.
   */ get target() {
        if (this.type === "history") {
            const historyConfig = this.config;
            return historyConfig.target;
        }
        return undefined;
    }
    /**
   * All the state node IDs of this state node and its descendant state nodes.
   */ get stateIds() {
        const childStateIds = (0, _actions5039C951EsmJs.d)(Object.keys(this.states).map((stateKey)=>{
            return this.states[stateKey].stateIds;
        }));
        return [
            this.id
        ].concat(childStateIds);
    }
    /**
   * All the event types accepted by this state node and its descendants.
   */ get events() {
        return (0, _actions5039C951EsmJs.c)(this, "events", ()=>{
            const { states } = this;
            const events = new Set(this.ownEvents);
            if (states) for (const stateId of Object.keys(states)){
                const state = states[stateId];
                if (state.states) for (const event of state.events)events.add(`${event}`);
            }
            return Array.from(events);
        });
    }
    /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */ get ownEvents() {
        const events = new Set([
            ...this.transitions.keys()
        ].filter((descriptor)=>{
            return this.transitions.get(descriptor).some((transition)=>!(!transition.target && !transition.actions.length && !transition.reenter));
        }));
        return Array.from(events);
    }
}
const STATE_IDENTIFIER = "#";
class StateMachine {
    /**
   * The machine's own version.
   */ constructor(/**
   * The raw config used to create the machine.
   */ config, implementations){
        this.config = config;
        this.version = void 0;
        this.implementations = void 0;
        this.types = void 0;
        this.__xstatenode = true;
        this.idMap = new Map();
        this.root = void 0;
        this.id = void 0;
        this.states = void 0;
        this.events = void 0;
        this.__TContext = void 0;
        this.__TEvent = void 0;
        this.__TAction = void 0;
        this.__TActor = void 0;
        this.__TResolvedTypesMeta = void 0;
        this.__TInput = void 0;
        this.id = config.id || "(machine)";
        this.implementations = {
            actors: implementations?.actors ?? {},
            actions: implementations?.actions ?? {},
            delays: implementations?.delays ?? {},
            guards: implementations?.guards ?? {}
        };
        this.version = this.config.version;
        this.types = this.config.types ?? {};
        this.transition = this.transition.bind(this);
        this.root = new StateNode(config, {
            _key: this.id,
            _machine: this
        });
        this.root._initialize();
        this.states = this.root.states; // TODO: remove!
        this.events = this.root.events;
    }
    /**
   * Clones this state machine with the provided implementations
   * and merges the `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)
   *  to recursively merge with the existing options.
   *
   * @returns A new `StateMachine` instance with the provided implementations.
   */ provide(implementations) {
        const { actions, guards, actors, delays } = this.implementations;
        return new StateMachine(this.config, {
            actions: {
                ...actions,
                ...implementations.actions
            },
            guards: {
                ...guards,
                ...implementations.guards
            },
            actors: {
                ...actors,
                ...implementations.actors
            },
            delays: {
                ...delays,
                ...implementations.delays
            }
        });
    }
    /**
   * Resolves the given `state` to a new `State` instance relative to this machine.
   *
   * This ensures that `.nextEvents` represent the correct values.
   *
   * @param state The state to resolve
   */ resolveState(state) {
        const configurationSet = (0, _actions5039C951EsmJs.l)((0, _actions5039C951EsmJs.n)(this.root, state.value));
        const configuration = Array.from(configurationSet);
        return this.createState({
            ...state,
            value: (0, _actions5039C951EsmJs.r)(this.root, state.value),
            configuration,
            done: (0, _actions5039C951EsmJs.o)(configuration)
        });
    }
    resolveStateValue(stateValue, ...[context]) {
        const resolvedStateValue = (0, _actions5039C951EsmJs.r)(this.root, stateValue);
        return this.resolveState((0, _actions5039C951EsmJs.p).from(resolvedStateValue, context, this));
    }
    /**
   * Determines the next state given the current `state` and received `event`.
   * Calculates a full macrostep from all microsteps.
   *
   * @param state The current State instance or state value
   * @param event The received event
   */ transition(state, event, actorCtx) {
        // TODO: handle error events in a better way
        if ((0, _actions5039C951EsmJs.q)(event) && !state.nextEvents.some((nextEvent)=>nextEvent === event.type)) return (0, _actions5039C951EsmJs.s)(state, {
            error: event.data
        });
        const { state: nextState } = (0, _actions5039C951EsmJs.u)(state, event, actorCtx);
        return nextState;
    }
    /**
   * Determines the next state given the current `state` and `event`.
   * Calculates a microstep.
   *
   * @param state The current state
   * @param event The received event
   */ microstep(state, event, actorCtx) {
        return (0, _actions5039C951EsmJs.u)(state, event, actorCtx).microstates;
    }
    getTransitionData(state, event) {
        return (0, _actions5039C951EsmJs.v)(this.root, state.value, state, event) || [];
    }
    /**
   * The initial state _before_ evaluating any microsteps.
   * This "pre-initial" state is provided to initial actions executed in the initial state.
   */ getPreInitialState(actorCtx, initEvent) {
        const { context } = this.config;
        const preInitial = this.resolveState(this.createState({
            value: {},
            // TODO: this is computed in state constructor
            context: typeof context !== "function" && context ? context : {},
            meta: undefined,
            configuration: (0, _actions5039C951EsmJs.w)(this.root),
            children: {}
        }));
        if (typeof context === "function") {
            const assignment = ({ spawn, event })=>context({
                    spawn,
                    input: event.input
                });
            return (0, _actions5039C951EsmJs.x)([
                (0, _actions5039C951EsmJs.y)(assignment)
            ], initEvent, preInitial, actorCtx);
        }
        return preInitial;
    }
    /**
   * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.
   */ getInitialState(actorCtx, input) {
        const initEvent = (0, _actions5039C951EsmJs.z)(input); // TODO: fix;
        const preInitialState = this.getPreInitialState(actorCtx, initEvent);
        const nextState = (0, _actions5039C951EsmJs.A)([
            {
                target: [
                    ...preInitialState.configuration
                ].filter((0, _actions5039C951EsmJs.B)),
                source: this.root,
                reenter: true,
                actions: [],
                eventType: null,
                toJSON: null // TODO: fix
            }
        ], preInitialState, actorCtx, initEvent, true);
        const { state: macroState } = (0, _actions5039C951EsmJs.u)(nextState, initEvent, actorCtx);
        return macroState;
    }
    start(state) {
        Object.values(state.children).forEach((child)=>{
            if (child.status === 0) child.start?.();
        });
    }
    getStateNodeById(stateId) {
        const fullPath = stateId.split((0, _actions5039C951EsmJs.S));
        const relativePath = fullPath.slice(1);
        const resolvedStateId = (0, _actions5039C951EsmJs.C)(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];
        const stateNode = this.idMap.get(resolvedStateId);
        if (!stateNode) throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);
        return (0, _actions5039C951EsmJs.D)(stateNode, relativePath);
    }
    get definition() {
        return this.root.definition;
    }
    toJSON() {
        return this.definition;
    }
    getPersistedState(state) {
        return (0, _actions5039C951EsmJs.E)(state);
    }
    createState(stateConfig) {
        return stateConfig instanceof (0, _actions5039C951EsmJs.p) ? stateConfig : new (0, _actions5039C951EsmJs.p)(stateConfig, this);
    }
    getStatus(state) {
        return state.error ? {
            status: "error",
            data: state.error
        } : state.done ? {
            status: "done",
            data: state.output
        } : {
            status: "active"
        };
    }
    restoreState(state, _actorCtx) {
        const children = {};
        Object.keys(state.children).forEach((actorId)=>{
            const actorData = state.children[actorId];
            const childState = actorData.state;
            const src = actorData.src;
            const logic = src ? (0, _actions5039C951EsmJs.F)(this.implementations.actors[src])?.src : undefined;
            if (!logic) return;
            const actorState = logic.restoreState?.(childState, _actorCtx);
            const actorRef = (0, _actions5039C951EsmJs.G)(logic, {
                id: actorId,
                state: actorState
            });
            children[actorId] = actorRef;
        });
        const restoredState = this.createState(new (0, _actions5039C951EsmJs.p)({
            ...state,
            children
        }, this));
        // TODO: DRY this up
        restoredState.configuration.forEach((stateNode)=>{
            if (stateNode.invoke) stateNode.invoke.forEach((invokeConfig)=>{
                const { id, src } = invokeConfig;
                if (children[id]) return;
                const referenced = (0, _actions5039C951EsmJs.F)(this.implementations.actors[src]);
                if (referenced) {
                    const actorRef = (0, _actions5039C951EsmJs.G)(referenced.src, {
                        id,
                        parent: _actorCtx?.self,
                        input: "input" in invokeConfig ? invokeConfig.input : referenced.input
                    });
                    children[id] = actorRef;
                }
            });
        });
        return restoredState;
    }
}
function createMachine(config, implementations) {
    return new StateMachine(config, implementations);
}
function mapState(stateMap, stateId) {
    let foundStateId;
    for (const mappedStateId of Object.keys(stateMap))if ((0, _actions5039C951EsmJs.H)(mappedStateId, stateId) && (!foundStateId || stateId.length > foundStateId.length)) foundStateId = mappedStateId;
    return stateMap[foundStateId];
}
class SimulatedClock {
    constructor(){
        this.timeouts = new Map();
        this._now = 0;
        this._id = 0;
    }
    now() {
        return this._now;
    }
    getId() {
        return this._id++;
    }
    setTimeout(fn, timeout) {
        const id = this.getId();
        this.timeouts.set(id, {
            start: this.now(),
            timeout,
            fn
        });
        return id;
    }
    clearTimeout(id) {
        this.timeouts.delete(id);
    }
    set(time) {
        if (this._now > time) throw new Error("Unable to travel back in time");
        this._now = time;
        this.flushTimeouts();
    }
    flushTimeouts() {
        [
            ...this.timeouts
        ].sort(([_idA, timeoutA], [_idB, timeoutB])=>{
            const endA = timeoutA.start + timeoutA.timeout;
            const endB = timeoutB.start + timeoutB.timeout;
            return endB > endA ? -1 : 1;
        }).forEach(([id, timeout])=>{
            if (this.now() - timeout.start >= timeout.timeout) {
                this.timeouts.delete(id);
                timeout.fn.call(null);
            }
        });
    }
    increment(ms) {
        this._now += ms;
        this.flushTimeouts();
    }
}
const defaultWaitForOptions = {
    timeout: 10000 // 10 seconds
};
/**
 * Subscribes to an actor ref and waits for its emitted value to satisfy
 * a predicate, and then resolves with that value.
 * Will throw if the desired state is not reached after a timeout
 * (defaults to 10 seconds).
 *
 * @example
 * ```js
 * const state = await waitFor(someService, state => {
 *   return state.hasTag('loaded');
 * });
 *
 * state.hasTag('loaded'); // true
 * ```
 *
 * @param actorRef The actor ref to subscribe to
 * @param predicate Determines if a value matches the condition to wait for
 * @param options
 * @returns A promise that eventually resolves to the emitted value
 * that matches the condition
 */ function waitFor(actorRef, predicate, options) {
    const resolvedOptions = {
        ...defaultWaitForOptions,
        ...options
    };
    return new Promise((res, rej)=>{
        let done = false;
        const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(()=>{
            sub.unsubscribe();
            rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));
        }, resolvedOptions.timeout);
        const dispose = ()=>{
            clearTimeout(handle);
            done = true;
            sub?.unsubscribe();
        };
        function checkEmitted(emitted) {
            if (predicate(emitted)) {
                dispose();
                res(emitted);
            }
        }
        let sub; // avoid TDZ when disposing synchronously
        // See if the current snapshot already matches the predicate
        checkEmitted(actorRef.getSnapshot());
        if (done) return;
        sub = actorRef.subscribe({
            next: checkEmitted,
            error: (err)=>{
                dispose();
                rej(err);
            },
            complete: ()=>{
                dispose();
                rej(new Error(`Actor terminated without satisfying predicate`));
            }
        });
        if (done) sub.unsubscribe();
    });
}

},{"./actions-5039c951.esm.js":"9IA1n","../dev/dist/xstate-dev.esm.js":"9qtaf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9IA1n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$", ()=>fromEventObservable);
parcelHelpers.export(exports, "A", ()=>microstep);
parcelHelpers.export(exports, "B", ()=>isAtomicStateNode);
parcelHelpers.export(exports, "C", ()=>isStateId);
parcelHelpers.export(exports, "D", ()=>getStateNodeByPath);
parcelHelpers.export(exports, "E", ()=>getPersistedState);
parcelHelpers.export(exports, "F", ()=>resolveReferencedActor);
parcelHelpers.export(exports, "G", ()=>interpret);
parcelHelpers.export(exports, "H", ()=>matchesState);
parcelHelpers.export(exports, "I", ()=>sendTo);
parcelHelpers.export(exports, "J", ()=>sendParent);
parcelHelpers.export(exports, "K", ()=>forwardTo);
parcelHelpers.export(exports, "L", ()=>Interpreter);
parcelHelpers.export(exports, "M", ()=>ActorStatus);
parcelHelpers.export(exports, "N", ()=>NULL_EVENT);
parcelHelpers.export(exports, "O", ()=>doneInvoke);
parcelHelpers.export(exports, "P", ()=>cancel);
parcelHelpers.export(exports, "Q", ()=>choose);
parcelHelpers.export(exports, "R", ()=>log);
parcelHelpers.export(exports, "S", ()=>STATE_DELIMITER);
parcelHelpers.export(exports, "T", ()=>pure);
parcelHelpers.export(exports, "U", ()=>raise);
parcelHelpers.export(exports, "V", ()=>stop);
parcelHelpers.export(exports, "W", ()=>pathToStateValue);
parcelHelpers.export(exports, "X", ()=>toObserver);
parcelHelpers.export(exports, "Y", ()=>fromPromise);
parcelHelpers.export(exports, "Z", ()=>fromObservable);
parcelHelpers.export(exports, "_", ()=>fromCallback);
parcelHelpers.export(exports, "a", ()=>toTransitionConfigArray);
parcelHelpers.export(exports, "a0", ()=>fromTransition);
parcelHelpers.export(exports, "a1", ()=>stateIn);
parcelHelpers.export(exports, "a2", ()=>not);
parcelHelpers.export(exports, "a3", ()=>and);
parcelHelpers.export(exports, "a4", ()=>or);
parcelHelpers.export(exports, "a5", ()=>ConstantPrefix);
parcelHelpers.export(exports, "a6", ()=>SpecialTargets);
parcelHelpers.export(exports, "a7", ()=>startSignalType);
parcelHelpers.export(exports, "a8", ()=>stopSignalType);
parcelHelpers.export(exports, "a9", ()=>startSignal);
parcelHelpers.export(exports, "aa", ()=>stopSignal);
parcelHelpers.export(exports, "ab", ()=>isSignal);
parcelHelpers.export(exports, "ac", ()=>isActorRef);
parcelHelpers.export(exports, "ad", ()=>toActorRef);
parcelHelpers.export(exports, "ae", ()=>createEmptyActor);
parcelHelpers.export(exports, "af", ()=>toGuardDefinition);
parcelHelpers.export(exports, "ag", ()=>constantPrefixes);
parcelHelpers.export(exports, "ah", ()=>after);
parcelHelpers.export(exports, "ai", ()=>done);
parcelHelpers.export(exports, "aj", ()=>error);
parcelHelpers.export(exports, "ak", ()=>escalate);
parcelHelpers.export(exports, "b", ()=>formatTransition);
parcelHelpers.export(exports, "c", ()=>memo);
parcelHelpers.export(exports, "d", ()=>flatten);
parcelHelpers.export(exports, "e", ()=>evaluateGuard);
parcelHelpers.export(exports, "f", ()=>formatTransitions);
parcelHelpers.export(exports, "g", ()=>createInvokeId);
parcelHelpers.export(exports, "h", ()=>getDelayedTransitions);
parcelHelpers.export(exports, "i", ()=>formatInitialTransition);
parcelHelpers.export(exports, "j", ()=>getCandidates);
parcelHelpers.export(exports, "k", ()=>toInvokeConfig);
parcelHelpers.export(exports, "l", ()=>getConfiguration);
parcelHelpers.export(exports, "m", ()=>mapValues);
parcelHelpers.export(exports, "n", ()=>getStateNodes);
parcelHelpers.export(exports, "o", ()=>isInFinalState);
parcelHelpers.export(exports, "p", ()=>State);
parcelHelpers.export(exports, "q", ()=>isErrorEvent);
parcelHelpers.export(exports, "r", ()=>resolveStateValue);
parcelHelpers.export(exports, "s", ()=>cloneState);
parcelHelpers.export(exports, "t", ()=>toArray);
parcelHelpers.export(exports, "u", ()=>macrostep);
parcelHelpers.export(exports, "v", ()=>transitionNode);
parcelHelpers.export(exports, "w", ()=>getInitialConfiguration);
parcelHelpers.export(exports, "x", ()=>resolveActionsAndContext);
parcelHelpers.export(exports, "y", ()=>assign);
parcelHelpers.export(exports, "z", ()=>createInitEvent);
var _xstateDevEsmJs = require("../dev/dist/xstate-dev.esm.js");
/**
 * `T | unknown` reduces to `unknown` and that can be problematic when it comes to contextual typing.
 * It especially is a problem when the union has a function member, like here:
 *
 * ```ts
 * declare function test(cbOrVal: ((arg: number) => unknown) | unknown): void;
 * test((arg) => {}) // oops, implicit any
 * ```
 *
 * This type can be used to avoid this problem. This union represents the same value space as `unknown`.
 */ // https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887
/**
 * The full definition of an event, with a string `type`.
 */ // TODO: do not accept machines without all implementations
// we should also accept a raw machine as actor logic here
// or just make machine actor logic
/**
 * The string or object representing the state value relative to the parent state node.
 *
 * - For a child atomic state node, this is a string, e.g., `"pending"`.
 * - For complex state nodes, this is an object, e.g., `{ success: "someChildState" }`.
 */ // TODO: remove once TS fixes this type-widening issue
// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something
let ConstantPrefix = /*#__PURE__*/ function(ConstantPrefix) {
    ConstantPrefix["After"] = "xstate.after";
    ConstantPrefix["DoneState"] = "done.state";
    ConstantPrefix["DoneInvoke"] = "done.invoke";
    ConstantPrefix["ErrorExecution"] = "error.execution";
    ConstantPrefix["ErrorCommunication"] = "error.communication";
    ConstantPrefix["ErrorPlatform"] = "error.platform";
    ConstantPrefix["ErrorCustom"] = "xstate.error";
    return ConstantPrefix;
}({});
let SpecialTargets = /*#__PURE__*/ function(SpecialTargets) {
    SpecialTargets["Parent"] = "#_parent";
    SpecialTargets["Internal"] = "#_internal";
    return SpecialTargets;
}({});
const after$1 = ConstantPrefix.After;
const doneState = ConstantPrefix.DoneState;
const errorExecution = ConstantPrefix.ErrorExecution;
const errorPlatform = ConstantPrefix.ErrorPlatform;
const error$1 = ConstantPrefix.ErrorCustom;
var constantPrefixes = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    after: after$1,
    doneState: doneState,
    errorExecution: errorExecution,
    errorPlatform: errorPlatform,
    error: error$1
});
const STATE_DELIMITER = ".";
const TARGETLESS_KEY = "";
const NULL_EVENT = "";
const STATE_IDENTIFIER = "#";
const WILDCARD = "*";
const INIT_TYPE = "xstate.init";
function resolve$8(actorContext, state, args, { to, event: eventOrExpr, id, delay }) {
    const delaysMap = state.machine.implementations.delays;
    if (typeof eventOrExpr === "string") throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: "${eventOrExpr}" }) instead`);
    const resolvedEvent = typeof eventOrExpr === "function" ? eventOrExpr(args) : eventOrExpr;
    let resolvedDelay;
    if (typeof delay === "string") {
        const configDelay = delaysMap && delaysMap[delay];
        resolvedDelay = typeof configDelay === "function" ? configDelay(args) : configDelay;
    } else resolvedDelay = typeof delay === "function" ? delay(args) : delay;
    const resolvedTarget = typeof to === "function" ? to(args) : to;
    let targetActorRef;
    if (typeof resolvedTarget === "string") {
        if (resolvedTarget === SpecialTargets.Parent) targetActorRef = actorContext?.self._parent;
        else if (resolvedTarget === SpecialTargets.Internal) targetActorRef = actorContext?.self;
        else if (resolvedTarget.startsWith("#_")) // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor
        // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.
        targetActorRef = state.children[resolvedTarget.slice(2)];
        else targetActorRef = state.children[resolvedTarget];
        if (!targetActorRef) throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${state.machine.id}'.`);
    } else targetActorRef = resolvedTarget || actorContext?.self;
    return [
        state,
        {
            to: targetActorRef,
            event: resolvedEvent,
            id,
            delay: resolvedDelay
        }
    ];
}
function execute$5(actorContext, params) {
    if (typeof params.delay === "number") {
        actorContext.self.delaySend(params);
        return;
    }
    const { to, event } = params;
    actorContext.defer(()=>{
        to.send(event.type === error$1 ? {
            type: `${error(actorContext.self.id)}`,
            data: event.data
        } : event);
    });
}
/**
 * Sends an event to an actor.
 *
 * @param actor The `ActorRef` to send the event to.
 * @param event The event to send, or an expression that evaluates to the event to send
 * @param options Send action options
 *  - `id` - The unique send event identifier (used with `cancel()`).
 *  - `delay` - The number of milliseconds to delay the sending of the event.
 */ function sendTo(to, eventOrExpr, options) {
    function sendTo(_) {}
    sendTo.type = "xstate.sendTo";
    sendTo.to = to;
    sendTo.event = eventOrExpr;
    sendTo.id = options?.id;
    sendTo.delay = options?.delay;
    sendTo.resolve = resolve$8;
    sendTo.execute = execute$5;
    return sendTo;
}
/**
 * Sends an event to this machine's parent.
 *
 * @param event The event to send to the parent machine.
 * @param options Options to pass into the send event.
 */ function sendParent(event, options) {
    return sendTo(SpecialTargets.Parent, event, options);
}
/**
 * Forwards (sends) an event to a specified service.
 *
 * @param target The target service to forward the event to.
 * @param options Options to pass into the send action creator.
 */ function forwardTo(target, options) {
    return sendTo(target, ({ event })=>event, options);
}
/**
 * Escalates an error by sending it as an event to this machine's parent.
 *
 * @param errorData The error data to send, or the expression function that
 * takes in the `context`, `event`, and `meta`, and returns the error data to send.
 * @param options Options to pass into the send action creator.
 */ function escalate(errorData, options) {
    return sendParent((arg)=>{
        return {
            type: error$1,
            data: typeof errorData === "function" ? errorData(arg) : errorData
        };
    }, options);
}
const cache = new WeakMap();
function memo(object, key, fn) {
    let memoizedData = cache.get(object);
    if (!memoizedData) {
        memoizedData = {
            [key]: fn()
        };
        cache.set(object, memoizedData);
    } else if (!(key in memoizedData)) memoizedData[key] = fn();
    return memoizedData[key];
}
function resolve$7(_, state, actionArgs, { sendId }) {
    const resolvedSendId = typeof sendId === "function" ? sendId(actionArgs) : sendId;
    return [
        state,
        resolvedSendId
    ];
}
function execute$4(actorContext, resolvedSendId) {
    actorContext.self.cancel(resolvedSendId);
}
/**
 * Cancels an in-flight `send(...)` action. A canceled sent action will not
 * be executed, nor will its event be sent, unless it has already been sent
 * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).
 *
 * @param sendId The `id` of the `send(...)` action to cancel.
 */ function cancel(sendId) {
    function cancel(_) {}
    cancel.type = "xstate.cancel";
    cancel.sendId = sendId;
    cancel.resolve = resolve$7;
    cancel.execute = execute$4;
    return cancel;
}
class Mailbox {
    constructor(_process){
        this._process = _process;
        this._active = false;
        this._current = null;
        this._last = null;
    }
    start() {
        this._active = true;
        this.flush();
    }
    clear() {
        // we can't set _current to null because we might be currently processing
        // and enqueue following clear shouldnt start processing the enqueued item immediately
        if (this._current) {
            this._current.next = null;
            this._last = this._current;
        }
    }
    // TODO: rethink this design
    prepend(event) {
        if (!this._current) {
            this.enqueue(event);
            return;
        }
        // we know that something is already queued up
        // so the mailbox is already flushing or it's inactive
        // therefore the only thing that we need to do is to reassign `this._current`
        this._current = {
            value: event,
            next: this._current
        };
    }
    enqueue(event) {
        const enqueued = {
            value: event,
            next: null
        };
        if (this._current) {
            this._last.next = enqueued;
            this._last = enqueued;
            return;
        }
        this._current = enqueued;
        this._last = enqueued;
        if (this._active) this.flush();
    }
    flush() {
        while(this._current){
            // atm the given _process is responsible for implementing proper try/catch handling
            // we assume here that this won't throw in a way that can affect this mailbox
            const consumed = this._current;
            this._process(consumed.value);
            // something could have been prepended in the meantime
            // so we need to be defensive here to avoid skipping over a prepended item
            if (consumed === this._current) this._current = this._current.next;
        }
        this._last = null;
    }
}
const symbolObservable = (()=>typeof Symbol === "function" && Symbol.observable || "@@observable")();
/**
 * Returns actor logic from a transition function and its initial state.
 *
 * A transition function is a function that takes the current state and an event and returns the next state.
 *
 * @param transition The transition function that returns the next state given the current state and event.
 * @param initialState The initial state of the transition function.
 * @returns Actor logic
 */ function fromTransition(transition, initialState) {
    return {
        config: transition,
        transition: (state, event, actorContext)=>{
            return transition(state, event, actorContext);
        },
        getInitialState: (_, input)=>{
            return typeof initialState === "function" ? initialState({
                input
            }) : initialState;
        },
        getSnapshot: (state)=>state,
        getPersistedState: (state)=>state,
        restoreState: (state)=>state
    };
}
function matchesState(parentStateId, childStateId) {
    const parentStateValue = toStateValue(parentStateId);
    const childStateValue = toStateValue(childStateId);
    if (typeof childStateValue === "string") {
        if (typeof parentStateValue === "string") return childStateValue === parentStateValue;
        // Parent more specific than child
        return false;
    }
    if (typeof parentStateValue === "string") return parentStateValue in childStateValue;
    return Object.keys(parentStateValue).every((key)=>{
        if (!(key in childStateValue)) return false;
        return matchesState(parentStateValue[key], childStateValue[key]);
    });
}
function toStatePath(stateId) {
    try {
        if (isArray(stateId)) return stateId;
        return stateId.toString().split(STATE_DELIMITER);
    } catch (e) {
        throw new Error(`'${stateId}' is not a valid state path.`);
    }
}
function isStateLike(state) {
    return typeof state === "object" && "value" in state && "context" in state && "event" in state;
}
function toStateValue(stateValue) {
    if (isStateLike(stateValue)) return stateValue.value;
    if (isArray(stateValue)) return pathToStateValue(stateValue);
    if (typeof stateValue !== "string") return stateValue;
    const statePath = toStatePath(stateValue);
    return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
    if (statePath.length === 1) return statePath[0];
    const value = {};
    let marker = value;
    for(let i = 0; i < statePath.length - 1; i++)if (i === statePath.length - 2) marker[statePath[i]] = statePath[i + 1];
    else {
        const previous = marker;
        marker = {};
        previous[statePath[i]] = marker;
    }
    return value;
}
function mapValues(collection, iteratee) {
    const result = {};
    const collectionKeys = Object.keys(collection);
    for(let i = 0; i < collectionKeys.length; i++){
        const key = collectionKeys[i];
        result[key] = iteratee(collection[key], key, collection, i);
    }
    return result;
}
function flatten(array) {
    return [].concat(...array);
}
function toArrayStrict(value) {
    if (isArray(value)) return value;
    return [
        value
    ];
}
function toArray(value) {
    if (value === undefined) return [];
    return toArrayStrict(value);
}
function mapContext(mapper, context, event, self) {
    if (typeof mapper === "function") return mapper({
        context,
        event,
        self
    });
    return mapper;
}
function isPromiseLike(value) {
    if (value instanceof Promise) return true;
    // Check if shape matches the Promise/A+ specification for a "thenable".
    if (value !== null && (typeof value === "function" || typeof value === "object") && typeof value.then === "function") return true;
    return false;
}
function isArray(value) {
    return Array.isArray(value);
}
function isErrorEvent(event) {
    return typeof event.type === "string" && (event.type === errorExecution || event.type.startsWith(errorPlatform));
}
function toTransitionConfigArray(configLike) {
    return toArrayStrict(configLike).map((transitionLike)=>{
        if (typeof transitionLike === "undefined" || typeof transitionLike === "string") return {
            target: transitionLike
        };
        return transitionLike;
    });
}
function normalizeTarget(target) {
    if (target === undefined || target === TARGETLESS_KEY) return undefined;
    return toArray(target);
}
function toInvokeConfig(invocable, id) {
    if (typeof invocable === "object") {
        if ("src" in invocable) return invocable;
        if ("transition" in invocable) return {
            id,
            src: invocable
        };
    }
    return {
        id,
        src: invocable
    };
}
function toObserver(nextHandler, errorHandler, completionHandler) {
    const isObserver = typeof nextHandler === "object";
    const self = isObserver ? nextHandler : undefined;
    return {
        next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),
        error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),
        complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self)
    };
}
function createInvokeId(stateNodeId, index) {
    return `${stateNodeId}:invocation[${index}]`;
}
function resolveReferencedActor(referenced) {
    return referenced ? "transition" in referenced ? {
        src: referenced,
        input: undefined
    } : referenced : undefined;
}
function fromCallback(invokeCallback) {
    return {
        config: invokeCallback,
        start: (_state, { self })=>{
            self.send({
                type: startSignalType
            });
        },
        transition: (state, event, { self, id, system })=>{
            if (event.type === startSignalType) {
                const sendBack = (eventForParent)=>{
                    if (state.canceled) return;
                    self._parent?.send(eventForParent);
                };
                const receive = (newListener)=>{
                    state.receivers.add(newListener);
                };
                state.dispose = invokeCallback({
                    input: state.input,
                    system,
                    self: self,
                    sendBack,
                    receive
                });
                if (isPromiseLike(state.dispose)) state.dispose.then((resolved)=>{
                    self._parent?.send(doneInvoke(id, resolved));
                    state.canceled = true;
                }, (errorData)=>{
                    state.canceled = true;
                    self._parent?.send(error(id, errorData));
                });
                return state;
            }
            if (event.type === stopSignalType) {
                state.canceled = true;
                if (typeof state.dispose === "function") state.dispose();
                return state;
            }
            if (isSignal(event)) // TODO: unrecognized signal
            return state;
            state.receivers.forEach((receiver)=>receiver(event));
            return state;
        },
        getInitialState: (_, input)=>{
            return {
                canceled: false,
                receivers: new Set(),
                dispose: undefined,
                input
            };
        },
        getSnapshot: ()=>undefined,
        getPersistedState: ({ input, canceled })=>({
                input,
                canceled
            })
    };
}
function fromObservable(observableCreator) {
    const nextEventType = "$$xstate.next";
    const errorEventType = "$$xstate.error";
    const completeEventType = "$$xstate.complete";
    return {
        config: observableCreator,
        transition: (state, event, { self, id, defer })=>{
            if (state.status !== "active") return state;
            switch(event.type){
                case nextEventType:
                    // match the exact timing of events sent by machines
                    // send actions are not executed immediately
                    defer(()=>{
                        self._parent?.send({
                            type: `xstate.snapshot.${id}`,
                            data: event.data
                        });
                    });
                    return {
                        ...state,
                        data: event.data
                    };
                case errorEventType:
                    return {
                        ...state,
                        status: "error",
                        input: undefined,
                        data: event.data,
                        // TODO: if we keep this as `data` we should reflect this in the type
                        subscription: undefined
                    };
                case completeEventType:
                    return {
                        ...state,
                        status: "done",
                        input: undefined,
                        subscription: undefined
                    };
                case stopSignalType:
                    state.subscription.unsubscribe();
                    return {
                        ...state,
                        status: "canceled",
                        input: undefined,
                        subscription: undefined
                    };
                default:
                    return state;
            }
        },
        getInitialState: (_, input)=>{
            return {
                subscription: undefined,
                status: "active",
                data: undefined,
                input
            };
        },
        start: (state, { self, system })=>{
            if (state.status === "done") // Do not restart a completed observable
            return;
            state.subscription = observableCreator({
                input: state.input,
                system,
                self
            }).subscribe({
                next: (value)=>{
                    self.send({
                        type: nextEventType,
                        data: value
                    });
                },
                error: (err)=>{
                    self.send({
                        type: errorEventType,
                        data: err
                    });
                },
                complete: ()=>{
                    self.send({
                        type: completeEventType
                    });
                }
            });
        },
        getSnapshot: (state)=>state.data,
        getPersistedState: ({ status, data, input })=>({
                status,
                data,
                input
            }),
        getStatus: (state)=>state,
        restoreState: (state)=>({
                ...state,
                subscription: undefined
            })
    };
}
/**
 * Creates event observable logic that listens to an observable
 * that delivers event objects.
 *
 *
 * @param lazyObservable A function that creates an observable
 * @returns Event observable logic
 */ function fromEventObservable(lazyObservable) {
    const errorEventType = "$$xstate.error";
    const completeEventType = "$$xstate.complete";
    // TODO: event types
    return {
        config: lazyObservable,
        transition: (state, event)=>{
            if (state.status !== "active") return state;
            switch(event.type){
                case errorEventType:
                    return {
                        ...state,
                        status: "error",
                        input: undefined,
                        data: event.data,
                        // TODO: if we keep this as `data` we should reflect this in the type
                        subscription: undefined
                    };
                case completeEventType:
                    return {
                        ...state,
                        status: "done",
                        input: undefined,
                        subscription: undefined
                    };
                case stopSignalType:
                    state.subscription.unsubscribe();
                    return {
                        ...state,
                        status: "canceled",
                        input: undefined,
                        subscription: undefined
                    };
                default:
                    return state;
            }
        },
        getInitialState: (_, input)=>{
            return {
                subscription: undefined,
                status: "active",
                data: undefined,
                input
            };
        },
        start: (state, { self, system })=>{
            if (state.status === "done") // Do not restart a completed observable
            return;
            state.subscription = lazyObservable({
                input: state.input,
                system,
                self
            }).subscribe({
                next: (value)=>{
                    self._parent?.send(value);
                },
                error: (err)=>{
                    self.send({
                        type: errorEventType,
                        data: err
                    });
                },
                complete: ()=>{
                    self.send({
                        type: completeEventType
                    });
                }
            });
        },
        getSnapshot: (_)=>undefined,
        getPersistedState: ({ status, data, input })=>({
                status,
                data,
                input
            }),
        getStatus: (state)=>state,
        restoreState: (state)=>({
                ...state,
                subscription: undefined
            })
    };
}
const resolveEventType = "$$xstate.resolve";
const rejectEventType = "$$xstate.reject";
function fromPromise(// TODO: add types
promiseCreator) {
    // TODO: add event types
    const logic = {
        config: promiseCreator,
        transition: (state, event)=>{
            if (state.status !== "active") return state;
            switch(event.type){
                case resolveEventType:
                    return {
                        ...state,
                        status: "done",
                        data: event.data,
                        input: undefined
                    };
                case rejectEventType:
                    return {
                        ...state,
                        status: "error",
                        data: event.data,
                        // TODO: if we keep this as `data` we should reflect this in the type
                        input: undefined
                    };
                case stopSignalType:
                    return {
                        ...state,
                        status: "canceled",
                        input: undefined
                    };
                default:
                    return state;
            }
        },
        start: (state, { self, system })=>{
            // TODO: determine how to allow customizing this so that promises
            // can be restarted if necessary
            if (state.status !== "active") return;
            const resolvedPromise = Promise.resolve(promiseCreator({
                input: state.input,
                system,
                self
            }));
            resolvedPromise.then((response)=>{
                // TODO: remove this condition once dead letter queue lands
                if (self._state.status !== "active") return;
                self.send({
                    type: resolveEventType,
                    data: response
                });
            }, (errorData)=>{
                // TODO: remove this condition once dead letter queue lands
                if (self._state.status !== "active") return;
                self.send({
                    type: rejectEventType,
                    data: errorData
                });
            });
        },
        getInitialState: (_, input)=>{
            return {
                status: "active",
                data: undefined,
                input
            };
        },
        getSnapshot: (state)=>state.data,
        getStatus: (state)=>state,
        getPersistedState: (state)=>state,
        restoreState: (state)=>state
    };
    return logic;
}
const startSignalType = "xstate.init";
const stopSignalType = "xstate.stop";
const startSignal = {
    type: "xstate.init"
};
const stopSignal = {
    type: "xstate.stop"
};
/**
 * An object that expresses the actor logic in reaction to received events,
 * as well as an optionally emitted stream of values.
 *
 * @template TReceived The received event
 * @template TSnapshot The emitted value
 */ function isSignal(event) {
    return event.type === startSignalType || event.type === stopSignalType;
}
function isActorRef(item) {
    return !!item && typeof item === "object" && typeof item.send === "function";
}
// TODO: refactor the return type, this could be written in a better way
// but it's best to avoid unneccessary breaking changes now
// @deprecated use `interpret(actorLogic)` instead
function toActorRef(actorRefLike) {
    return {
        subscribe: ()=>({
                unsubscribe: ()=>void 0
            }),
        id: "anonymous",
        sessionId: "",
        getSnapshot: ()=>undefined,
        // TODO: this isn't safe
        [symbolObservable]: function() {
            return this;
        },
        status: ActorStatus.Running,
        stop: ()=>void 0,
        ...actorRefLike
    };
}
const emptyLogic = fromTransition((_)=>undefined, undefined);
function createEmptyActor() {
    return interpret(emptyLogic);
}
/**
 * This function makes sure that unhandled errors are thrown in a separate macrotask.
 * It allows those errors to be detected by global error handlers and reported to bug tracking services
 * without interrupting our own stack of execution.
 *
 * @param err error to be thrown
 */ function reportUnhandledError(err) {
    setTimeout(()=>{
        throw err;
    });
}
function createSystem() {
    let sessionIdCounter = 0;
    const children = new Map();
    const keyedActors = new Map();
    const reverseKeyedActors = new WeakMap();
    const system = {
        _bookId: ()=>`x:${sessionIdCounter++}`,
        _register: (sessionId, actorRef)=>{
            children.set(sessionId, actorRef);
            return sessionId;
        },
        _unregister: (actorRef)=>{
            children.delete(actorRef.sessionId);
            const systemId = reverseKeyedActors.get(actorRef);
            if (systemId !== undefined) {
                keyedActors.delete(systemId);
                reverseKeyedActors.delete(actorRef);
            }
        },
        get: (systemId)=>{
            return keyedActors.get(systemId);
        },
        _set: (systemId, actorRef)=>{
            const existing = keyedActors.get(systemId);
            if (existing && existing !== actorRef) throw new Error(`Actor with system ID '${systemId}' already exists.`);
            keyedActors.set(systemId, actorRef);
            reverseKeyedActors.set(actorRef, systemId);
        }
    };
    return system;
}
let ActorStatus = /*#__PURE__*/ function(ActorStatus) {
    ActorStatus[ActorStatus["NotStarted"] = 0] = "NotStarted";
    ActorStatus[ActorStatus["Running"] = 1] = "Running";
    ActorStatus[ActorStatus["Stopped"] = 2] = "Stopped";
    return ActorStatus;
}({});
const defaultOptions = {
    deferEvents: true,
    clock: {
        setTimeout: (fn, ms)=>{
            return setTimeout(fn, ms);
        },
        clearTimeout: (id)=>{
            return clearTimeout(id);
        }
    },
    logger: console.log.bind(console),
    devTools: false
};
class Interpreter {
    /**
   * The current state of the interpreted logic.
   */ /**
   * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.
   */ /**
   * The unique identifier for this actor relative to its parent.
   */ /**
   * Whether the service is started.
   */ // Actor Ref
    // TODO: add typings for system
    /**
   * The globally unique process ID for this invocation.
   */ /**
   * Creates a new Interpreter instance (i.e., service) for the given logic with the provided options, if any.
   *
   * @param logic The logic to be interpreted
   * @param options Interpreter options
   */ constructor(logic, options){
        this.logic = logic;
        this._state = void 0;
        this.clock = void 0;
        this.options = void 0;
        this.id = void 0;
        this.mailbox = new Mailbox(this._process.bind(this));
        this.delayedEventsMap = {};
        this.observers = new Set();
        this.logger = void 0;
        this.status = ActorStatus.NotStarted;
        this._parent = void 0;
        this.ref = void 0;
        this._actorContext = void 0;
        this._systemId = void 0;
        this.sessionId = void 0;
        this.system = void 0;
        this._doneEvent = void 0;
        this.src = void 0;
        this._deferred = [];
        const resolvedOptions = {
            ...defaultOptions,
            ...options
        };
        const { clock, logger, parent, id, systemId } = resolvedOptions;
        const self = this;
        this.system = parent?.system ?? createSystem();
        if (systemId) {
            this._systemId = systemId;
            this.system._set(systemId, this);
        }
        this.sessionId = this.system._bookId();
        this.id = id ?? this.sessionId;
        this.logger = logger;
        this.clock = clock;
        this._parent = parent;
        this.options = resolvedOptions;
        this.src = resolvedOptions.src;
        this.ref = this;
        this._actorContext = {
            self,
            id: this.id,
            sessionId: this.sessionId,
            logger: this.logger,
            defer: (fn)=>{
                this._deferred.push(fn);
            },
            system: this.system,
            stopChild: (child)=>{
                if (child._parent !== this) throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);
                child._stop();
            }
        };
        // Ensure that the send method is bound to this interpreter instance
        // if destructured
        this.send = this.send.bind(this);
        this._initState();
    }
    _initState() {
        this._state = this.options.state ? this.logic.restoreState ? this.logic.restoreState(this.options.state, this._actorContext) : this.options.state : this.logic.getInitialState(this._actorContext, this.options?.input);
    }
    // array of functions to defer
    update(state) {
        // Update state
        this._state = state;
        const snapshot = this.getSnapshot();
        // Execute deferred effects
        let deferredFn;
        while(deferredFn = this._deferred.shift())deferredFn();
        for (const observer of this.observers)// TODO: should observers be notified in case of the error?
        try {
            observer.next?.(snapshot);
        } catch (err) {
            reportUnhandledError(err);
        }
        const status = this.logic.getStatus?.(state);
        switch(status?.status){
            case "done":
                this._stopProcedure();
                this._complete();
                this._doneEvent = doneInvoke(this.id, status.data);
                this._parent?.send(this._doneEvent);
                break;
            case "error":
                this._stopProcedure();
                this._error(status.data);
                this._parent?.send(error(this.id, status.data));
                break;
        }
    }
    subscribe(nextListenerOrObserver, errorListener, completeListener) {
        const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);
        if (this.status !== ActorStatus.Stopped) this.observers.add(observer);
        else try {
            observer.complete?.();
        } catch (err) {
            reportUnhandledError(err);
        }
        return {
            unsubscribe: ()=>{
                this.observers.delete(observer);
            }
        };
    }
    /**
   * Starts the interpreter from the initial state
   */ start() {
        if (this.status === ActorStatus.Running) // Do not restart the service if it is already started
        return this;
        this.system._register(this.sessionId, this);
        if (this._systemId) this.system._set(this._systemId, this);
        this.status = ActorStatus.Running;
        const status = this.logic.getStatus?.(this._state);
        switch(status?.status){
            case "done":
                // a state machine can be "done" upon intialization (it could reach a final state using initial microsteps)
                // we still need to complete observers, flush deferreds etc
                this.update(this._state);
            // fallthrough
            case "error":
                // TODO: rethink cleanup of observers, mailbox, etc
                return this;
        }
        if (this.logic.start) try {
            this.logic.start(this._state, this._actorContext);
        } catch (err) {
            this._stopProcedure();
            this._error(err);
            this._parent?.send(error(this.id, err));
            return this;
        }
        // TODO: this notifies all subscribers but usually this is redundant
        // there is no real change happening here
        // we need to rethink if this needs to be refactored
        this.update(this._state);
        if (this.options.devTools) this.attachDevTools();
        this.mailbox.start();
        return this;
    }
    _process(event) {
        // TODO: reexamine what happens when an action (or a guard or smth) throws
        let nextState;
        let caughtError;
        try {
            nextState = this.logic.transition(this._state, event, this._actorContext);
        } catch (err) {
            // we wrap it in a box so we can rethrow it later even if falsy value gets caught here
            caughtError = {
                err
            };
        }
        if (caughtError) {
            const { err } = caughtError;
            this._stopProcedure();
            this._error(err);
            this._parent?.send(error(this.id, err));
            return;
        }
        this.update(nextState);
        if (event.type === stopSignalType) {
            this._stopProcedure();
            this._complete();
        }
    }
    _stop() {
        if (this.status === ActorStatus.Stopped) return this;
        this.mailbox.clear();
        if (this.status === ActorStatus.NotStarted) {
            this.status = ActorStatus.Stopped;
            return this;
        }
        this.mailbox.enqueue({
            type: stopSignalType
        });
        return this;
    }
    /**
   * Stops the interpreter and unsubscribe all listeners.
   */ stop() {
        if (this._parent) throw new Error("A non-root actor cannot be stopped directly.");
        return this._stop();
    }
    _complete() {
        for (const observer of this.observers)try {
            observer.complete?.();
        } catch (err) {
            reportUnhandledError(err);
        }
        this.observers.clear();
    }
    _error(err) {
        if (!this.observers.size) {
            if (!this._parent) reportUnhandledError(err);
            return;
        }
        let reportError = false;
        for (const observer of this.observers){
            const errorListener = observer.error;
            reportError ||= !errorListener;
            try {
                errorListener?.(err);
            } catch (err2) {
                reportUnhandledError(err2);
            }
        }
        this.observers.clear();
        if (reportError) reportUnhandledError(err);
    }
    _stopProcedure() {
        if (this.status !== ActorStatus.Running) // Interpreter already stopped; do nothing
        return this;
        // Cancel all delayed events
        for (const key of Object.keys(this.delayedEventsMap))this.clock.clearTimeout(this.delayedEventsMap[key]);
        // TODO: mailbox.reset
        this.mailbox.clear();
        // TODO: after `stop` we must prepare ourselves for receiving events again
        // events sent *after* stop signal must be queued
        // it seems like this should be the common behavior for all of our consumers
        // so perhaps this should be unified somehow for all of them
        this.mailbox = new Mailbox(this._process.bind(this));
        this.status = ActorStatus.Stopped;
        this.system._unregister(this);
        return this;
    }
    /**
   * Sends an event to the running interpreter to trigger a transition.
   *
   * @param event The event to send
   */ send(event) {
        if (typeof event === "string") throw new Error(`Only event objects may be sent to actors; use .send({ type: "${event}" }) instead`);
        if (this.status === ActorStatus.Stopped) return;
        if (this.status !== ActorStatus.Running && !this.options.deferEvents) throw new Error(`Event "${event.type}" was sent to uninitialized actor "${this.id}". Make sure .start() is called for this actor, or set { deferEvents: true } in the actor options.\nEvent: ${JSON.stringify(event)}`);
        this.mailbox.enqueue(event);
    }
    // TODO: make private (and figure out a way to do this within the machine)
    delaySend({ event, id, delay, to }) {
        const timerId = this.clock.setTimeout(()=>{
            if (to) to.send(event);
            else this.send(event);
        }, delay);
        // TODO: consider the rehydration story here
        if (id) this.delayedEventsMap[id] = timerId;
    }
    // TODO: make private (and figure out a way to do this within the machine)
    cancel(sendId) {
        this.clock.clearTimeout(this.delayedEventsMap[sendId]);
        delete this.delayedEventsMap[sendId];
    }
    attachDevTools() {
        const { devTools } = this.options;
        if (devTools) {
            const resolvedDevToolsAdapter = typeof devTools === "function" ? devTools : (0, _xstateDevEsmJs.devToolsAdapter);
            resolvedDevToolsAdapter(this);
        }
    }
    toJSON() {
        return {
            id: this.id
        };
    }
    getPersistedState() {
        return this.logic.getPersistedState?.(this._state);
    }
    [symbolObservable]() {
        return this;
    }
    getSnapshot() {
        return this.logic.getSnapshot ? this.logic.getSnapshot(this._state) : this._state;
    }
}
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to interpret
 * @param options Interpreter options
 */ function interpret(logic, options) {
    const interpreter = new Interpreter(logic, options);
    return interpreter;
}
function resolve$6(actorContext, state, actionArgs, { id, systemId, src, input }) {
    const referenced = resolveReferencedActor(state.machine.implementations.actors[src]);
    let actorRef;
    if (referenced) {
        // TODO: inline `input: undefined` should win over the referenced one
        const configuredInput = input || referenced.input;
        actorRef = interpret(referenced.src, {
            id,
            src,
            parent: actorContext?.self,
            systemId,
            input: typeof configuredInput === "function" ? configuredInput({
                context: state.context,
                event: actionArgs.event,
                self: actorContext?.self
            }) : configuredInput
        });
    }
    return [
        cloneState(state, {
            children: {
                ...state.children,
                [id]: actorRef
            }
        }),
        {
            id,
            actorRef
        }
    ];
}
function execute$3(actorContext, { id, actorRef }) {
    if (!actorRef) return;
    actorContext.defer(()=>{
        if (actorRef.status === ActorStatus.Stopped) return;
        try {
            actorRef.start?.();
        } catch (err) {
            actorContext.self.send(error(id, err));
            return;
        }
    });
}
function invoke({ id, systemId, src, input }) {
    function invoke(_) {}
    invoke.type = "xstate.invoke";
    invoke.id = id;
    invoke.systemId = systemId;
    invoke.src = src;
    invoke.input = input;
    invoke.resolve = resolve$6;
    invoke.execute = execute$3;
    return invoke;
}
function stateIn(stateValue) {
    return {
        type: "xstate.guard:in",
        params: {
            stateValue
        },
        predicate: ({ state })=>{
            if (typeof stateValue === "string" && isStateId(stateValue)) return state.configuration.some((sn)=>sn.id === stateValue.slice(1));
            return state.matches(stateValue);
        }
    };
}
function not(guard) {
    return {
        type: "xstate.boolean",
        params: {
            op: "not"
        },
        children: [
            toGuardDefinition(guard)
        ],
        predicate: ({ evaluate, guard, context, event, state })=>{
            return !evaluate(guard.children[0], context, event, state);
        }
    };
}
function and(guards) {
    return {
        type: "xstate.boolean",
        params: {
            op: "and"
        },
        children: guards.map((guard)=>toGuardDefinition(guard)),
        predicate: ({ evaluate, guard, context, event, state })=>{
            return guard.children.every((childGuard)=>{
                return evaluate(childGuard, context, event, state);
            });
        }
    };
}
function or(guards) {
    return {
        type: "xstate.boolean",
        params: {
            op: "or"
        },
        children: guards.map((guard)=>toGuardDefinition(guard)),
        predicate: ({ evaluate, guard, context, event, state })=>{
            return guard.children.some((childGuard)=>{
                return evaluate(childGuard, context, event, state);
            });
        }
    };
}
function evaluateGuard(guard, context, event, state) {
    const { machine } = state;
    const predicate = machine?.implementations?.guards?.[guard.type] ?? guard.predicate;
    if (!predicate) throw new Error(`Guard '${guard.type}' is not implemented.'.`);
    return predicate({
        context,
        event,
        state,
        guard,
        evaluate: evaluateGuard
    });
}
function toGuardDefinition(guardConfig, getPredicate) {
    // TODO: check for cycles and consider a refactor to more lazily evaluated guards
    // TODO: resolve this more recursively: https://github.com/statelyai/xstate/pull/4064#discussion_r1229915724
    if (typeof guardConfig === "string") {
        const predicateOrDef = getPredicate?.(guardConfig);
        if (typeof predicateOrDef === "function") return {
            type: guardConfig,
            predicate: predicateOrDef,
            params: {
                type: guardConfig
            }
        };
        else if (predicateOrDef) return predicateOrDef;
        else return {
            type: guardConfig,
            params: {
                type: guardConfig
            }
        };
    }
    if (typeof guardConfig === "function") return {
        type: guardConfig.name,
        predicate: guardConfig,
        params: {
            type: guardConfig.name,
            name: guardConfig.name
        }
    };
    const predicateOrDef = getPredicate?.(guardConfig.type);
    if (typeof predicateOrDef === "function") return {
        type: guardConfig.type,
        params: guardConfig.params || guardConfig,
        children: guardConfig.children?.map((childGuard)=>toGuardDefinition(childGuard, getPredicate)),
        predicate: getPredicate?.(guardConfig.type) || guardConfig.predicate
    };
    else if (predicateOrDef) return predicateOrDef;
    else return {
        type: guardConfig.type,
        params: guardConfig.params || guardConfig,
        children: guardConfig.children?.map((childGuard)=>toGuardDefinition(childGuard, getPredicate)),
        predicate: guardConfig.predicate
    };
}
function getOutput(configuration, context, event, self) {
    const machine = configuration[0].machine;
    const finalChildStateNode = configuration.find((stateNode)=>stateNode.type === "final" && stateNode.parent === machine.root);
    return finalChildStateNode && finalChildStateNode.output ? mapContext(finalChildStateNode.output, context, event, self) : undefined;
}
const isAtomicStateNode = (stateNode)=>stateNode.type === "atomic" || stateNode.type === "final";
function getChildren(stateNode) {
    return Object.values(stateNode.states).filter((sn)=>sn.type !== "history");
}
function getProperAncestors(stateNode, toStateNode) {
    const ancestors = [];
    // add all ancestors
    let m = stateNode.parent;
    while(m && m !== toStateNode){
        ancestors.push(m);
        m = m.parent;
    }
    return ancestors;
}
function getConfiguration(stateNodes) {
    const configuration = new Set(stateNodes);
    const configurationSet = new Set(stateNodes);
    const adjList = getAdjList(configurationSet);
    // add descendants
    for (const s of configuration)// if previously active, add existing child nodes
    if (s.type === "compound" && (!adjList.get(s) || !adjList.get(s).length)) getInitialStateNodes(s).forEach((sn)=>configurationSet.add(sn));
    else {
        if (s.type === "parallel") for (const child of getChildren(s)){
            if (child.type === "history") continue;
            if (!configurationSet.has(child)) for (const initialStateNode of getInitialStateNodes(child))configurationSet.add(initialStateNode);
        }
    }
    // add all ancestors
    for (const s of configurationSet){
        let m = s.parent;
        while(m){
            configurationSet.add(m);
            m = m.parent;
        }
    }
    return configurationSet;
}
function getValueFromAdj(baseNode, adjList) {
    const childStateNodes = adjList.get(baseNode);
    if (!childStateNodes) return {}; // todo: fix?
    if (baseNode.type === "compound") {
        const childStateNode = childStateNodes[0];
        if (childStateNode) {
            if (isAtomicStateNode(childStateNode)) return childStateNode.key;
        } else return {};
    }
    const stateValue = {};
    for (const childStateNode of childStateNodes)stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);
    return stateValue;
}
function getAdjList(configuration) {
    const adjList = new Map();
    for (const s of configuration){
        if (!adjList.has(s)) adjList.set(s, []);
        if (s.parent) {
            if (!adjList.has(s.parent)) adjList.set(s.parent, []);
            adjList.get(s.parent).push(s);
        }
    }
    return adjList;
}
function getStateValue(rootNode, configuration) {
    const config = getConfiguration(configuration);
    return getValueFromAdj(rootNode, getAdjList(config));
}
function isInFinalState(configuration, stateNode = configuration[0].machine.root) {
    if (stateNode.type === "compound") return getChildren(stateNode).some((s)=>s.type === "final" && configuration.includes(s));
    if (stateNode.type === "parallel") return getChildren(stateNode).every((sn)=>isInFinalState(configuration, sn));
    return false;
}
const isStateId = (str)=>str[0] === STATE_IDENTIFIER;
function getCandidates(stateNode, receivedEventType) {
    const candidates = stateNode.transitions.get(receivedEventType) || [
        ...stateNode.transitions.keys()
    ].filter((descriptor)=>{
        // check if transition is a wildcard transition,
        // which matches any non-transient events
        if (descriptor === WILDCARD) return true;
        if (!descriptor.endsWith(".*")) return false;
        const partialEventTokens = descriptor.split(".");
        const eventTokens = receivedEventType.split(".");
        for(let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++){
            const partialEventToken = partialEventTokens[tokenIndex];
            const eventToken = eventTokens[tokenIndex];
            if (partialEventToken === "*") {
                const isLastToken = tokenIndex === partialEventTokens.length - 1;
                return isLastToken;
            }
            if (partialEventToken !== eventToken) return false;
        }
        return true;
    }).sort((a, b)=>b.length - a.length).flatMap((key)=>stateNode.transitions.get(key));
    return candidates;
}
/**
 * All delayed transitions from the config.
 */ function getDelayedTransitions(stateNode) {
    const afterConfig = stateNode.config.after;
    if (!afterConfig) return [];
    const mutateEntryExit = (delay, i)=>{
        const delayRef = typeof delay === "function" ? `${stateNode.id}:delay[${i}]` : delay;
        const eventType = after(delayRef, stateNode.id);
        stateNode.entry.push(raise({
            type: eventType
        }, {
            id: eventType,
            delay
        }));
        stateNode.exit.push(cancel(eventType));
        return eventType;
    };
    const delayedTransitions = isArray(afterConfig) ? afterConfig.map((transition, i)=>{
        const eventType = mutateEntryExit(transition.delay, i);
        return {
            ...transition,
            event: eventType
        };
    }) : Object.keys(afterConfig).flatMap((delay, i)=>{
        const configTransition = afterConfig[delay];
        const resolvedTransition = typeof configTransition === "string" ? {
            target: configTransition
        } : configTransition;
        const resolvedDelay = !isNaN(+delay) ? +delay : delay;
        const eventType = mutateEntryExit(resolvedDelay, i);
        return toArray(resolvedTransition).map((transition)=>({
                ...transition,
                event: eventType,
                delay: resolvedDelay
            }));
    });
    return delayedTransitions.map((delayedTransition)=>{
        const { delay } = delayedTransition;
        return {
            ...formatTransition(stateNode, delayedTransition.event, delayedTransition),
            delay
        };
    });
}
function formatTransition(stateNode, descriptor, transitionConfig) {
    const normalizedTarget = normalizeTarget(transitionConfig.target);
    const reenter = transitionConfig.reenter ?? false;
    const { guards } = stateNode.machine.implementations;
    const target = resolveTarget(stateNode, normalizedTarget);
    const transition = {
        ...transitionConfig,
        actions: toArray(transitionConfig.actions),
        guard: transitionConfig.guard ? toGuardDefinition(transitionConfig.guard, (guardType)=>guards[guardType]) : undefined,
        target,
        source: stateNode,
        reenter,
        eventType: descriptor,
        toJSON: ()=>({
                ...transition,
                source: `#${stateNode.id}`,
                target: target ? target.map((t)=>`#${t.id}`) : undefined
            })
    };
    return transition;
}
function formatTransitions(stateNode) {
    const transitions = new Map();
    if (stateNode.config.on) for (const descriptor of Object.keys(stateNode.config.on)){
        if (descriptor === NULL_EVENT) throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
        const transitionsConfig = stateNode.config.on[descriptor];
        transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t)=>formatTransition(stateNode, descriptor, t)));
    }
    if (stateNode.config.onDone) {
        const descriptor = String(done(stateNode.id));
        transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));
    }
    for (const invokeDef of stateNode.invoke){
        if (invokeDef.onDone) {
            const descriptor = `done.invoke.${invokeDef.id}`;
            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));
        }
        if (invokeDef.onError) {
            const descriptor = `error.platform.${invokeDef.id}`;
            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t)=>formatTransition(stateNode, descriptor, t)));
        }
        if (invokeDef.onSnapshot) {
            const descriptor = `xstate.snapshot.${invokeDef.id}`;
            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t)=>formatTransition(stateNode, descriptor, t)));
        }
    }
    for (const delayedTransition of stateNode.after){
        let existing = transitions.get(delayedTransition.eventType);
        if (!existing) {
            existing = [];
            transitions.set(delayedTransition.eventType, existing);
        }
        existing.push(delayedTransition);
    }
    return transitions;
}
function formatInitialTransition(stateNode, _target) {
    if (typeof _target === "string" || isArray(_target)) {
        const targets = toArray(_target).map((t)=>{
            // Resolve state string keys (which represent children)
            // to their state node
            const descStateNode = typeof t === "string" ? isStateId(t) ? stateNode.machine.getStateNodeById(t) : stateNode.states[t] : t;
            if (!descStateNode) throw new Error(`Initial state node "${t}" not found on parent state node #${stateNode.id}`);
            if (!isDescendant(descStateNode, stateNode)) throw new Error(`Invalid initial target: state node #${descStateNode.id} is not a descendant of #${stateNode.id}`);
            return descStateNode;
        });
        const resolvedTarget = resolveTarget(stateNode, targets);
        const transition = {
            source: stateNode,
            actions: [],
            eventType: null,
            reenter: false,
            target: resolvedTarget,
            toJSON: ()=>({
                    ...transition,
                    source: `#${stateNode.id}`,
                    target: resolvedTarget ? resolvedTarget.map((t)=>`#${t.id}`) : undefined
                })
        };
        return transition;
    }
    return formatTransition(stateNode, "__INITIAL__", {
        target: toArray(_target.target).map((t)=>{
            if (typeof t === "string") return isStateId(t) ? t : `${STATE_DELIMITER}${t}`;
            return t;
        }),
        actions: _target.actions
    });
}
function resolveTarget(stateNode, targets) {
    if (targets === undefined) // an undefined target signals that the state node should not transition from that state when receiving that event
    return undefined;
    return targets.map((target)=>{
        if (typeof target !== "string") return target;
        if (isStateId(target)) return stateNode.machine.getStateNodeById(target);
        const isInternalTarget = target[0] === STATE_DELIMITER;
        // If internal target is defined on machine,
        // do not include machine key on target
        if (isInternalTarget && !stateNode.parent) return getStateNodeByPath(stateNode, target.slice(1));
        const resolvedTarget = isInternalTarget ? stateNode.key + target : target;
        if (stateNode.parent) try {
            const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);
            return targetStateNode;
        } catch (err) {
            throw new Error(`Invalid transition definition for state node '${stateNode.id}':\n${err.message}`);
        }
        else throw new Error(`Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`);
    });
}
function resolveHistoryTarget(stateNode) {
    const normalizedTarget = normalizeTarget(stateNode.target);
    if (!normalizedTarget) return stateNode.parent.initial.target;
    return normalizedTarget.map((t)=>typeof t === "string" ? getStateNodeByPath(stateNode.parent, t) : t);
}
function isHistoryNode(stateNode) {
    return stateNode.type === "history";
}
function getInitialStateNodes(stateNode) {
    const set = new Set();
    function iter(descStateNode) {
        if (set.has(descStateNode)) return;
        set.add(descStateNode);
        if (descStateNode.type === "compound") for (const targetStateNode of descStateNode.initial.target){
            for (const a of getProperAncestors(targetStateNode, stateNode))set.add(a);
            iter(targetStateNode);
        }
        else if (descStateNode.type === "parallel") for (const child of getChildren(descStateNode))iter(child);
    }
    iter(stateNode);
    return [
        ...set
    ];
}
/**
 * Returns the child state node from its relative `stateKey`, or throws.
 */ function getStateNode(stateNode, stateKey) {
    if (isStateId(stateKey)) return stateNode.machine.getStateNodeById(stateKey);
    if (!stateNode.states) throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);
    const result = stateNode.states[stateKey];
    if (!result) throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);
    return result;
}
/**
 * Returns the relative state node from the given `statePath`, or throws.
 *
 * @param statePath The string or string array relative path to the state node.
 */ function getStateNodeByPath(stateNode, statePath) {
    if (typeof statePath === "string" && isStateId(statePath)) try {
        return stateNode.machine.getStateNodeById(statePath);
    } catch (e) {
    // try individual paths
    // throw e;
    }
    const arrayStatePath = toStatePath(statePath).slice();
    let currentStateNode = stateNode;
    while(arrayStatePath.length){
        const key = arrayStatePath.shift();
        if (!key.length) break;
        currentStateNode = getStateNode(currentStateNode, key);
    }
    return currentStateNode;
}
/**
 * Returns the state nodes represented by the current state value.
 *
 * @param state The state value or State instance
 */ function getStateNodes(stateNode, state) {
    const stateValue = state instanceof State ? state.value : toStateValue(state);
    if (typeof stateValue === "string") return [
        stateNode,
        stateNode.states[stateValue]
    ];
    const childStateKeys = Object.keys(stateValue);
    const childStateNodes = childStateKeys.map((subStateKey)=>getStateNode(stateNode, subStateKey)).filter(Boolean);
    return [
        stateNode.machine.root,
        stateNode
    ].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey)=>{
        const subStateNode = getStateNode(stateNode, subStateKey);
        if (!subStateNode) return allSubStateNodes;
        const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);
        return allSubStateNodes.concat(subStateNodes);
    }, []));
}
function transitionAtomicNode(stateNode, stateValue, state, event) {
    const childStateNode = getStateNode(stateNode, stateValue);
    const next = childStateNode.next(state, event);
    if (!next || !next.length) return stateNode.next(state, event);
    return next;
}
function transitionCompoundNode(stateNode, stateValue, state, event) {
    const subStateKeys = Object.keys(stateValue);
    const childStateNode = getStateNode(stateNode, subStateKeys[0]);
    const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], state, event);
    if (!next || !next.length) return stateNode.next(state, event);
    return next;
}
function transitionParallelNode(stateNode, stateValue, state, event) {
    const allInnerTransitions = [];
    for (const subStateKey of Object.keys(stateValue)){
        const subStateValue = stateValue[subStateKey];
        if (!subStateValue) continue;
        const subStateNode = getStateNode(stateNode, subStateKey);
        const innerTransitions = transitionNode(subStateNode, subStateValue, state, event);
        if (innerTransitions) allInnerTransitions.push(...innerTransitions);
    }
    if (!allInnerTransitions.length) return stateNode.next(state, event);
    return allInnerTransitions;
}
function transitionNode(stateNode, stateValue, state, event) {
    // leaf node
    if (typeof stateValue === "string") return transitionAtomicNode(stateNode, stateValue, state, event);
    // compound node
    if (Object.keys(stateValue).length === 1) return transitionCompoundNode(stateNode, stateValue, state, event);
    // parallel node
    return transitionParallelNode(stateNode, stateValue, state, event);
}
function getHistoryNodes(stateNode) {
    return Object.keys(stateNode.states).map((key)=>stateNode.states[key]).filter((sn)=>sn.type === "history");
}
function isDescendant(childStateNode, parentStateNode) {
    let marker = childStateNode;
    while(marker.parent && marker.parent !== parentStateNode)marker = marker.parent;
    return marker.parent === parentStateNode;
}
function getPathFromRootToNode(stateNode) {
    const path = [];
    let marker = stateNode.parent;
    while(marker){
        path.unshift(marker);
        marker = marker.parent;
    }
    return path;
}
function hasIntersection(s1, s2) {
    const set1 = new Set(s1);
    const set2 = new Set(s2);
    for (const item of set1){
        if (set2.has(item)) return true;
    }
    for (const item of set2){
        if (set1.has(item)) return true;
    }
    return false;
}
function removeConflictingTransitions(enabledTransitions, configuration, historyValue) {
    const filteredTransitions = new Set();
    for (const t1 of enabledTransitions){
        let t1Preempted = false;
        const transitionsToRemove = new Set();
        for (const t2 of filteredTransitions)if (hasIntersection(computeExitSet([
            t1
        ], configuration, historyValue), computeExitSet([
            t2
        ], configuration, historyValue))) {
            if (isDescendant(t1.source, t2.source)) transitionsToRemove.add(t2);
            else {
                t1Preempted = true;
                break;
            }
        }
        if (!t1Preempted) {
            for (const t3 of transitionsToRemove)filteredTransitions.delete(t3);
            filteredTransitions.add(t1);
        }
    }
    return Array.from(filteredTransitions);
}
function findLCCA(stateNodes) {
    const [head] = stateNodes;
    let current = getPathFromRootToNode(head);
    let candidates = [];
    for (const stateNode of stateNodes){
        const path = getPathFromRootToNode(stateNode);
        candidates = current.filter((sn)=>path.includes(sn));
        current = candidates;
        candidates = [];
    }
    return current[current.length - 1];
}
function getEffectiveTargetStates(transition, historyValue) {
    if (!transition.target) return [];
    const targets = new Set();
    for (const targetNode of transition.target)if (isHistoryNode(targetNode)) {
        if (historyValue[targetNode.id]) for (const node of historyValue[targetNode.id])targets.add(node);
        else for (const node of getEffectiveTargetStates({
            target: resolveHistoryTarget(targetNode)
        }, historyValue))targets.add(node);
    } else targets.add(targetNode);
    return [
        ...targets
    ];
}
function getTransitionDomain(transition, historyValue) {
    const targetStates = getEffectiveTargetStates(transition, historyValue);
    if (!targetStates) return null;
    if (!transition.reenter && transition.source.type !== "parallel" && targetStates.every((targetStateNode)=>isDescendant(targetStateNode, transition.source))) return transition.source;
    const lcca = findLCCA(targetStates.concat(transition.source));
    return lcca;
}
function computeExitSet(transitions, configuration, historyValue) {
    const statesToExit = new Set();
    for (const t of transitions)if (t.target?.length) {
        const domain = getTransitionDomain(t, historyValue);
        for (const stateNode of configuration)if (isDescendant(stateNode, domain)) statesToExit.add(stateNode);
    }
    return [
        ...statesToExit
    ];
}
/**
 * https://www.w3.org/TR/scxml/#microstepProcedure
 *
 * @private
 * @param transitions
 * @param currentState
 * @param mutConfiguration
 */ function microstep(transitions, currentState, actorCtx, event, isInitial) {
    const mutConfiguration = new Set(currentState.configuration);
    if (!transitions.length) return currentState;
    const microstate = microstepProcedure(transitions, currentState, mutConfiguration, event, actorCtx, isInitial);
    return cloneState(microstate, {
        value: {} // TODO: make optional
    });
}
function microstepProcedure(transitions, currentState, mutConfiguration, event, actorCtx, isInitial) {
    const actions = [];
    const historyValue = {
        ...currentState.historyValue
    };
    const filteredTransitions = removeConflictingTransitions(transitions, mutConfiguration, historyValue);
    const internalQueue = [
        ...currentState._internalQueue
    ];
    // Exit states
    if (!isInitial) exitStates(filteredTransitions, mutConfiguration, historyValue, actions);
    // Execute transition content
    actions.push(...filteredTransitions.flatMap((t)=>t.actions));
    // Enter states
    enterStates(event, filteredTransitions, mutConfiguration, actions, internalQueue, currentState, historyValue, isInitial, actorCtx);
    const nextConfiguration = [
        ...mutConfiguration
    ];
    const done = isInFinalState(nextConfiguration);
    if (done) {
        const finalActions = nextConfiguration.sort((a, b)=>b.order - a.order).flatMap((state)=>state.exit);
        actions.push(...finalActions);
    }
    try {
        const nextState = resolveActionsAndContext(actions, event, currentState, actorCtx);
        const output = done ? getOutput(nextConfiguration, nextState.context, event, actorCtx.self) : undefined;
        internalQueue.push(...nextState._internalQueue);
        return cloneState(currentState, {
            configuration: nextConfiguration,
            historyValue,
            _internalQueue: internalQueue,
            context: nextState.context,
            done,
            output,
            children: nextState.children
        });
    } catch (e) {
        // TODO: Refactor this once proper error handling is implemented.
        // See https://github.com/statelyai/rfcs/pull/4
        throw e;
    }
}
function enterStates(event, filteredTransitions, mutConfiguration, actions, internalQueue, currentState, historyValue, isInitial, actorContext) {
    const statesToEnter = new Set();
    const statesForDefaultEntry = new Set();
    computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);
    // In the initial state, the root state node is "entered".
    if (isInitial) statesForDefaultEntry.add(currentState.machine.root);
    for (const stateNodeToEnter of [
        ...statesToEnter
    ].sort((a, b)=>a.order - b.order)){
        mutConfiguration.add(stateNodeToEnter);
        for (const invokeDef of stateNodeToEnter.invoke)actions.push(invoke(invokeDef));
        // Add entry actions
        actions.push(...stateNodeToEnter.entry);
        if (statesForDefaultEntry.has(stateNodeToEnter)) for (const stateNode of statesForDefaultEntry){
            const initialActions = stateNode.initial.actions;
            actions.push(...initialActions);
        }
        if (stateNodeToEnter.type === "final") {
            const parent = stateNodeToEnter.parent;
            if (!parent.parent) continue;
            internalQueue.push(done(parent.id, stateNodeToEnter.output ? mapContext(stateNodeToEnter.output, currentState.context, event, actorContext.self) : undefined));
            if (parent.parent) {
                const grandparent = parent.parent;
                if (grandparent.type === "parallel") {
                    if (getChildren(grandparent).every((parentNode)=>isInFinalState([
                            ...mutConfiguration
                        ], parentNode))) internalQueue.push(done(grandparent.id));
                }
            }
        }
    }
}
function computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {
    for (const t of transitions){
        for (const s of t.target || [])addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
        const ancestor = getTransitionDomain(t, historyValue);
        const targetStates = getEffectiveTargetStates(t, historyValue);
        for (const s of targetStates)addAncestorStatesToEnter(s, ancestor, statesToEnter, historyValue, statesForDefaultEntry);
    }
}
function addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {
    if (isHistoryNode(stateNode)) {
        if (historyValue[stateNode.id]) {
            const historyStateNodes = historyValue[stateNode.id];
            for (const s of historyStateNodes)addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
            for (const s of historyStateNodes){
                addAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
                for (const stateForDefaultEntry of statesForDefaultEntry)statesForDefaultEntry.add(stateForDefaultEntry);
            }
        } else {
            const targets = resolveHistoryTarget(stateNode);
            for (const s of targets)addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
            for (const s of targets){
                addAncestorStatesToEnter(s, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
                for (const stateForDefaultEntry of statesForDefaultEntry)statesForDefaultEntry.add(stateForDefaultEntry);
            }
        }
    } else {
        statesToEnter.add(stateNode);
        if (stateNode.type === "compound") {
            statesForDefaultEntry.add(stateNode);
            const initialStates = stateNode.initial.target;
            for (const initialState of initialStates)addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);
            for (const initialState of initialStates)addAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
        } else if (stateNode.type === "parallel") {
            for (const child of getChildren(stateNode).filter((sn)=>!isHistoryNode(sn)))if (![
                ...statesToEnter
            ].some((s)=>isDescendant(s, child))) addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);
        }
    }
}
function addAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {
    const properAncestors = getProperAncestors(stateNode, toStateNode);
    for (const anc of properAncestors){
        statesToEnter.add(anc);
        if (anc.type === "parallel") {
            for (const child of getChildren(anc).filter((sn)=>!isHistoryNode(sn)))if (![
                ...statesToEnter
            ].some((s)=>isDescendant(s, child))) addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);
        }
    }
}
function exitStates(transitions, mutConfiguration, historyValue, actions) {
    const statesToExit = computeExitSet(transitions, mutConfiguration, historyValue);
    statesToExit.sort((a, b)=>b.order - a.order);
    // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates
    for (const exitStateNode of statesToExit)for (const historyNode of getHistoryNodes(exitStateNode)){
        let predicate;
        if (historyNode.history === "deep") predicate = (sn)=>isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);
        else predicate = (sn)=>{
            return sn.parent === exitStateNode;
        };
        historyValue[historyNode.id] = Array.from(mutConfiguration).filter(predicate);
    }
    for (const s of statesToExit){
        actions.push(...s.exit, ...s.invoke.map((def)=>stop(def.id)));
        mutConfiguration.delete(s);
    }
}
function resolveActionsAndContext(actions, event, currentState, actorCtx) {
    const { machine } = currentState;
    // TODO: this `cloneState` is really just a hack to prevent infinite loops
    // we need to take another look at how internal queue is managed
    let intermediateState = cloneState(currentState, {
        _internalQueue: []
    });
    for (const action of actions){
        const resolved = typeof action === "function" ? action : machine.implementations.actions[typeof action === "string" ? action : action.type];
        if (!resolved) continue;
        const args = {
            context: intermediateState.context,
            event,
            self: actorCtx?.self,
            system: actorCtx?.system,
            // TODO: figure out story for `action` and inline actions
            // what those ones should receive?
            //
            // entry: ({ action }) => {}
            // exit: assign(({ action }) => {})
            action: typeof action === "string" ? {
                type: action
            } : action
        };
        if (!("resolve" in resolved)) {
            if (actorCtx?.self.status === ActorStatus.Running) resolved(args);
            else actorCtx?.defer(()=>resolved(args));
            continue;
        }
        const builtinAction = resolved;
        const [nextState, params, actions] = builtinAction.resolve(actorCtx, intermediateState, args, resolved // this holds all params
        );
        intermediateState = nextState;
        if ("execute" in resolved) {
            if (actorCtx?.self.status === ActorStatus.Running) builtinAction.execute(actorCtx, params);
            else actorCtx?.defer(builtinAction.execute.bind(null, actorCtx, params));
        }
        if (actions) intermediateState = resolveActionsAndContext(actions, event, intermediateState, actorCtx);
    }
    return intermediateState;
}
function macrostep(state, event, actorCtx) {
    let nextState = state;
    const states = [];
    // Handle stop event
    if (event.type === stopSignalType) {
        nextState = stopStep(event, nextState, actorCtx);
        states.push(nextState);
        return {
            state: nextState,
            microstates: states
        };
    }
    let nextEvent = event;
    // Assume the state is at rest (no raised events)
    // Determine the next state based on the next microstep
    if (nextEvent.type !== INIT_TYPE) {
        const transitions = selectTransitions(nextEvent, nextState);
        nextState = microstep(transitions, state, actorCtx, nextEvent, false);
        states.push(nextState);
    }
    while(!nextState.done){
        let enabledTransitions = selectEventlessTransitions(nextState, nextEvent);
        if (!enabledTransitions.length) {
            if (!nextState._internalQueue.length) break;
            else {
                nextEvent = nextState._internalQueue[0];
                const transitions = selectTransitions(nextEvent, nextState);
                nextState = microstep(transitions, nextState, actorCtx, nextEvent, false);
                nextState._internalQueue.shift();
                states.push(nextState);
            }
        } else {
            nextState = microstep(enabledTransitions, nextState, actorCtx, nextEvent, false);
            states.push(nextState);
        }
    }
    if (nextState.done) // Perform the stop step to ensure that child actors are stopped
    stopStep(nextEvent, nextState, actorCtx);
    return {
        state: nextState,
        microstates: states
    };
}
function stopStep(event, nextState, actorCtx) {
    const actions = [];
    for (const stateNode of nextState.configuration.sort((a, b)=>b.order - a.order))actions.push(...stateNode.exit);
    for (const child of Object.values(nextState.children))actions.push(stop(child));
    return resolveActionsAndContext(actions, event, nextState, actorCtx);
}
function selectTransitions(event, nextState) {
    return nextState.machine.getTransitionData(nextState, event);
}
function selectEventlessTransitions(nextState, event) {
    const enabledTransitionSet = new Set();
    const atomicStates = nextState.configuration.filter(isAtomicStateNode);
    for (const stateNode of atomicStates)loop: for (const s of [
        stateNode
    ].concat(getProperAncestors(stateNode, null))){
        if (!s.always) continue;
        for (const transition of s.always)if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {
            enabledTransitionSet.add(transition);
            break loop;
        }
    }
    return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState.configuration), nextState.historyValue);
}
/**
 * Resolves a partial state value with its full representation in the state node's machine.
 *
 * @param stateValue The partial state value to resolve.
 */ function resolveStateValue(rootNode, stateValue) {
    const configuration = getConfiguration(getStateNodes(rootNode, stateValue));
    return getStateValue(rootNode, [
        ...configuration
    ]);
}
function getInitialConfiguration(rootNode) {
    const configuration = [];
    const initialTransition = rootNode.initial;
    const statesToEnter = new Set();
    const statesForDefaultEntry = new Set([
        rootNode
    ]);
    computeEntrySet([
        initialTransition
    ], {}, statesForDefaultEntry, statesToEnter);
    for (const stateNodeToEnter of [
        ...statesToEnter
    ].sort((a, b)=>a.order - b.order))configuration.push(stateNodeToEnter);
    return configuration;
}
class State {
    /**
   * Indicates whether the state is a final state.
   */ /**
   * The done data of the top-level finite state.
   */ // TODO: add an explicit type for `output`
    /**
   * The enabled state nodes representative of the state value.
   */ /**
   * An object mapping actor names to spawned/invoked actors.
   */ /**
   * Creates a new State instance for the given `stateValue` and `context`.
   * @param stateValue
   * @param context
   */ static from(stateValue, context = {}, machine) {
        if (stateValue instanceof State) {
            if (stateValue.context !== context) return new State({
                value: stateValue.value,
                context,
                meta: {},
                configuration: [],
                // TODO: fix,
                children: {}
            }, machine);
            return stateValue;
        }
        const configuration = getConfiguration(getStateNodes(machine.root, stateValue));
        return new State({
            value: stateValue,
            context,
            meta: undefined,
            configuration: Array.from(configuration),
            children: {}
        }, machine);
    }
    /**
   * Creates a new `State` instance that represents the current state of a running machine.
   *
   * @param config
   */ constructor(config, machine){
        this.machine = machine;
        this.tags = void 0;
        this.value = void 0;
        this.done = void 0;
        this.output = void 0;
        this.error = void 0;
        this.context = void 0;
        this.historyValue = {};
        this._internalQueue = void 0;
        this.configuration = void 0;
        this.children = void 0;
        this.context = config.context;
        this._internalQueue = config._internalQueue ?? [];
        this.historyValue = config.historyValue || {};
        this.matches = this.matches.bind(this);
        this.toStrings = this.toStrings.bind(this);
        this.configuration = config.configuration ?? Array.from(getConfiguration(getStateNodes(machine.root, config.value)));
        this.children = config.children;
        this.value = getStateValue(machine.root, this.configuration);
        this.tags = new Set(flatten(this.configuration.map((sn)=>sn.tags)));
        this.done = config.done ?? false;
        this.output = config.output;
        this.error = config.error;
    }
    /**
   * Returns an array of all the string leaf state node paths.
   * @param stateValue
   * @param delimiter The character(s) that separate each subpath in the string state node path.
   */ toStrings(stateValue = this.value) {
        if (typeof stateValue === "string") return [
            stateValue
        ];
        const valueKeys = Object.keys(stateValue);
        return valueKeys.concat(...valueKeys.map((key)=>this.toStrings(stateValue[key]).map((s)=>key + STATE_DELIMITER + s)));
    }
    toJSON() {
        const { configuration, tags, machine, ...jsonValues } = this;
        return {
            ...jsonValues,
            tags: Array.from(tags),
            meta: this.meta
        };
    }
    /**
   * Whether the current state value is a subset of the given parent state value.
   * @param parentStateValue
   */ matches(parentStateValue) {
        return matchesState(parentStateValue, this.value);
    }
    /**
   * Whether the current state configuration has a state node with the specified `tag`.
   * @param tag
   */ hasTag(tag) {
        return this.tags.has(tag);
    }
    /**
   * Determines whether sending the `event` will cause a non-forbidden transition
   * to be selected, even if the transitions have no actions nor
   * change the state value.
   *
   * @param event The event to test
   * @returns Whether the event will cause a transition
   */ can(event) {
        const transitionData = this.machine.getTransitionData(this, event);
        return !!transitionData?.length && // Check that at least one transition is not forbidden
        transitionData.some((t)=>t.target !== undefined || t.actions.length);
    }
    /**
   * The next events that will cause a transition from the current state.
   */ get nextEvents() {
        return memo(this, "nextEvents", ()=>{
            return [
                ...new Set(flatten([
                    ...this.configuration.map((sn)=>sn.ownEvents)
                ]))
            ];
        });
    }
    get meta() {
        return this.configuration.reduce((acc, stateNode)=>{
            if (stateNode.meta !== undefined) acc[stateNode.id] = stateNode.meta;
            return acc;
        }, {});
    }
}
function cloneState(state, config = {}) {
    return new State({
        ...state,
        ...config
    }, state.machine);
}
function getPersistedState(state) {
    const { configuration, tags, machine, children, ...jsonValues } = state;
    const childrenJson = {};
    for(const id in children)childrenJson[id] = {
        state: children[id].getPersistedState?.(),
        src: children[id].src
    };
    return {
        ...jsonValues,
        children: childrenJson
    };
}
function resolve$5(_, state, args, { actorRef }) {
    const actorRefOrString = typeof actorRef === "function" ? actorRef(args) : actorRef;
    const resolvedActorRef = typeof actorRefOrString === "string" ? state.children[actorRefOrString] : actorRefOrString;
    let children = state.children;
    if (resolvedActorRef) {
        children = {
            ...children
        };
        delete children[resolvedActorRef.id];
    }
    return [
        cloneState(state, {
            children
        }),
        resolvedActorRef
    ];
}
function execute$2(actorContext, actorRef) {
    if (!actorRef) return;
    if (actorRef.status !== ActorStatus.Running) {
        actorContext.stopChild(actorRef);
        return;
    }
    // TODO: recheck why this one has to be deferred
    actorContext.defer(()=>{
        actorContext.stopChild(actorRef);
    });
}
/**
 * Stops an actor.
 *
 * @param actorRef The actor to stop.
 */ function stop(actorRef) {
    function stop(_) {}
    stop.type = "xstate.stop";
    stop.actorRef = actorRef;
    stop.resolve = resolve$5;
    stop.execute = execute$2;
    return stop;
}
function resolve$4(_, state, actionArgs, { value, label }) {
    return [
        state,
        {
            value: typeof value === "function" ? value(actionArgs) : value,
            label
        }
    ];
}
function execute$1({ logger }, { value, label }) {
    if (label) logger(label, value);
    else logger(value);
}
/**
 *
 * @param expr The expression function to evaluate which will be logged.
 *  Takes in 2 arguments:
 *  - `ctx` - the current state context
 *  - `event` - the event that caused this action to be executed.
 * @param label The label to give to the logged expression.
 */ function log(value = ({ context, event })=>({
        context,
        event
    }), label) {
    function log(_) {}
    log.type = "xstate.log";
    log.value = value;
    log.label = label;
    log.resolve = resolve$4;
    log.execute = execute$1;
    return log;
}
function createSpawner(actorContext, { machine, context }, event, spawnedChildren) {
    const spawn = (src, options = {})=>{
        const { systemId } = options;
        if (typeof src === "string") {
            const referenced = resolveReferencedActor(machine.implementations.actors[src]);
            if (!referenced) throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);
            const input = "input" in options ? options.input : referenced.input;
            // TODO: this should also receive `src`
            const actor = interpret(referenced.src, {
                id: options.id,
                parent: actorContext.self,
                input: typeof input === "function" ? input({
                    context,
                    event,
                    self: actorContext.self
                }) : input,
                systemId
            });
            spawnedChildren[actor.id] = actor;
            return actor;
        } else // TODO: this should also receive `src`
        return interpret(src, {
            id: options.id,
            parent: actorContext.self,
            input: options.input,
            systemId
        });
    };
    return (src, options)=>{
        const actorRef = spawn(src, options); // TODO: fix types
        spawnedChildren[actorRef.id] = actorRef;
        actorContext.defer(()=>{
            if (actorRef.status === ActorStatus.Stopped) return;
            try {
                actorRef.start?.();
            } catch (err) {
                actorContext.self.send(error(actorRef.id, err));
                return;
            }
        });
        return actorRef;
    };
}
function resolve$3(actorContext, state, actionArgs, { assignment }) {
    if (!state.context) throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
    const spawnedChildren = {};
    const assignArgs = {
        context: state.context,
        event: actionArgs.event,
        action: actionArgs.action,
        spawn: createSpawner(actorContext, state, actionArgs.event, spawnedChildren),
        self: actorContext?.self,
        system: actorContext?.system
    };
    let partialUpdate = {};
    if (typeof assignment === "function") partialUpdate = assignment(assignArgs);
    else for (const key of Object.keys(assignment)){
        const propAssignment = assignment[key];
        partialUpdate[key] = typeof propAssignment === "function" ? propAssignment(assignArgs) : propAssignment;
    }
    const updatedContext = Object.assign({}, state.context, partialUpdate);
    return [
        cloneState(state, {
            context: updatedContext,
            children: Object.keys(spawnedChildren).length ? {
                ...state.children,
                ...spawnedChildren
            } : state.children
        })
    ];
}
/**
 * Updates the current context of the machine.
 *
 * @param assignment An object that represents the partial context to update.
 */ function assign(assignment) {
    function assign(_) {}
    assign.type = "xstate.assign";
    assign.assignment = assignment;
    assign.resolve = resolve$3;
    return assign;
}
function resolve$2(_, state, args, { event: eventOrExpr, id, delay }) {
    const delaysMap = state.machine.implementations.delays;
    if (typeof eventOrExpr === "string") throw new Error(`Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`);
    const resolvedEvent = typeof eventOrExpr === "function" ? eventOrExpr(args) : eventOrExpr;
    let resolvedDelay;
    if (typeof delay === "string") {
        const configDelay = delaysMap && delaysMap[delay];
        resolvedDelay = typeof configDelay === "function" ? configDelay(args) : configDelay;
    } else resolvedDelay = typeof delay === "function" ? delay(args) : delay;
    return [
        typeof resolvedDelay !== "number" ? cloneState(state, {
            _internalQueue: state._internalQueue.concat(resolvedEvent)
        }) : state,
        {
            event: resolvedEvent,
            id,
            delay: resolvedDelay
        }
    ];
}
function execute(actorContext, params) {
    if (typeof params.delay === "number") {
        actorContext.self.delaySend(params);
        return;
    }
}
/**
 * Raises an event. This places the event in the internal event queue, so that
 * the event is immediately consumed by the machine in the current step.
 *
 * @param eventType The event to raise.
 */ function raise(eventOrExpr, options) {
    function raise(_) {}
    raise.type = "xstate.raise";
    raise.event = eventOrExpr;
    raise.id = options?.id;
    raise.delay = options?.delay;
    raise.resolve = resolve$2;
    raise.execute = execute;
    return raise;
}
function resolve$1(_, state, actionArgs, { branches }) {
    const matchedActions = branches.find((condition)=>{
        const guard = condition.guard && toGuardDefinition(condition.guard, (guardType)=>state.machine.implementations.guards[guardType]);
        return !guard || evaluateGuard(guard, state.context, actionArgs.event, state);
    })?.actions;
    return [
        state,
        undefined,
        toArray(matchedActions)
    ];
}
function choose(branches) {
    function choose(_) {}
    choose.type = "xstate.choose";
    choose.branches = branches;
    choose.resolve = resolve$1;
    return choose;
}
function resolve(_, state, args, { get }) {
    return [
        state,
        undefined,
        toArray(get({
            context: state.context,
            event: args.event
        }))
    ];
}
function pure(getActions) {
    function pure(_) {}
    pure.type = "xstate.pure";
    pure.get = getActions;
    pure.resolve = resolve;
    return pure;
}
/**
 * Returns an event type that represents an implicit event that
 * is sent after the specified `delay`.
 *
 * @param delayRef The delay in milliseconds
 * @param id The state node ID where this event is handled
 */ function after(delayRef, id) {
    const idSuffix = id ? `#${id}` : "";
    return `${ConstantPrefix.After}(${delayRef})${idSuffix}`;
}
/**
 * Returns an event that represents that a final state node
 * has been reached in the parent state node.
 *
 * @param id The final state node's parent state node `id`
 * @param output The data to pass into the event
 */ function done(id, output) {
    const type = `${ConstantPrefix.DoneState}.${id}`;
    const eventObject = {
        type,
        output
    };
    eventObject.toString = ()=>type;
    return eventObject;
}
/**
 * Returns an event that represents that an invoked service has terminated.
 *
 * An invoked service is terminated when it has reached a top-level final state node,
 * but not when it is canceled.
 *
 * @param invokeId The invoked service ID
 * @param output The data to pass into the event
 */ function doneInvoke(invokeId, output) {
    const type = `${ConstantPrefix.DoneInvoke}.${invokeId}`;
    const eventObject = {
        type,
        output
    };
    eventObject.toString = ()=>type;
    return eventObject;
}
function error(id, data) {
    const type = `${ConstantPrefix.ErrorPlatform}.${id}`;
    const eventObject = {
        type,
        data
    };
    eventObject.toString = ()=>type;
    return eventObject;
}
function createInitEvent(input) {
    return {
        type: INIT_TYPE,
        input
    };
}

},{"../dev/dist/xstate-dev.esm.js":"9qtaf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9qtaf":[function(require,module,exports) {
// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "devToolsAdapter", ()=>devToolsAdapter);
parcelHelpers.export(exports, "getGlobal", ()=>getGlobal);
parcelHelpers.export(exports, "registerService", ()=>registerService);
var global = arguments[3];
function getGlobal() {
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
}
function getDevTools() {
    const w = getGlobal();
    if (!!w.__xstate__) return w.__xstate__;
    return undefined;
}
function registerService(service) {
    if (typeof window === "undefined") return;
    const devTools = getDevTools();
    if (devTools) devTools.register(service);
}
const devToolsAdapter = (service)=>{
    if (typeof window === "undefined") return;
    const devTools = getDevTools();
    if (devTools) devTools.register(service);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"brbXg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ttsMachine = void 0;
const xstate_1 = require("9dae4590ef35cc18");
const getToken_1 = require("e908e9bfab0970a");
const TextToSpeech_1 = require("1abb92ca7d0aa35d");
const REGION = "northeurope";
exports.ttsMachine = (0, xstate_1.createMachine)({
    id: "tts",
    types: {
        context: {},
        events: {}
    },
    context: ({ input })=>({
            ttsDefaultVoice: input.ttsDefaultVoice || "en-US-DavisNeural",
            audioContext: input.audioContext,
            azureCredentials: input.azureCredentials
        }),
    initial: "GetToken",
    on: {
        READY: {
            target: ".Ready",
            actions: [
                (0, xstate_1.assign)({
                    wsaTTS: ({ event })=>event.value.wsaTTS,
                    wsaUtt: ({ event })=>event.value.wsaUtt
                }),
                (0, xstate_1.sendParent)({
                    type: "TTS_READY"
                })
            ]
        },
        ERROR: {
            actions: (0, xstate_1.sendParent)({
                type: "TTS_ERROR"
            })
        }
    },
    states: {
        Ready: {
            on: {
                SPEAK: {
                    target: "Speaking",
                    actions: (0, xstate_1.assign)({
                        agenda: ({ event })=>event.value
                    })
                }
            }
        },
        Fail: {},
        GetToken: {
            invoke: {
                id: "getAuthorizationToken",
                input: ({ context })=>({
                        credentials: context.azureCredentials
                    }),
                src: "getToken",
                onDone: {
                    target: "Ponyfill",
                    actions: [
                        (0, xstate_1.assign)(({ event })=>{
                            return {
                                azureAuthorizationToken: event.output
                            };
                        })
                    ]
                },
                onError: {
                    actions: ({ event })=>console.error("[TTS] getToken error", event),
                    target: "Fail"
                }
            }
        },
        Ponyfill: {
            invoke: {
                id: "ponyTTS",
                src: "ponyfill",
                input: ({ context })=>({
                        audioContext: context.audioContext,
                        azureAuthorizationToken: context.azureAuthorizationToken
                    })
            }
        },
        Speaking: {
            initial: "Go",
            on: {
                STOP: {
                    target: "Ready"
                },
                TTS_STARTED: {
                    actions: (0, xstate_1.sendParent)({
                        type: "TTS_STARTED"
                    })
                },
                SPEAK_COMPLETE: {
                    target: "Ready"
                }
            },
            exit: (0, xstate_1.sendParent)({
                type: "SPEAK_COMPLETE"
            }),
            states: {
                Go: {
                    invoke: {
                        src: "start",
                        input: ({ context })=>({
                                wsaTTS: context.wsaTTS,
                                wsaUtt: context.wsaUtt,
                                ttsLexicon: context.ttsLexicon,
                                voice: context.agenda.voice || context.ttsDefaultVoice,
                                streamURL: context.agenda.streamURL,
                                utterance: context.agenda.utterance
                            })
                    },
                    on: {
                        CONTROL: "Paused"
                    },
                    exit: "ttsStop"
                },
                Paused: {
                    on: {
                        CONTROL: "Go"
                    }
                }
            }
        }
    }
}, {
    actions: {
        ttsStop: ({ context })=>{
            context.wsaTTS.cancel();
        }
    },
    actors: {
        getToken: getToken_1.getToken,
        ponyfill: (0, xstate_1.fromCallback)(({ sendBack, input })=>{
            const ponyfill = (0, TextToSpeech_1.default)({
                audioContext: input.audioContext,
                credentials: {
                    region: REGION,
                    authorizationToken: input.azureAuthorizationToken
                }
            });
            const { speechSynthesis, SpeechSynthesisUtterance } = ponyfill;
            const tts = speechSynthesis;
            const ttsUtterance = SpeechSynthesisUtterance;
            tts.addEventListener("voiceschanged", ()=>{
                const voices = tts.getVoices();
                if (voices.length > 0) {
                    console.debug("[TTS] READY");
                    sendBack({
                        type: "READY",
                        value: {
                            wsaTTS: tts,
                            wsaUtt: ttsUtterance
                        }
                    });
                } else {
                    console.error("[TTS] No voices available");
                    sendBack({
                        type: "ERROR"
                    });
                }
            });
        }),
        start: (0, xstate_1.fromCallback)(({ sendBack, input })=>{
            if ([
                "",
                " "
            ].includes(input.utterance)) {
                console.debug("[TTS] SPEAK: ", input.utterance);
                input.wsaTTS.speak("");
            } else {
                console.debug("[TTS] SPEAK: ", input.utterance);
                const content = wrapSSML(input.utterance, input.voice, input.ttsLexicon, 1); // todo speech rate;
                const utterance = new input.wsaUtt(content);
                utterance.addEventListener("start", ()=>{
                    sendBack({
                        type: "TTS_STARTED"
                    });
                    console.debug("[TTS] TTS_STARTED");
                });
                utterance.addEventListener("end", ()=>{
                    sendBack({
                        type: "SPEAK_COMPLETE"
                    });
                    console.debug("[TTS] SPEAK_COMPLETE");
                });
                input.wsaTTS.speak(utterance);
            }
        })
    }
});
const wrapSSML = (text, voice, lexicon, speechRate)=>{
    let content = `<speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" xmlns:mstts="http://www.w3.org/2001/mstts" xml:lang="en-US"><voice name="${voice}">`;
    if (lexicon) content = content + `<lexicon uri="${lexicon}"/>`;
    content = content + `<prosody rate="${speechRate}">` + `${text}</prosody></voice></speak>`;
    return content;
};

},{"9dae4590ef35cc18":"aP1sj","e908e9bfab0970a":"a233R","1abb92ca7d0aa35d":"bA1jh"}],"a233R":[function(require,module,exports) {
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getToken = void 0;
const xstate_1 = require("b971535f44f8cfff");
exports.getToken = (0, xstate_1.fromPromise)(({ input })=>__awaiter(void 0, void 0, void 0, function*() {
        if (typeof input.credentials === "string") return fetch(new Request(input.credentials)).then((data)=>data.text());
        else return fetch(new Request(input.credentials.endpoint, {
            method: "POST",
            headers: {
                "Ocp-Apim-Subscription-Key": input.credentials.key
            }
        })).then((data)=>data.text());
    }));

},{"b971535f44f8cfff":"aP1sj"}],"bA1jh":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("9a877400b653432c");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _createSpeechSynthesisPonyfill = _interopRequireDefault(require("5beb3e20b0be5282"));
var _default = _createSpeechSynthesisPonyfill.default;
exports.default = _default;

},{"9a877400b653432c":"1hUHf","5beb3e20b0be5282":"aZKdA"}],"1hUHf":[function(require,module,exports) {
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"aZKdA":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("5aed1780095e02b3");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("e9857a489c776a32"));
var _asyncToGenerator2 = _interopRequireDefault(require("52feed95a60634c2"));
var _classCallCheck2 = _interopRequireDefault(require("586d72f54018c277"));
var _createClass2 = _interopRequireDefault(require("3e3719caf5454b5b"));
var _inherits2 = _interopRequireDefault(require("a23fe2074a3e9db"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("75844a50802e8838"));
var _getPrototypeOf2 = _interopRequireDefault(require("ea0f6cf16eb20f2c"));
var _es = require("adccd22dd8f0f108");
var _pDeferEs = _interopRequireDefault(require("eacbfcbffe034dda"));
var _onErrorResumeNext = _interopRequireDefault(require("ff34c73e54f5bc5c"));
var _AudioContextQueue = _interopRequireDefault(require("ed1b50bbeba1f0f9"));
var _fetchCustomVoices = _interopRequireDefault(require("b10cc52db8609d02"));
var _fetchVoices = _interopRequireDefault(require("39885ce192e71675"));
var _patchOptions2 = _interopRequireDefault(require("d87f7070ec21b67e"));
var _SpeechSynthesisEvent = _interopRequireDefault(require("196d1478ad27d3b4"));
var _SpeechSynthesisUtterance = _interopRequireDefault(require("e4a0ecaeee11858a"));
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return (0, _possibleConstructorReturn2.default)(this, result);
    };
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
// Supported output format can be found at https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/rest-text-to-speech#audio-outputs
var DEFAULT_OUTPUT_FORMAT = "audio-24khz-160kbitrate-mono-mp3";
var EMPTY_ARRAY = [];
var _default = function _default(options) {
    var _patchOptions = (0, _patchOptions2.default)(options), audioContext = _patchOptions.audioContext, fetchCredentials = _patchOptions.fetchCredentials, _patchOptions$ponyfil = _patchOptions.ponyfill, ponyfill = _patchOptions$ponyfil === void 0 ? {
        AudioContext: window.AudioContext || window.webkitAudioContext
    } : _patchOptions$ponyfil, speechSynthesisDeploymentId = _patchOptions.speechSynthesisDeploymentId, _patchOptions$speechS = _patchOptions.speechSynthesisOutputFormat, speechSynthesisOutputFormat = _patchOptions$speechS === void 0 ? DEFAULT_OUTPUT_FORMAT : _patchOptions$speechS;
    if (!audioContext && !ponyfill.AudioContext) {
        console.warn("web-speech-cognitive-services: This browser does not support Web Audio and it will not work with Cognitive Services Speech Services.");
        return {};
    }
    var SpeechSynthesis = /*#__PURE__*/ function(_EventTarget) {
        (0, _inherits2.default)(SpeechSynthesis, _EventTarget);
        var _super = _createSuper(SpeechSynthesis);
        function SpeechSynthesis() {
            var _this;
            (0, _classCallCheck2.default)(this, SpeechSynthesis);
            _this = _super.call(this);
            _this.queue = new _AudioContextQueue.default({
                audioContext: audioContext,
                ponyfill: ponyfill
            });
            _this.updateVoices();
            return _this;
        }
        (0, _createClass2.default)(SpeechSynthesis, [
            {
                key: "cancel",
                value: function cancel() {
                    this.queue.stop();
                }
            },
            {
                key: "getVoices",
                value: function getVoices() {
                    return EMPTY_ARRAY;
                }
            },
            {
                key: "onvoiceschanged",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "voiceschanged");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "voiceschanged", value);
                }
            },
            {
                key: "pause",
                value: function pause() {
                    this.queue.pause();
                }
            },
            {
                key: "resume",
                value: function resume() {
                    this.queue.resume();
                }
            },
            {
                key: "speak",
                value: function speak(utterance) {
                    if (!(utterance instanceof _SpeechSynthesisUtterance.default)) throw new Error("invalid utterance");
                    var _createDeferred = (0, _pDeferEs.default)(), reject = _createDeferred.reject, resolve = _createDeferred.resolve, promise = _createDeferred.promise;
                    var handleError = function handleError(_ref) {
                        var errorCode = _ref.error, message = _ref.message;
                        var error = new Error(errorCode);
                        error.stack = message;
                        reject(error);
                    };
                    utterance.addEventListener("end", resolve);
                    utterance.addEventListener("error", handleError);
                    utterance.preload({
                        deploymentId: speechSynthesisDeploymentId,
                        fetchCredentials: fetchCredentials,
                        outputFormat: speechSynthesisOutputFormat
                    });
                    this.queue.push(utterance);
                    return promise.finally(function() {
                        utterance.removeEventListener("end", resolve);
                        utterance.removeEventListener("error", handleError);
                    });
                }
            },
            {
                key: "speaking",
                get: function get() {
                    return this.queue.speaking;
                }
            },
            {
                key: "updateVoices",
                value: function() {
                    var _updateVoices = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee3() {
                        var _this2 = this;
                        var _yield$fetchCredentia, customVoiceHostname, region, speechSynthesisHostname, subscriptionKey;
                        return _regenerator.default.wrap(function _callee3$(_context3) {
                            while(true)switch(_context3.prev = _context3.next){
                                case 0:
                                    _context3.next = 2;
                                    return fetchCredentials();
                                case 2:
                                    _yield$fetchCredentia = _context3.sent;
                                    customVoiceHostname = _yield$fetchCredentia.customVoiceHostname;
                                    region = _yield$fetchCredentia.region;
                                    speechSynthesisHostname = _yield$fetchCredentia.speechSynthesisHostname;
                                    subscriptionKey = _yield$fetchCredentia.subscriptionKey;
                                    if (!speechSynthesisDeploymentId) {
                                        _context3.next = 14;
                                        break;
                                    }
                                    if (!subscriptionKey) {
                                        _context3.next = 12;
                                        break;
                                    }
                                    console.warn("web-speech-cognitive-services: Listing of custom voice models are only available when using subscription key.");
                                    _context3.next = 12;
                                    return (0, _onErrorResumeNext.default)(/*#__PURE__*/ (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee() {
                                        var voices;
                                        return _regenerator.default.wrap(function _callee$(_context) {
                                            while(true)switch(_context.prev = _context.next){
                                                case 0:
                                                    _context.next = 2;
                                                    return (0, _fetchCustomVoices.default)({
                                                        customVoiceHostname: customVoiceHostname,
                                                        deploymentId: speechSynthesisDeploymentId,
                                                        region: region,
                                                        speechSynthesisHostname: speechSynthesisHostname,
                                                        subscriptionKey: subscriptionKey
                                                    });
                                                case 2:
                                                    voices = _context.sent;
                                                    _this2.getVoices = function() {
                                                        return voices;
                                                    };
                                                case 4:
                                                case "end":
                                                    return _context.stop();
                                            }
                                        }, _callee);
                                    })));
                                case 12:
                                    _context3.next = 16;
                                    break;
                                case 14:
                                    _context3.next = 16;
                                    return (0, _onErrorResumeNext.default)(/*#__PURE__*/ (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee2() {
                                        var voices;
                                        return _regenerator.default.wrap(function _callee2$(_context2) {
                                            while(true)switch(_context2.prev = _context2.next){
                                                case 0:
                                                    _context2.t0 = _fetchVoices.default;
                                                    _context2.next = 3;
                                                    return fetchCredentials();
                                                case 3:
                                                    _context2.t1 = _context2.sent;
                                                    _context2.next = 6;
                                                    return (0, _context2.t0)(_context2.t1);
                                                case 6:
                                                    voices = _context2.sent;
                                                    _this2.getVoices = function() {
                                                        return voices;
                                                    };
                                                case 8:
                                                case "end":
                                                    return _context2.stop();
                                            }
                                        }, _callee2);
                                    })));
                                case 16:
                                    this.dispatchEvent(new _SpeechSynthesisEvent.default("voiceschanged"));
                                case 17:
                                case "end":
                                    return _context3.stop();
                            }
                        }, _callee3, this);
                    }));
                    function updateVoices() {
                        return _updateVoices.apply(this, arguments);
                    }
                    return updateVoices;
                }()
            }
        ]);
        return SpeechSynthesis;
    }(_es.EventTarget);
    return {
        speechSynthesis: new SpeechSynthesis(),
        SpeechSynthesisEvent: _SpeechSynthesisEvent.default,
        SpeechSynthesisUtterance: _SpeechSynthesisUtterance.default
    };
};
exports.default = _default;

},{"5aed1780095e02b3":"1hUHf","e9857a489c776a32":"iN2WL","52feed95a60634c2":"jaYFv","586d72f54018c277":"7zlNi","3e3719caf5454b5b":"b694u","a23fe2074a3e9db":"bQ802","75844a50802e8838":"kJc1U","ea0f6cf16eb20f2c":"g7YIw","adccd22dd8f0f108":"iVIs8","eacbfcbffe034dda":"dhDU2","ff34c73e54f5bc5c":"cNudy","ed1b50bbeba1f0f9":"jQGXv","b10cc52db8609d02":"7EDr3","39885ce192e71675":"76WXp","d87f7070ec21b67e":"kIQZq","196d1478ad27d3b4":"4fVgH","e4a0ecaeee11858a":"l3D6T"}],"iN2WL":[function(require,module,exports) {
// TODO(Babel 8): Remove this file.
var runtime = require("77a8e8cbd3cce19b")();
module.exports = runtime;
// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
    regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
    if (typeof globalThis === "object") globalThis.regeneratorRuntime = runtime;
    else Function("r", "regeneratorRuntime = r")(runtime);
}

},{"77a8e8cbd3cce19b":"4o7bL"}],"4o7bL":[function(require,module,exports) {
var _typeof = require("702235e1300f6655")["default"];
function _regeneratorRuntime() {
    "use strict";
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }), obj[key];
    }
    try {
        define({}, "");
    } catch (err) {
        define = function define(obj, key, value) {
            return obj[key] = value;
        };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return generator._invoke = function(innerFn, self, context) {
            var state = "suspendedStart";
            return function(method, arg) {
                if ("executing" === state) throw new Error("Generator is already running");
                if ("completed" === state) {
                    if ("throw" === method) throw arg;
                    return doneResult();
                }
                for(context.method = method, context.arg = arg;;){
                    var delegate = context.delegate;
                    if (delegate) {
                        var delegateResult = maybeInvokeDelegate(delegate, context);
                        if (delegateResult) {
                            if (delegateResult === ContinueSentinel) continue;
                            return delegateResult;
                        }
                    }
                    if ("next" === context.method) context.sent = context._sent = context.arg;
                    else if ("throw" === context.method) {
                        if ("suspendedStart" === state) throw state = "completed", context.arg;
                        context.dispatchException(context.arg);
                    } else "return" === context.method && context.abrupt("return", context.arg);
                    state = "executing";
                    var record = tryCatch(innerFn, self, context);
                    if ("normal" === record.type) {
                        if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                        return {
                            value: record.arg,
                            done: context.done
                        };
                    }
                    "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
                }
            };
        }(innerFn, self, context), generator;
    }
    function tryCatch(fn, obj, arg) {
        try {
            return {
                type: "normal",
                arg: fn.call(obj, arg)
            };
        } catch (err) {
            return {
                type: "throw",
                arg: err
            };
        }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
        return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
        [
            "next",
            "throw",
            "return"
        ].forEach(function(method) {
            define(prototype, method, function(arg) {
                return this._invoke(method, arg);
            });
        });
    }
    function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if ("throw" !== record.type) {
                var result = record.arg, value = result.value;
                return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value) {
                    invoke("next", value, resolve, reject);
                }, function(err) {
                    invoke("throw", err, resolve, reject);
                }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                    result.value = unwrapped, resolve(result);
                }, function(error) {
                    return invoke("throw", error, resolve, reject);
                });
            }
            reject(record.arg);
        }
        var previousPromise;
        this._invoke = function(method, arg) {
            function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                    invoke(method, arg, resolve, reject);
                });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
    }
    function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (undefined === method) {
            if (context.delegate = null, "throw" === context.method) {
                if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
                context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
        var entry = {
            tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
        this.tryEntries = [
            {
                tryLoc: "root"
            }
        ], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
        if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next) return iterable;
            if (!isNaN(iterable.length)) {
                var i = -1, next = function next() {
                    for(; ++i < iterable.length;){
                        if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                    }
                    return next.value = undefined, next.done = !0, next;
                };
                return next.next = next;
            }
        }
        return {
            next: doneResult
        };
    }
    function doneResult() {
        return {
            value: undefined,
            done: !0
        };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
        return {
            __await: arg
        };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
        });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
    }), define(Gp, "toString", function() {
        return "[object Generator]";
    }), exports.keys = function(object) {
        var keys = [];
        for(var key in object)keys.push(key);
        return keys.reverse(), function next() {
            for(; keys.length;){
                var key = keys.pop();
                if (key in object) return next.value = key, next.done = !1, next;
            }
            return next.done = !0, next;
        };
    }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for(var name in this)"t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
        },
        stop: function stop() {
            this.done = !0;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type) throw rootRecord.arg;
            return this.rval;
        },
        dispatchException: function dispatchException(exception) {
            if (this.done) throw exception;
            var context = this;
            function handle(loc, caught) {
                return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
            }
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i], record = entry.completion;
                if ("root" === entry.tryLoc) return handle("end");
                if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
                    if (hasCatch && hasFinally) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    } else if (hasCatch) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                    } else {
                        if (!hasFinally) throw new Error("try statement without catch or finally");
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    }
                }
            }
        },
        abrupt: function abrupt(type, arg) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                    var finallyEntry = entry;
                    break;
                }
            }
            finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
            if ("throw" === record.type) throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
        },
        "catch": function _catch(tryLoc) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if ("throw" === record.type) {
                        var thrown = record.arg;
                        resetTryEntry(entry);
                    }
                    return thrown;
                }
            }
            throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
            }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
    }, exports;
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"702235e1300f6655":"64MFb"}],"64MFb":[function(require,module,exports) {
function _typeof(obj) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"jaYFv":[function(require,module,exports) {
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"7zlNi":[function(require,module,exports) {
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"b694u":[function(require,module,exports) {
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"bQ802":[function(require,module,exports) {
var setPrototypeOf = require("5ed6dfdace2d83d2");
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"5ed6dfdace2d83d2":"hwPzH"}],"hwPzH":[function(require,module,exports) {
function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"kJc1U":[function(require,module,exports) {
var _typeof = require("71b78395fe0ee6fb")["default"];
var assertThisInitialized = require("9d69959199ea4856");
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"71b78395fe0ee6fb":"64MFb","9d69959199ea4856":"chPlo"}],"chPlo":[function(require,module,exports) {
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"g7YIw":[function(require,module,exports) {
function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"iVIs8":[function(require,module,exports) {
var process = require("eb79af20fcd06e32");
var global = arguments[3];
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _toConsumableArray = require("26b2219201cd07ee");
var _set = require("56d39df50603c838");
var _get = require("bd1e95fd7001e0a");
var _assertThisInitialized = require("a1063d2920c16f36");
var _inherits = require("cc70ed9f6c749fe7");
var _possibleConstructorReturn = require("86f81d2e5203b87a");
var _getPrototypeOf = require("120e9f99079e0a71");
var _wrapNativeSuper = require("e1a68cab5f60d1e7");
var _defineProperty = require("e3f247ff05fc85eb");
var _classCallCheck = require("2efdec3106c7e93f");
var _createClass = require("4d3cad845e560498");
var _typeof = require("e85f43ec4ed870e9");
function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {
        "default": e
    };
}
var _toConsumableArray__default = /*#__PURE__*/ _interopDefaultLegacy(_toConsumableArray);
var _set__default = /*#__PURE__*/ _interopDefaultLegacy(_set);
var _get__default = /*#__PURE__*/ _interopDefaultLegacy(_get);
var _assertThisInitialized__default = /*#__PURE__*/ _interopDefaultLegacy(_assertThisInitialized);
var _inherits__default = /*#__PURE__*/ _interopDefaultLegacy(_inherits);
var _possibleConstructorReturn__default = /*#__PURE__*/ _interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/ _interopDefaultLegacy(_getPrototypeOf);
var _wrapNativeSuper__default = /*#__PURE__*/ _interopDefaultLegacy(_wrapNativeSuper);
var _defineProperty__default = /*#__PURE__*/ _interopDefaultLegacy(_defineProperty);
var _classCallCheck__default = /*#__PURE__*/ _interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/ _interopDefaultLegacy(_createClass);
var _typeof__default = /*#__PURE__*/ _interopDefaultLegacy(_typeof);
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf__default["default"](Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf__default["default"](this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn__default["default"](this, result);
    };
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty__default["default"](target, key, source[key]);
        });
        else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        else ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
/**
 * Assert a condition.
 * @param condition The condition that it should satisfy.
 * @param message The error message.
 * @param args The arguments for replacing placeholders in the message.
 */ function assertType(condition, message) {
    if (!condition) {
        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)args[_key - 2] = arguments[_key];
        throw new TypeError(format(message, args));
    }
}
/**
 * Convert a text and arguments to one string.
 * @param message The formating text
 * @param args The arguments.
 */ function format(message, args) {
    var i = 0;
    return message.replace(/%[os]/g, function() {
        return anyToString(args[i++]);
    });
}
/**
 * Convert a value to a string representation.
 * @param x The value to get the string representation.
 */ function anyToString(x) {
    if (_typeof__default["default"](x) !== "object" || x === null) return String(x);
    return Object.prototype.toString.call(x);
}
var currentErrorHandler;
/**
 * Set the error handler.
 * @param value The error handler to set.
 */ function setErrorHandler(value) {
    assertType(typeof value === "function" || value === undefined, "The error handler must be a function or undefined, but got %o.", value);
    currentErrorHandler = value;
}
/**
 * Print a error message.
 * @param maybeError The error object.
 */ function reportError(maybeError) {
    try {
        var error = maybeError instanceof Error ? maybeError : new Error(anyToString(maybeError)); // Call the user-defined error handler if exists.
        if (currentErrorHandler) {
            currentErrorHandler(error);
            return;
        } // Dispatch an `error` event if this is on a browser.
        if (typeof dispatchEvent === "function" && typeof ErrorEvent === "function") dispatchEvent(new ErrorEvent("error", {
            error: error,
            message: error.message
        }));
        else if (typeof process !== "undefined" && typeof process.emit === "function") {
            process.emit("uncaughtException", error);
            return;
        } // Otherwise, print the error.
        console.error(error);
    } catch (_a) {}
}
/**
 * The global object.
 */ //istanbul ignore next
var Global = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : typeof globalThis !== "undefined" ? globalThis : undefined;
var currentWarnHandler;
/**
 * Set the warning handler.
 * @param value The warning handler to set.
 */ function setWarningHandler(value) {
    assertType(typeof value === "function" || value === undefined, "The warning handler must be a function or undefined, but got %o.", value);
    currentWarnHandler = value;
}
/**
 * The warning information.
 */ var Warning = /*#__PURE__*/ function() {
    function Warning(code, message) {
        _classCallCheck__default["default"](this, Warning);
        this.code = code;
        this.message = message;
    }
    /**
   * Report this warning.
   * @param args The arguments of the warning.
   */ _createClass__default["default"](Warning, [
        {
            key: "warn",
            value: function warn() {
                var _a;
                try {
                    var _console;
                    for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
                    // Call the user-defined warning handler if exists.
                    if (currentWarnHandler) {
                        currentWarnHandler(_objectSpread(_objectSpread({}, this), {}, {
                            args: args
                        }));
                        return;
                    } // Otherwise, print the warning.
                    var stack = ((_a = new Error().stack) !== null && _a !== void 0 ? _a : "").replace(/^(?:(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+?\n){2}/g, "\n");
                    (_console = console).warn.apply(_console, [
                        this.message
                    ].concat(args, [
                        stack
                    ]));
                } catch (_b) {}
            }
        }
    ]);
    return Warning;
}();
var InitEventWasCalledWhileDispatching = new Warning("W01", "Unable to initialize event under dispatching.");
var FalsyWasAssignedToCancelBubble = new Warning("W02", "Assigning any falsy value to 'cancelBubble' property has no effect.");
var TruthyWasAssignedToReturnValue = new Warning("W03", "Assigning any truthy value to 'returnValue' property has no effect.");
var NonCancelableEventWasCanceled = new Warning("W04", "Unable to preventDefault on non-cancelable events.");
var CanceledInPassiveListener = new Warning("W05", "Unable to preventDefault inside passive event listener invocation.");
var EventListenerWasDuplicated = new Warning("W06", "An event listener wasn't added because it has been added already: %o, %o");
var OptionWasIgnored = new Warning("W07", "The %o option value was abandoned because the event listener wasn't added as duplicated.");
var InvalidEventListener = new Warning("W08", "The 'callback' argument must be a function or an object that has 'handleEvent' method: %o");
var InvalidAttributeHandler = new Warning("W09", "Event attribute handler must be a function: %o");
/*eslint-disable class-methods-use-this */ /**
 * An implementation of `Event` interface, that wraps a given event object.
 * `EventTarget` shim can control the internal state of this `Event` objects.
 * @see https://dom.spec.whatwg.org/#event
 */ var Event = /*#__PURE__*/ function() {
    _createClass__default["default"](Event, null, [
        {
            key: "NONE",
            /**
     * @see https://dom.spec.whatwg.org/#dom-event-none
     */ get: function get() {
                return NONE;
            }
        },
        {
            key: "CAPTURING_PHASE",
            get: function get() {
                return CAPTURING_PHASE;
            }
        },
        {
            key: "AT_TARGET",
            get: function get() {
                return AT_TARGET;
            }
        },
        {
            key: "BUBBLING_PHASE",
            get: function get() {
                return BUBBLING_PHASE;
            }
        }
    ]);
    function Event(type, eventInitDict) {
        _classCallCheck__default["default"](this, Event);
        Object.defineProperty(this, "isTrusted", {
            value: false,
            enumerable: true
        });
        var opts = eventInitDict !== null && eventInitDict !== void 0 ? eventInitDict : {};
        internalDataMap.set(this, {
            type: String(type),
            bubbles: Boolean(opts.bubbles),
            cancelable: Boolean(opts.cancelable),
            composed: Boolean(opts.composed),
            target: null,
            currentTarget: null,
            stopPropagationFlag: false,
            stopImmediatePropagationFlag: false,
            canceledFlag: false,
            inPassiveListenerFlag: false,
            dispatchFlag: false,
            timeStamp: Date.now()
        });
    }
    /**
   * The type of this event.
   * @see https://dom.spec.whatwg.org/#dom-event-type
   */ _createClass__default["default"](Event, [
        {
            key: "composedPath",
            /**
     * The event target of the current dispatching.
     * This doesn't support node tree.
     * @see https://dom.spec.whatwg.org/#dom-event-composedpath
     */ value: function composedPath() {
                var currentTarget = $(this).currentTarget;
                if (currentTarget) return [
                    currentTarget
                ];
                return [];
            }
        },
        {
            key: "stopPropagation",
            /**
     * Stop event bubbling.
     * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.
     * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation
     */ value: function stopPropagation() {
                $(this).stopPropagationFlag = true;
            }
        },
        {
            key: "stopImmediatePropagation",
            /**
     * Stop event bubbling and subsequent event listener callings.
     * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation
     */ value: function stopImmediatePropagation() {
                var data = $(this);
                data.stopPropagationFlag = data.stopImmediatePropagationFlag = true;
            }
        },
        {
            key: "preventDefault",
            /**
     * Cancel the default behavior.
     * @see https://dom.spec.whatwg.org/#dom-event-preventdefault
     */ value: function preventDefault() {
                setCancelFlag($(this));
            }
        },
        {
            key: "initEvent",
            /**
     * @deprecated Don't use this method. The constructor did initialization.
     */ value: function initEvent(type) {
                var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                var data = $(this);
                if (data.dispatchFlag) {
                    InitEventWasCalledWhileDispatching.warn();
                    return;
                }
                internalDataMap.set(this, _objectSpread(_objectSpread({}, data), {}, {
                    type: String(type),
                    bubbles: Boolean(bubbles),
                    cancelable: Boolean(cancelable),
                    target: null,
                    currentTarget: null,
                    stopPropagationFlag: false,
                    stopImmediatePropagationFlag: false,
                    canceledFlag: false
                }));
            }
        },
        {
            key: "type",
            get: function get() {
                return $(this).type;
            }
        },
        {
            key: "target",
            get: function get() {
                return $(this).target;
            }
        },
        {
            key: "srcElement",
            get: function get() {
                return $(this).target;
            }
        },
        {
            key: "currentTarget",
            get: function get() {
                return $(this).currentTarget;
            }
        },
        {
            key: "NONE",
            get: function get() {
                return NONE;
            }
        },
        {
            key: "CAPTURING_PHASE",
            get: function get() {
                return CAPTURING_PHASE;
            }
        },
        {
            key: "AT_TARGET",
            get: function get() {
                return AT_TARGET;
            }
        },
        {
            key: "BUBBLING_PHASE",
            get: function get() {
                return BUBBLING_PHASE;
            }
        },
        {
            key: "eventPhase",
            get: function get() {
                return $(this).dispatchFlag ? 2 : 0;
            }
        },
        {
            key: "cancelBubble",
            get: function get() {
                return $(this).stopPropagationFlag;
            },
            set: function set(value) {
                if (value) $(this).stopPropagationFlag = true;
                else FalsyWasAssignedToCancelBubble.warn();
            }
        },
        {
            key: "bubbles",
            get: function get() {
                return $(this).bubbles;
            }
        },
        {
            key: "cancelable",
            get: function get() {
                return $(this).cancelable;
            }
        },
        {
            key: "returnValue",
            get: function get() {
                return !$(this).canceledFlag;
            },
            set: function set(value) {
                if (!value) setCancelFlag($(this));
                else TruthyWasAssignedToReturnValue.warn();
            }
        },
        {
            key: "defaultPrevented",
            get: function get() {
                return $(this).canceledFlag;
            }
        },
        {
            key: "composed",
            get: function get() {
                return $(this).composed;
            }
        },
        {
            key: "isTrusted",
            get: function get() {
                return false;
            }
        },
        {
            key: "timeStamp",
            get: function get() {
                return $(this).timeStamp;
            }
        }
    ]);
    return Event;
}(); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
var NONE = 0;
var CAPTURING_PHASE = 1;
var AT_TARGET = 2;
var BUBBLING_PHASE = 3;
/**
 * Private data for event wrappers.
 */ var internalDataMap = new WeakMap();
/**
 * Get private data.
 * @param event The event object to get private data.
 * @param name The variable name to report.
 * @returns The private data of the event.
 */ function $(event) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "this";
    var retv = internalDataMap.get(event);
    assertType(retv != null, "'%s' must be an object that Event constructor created, but got another one: %o", name, event);
    return retv;
}
/**
 * https://dom.spec.whatwg.org/#set-the-canceled-flag
 * @param data private data.
 */ function setCancelFlag(data) {
    if (data.inPassiveListenerFlag) {
        CanceledInPassiveListener.warn();
        return;
    }
    if (!data.cancelable) {
        NonCancelableEventWasCanceled.warn();
        return;
    }
    data.canceledFlag = true;
} // Set enumerable
Object.defineProperty(Event, "NONE", {
    enumerable: true
});
Object.defineProperty(Event, "CAPTURING_PHASE", {
    enumerable: true
});
Object.defineProperty(Event, "AT_TARGET", {
    enumerable: true
});
Object.defineProperty(Event, "BUBBLING_PHASE", {
    enumerable: true
});
var keys = Object.getOwnPropertyNames(Event.prototype);
for(var i = 0; i < keys.length; ++i){
    if (keys[i] === "constructor") continue;
    Object.defineProperty(Event.prototype, keys[i], {
        enumerable: true
    });
} // Ensure `event instanceof window.Event` is `true`.
if (typeof Global !== "undefined" && typeof Global.Event !== "undefined") Object.setPrototypeOf(Event.prototype, Global.Event.prototype);
/**
 * Create a new InvalidStateError instance.
 * @param message The error message.
 */ function createInvalidStateError(message) {
    if (Global.DOMException) return new Global.DOMException(message, "InvalidStateError");
    if (DOMException == null) {
        DOMException = /*#__PURE__*/ function(_Error) {
            _inherits__default["default"](DOMException, _Error);
            var _super = _createSuper(DOMException);
            function DOMException(msg) {
                var _this;
                _classCallCheck__default["default"](this, DOMException);
                _this = _super.call(this, msg);
                if (Error.captureStackTrace) Error.captureStackTrace(_assertThisInitialized__default["default"](_this), DOMException);
                return _this;
            } // eslint-disable-next-line class-methods-use-this
            _createClass__default["default"](DOMException, [
                {
                    key: "code",
                    get: function get() {
                        return 11;
                    } // eslint-disable-next-line class-methods-use-this
                },
                {
                    key: "name",
                    get: function get() {
                        return "InvalidStateError";
                    }
                }
            ]);
            return DOMException;
        }(/*#__PURE__*/ _wrapNativeSuper__default["default"](Error));
        Object.defineProperties(DOMException.prototype, {
            code: {
                enumerable: true
            },
            name: {
                enumerable: true
            }
        });
        defineErrorCodeProperties(DOMException);
        defineErrorCodeProperties(DOMException.prototype);
    }
    return new DOMException(message);
} //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
var DOMException;
var ErrorCodeMap = {
    INDEX_SIZE_ERR: 1,
    DOMSTRING_SIZE_ERR: 2,
    HIERARCHY_REQUEST_ERR: 3,
    WRONG_DOCUMENT_ERR: 4,
    INVALID_CHARACTER_ERR: 5,
    NO_DATA_ALLOWED_ERR: 6,
    NO_MODIFICATION_ALLOWED_ERR: 7,
    NOT_FOUND_ERR: 8,
    NOT_SUPPORTED_ERR: 9,
    INUSE_ATTRIBUTE_ERR: 10,
    INVALID_STATE_ERR: 11,
    SYNTAX_ERR: 12,
    INVALID_MODIFICATION_ERR: 13,
    NAMESPACE_ERR: 14,
    INVALID_ACCESS_ERR: 15,
    VALIDATION_ERR: 16,
    TYPE_MISMATCH_ERR: 17,
    SECURITY_ERR: 18,
    NETWORK_ERR: 19,
    ABORT_ERR: 20,
    URL_MISMATCH_ERR: 21,
    QUOTA_EXCEEDED_ERR: 22,
    TIMEOUT_ERR: 23,
    INVALID_NODE_TYPE_ERR: 24,
    DATA_CLONE_ERR: 25
};
function defineErrorCodeProperties(obj) {
    var keys = Object.keys(ErrorCodeMap);
    var _loop = function _loop(_i) {
        var key = keys[_i];
        var value = ErrorCodeMap[key];
        Object.defineProperty(obj, key, {
            get: function get() {
                return value;
            },
            configurable: true,
            enumerable: true
        });
    };
    for(var _i = 0; _i < keys.length; ++_i)_loop(_i);
}
/**
 * An implementation of `Event` interface, that wraps a given event object.
 * This class controls the internal state of `Event`.
 * @see https://dom.spec.whatwg.org/#interface-event
 */ var EventWrapper = /*#__PURE__*/ function(_Event) {
    _inherits__default["default"](EventWrapper, _Event);
    var _super2 = _createSuper(EventWrapper);
    _createClass__default["default"](EventWrapper, null, [
        {
            key: "wrap",
            /**
     * Wrap a given event object to control states.
     * @param event The event-like object to wrap.
     */ value: function wrap(event) {
                return new (getWrapperClassOf(event))(event);
            }
        }
    ]);
    function EventWrapper(event) {
        var _thisSuper, _thisSuper2, _this2;
        _classCallCheck__default["default"](this, EventWrapper);
        _this2 = _super2.call(this, event.type, {
            bubbles: event.bubbles,
            cancelable: event.cancelable,
            composed: event.composed
        });
        if (event.cancelBubble) _get__default["default"]((_thisSuper = _assertThisInitialized__default["default"](_this2), _getPrototypeOf__default["default"](EventWrapper.prototype)), "stopPropagation", _thisSuper).call(_thisSuper);
        if (event.defaultPrevented) _get__default["default"]((_thisSuper2 = _assertThisInitialized__default["default"](_this2), _getPrototypeOf__default["default"](EventWrapper.prototype)), "preventDefault", _thisSuper2).call(_thisSuper2);
        internalDataMap$1.set(_assertThisInitialized__default["default"](_this2), {
            original: event
        }); // Define accessors
        var keys = Object.keys(event);
        for(var _i2 = 0; _i2 < keys.length; ++_i2){
            var key = keys[_i2];
            if (!(key in _assertThisInitialized__default["default"](_this2))) Object.defineProperty(_assertThisInitialized__default["default"](_this2), key, defineRedirectDescriptor(event, key));
        }
        return _this2;
    }
    _createClass__default["default"](EventWrapper, [
        {
            key: "stopPropagation",
            value: function stopPropagation() {
                _get__default["default"](_getPrototypeOf__default["default"](EventWrapper.prototype), "stopPropagation", this).call(this);
                var _$$ = $$1(this), original = _$$.original;
                if ("stopPropagation" in original) original.stopPropagation();
            }
        },
        {
            key: "stopImmediatePropagation",
            value: function stopImmediatePropagation() {
                _get__default["default"](_getPrototypeOf__default["default"](EventWrapper.prototype), "stopImmediatePropagation", this).call(this);
                var _$$2 = $$1(this), original = _$$2.original;
                if ("stopImmediatePropagation" in original) original.stopImmediatePropagation();
            }
        },
        {
            key: "preventDefault",
            value: function preventDefault() {
                _get__default["default"](_getPrototypeOf__default["default"](EventWrapper.prototype), "preventDefault", this).call(this);
                var _$$3 = $$1(this), original = _$$3.original;
                if ("preventDefault" in original) original.preventDefault();
            }
        },
        {
            key: "cancelBubble",
            get: function get() {
                return _get__default["default"](_getPrototypeOf__default["default"](EventWrapper.prototype), "cancelBubble", this);
            },
            set: function set(value) {
                _set__default["default"](_getPrototypeOf__default["default"](EventWrapper.prototype), "cancelBubble", value, this, true);
                var _$$4 = $$1(this), original = _$$4.original;
                if ("cancelBubble" in original) original.cancelBubble = value;
            }
        },
        {
            key: "returnValue",
            get: function get() {
                return _get__default["default"](_getPrototypeOf__default["default"](EventWrapper.prototype), "returnValue", this);
            },
            set: function set(value) {
                _set__default["default"](_getPrototypeOf__default["default"](EventWrapper.prototype), "returnValue", value, this, true);
                var _$$5 = $$1(this), original = _$$5.original;
                if ("returnValue" in original) original.returnValue = value;
            }
        },
        {
            key: "timeStamp",
            get: function get() {
                var _$$6 = $$1(this), original = _$$6.original;
                if ("timeStamp" in original) return original.timeStamp;
                return _get__default["default"](_getPrototypeOf__default["default"](EventWrapper.prototype), "timeStamp", this);
            }
        }
    ]);
    return EventWrapper;
}(Event);
/**
 * Private data for event wrappers.
 */ var internalDataMap$1 = new WeakMap();
/**
 * Get private data.
 * @param event The event object to get private data.
 * @returns The private data of the event.
 */ function $$1(event) {
    var retv = internalDataMap$1.get(event);
    assertType(retv != null, "'this' is expected an Event object, but got", event);
    return retv;
}
/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */ var wrapperClassCache = new WeakMap(); // Make association for wrappers.
wrapperClassCache.set(Object.prototype, EventWrapper);
if (typeof Global !== "undefined" && typeof Global.Event !== "undefined") wrapperClassCache.set(Global.Event.prototype, EventWrapper);
/**
 * Get the wrapper class of a given prototype.
 * @param originalEvent The event object to wrap.
 */ function getWrapperClassOf(originalEvent) {
    var prototype = Object.getPrototypeOf(originalEvent);
    if (prototype == null) return EventWrapper;
    var wrapper = wrapperClassCache.get(prototype);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapperClassOf(prototype), prototype);
        wrapperClassCache.set(prototype, wrapper);
    }
    return wrapper;
}
/**
 * Define new wrapper class.
 * @param BaseEventWrapper The base wrapper class.
 * @param originalPrototype The prototype of the original event.
 */ function defineWrapper(BaseEventWrapper, originalPrototype) {
    var CustomEventWrapper = /*#__PURE__*/ function(_BaseEventWrapper) {
        _inherits__default["default"](CustomEventWrapper, _BaseEventWrapper);
        var _super3 = _createSuper(CustomEventWrapper);
        function CustomEventWrapper() {
            _classCallCheck__default["default"](this, CustomEventWrapper);
            return _super3.apply(this, arguments);
        }
        return CustomEventWrapper;
    }(BaseEventWrapper);
    var keys = Object.keys(originalPrototype);
    for(var _i3 = 0; _i3 < keys.length; ++_i3)Object.defineProperty(CustomEventWrapper.prototype, keys[_i3], defineRedirectDescriptor(originalPrototype, keys[_i3]));
    return CustomEventWrapper;
}
/**
 * Get the property descriptor to redirect a given property.
 */ function defineRedirectDescriptor(obj, key) {
    var d = Object.getOwnPropertyDescriptor(obj, key);
    return {
        get: function get() {
            var original = $$1(this).original;
            var value = original[key];
            if (typeof value === "function") return value.bind(original);
            return value;
        },
        set: function set(value) {
            var original = $$1(this).original;
            original[key] = value;
        },
        configurable: d.configurable,
        enumerable: d.enumerable
    };
}
/**
 * Create a new listener.
 * @param callback The callback function.
 * @param capture The capture flag.
 * @param passive The passive flag.
 * @param once The once flag.
 * @param signal The abort signal.
 * @param signalListener The abort event listener for the abort signal.
 */ function createListener(callback, capture, passive, once, signal, signalListener) {
    return {
        callback: callback,
        flags: (capture ? 1 : 0) | (passive ? 2 : 0) | (once ? 4 : 0),
        signal: signal,
        signalListener: signalListener
    };
}
/**
 * Set the `removed` flag to the given listener.
 * @param listener The listener to check.
 */ function setRemoved(listener) {
    listener.flags |= 8 /* Removed */ ;
}
/**
 * Check if the given listener has the `capture` flag or not.
 * @param listener The listener to check.
 */ function isCapture(listener) {
    return (listener.flags & 1) === 1 /* Capture */ ;
}
/**
 * Check if the given listener has the `passive` flag or not.
 * @param listener The listener to check.
 */ function isPassive(listener) {
    return (listener.flags & 2) === 2 /* Passive */ ;
}
/**
 * Check if the given listener has the `once` flag or not.
 * @param listener The listener to check.
 */ function isOnce(listener) {
    return (listener.flags & 4) === 4 /* Once */ ;
}
/**
 * Check if the given listener has the `removed` flag or not.
 * @param listener The listener to check.
 */ function isRemoved(listener) {
    return (listener.flags & 8) === 8 /* Removed */ ;
}
/**
 * Call an event listener.
 * @param listener The listener to call.
 * @param target The event target object for `thisArg`.
 * @param event The event object for the first argument.
 * @param attribute `true` if this callback is an event attribute handler.
 */ function invokeCallback(_ref, target, event) {
    var callback = _ref.callback;
    try {
        if (typeof callback === "function") callback.call(target, event);
        else if (typeof callback.handleEvent === "function") callback.handleEvent(event);
    } catch (thrownError) {
        reportError(thrownError);
    }
}
/**
 * Find the index of given listener.
 * This returns `-1` if not found.
 * @param list The listener list.
 * @param callback The callback function to find.
 * @param capture The capture flag to find.
 */ function findIndexOfListener(_ref2, callback, capture) {
    var listeners = _ref2.listeners;
    for(var _i4 = 0; _i4 < listeners.length; ++_i4){
        if (listeners[_i4].callback === callback && isCapture(listeners[_i4]) === capture) return _i4;
    }
    return -1;
}
/**
 * Add the given listener.
 * Does copy-on-write if needed.
 * @param list The listener list.
 * @param callback The callback function.
 * @param capture The capture flag.
 * @param passive The passive flag.
 * @param once The once flag.
 * @param signal The abort signal.
 */ function addListener(list, callback, capture, passive, once, signal) {
    var signalListener;
    if (signal) {
        signalListener = removeListener.bind(null, list, callback, capture);
        signal.addEventListener("abort", signalListener);
    }
    var listener = createListener(callback, capture, passive, once, signal, signalListener);
    if (list.cow) {
        list.cow = false;
        list.listeners = [].concat(_toConsumableArray__default["default"](list.listeners), [
            listener
        ]);
    } else list.listeners.push(listener);
    return listener;
}
/**
 * Remove a listener.
 * @param list The listener list.
 * @param callback The callback function to find.
 * @param capture The capture flag to find.
 * @returns `true` if it mutated the list directly.
 */ function removeListener(list, callback, capture) {
    var index = findIndexOfListener(list, callback, capture);
    if (index !== -1) return removeListenerAt(list, index);
    return false;
}
/**
 * Remove a listener.
 * @param list The listener list.
 * @param index The index of the target listener.
 * @param disableCow Disable copy-on-write if true.
 * @returns `true` if it mutated the `listeners` array directly.
 */ function removeListenerAt(list, index) {
    var disableCow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var listener = list.listeners[index]; // Set the removed flag.
    setRemoved(listener); // Dispose the abort signal listener if exists.
    if (listener.signal) listener.signal.removeEventListener("abort", listener.signalListener);
     // Remove it from the array.
    if (list.cow && !disableCow) {
        list.cow = false;
        list.listeners = list.listeners.filter(function(_, i) {
            return i !== index;
        });
        return false;
    }
    list.listeners.splice(index, 1);
    return true;
}
/**
 * Create a new `ListenerListMap` object.
 */ function createListenerListMap() {
    return Object.create(null);
}
/**
 * Get the listener list of the given type.
 * If the listener list has not been initialized, initialize and return it.
 * @param listenerMap The listener list map.
 * @param type The event type to get.
 */ function ensureListenerList(listenerMap, type) {
    var _a;
    return (_a = listenerMap[type]) !== null && _a !== void 0 ? _a : listenerMap[type] = {
        attrCallback: undefined,
        attrListener: undefined,
        cow: false,
        listeners: []
    };
}
/**
 * An implementation of the `EventTarget` interface.
 * @see https://dom.spec.whatwg.org/#eventtarget
 */ var EventTarget = /*#__PURE__*/ function() {
    /**
   * Initialize this instance.
   */ function EventTarget() {
        _classCallCheck__default["default"](this, EventTarget);
        internalDataMap$2.set(this, createListenerListMap());
    } // Implementation
    _createClass__default["default"](EventTarget, [
        {
            key: "addEventListener",
            value: function addEventListener(type0, callback0, options0) {
                var listenerMap = $$2(this);
                var _normalizeAddOptions = normalizeAddOptions(type0, callback0, options0), callback = _normalizeAddOptions.callback, capture = _normalizeAddOptions.capture, once = _normalizeAddOptions.once, passive = _normalizeAddOptions.passive, signal = _normalizeAddOptions.signal, type = _normalizeAddOptions.type;
                if (callback == null || (signal === null || signal === void 0 ? void 0 : signal.aborted)) return;
                var list = ensureListenerList(listenerMap, type); // Find existing listener.
                var i = findIndexOfListener(list, callback, capture);
                if (i !== -1) {
                    warnDuplicate(list.listeners[i], passive, once, signal);
                    return;
                } // Add the new listener.
                addListener(list, callback, capture, passive, once, signal);
            } // Implementation
        },
        {
            key: "removeEventListener",
            value: function removeEventListener(type0, callback0, options0) {
                var listenerMap = $$2(this);
                var _normalizeOptions = normalizeOptions(type0, callback0, options0), callback = _normalizeOptions.callback, capture = _normalizeOptions.capture, type = _normalizeOptions.type;
                var list = listenerMap[type];
                if (callback != null && list) removeListener(list, callback, capture);
            } // Implementation
        },
        {
            key: "dispatchEvent",
            value: function dispatchEvent1(e) {
                var list = $$2(this)[String(e.type)];
                if (list == null) return true;
                var event = e instanceof Event ? e : EventWrapper.wrap(e);
                var eventData = $(event, "event");
                if (eventData.dispatchFlag) throw createInvalidStateError("This event has been in dispatching.");
                eventData.dispatchFlag = true;
                eventData.target = eventData.currentTarget = this;
                if (!eventData.stopPropagationFlag) {
                    var cow = list.cow, listeners = list.listeners; // Set copy-on-write flag.
                    list.cow = true; // Call listeners.
                    for(var _i5 = 0; _i5 < listeners.length; ++_i5){
                        var listener = listeners[_i5]; // Skip if removed.
                        if (isRemoved(listener)) continue;
                         // Remove this listener if has the `once` flag.
                        if (isOnce(listener) && removeListenerAt(list, _i5, !cow)) // Because this listener was removed, the next index is the
                        // same as the current value.
                        _i5 -= 1;
                         // Call this listener with the `passive` flag.
                        eventData.inPassiveListenerFlag = isPassive(listener);
                        invokeCallback(listener, this, event);
                        eventData.inPassiveListenerFlag = false; // Stop if the `event.stopImmediatePropagation()` method was called.
                        if (eventData.stopImmediatePropagationFlag) break;
                    } // Restore copy-on-write flag.
                    if (!cow) list.cow = false;
                }
                eventData.target = null;
                eventData.currentTarget = null;
                eventData.stopImmediatePropagationFlag = false;
                eventData.stopPropagationFlag = false;
                eventData.dispatchFlag = false;
                return !eventData.canceledFlag;
            }
        }
    ]);
    return EventTarget;
}();
/**
 * Internal data.
 */ var internalDataMap$2 = new WeakMap();
/**
 * Get private data.
 * @param target The event target object to get private data.
 * @param name The variable name to report.
 * @returns The private data of the event.
 */ function $$2(target) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "this";
    var retv = internalDataMap$2.get(target);
    assertType(retv != null, "'%s' must be an object that EventTarget constructor created, but got another one: %o", name, target);
    return retv;
}
/**
 * Normalize options.
 * @param options The options to normalize.
 */ function normalizeAddOptions(type, callback, options) {
    var _a;
    assertCallback(callback);
    if (_typeof__default["default"](options) === "object" && options !== null) return {
        type: String(type),
        callback: callback !== null && callback !== void 0 ? callback : undefined,
        capture: Boolean(options.capture),
        passive: Boolean(options.passive),
        once: Boolean(options.once),
        signal: (_a = options.signal) !== null && _a !== void 0 ? _a : undefined
    };
    return {
        type: String(type),
        callback: callback !== null && callback !== void 0 ? callback : undefined,
        capture: Boolean(options),
        passive: false,
        once: false,
        signal: undefined
    };
}
/**
 * Normalize options.
 * @param options The options to normalize.
 */ function normalizeOptions(type, callback, options) {
    assertCallback(callback);
    if (_typeof__default["default"](options) === "object" && options !== null) return {
        type: String(type),
        callback: callback !== null && callback !== void 0 ? callback : undefined,
        capture: Boolean(options.capture)
    };
    return {
        type: String(type),
        callback: callback !== null && callback !== void 0 ? callback : undefined,
        capture: Boolean(options)
    };
}
/**
 * Assert the type of 'callback' argument.
 * @param callback The callback to check.
 */ function assertCallback(callback) {
    if (typeof callback === "function" || _typeof__default["default"](callback) === "object" && callback !== null && typeof callback.handleEvent === "function") return;
    if (callback == null || _typeof__default["default"](callback) === "object") {
        InvalidEventListener.warn(callback);
        return;
    }
    throw new TypeError(format(InvalidEventListener.message, [
        callback
    ]));
}
/**
 * Print warning for duplicated.
 * @param listener The current listener that is duplicated.
 * @param passive The passive flag of the new duplicated listener.
 * @param once The once flag of the new duplicated listener.
 * @param signal The signal object of the new duplicated listener.
 */ function warnDuplicate(listener, passive, once, signal) {
    EventListenerWasDuplicated.warn(isCapture(listener) ? "capture" : "bubble", listener.callback);
    if (isPassive(listener) !== passive) OptionWasIgnored.warn("passive");
    if (isOnce(listener) !== once) OptionWasIgnored.warn("once");
    if (listener.signal !== signal) OptionWasIgnored.warn("signal");
} // Set enumerable
var keys$1 = Object.getOwnPropertyNames(EventTarget.prototype);
for(var _i6 = 0; _i6 < keys$1.length; ++_i6){
    if (keys$1[_i6] === "constructor") continue;
    Object.defineProperty(EventTarget.prototype, keys$1[_i6], {
        enumerable: true
    });
} // Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (typeof Global !== "undefined" && typeof Global.EventTarget !== "undefined") Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype);
/**
 * Get the current value of a given event attribute.
 * @param target The `EventTarget` object to get.
 * @param type The event type.
 */ function getEventAttributeValue(target, type) {
    var _a, _b;
    var listMap = $$2(target, "target");
    return (_b = (_a = listMap[type]) === null || _a === void 0 ? void 0 : _a.attrCallback) !== null && _b !== void 0 ? _b : null;
}
/**
 * Set an event listener to a given event attribute.
 * @param target The `EventTarget` object to set.
 * @param type The event type.
 * @param callback The event listener.
 */ function setEventAttributeValue(target, type, callback) {
    if (callback != null && typeof callback !== "function") InvalidAttributeHandler.warn(callback);
    if (typeof callback === "function" || _typeof__default["default"](callback) === "object" && callback !== null) upsertEventAttributeListener(target, type, callback);
    else removeEventAttributeListener(target, type);
} //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
/**
 * Update or insert the given event attribute handler.
 * @param target The `EventTarget` object to set.
 * @param type The event type.
 * @param callback The event listener.
 */ function upsertEventAttributeListener(target, type, callback) {
    var list = ensureListenerList($$2(target, "target"), String(type));
    list.attrCallback = callback;
    if (list.attrListener == null) list.attrListener = addListener(list, defineEventAttributeCallback(list), false, false, false, undefined);
}
/**
 * Remove the given event attribute handler.
 * @param target The `EventTarget` object to remove.
 * @param type The event type.
 * @param callback The event listener.
 */ function removeEventAttributeListener(target, type) {
    var listMap = $$2(target, "target");
    var list = listMap[String(type)];
    if (list && list.attrListener) {
        removeListener(list, list.attrListener.callback, false);
        list.attrCallback = list.attrListener = undefined;
    }
}
/**
 * Define the callback function for the given listener list object.
 * It calls `attrCallback` property if the property value is a function.
 * @param list The `ListenerList` object.
 */ function defineEventAttributeCallback(list) {
    return function(event) {
        var callback = list.attrCallback;
        if (typeof callback === "function") callback.call(this, event);
    };
}
/**
 * Define an `EventTarget` class that has event attibutes.
 * @param types The types to define event attributes.
 * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.
 */ function defineCustomEventTarget() {
    var CustomEventTarget = /*#__PURE__*/ function(_EventTarget) {
        _inherits__default["default"](CustomEventTarget, _EventTarget);
        var _super4 = _createSuper(CustomEventTarget);
        function CustomEventTarget() {
            _classCallCheck__default["default"](this, CustomEventTarget);
            return _super4.apply(this, arguments);
        }
        return CustomEventTarget;
    }(EventTarget);
    for(var _i7 = 0; _i7 < arguments.length; ++_i7)defineEventAttribute(CustomEventTarget.prototype, _i7 < 0 || arguments.length <= _i7 ? undefined : arguments[_i7]);
    return CustomEventTarget;
}
/**
 * Define an event attribute.
 * @param target The `EventTarget` object to define an event attribute.
 * @param type The event type to define.
 * @param _eventClass Unused, but to infer `Event` class type.
 * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.
 */ function defineEventAttribute(target, type, _eventClass) {
    Object.defineProperty(target, "on".concat(type), {
        get: function get() {
            return getEventAttributeValue(this, type);
        },
        set: function set(value) {
            setEventAttributeValue(this, type, value);
        },
        configurable: true,
        enumerable: true
    });
}
exports.Event = Event;
exports.EventTarget = EventTarget;
exports.default = EventTarget;
exports.defineCustomEventTarget = defineCustomEventTarget;
exports.defineEventAttribute = defineEventAttribute;
exports.getEventAttributeValue = getEventAttributeValue;
exports.setErrorHandler = setErrorHandler;
exports.setEventAttributeValue = setEventAttributeValue;
exports.setWarningHandler = setWarningHandler;

},{"eb79af20fcd06e32":"1htrR","26b2219201cd07ee":"fb7ej","56d39df50603c838":"9ivV0","bd1e95fd7001e0a":"e2Qe9","a1063d2920c16f36":"chPlo","cc70ed9f6c749fe7":"bQ802","86f81d2e5203b87a":"kJc1U","120e9f99079e0a71":"g7YIw","e1a68cab5f60d1e7":"kFk6J","e3f247ff05fc85eb":"3d8OR","2efdec3106c7e93f":"7zlNi","4d3cad845e560498":"b694u","e85f43ec4ed870e9":"64MFb"}],"1htrR":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"fb7ej":[function(require,module,exports) {
var arrayWithoutHoles = require("427141a8da2b2bd0");
var iterableToArray = require("dc8b55c5bd1fac22");
var unsupportedIterableToArray = require("1a3c05431e4f1c1d");
var nonIterableSpread = require("5abd58724e2ea644");
function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"427141a8da2b2bd0":"furF3","dc8b55c5bd1fac22":"djydW","1a3c05431e4f1c1d":"8gCyU","5abd58724e2ea644":"5sy1G"}],"furF3":[function(require,module,exports) {
var arrayLikeToArray = require("32cc9b3e9b1c957d");
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"32cc9b3e9b1c957d":"bZiNj"}],"bZiNj":[function(require,module,exports) {
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"djydW":[function(require,module,exports) {
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"8gCyU":[function(require,module,exports) {
var arrayLikeToArray = require("d8c3baa407b40876");
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"d8c3baa407b40876":"bZiNj"}],"5sy1G":[function(require,module,exports) {
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"9ivV0":[function(require,module,exports) {
var superPropBase = require("9e01d53c4faa971c");
var defineProperty = require("316af6eed405c14a");
function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) set = Reflect.set;
    else set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;
        if (base) {
            desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.set) {
                desc.set.call(receiver, value);
                return true;
            } else if (!desc.writable) return false;
        }
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
            if (!desc.writable) return false;
            desc.value = value;
            Object.defineProperty(receiver, property, desc);
        } else defineProperty(receiver, property, value);
        return true;
    };
    return set(target, property, value, receiver);
}
function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) throw new Error("failed to set property");
    return value;
}
module.exports = _set, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"9e01d53c4faa971c":"1JcyI","316af6eed405c14a":"3d8OR"}],"1JcyI":[function(require,module,exports) {
var getPrototypeOf = require("3e77e6afd5cb0253");
function _superPropBase(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = getPrototypeOf(object);
        if (object === null) break;
    }
    return object;
}
module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"3e77e6afd5cb0253":"g7YIw"}],"3d8OR":[function(require,module,exports) {
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"e2Qe9":[function(require,module,exports) {
var superPropBase = require("790bc9f016abc359");
function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
    else module.exports = _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) return desc.get.call(arguments.length < 3 ? target : receiver);
        return desc.value;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _get.apply(this, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"790bc9f016abc359":"1JcyI"}],"kFk6J":[function(require,module,exports) {
var getPrototypeOf = require("2436b4d99863223f");
var setPrototypeOf = require("954123c3dcc39f7d");
var isNativeFunction = require("9099bd7a86890b21");
var construct = require("53c00dc8961e002a");
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return construct(Class, arguments, getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return setPrototypeOf(Wrapper, Class);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _wrapNativeSuper(Class);
}
module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"2436b4d99863223f":"g7YIw","954123c3dcc39f7d":"hwPzH","9099bd7a86890b21":"kadCf","53c00dc8961e002a":"1MW8S"}],"kadCf":[function(require,module,exports) {
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"1MW8S":[function(require,module,exports) {
var setPrototypeOf = require("511e8ed0ccee239b");
var isNativeReflectConstruct = require("325e2b6111b0f2d6");
function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
    else module.exports = _construct = function _construct(Parent, args, Class) {
        var a = [
            null
        ];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _construct.apply(null, arguments);
}
module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"511e8ed0ccee239b":"hwPzH","325e2b6111b0f2d6":"6e2VU"}],"6e2VU":[function(require,module,exports) {
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"dhDU2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>src_default);
var _promise = require("@babel/runtime-corejs3/core-js-stable/promise");
var _promiseDefault = parcelHelpers.interopDefault(_promise);
// ../p-defer/index.js
function pDefer() {
    var deferred = {};
    deferred.promise = new (0, _promiseDefault.default)(function(resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
// src/index.mjs
var src_default = pDefer;

},{"@babel/runtime-corejs3/core-js-stable/promise":"4HVeB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4HVeB":[function(require,module,exports) {
module.exports = require("f31859c74d2e971a");

},{"f31859c74d2e971a":"8GlAj"}],"8GlAj":[function(require,module,exports) {
var parent = require("bf5f4c2dc1961ad");
require("10edbf3a4eb01f52");
module.exports = parent;

},{"bf5f4c2dc1961ad":"3EkVY","10edbf3a4eb01f52":"aRnAU"}],"3EkVY":[function(require,module,exports) {
require("122d29c336331537");
require("975ab69ec624a664");
require("b656cf5187eba6c4");
require("b9a051fa89075959");
require("1894031660674c0e");
require("dcdfb84724f1f012");
require("bd3c35f8b2c79b95");
require("8ce5a079eaa8a2c9");
var path = require("76153adf4e437e17");
module.exports = path.Promise;

},{"122d29c336331537":"clN8G","975ab69ec624a664":"eISyY","b656cf5187eba6c4":"khsXc","b9a051fa89075959":"NDL2A","1894031660674c0e":"aNkmH","dcdfb84724f1f012":"6nvNo","bd3c35f8b2c79b95":"abmdO","8ce5a079eaa8a2c9":"1Sesg","76153adf4e437e17":"1LE1f"}],"clN8G":[function(require,module,exports) {
// TODO: Remove this module from `core-js@4` since it's replaced to module below
require("d845cbcb1462e90f");

},{"d845cbcb1462e90f":"0oOom"}],"0oOom":[function(require,module,exports) {
"use strict";
var $ = require("55bf81c4ee871390");
var isPrototypeOf = require("392361b6d88ce672");
var getPrototypeOf = require("7b0550b5a75af08");
var setPrototypeOf = require("a3e4373320cdfa3f");
var copyConstructorProperties = require("8a903f3987b37b83");
var create = require("4fcf5b57ca1eff2");
var createNonEnumerableProperty = require("d2aaabb6087fd697");
var createPropertyDescriptor = require("1654c1f57441cf41");
var installErrorCause = require("d68a81ba0eeabab");
var installErrorStack = require("3575ca5a3fab8c8d");
var iterate = require("6158d01cfca494f9");
var normalizeStringArgument = require("e949f91297759abc");
var wellKnownSymbol = require("c096e15a62fefd10");
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
var $Error = Error;
var push = [].push;
var $AggregateError = function AggregateError(errors, message /* , options */ ) {
    var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
    var that;
    if (setPrototypeOf) that = setPrototypeOf($Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
    else {
        that = isInstance ? this : create(AggregateErrorPrototype);
        createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
    }
    if (message !== undefined) createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
    installErrorStack(that, $AggregateError, that.stack, 1);
    if (arguments.length > 2) installErrorCause(that, arguments[2]);
    var errorsArray = [];
    iterate(errors, push, {
        that: errorsArray
    });
    createNonEnumerableProperty(that, "errors", errorsArray);
    return that;
};
if (setPrototypeOf) setPrototypeOf($AggregateError, $Error);
else copyConstructorProperties($AggregateError, $Error, {
    name: true
});
var AggregateErrorPrototype = $AggregateError.prototype = create($Error.prototype, {
    constructor: createPropertyDescriptor(1, $AggregateError),
    message: createPropertyDescriptor(1, ""),
    name: createPropertyDescriptor(1, "AggregateError")
});
// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$({
    global: true,
    constructor: true,
    arity: 2
}, {
    AggregateError: $AggregateError
});

},{"55bf81c4ee871390":"6O4uB","392361b6d88ce672":"hViWt","7b0550b5a75af08":"gpCyL","a3e4373320cdfa3f":"dBbtF","8a903f3987b37b83":"3IFAs","4fcf5b57ca1eff2":"ib5ns","d2aaabb6087fd697":"kRRdZ","1654c1f57441cf41":"7Ue8a","d68a81ba0eeabab":"75fqZ","3575ca5a3fab8c8d":"95bJ4","6158d01cfca494f9":"9aBKZ","e949f91297759abc":"bhj1E","c096e15a62fefd10":"daYw1"}],"6O4uB":[function(require,module,exports) {
"use strict";
var global = require("3e7c74f916015c52");
var apply = require("24e77ebe6c484bf4");
var uncurryThis = require("6811b2767a15df87");
var isCallable = require("b3898928410c1127");
var getOwnPropertyDescriptor = require("5d49509fd85b0b50").f;
var isForced = require("ccdd7d0915bd9907");
var path = require("bc5ad97a719725e2");
var bind = require("9630cb663179c11e");
var createNonEnumerableProperty = require("8525e182df2f1cd7");
var hasOwn = require("ef54b5cee75ed1a0");
var wrapConstructor = function(NativeConstructor) {
    var Wrapper = function(a, b, c) {
        if (this instanceof Wrapper) {
            switch(arguments.length){
                case 0:
                    return new NativeConstructor();
                case 1:
                    return new NativeConstructor(a);
                case 2:
                    return new NativeConstructor(a, b);
            }
            return new NativeConstructor(a, b, c);
        }
        return apply(NativeConstructor, this, arguments);
    };
    Wrapper.prototype = NativeConstructor.prototype;
    return Wrapper;
};
/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/ module.exports = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var PROTO = options.proto;
    var nativeSource = GLOBAL ? global : STATIC ? global[TARGET] : (global[TARGET] || {}).prototype;
    var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
    var targetPrototype = target.prototype;
    var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
    var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
    for(key in source){
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        // contains in native
        USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);
        targetProperty = target[key];
        if (USE_NATIVE) {
            if (options.dontCallGetSet) {
                descriptor = getOwnPropertyDescriptor(nativeSource, key);
                nativeProperty = descriptor && descriptor.value;
            } else nativeProperty = nativeSource[key];
        }
        // export native or implementation
        sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
        if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;
        // bind methods to global for calling from export context
        if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global);
        else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
        else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
        else resultProperty = sourceProperty;
        // add a flag to not completely full polyfills
        if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) createNonEnumerableProperty(resultProperty, "sham", true);
        createNonEnumerableProperty(target, key, resultProperty);
        if (PROTO) {
            VIRTUAL_PROTOTYPE = TARGET + "Prototype";
            if (!hasOwn(path, VIRTUAL_PROTOTYPE)) createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
            // export virtual prototype methods
            createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
            // export real prototype methods
            if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) createNonEnumerableProperty(targetPrototype, key, sourceProperty);
        }
    }
};

},{"3e7c74f916015c52":"fGEOS","24e77ebe6c484bf4":"5V42h","6811b2767a15df87":"LsUO3","b3898928410c1127":"ceVMR","5d49509fd85b0b50":"6zTL3","ccdd7d0915bd9907":"xJExK","bc5ad97a719725e2":"1LE1f","9630cb663179c11e":"kjhmo","8525e182df2f1cd7":"kRRdZ","ef54b5cee75ed1a0":"6CR0z"}],"fGEOS":[function(require,module,exports) {
var global = arguments[3];
var check = function(it) {
    return it && it.Math == Math && it;
};
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports = // eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == "object" && self) || check(typeof global == "object" && global) || // eslint-disable-next-line no-new-func -- fallback
function() {
    return this;
}() || this || Function("return this")();

},{}],"5V42h":[function(require,module,exports) {
var NATIVE_BIND = require("8a97593d0fc8c61d");
var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
    return call.apply(apply, arguments);
});

},{"8a97593d0fc8c61d":"fTjmV"}],"fTjmV":[function(require,module,exports) {
var fails = require("5d46443f861435fd");
module.exports = !fails(function() {
    // eslint-disable-next-line es/no-function-prototype-bind -- safe
    var test = (function() {}).bind();
    // eslint-disable-next-line no-prototype-builtins -- safe
    return typeof test != "function" || test.hasOwnProperty("prototype");
});

},{"5d46443f861435fd":"fy30P"}],"fy30P":[function(require,module,exports) {
module.exports = function(exec) {
    try {
        return !!exec();
    } catch (error) {
        return true;
    }
};

},{}],"LsUO3":[function(require,module,exports) {
var classofRaw = require("117f3c4623019c14");
var uncurryThis = require("7303666db900b547");
module.exports = function(fn) {
    // Nashorn bug:
    //   https://github.com/zloirock/core-js/issues/1128
    //   https://github.com/zloirock/core-js/issues/1130
    if (classofRaw(fn) === "Function") return uncurryThis(fn);
};

},{"117f3c4623019c14":"5grTi","7303666db900b547":"jdja0"}],"5grTi":[function(require,module,exports) {
var uncurryThis = require("ed0c2a57055e47cd");
var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis("".slice);
module.exports = function(it) {
    return stringSlice(toString(it), 8, -1);
};

},{"ed0c2a57055e47cd":"jdja0"}],"jdja0":[function(require,module,exports) {
var NATIVE_BIND = require("bd2a10eda8492931");
var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
    return function() {
        return call.apply(fn, arguments);
    };
};

},{"bd2a10eda8492931":"fTjmV"}],"ceVMR":[function(require,module,exports) {
var $documentAll = require("16b29270381384b2");
var documentAll = $documentAll.all;
// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = $documentAll.IS_HTMLDDA ? function(argument) {
    return typeof argument == "function" || argument === documentAll;
} : function(argument) {
    return typeof argument == "function";
};

},{"16b29270381384b2":"dxsxJ"}],"dxsxJ":[function(require,module,exports) {
var documentAll = typeof document == "object" && document.all;
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== undefined;
module.exports = {
    all: documentAll,
    IS_HTMLDDA: IS_HTMLDDA
};

},{}],"6zTL3":[function(require,module,exports) {
var DESCRIPTORS = require("6fa53b9b18eb2466");
var call = require("a1863235f6e77887");
var propertyIsEnumerableModule = require("61fa621612895bc2");
var createPropertyDescriptor = require("3f1b3d2480f8a21f");
var toIndexedObject = require("f0065cc74f1567a3");
var toPropertyKey = require("ce2033f6ffa0f2f1");
var hasOwn = require("598603ac11a85c98");
var IE8_DOM_DEFINE = require("d260824be96b2c38");
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPropertyKey(P);
    if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
    } catch (error) {}
    if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};

},{"6fa53b9b18eb2466":"6zWS1","a1863235f6e77887":"hzvOQ","61fa621612895bc2":"6ltCb","3f1b3d2480f8a21f":"7Ue8a","f0065cc74f1567a3":"d6f5x","ce2033f6ffa0f2f1":"gJLsb","598603ac11a85c98":"6CR0z","d260824be96b2c38":"kAPtu"}],"6zWS1":[function(require,module,exports) {
var fails = require("cbda51c6fe1926d3");
// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({}, 1, {
        get: function() {
            return 7;
        }
    })[1] != 7;
});

},{"cbda51c6fe1926d3":"fy30P"}],"hzvOQ":[function(require,module,exports) {
var NATIVE_BIND = require("e47675753cf7c2fd");
var call = Function.prototype.call;
module.exports = NATIVE_BIND ? call.bind(call) : function() {
    return call.apply(call, arguments);
};

},{"e47675753cf7c2fd":"fTjmV"}],"6ltCb":[function(require,module,exports) {
"use strict";
var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({
    1: 2
}, 1);
// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

},{}],"7Ue8a":[function(require,module,exports) {
module.exports = function(bitmap, value) {
    return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
    };
};

},{}],"d6f5x":[function(require,module,exports) {
// toObject with fallback for non-array-like ES3 strings
var IndexedObject = require("cbf0e5dcbda13119");
var requireObjectCoercible = require("28fa7a274ca65290");
module.exports = function(it) {
    return IndexedObject(requireObjectCoercible(it));
};

},{"cbf0e5dcbda13119":"37l14","28fa7a274ca65290":"30Lwm"}],"37l14":[function(require,module,exports) {
var uncurryThis = require("6d57f03224743078");
var fails = require("3ad25551ecb028fe");
var classof = require("d4a3dbf463b23178");
var $Object = Object;
var split = uncurryThis("".split);
// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function() {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !$Object("z").propertyIsEnumerable(0);
}) ? function(it) {
    return classof(it) == "String" ? split(it, "") : $Object(it);
} : $Object;

},{"6d57f03224743078":"jdja0","3ad25551ecb028fe":"fy30P","d4a3dbf463b23178":"5grTi"}],"30Lwm":[function(require,module,exports) {
var isNullOrUndefined = require("be9eb2477b25e5ca");
var $TypeError = TypeError;
// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function(it) {
    if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
    return it;
};

},{"be9eb2477b25e5ca":"jrvBZ"}],"jrvBZ":[function(require,module,exports) {
// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function(it) {
    return it === null || it === undefined;
};

},{}],"gJLsb":[function(require,module,exports) {
var toPrimitive = require("3f23171c2ead752c");
var isSymbol = require("283b00490eab8e15");
// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function(argument) {
    var key = toPrimitive(argument, "string");
    return isSymbol(key) ? key : key + "";
};

},{"3f23171c2ead752c":"7uQTe","283b00490eab8e15":"GJTIj"}],"7uQTe":[function(require,module,exports) {
var call = require("f706ee1b01d602d5");
var isObject = require("9fe34fbf27800a");
var isSymbol = require("5b21fa1261ec2232");
var getMethod = require("977d1b50e5ebcbc5");
var ordinaryToPrimitive = require("f2b83813b1d6bc59");
var wellKnownSymbol = require("23936ed9e370839f");
var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function(input, pref) {
    if (!isObject(input) || isSymbol(input)) return input;
    var exoticToPrim = getMethod(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
        if (pref === undefined) pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result)) return result;
        throw $TypeError("Can't convert object to primitive value");
    }
    if (pref === undefined) pref = "number";
    return ordinaryToPrimitive(input, pref);
};

},{"f706ee1b01d602d5":"hzvOQ","9fe34fbf27800a":"alLMh","5b21fa1261ec2232":"GJTIj","977d1b50e5ebcbc5":"lRimi","f2b83813b1d6bc59":"5jybi","23936ed9e370839f":"daYw1"}],"alLMh":[function(require,module,exports) {
var isCallable = require("9812fa32eb5e4e5c");
var $documentAll = require("45a7555818438e63");
var documentAll = $documentAll.all;
module.exports = $documentAll.IS_HTMLDDA ? function(it) {
    return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
} : function(it) {
    return typeof it == "object" ? it !== null : isCallable(it);
};

},{"9812fa32eb5e4e5c":"ceVMR","45a7555818438e63":"dxsxJ"}],"GJTIj":[function(require,module,exports) {
var getBuiltIn = require("1d2694e832c71d37");
var isCallable = require("aca3d55cb650cd1e");
var isPrototypeOf = require("e744f274bcff5d1e");
var USE_SYMBOL_AS_UID = require("915148ecb40afc3f");
var $Object = Object;
module.exports = USE_SYMBOL_AS_UID ? function(it) {
    return typeof it == "symbol";
} : function(it) {
    var $Symbol = getBuiltIn("Symbol");
    return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};

},{"1d2694e832c71d37":"er1gl","aca3d55cb650cd1e":"ceVMR","e744f274bcff5d1e":"hViWt","915148ecb40afc3f":"hakMC"}],"er1gl":[function(require,module,exports) {
var path = require("5ce86436bf32f268");
var global = require("b82af33fff2c94f");
var isCallable = require("88a0c950d084724a");
var aFunction = function(variable) {
    return isCallable(variable) ? variable : undefined;
};
module.exports = function(namespace, method) {
    return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};

},{"5ce86436bf32f268":"1LE1f","b82af33fff2c94f":"fGEOS","88a0c950d084724a":"ceVMR"}],"1LE1f":[function(require,module,exports) {
module.exports = {};

},{}],"hViWt":[function(require,module,exports) {
var uncurryThis = require("9a688e860c45ac1b");
module.exports = uncurryThis({}.isPrototypeOf);

},{"9a688e860c45ac1b":"jdja0"}],"hakMC":[function(require,module,exports) {
/* eslint-disable es/no-symbol -- required for testing */ var NATIVE_SYMBOL = require("3e80cc2387129063");
module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";

},{"3e80cc2387129063":"6eczE"}],"6eczE":[function(require,module,exports) {
/* eslint-disable es/no-symbol -- required for testing */ var V8_VERSION = require("8ef67a4e16a9a05");
var fails = require("554e60cb57880333");
var global = require("1f1acfd0be6fadd0");
var $String = global.String;
// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
    var symbol = Symbol();
    // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
    // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
    // of course, fail.
    return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});

},{"8ef67a4e16a9a05":"3YYAQ","554e60cb57880333":"fy30P","1f1acfd0be6fadd0":"fGEOS"}],"3YYAQ":[function(require,module,exports) {
var global = require("5f9ef04f45100156");
var userAgent = require("9308a3ec2d4b6088");
var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
    match = v8.split(".");
    // in old Chrome, versions of V8 isn't V8 = Chrome / 10
    // but their correct versions are not interesting for us
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = +match[1];
    }
}
module.exports = version;

},{"5f9ef04f45100156":"fGEOS","9308a3ec2d4b6088":"54Cpt"}],"54Cpt":[function(require,module,exports) {
module.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";

},{}],"lRimi":[function(require,module,exports) {
var aCallable = require("c226d5907093fb2b");
var isNullOrUndefined = require("50ed5918c75a377");
// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function(V, P) {
    var func = V[P];
    return isNullOrUndefined(func) ? undefined : aCallable(func);
};

},{"c226d5907093fb2b":"bBfjy","50ed5918c75a377":"jrvBZ"}],"bBfjy":[function(require,module,exports) {
var isCallable = require("2e095147704c12de");
var tryToString = require("c7f6c3598cc52edb");
var $TypeError = TypeError;
// `Assert: IsCallable(argument) is true`
module.exports = function(argument) {
    if (isCallable(argument)) return argument;
    throw $TypeError(tryToString(argument) + " is not a function");
};

},{"2e095147704c12de":"ceVMR","c7f6c3598cc52edb":"cyFMR"}],"cyFMR":[function(require,module,exports) {
var $String = String;
module.exports = function(argument) {
    try {
        return $String(argument);
    } catch (error) {
        return "Object";
    }
};

},{}],"5jybi":[function(require,module,exports) {
var call = require("2ba40f8c31b692e5");
var isCallable = require("99cd394ce8304fe6");
var isObject = require("d5ad80493164a6f6");
var $TypeError = TypeError;
// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function(input, pref) {
    var fn, val;
    if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
    if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
    if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
    throw $TypeError("Can't convert object to primitive value");
};

},{"2ba40f8c31b692e5":"hzvOQ","99cd394ce8304fe6":"ceVMR","d5ad80493164a6f6":"alLMh"}],"daYw1":[function(require,module,exports) {
var global = require("8dc66fefc7fec4b");
var shared = require("8e95f9ffbd3b8919");
var hasOwn = require("bfa9931dfbe56a2b");
var uid = require("fb50d088f36dbffb");
var NATIVE_SYMBOL = require("90b2dd8ed90531b3");
var USE_SYMBOL_AS_UID = require("50d3eef926131571");
var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol["for"] || Symbol : Symbol && Symbol.withoutSetter || uid;
module.exports = function(name) {
    if (!hasOwn(WellKnownSymbolsStore, name)) WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name) ? Symbol[name] : createWellKnownSymbol("Symbol." + name);
    return WellKnownSymbolsStore[name];
};

},{"8dc66fefc7fec4b":"fGEOS","8e95f9ffbd3b8919":"hlLyd","bfa9931dfbe56a2b":"6CR0z","fb50d088f36dbffb":"5qA7n","90b2dd8ed90531b3":"6eczE","50d3eef926131571":"hakMC"}],"hlLyd":[function(require,module,exports) {
var IS_PURE = require("246556672b90b159");
var store = require("6ce395d8b7d9425");
(module.exports = function(key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
})("versions", []).push({
    version: "3.30.2",
    mode: IS_PURE ? "pure" : "global",
    copyright: "\xa9 2014-2023 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE",
    source: "https://github.com/zloirock/core-js"
});

},{"246556672b90b159":"lOkfM","6ce395d8b7d9425":"kkX3p"}],"lOkfM":[function(require,module,exports) {
module.exports = true;

},{}],"kkX3p":[function(require,module,exports) {
var global = require("325d84e2f3f7fef9");
var defineGlobalProperty = require("a8960bbec763db1d");
var SHARED = "__core-js_shared__";
var store = global[SHARED] || defineGlobalProperty(SHARED, {});
module.exports = store;

},{"325d84e2f3f7fef9":"fGEOS","a8960bbec763db1d":"3l46O"}],"3l46O":[function(require,module,exports) {
var global = require("a307bca43385e632");
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
module.exports = function(key, value) {
    try {
        defineProperty(global, key, {
            value: value,
            configurable: true,
            writable: true
        });
    } catch (error) {
        global[key] = value;
    }
    return value;
};

},{"a307bca43385e632":"fGEOS"}],"6CR0z":[function(require,module,exports) {
var uncurryThis = require("631e82bb0250589a");
var toObject = require("7e48b9c345f8a49c");
var hasOwnProperty = uncurryThis({}.hasOwnProperty);
// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty(toObject(it), key);
};

},{"631e82bb0250589a":"jdja0","7e48b9c345f8a49c":"8ED1J"}],"8ED1J":[function(require,module,exports) {
var requireObjectCoercible = require("c037d4178d2311e2");
var $Object = Object;
// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function(argument) {
    return $Object(requireObjectCoercible(argument));
};

},{"c037d4178d2311e2":"30Lwm"}],"5qA7n":[function(require,module,exports) {
var uncurryThis = require("19cbff12e37d26a3");
var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);
module.exports = function(key) {
    return "Symbol(" + (key === undefined ? "" : key) + ")_" + toString(++id + postfix, 36);
};

},{"19cbff12e37d26a3":"jdja0"}],"kAPtu":[function(require,module,exports) {
var DESCRIPTORS = require("c9c51838dd9e4200");
var fails = require("7aec8c862e2b5536");
var createElement = require("7c821f21811925d6");
// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(createElement("div"), "a", {
        get: function() {
            return 7;
        }
    }).a != 7;
});

},{"c9c51838dd9e4200":"6zWS1","7aec8c862e2b5536":"fy30P","7c821f21811925d6":"5uUco"}],"5uUco":[function(require,module,exports) {
var global = require("871a52583970d5d4");
var isObject = require("d5fbabd25cebab82");
var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);
module.exports = function(it) {
    return EXISTS ? document.createElement(it) : {};
};

},{"871a52583970d5d4":"fGEOS","d5fbabd25cebab82":"alLMh"}],"xJExK":[function(require,module,exports) {
var fails = require("8ddf77376ca8945b");
var isCallable = require("3620b7e39aa0e4d2");
var replacement = /#|\.prototype\./;
var isForced = function(feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
};
var normalize = isForced.normalize = function(string) {
    return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced.data = {};
var NATIVE = isForced.NATIVE = "N";
var POLYFILL = isForced.POLYFILL = "P";
module.exports = isForced;

},{"8ddf77376ca8945b":"fy30P","3620b7e39aa0e4d2":"ceVMR"}],"kjhmo":[function(require,module,exports) {
var uncurryThis = require("50c36d378ce58d8d");
var aCallable = require("bb08df8a909f136");
var NATIVE_BIND = require("5e0d2b1d676a5c25");
var bind = uncurryThis(uncurryThis.bind);
// optional / simple context binding
module.exports = function(fn, that) {
    aCallable(fn);
    return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
    };
};

},{"50c36d378ce58d8d":"LsUO3","bb08df8a909f136":"bBfjy","5e0d2b1d676a5c25":"fTjmV"}],"kRRdZ":[function(require,module,exports) {
var DESCRIPTORS = require("3fe0f69aa1a0656");
var definePropertyModule = require("b1e280fdf078c879");
var createPropertyDescriptor = require("39768f1327dca973");
module.exports = DESCRIPTORS ? function(object, key, value) {
    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
    object[key] = value;
    return object;
};

},{"3fe0f69aa1a0656":"6zWS1","b1e280fdf078c879":"2BHbc","39768f1327dca973":"7Ue8a"}],"2BHbc":[function(require,module,exports) {
var DESCRIPTORS = require("ef7153d7a06d121f");
var IE8_DOM_DEFINE = require("3f816f3d795dbedd");
var V8_PROTOTYPE_DEFINE_BUG = require("14849582ad7d5c8a");
var anObject = require("4c59114d1505930d");
var toPropertyKey = require("76276a153a3656b0");
var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE = "configurable";
var WRITABLE = "writable";
// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
            O[P] = Attributes.value;
            Attributes = {
                configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                writable: false
            };
        }
    }
    return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
    } catch (error) {}
    if ("get" in Attributes || "set" in Attributes) throw $TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
};

},{"ef7153d7a06d121f":"6zWS1","3f816f3d795dbedd":"kAPtu","14849582ad7d5c8a":"1VIjt","4c59114d1505930d":"hjvO5","76276a153a3656b0":"gJLsb"}],"1VIjt":[function(require,module,exports) {
var DESCRIPTORS = require("6a56686906541e72");
var fails = require("8cc1a36ddba33daa");
// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function() {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(function() {}, "prototype", {
        value: 42,
        writable: false
    }).prototype != 42;
});

},{"6a56686906541e72":"6zWS1","8cc1a36ddba33daa":"fy30P"}],"hjvO5":[function(require,module,exports) {
var isObject = require("4f949c1c9c57e4ae");
var $String = String;
var $TypeError = TypeError;
// `Assert: Type(argument) is Object`
module.exports = function(argument) {
    if (isObject(argument)) return argument;
    throw $TypeError($String(argument) + " is not an object");
};

},{"4f949c1c9c57e4ae":"alLMh"}],"gpCyL":[function(require,module,exports) {
var hasOwn = require("5c2dba65f1b198e");
var isCallable = require("5be1a3256e23032a");
var toObject = require("ba4729930725372");
var sharedKey = require("a7bf17a87ad18688");
var CORRECT_PROTOTYPE_GETTER = require("9e35720e40310550");
var IE_PROTO = sharedKey("IE_PROTO");
var $Object = Object;
var ObjectPrototype = $Object.prototype;
// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
    var object = toObject(O);
    if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
    var constructor = object.constructor;
    if (isCallable(constructor) && object instanceof constructor) return constructor.prototype;
    return object instanceof $Object ? ObjectPrototype : null;
};

},{"5c2dba65f1b198e":"6CR0z","5be1a3256e23032a":"ceVMR","ba4729930725372":"8ED1J","a7bf17a87ad18688":"fDz6R","9e35720e40310550":"iVl5P"}],"fDz6R":[function(require,module,exports) {
var shared = require("7225717a2d1a4899");
var uid = require("93c2ef1a8fd784ed");
var keys = shared("keys");
module.exports = function(key) {
    return keys[key] || (keys[key] = uid(key));
};

},{"7225717a2d1a4899":"hlLyd","93c2ef1a8fd784ed":"5qA7n"}],"iVl5P":[function(require,module,exports) {
var fails = require("75105eeb0a922a63");
module.exports = !fails(function() {
    function F() {}
    F.prototype.constructor = null;
    // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
    return Object.getPrototypeOf(new F()) !== F.prototype;
});

},{"75105eeb0a922a63":"fy30P"}],"dBbtF":[function(require,module,exports) {
/* eslint-disable no-proto -- safe */ var uncurryThisAccessor = require("8a14a3b6944e7749");
var anObject = require("a267024ae0a38bb9");
var aPossiblePrototype = require("2b8cf8312b7a9591");
// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
    } catch (error) {}
    return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER) setter(O, proto);
        else O.__proto__ = proto;
        return O;
    };
}() : undefined);

},{"8a14a3b6944e7749":"i4qdR","a267024ae0a38bb9":"hjvO5","2b8cf8312b7a9591":"8fWXS"}],"i4qdR":[function(require,module,exports) {
var uncurryThis = require("aeb9b612ae67db84");
var aCallable = require("32a1cacd96765622");
module.exports = function(object, key, method) {
    try {
        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
    } catch (error) {}
};

},{"aeb9b612ae67db84":"jdja0","32a1cacd96765622":"bBfjy"}],"8fWXS":[function(require,module,exports) {
var isCallable = require("5545f933bff660d9");
var $String = String;
var $TypeError = TypeError;
module.exports = function(argument) {
    if (typeof argument == "object" || isCallable(argument)) return argument;
    throw $TypeError("Can't set " + $String(argument) + " as a prototype");
};

},{"5545f933bff660d9":"ceVMR"}],"3IFAs":[function(require,module,exports) {
var hasOwn = require("4402e9899506fcbf");
var ownKeys = require("f3fcff225de76ca1");
var getOwnPropertyDescriptorModule = require("1f516a9f181b1a73");
var definePropertyModule = require("d6e61304ff62d018");
module.exports = function(target, source, exceptions) {
    var keys = ownKeys(source);
    var defineProperty = definePropertyModule.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
};

},{"4402e9899506fcbf":"6CR0z","f3fcff225de76ca1":"d6zL8","1f516a9f181b1a73":"6zTL3","d6e61304ff62d018":"2BHbc"}],"d6zL8":[function(require,module,exports) {
var getBuiltIn = require("df612c0e5df8cf40");
var uncurryThis = require("197280d54aa9630a");
var getOwnPropertyNamesModule = require("bbdb37d5a984679e");
var getOwnPropertySymbolsModule = require("2acd4a361feaf893");
var anObject = require("be4308b166e918e9");
var concat = uncurryThis([].concat);
// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule.f(anObject(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};

},{"df612c0e5df8cf40":"er1gl","197280d54aa9630a":"jdja0","bbdb37d5a984679e":"fvowa","2acd4a361feaf893":"hIzX6","be4308b166e918e9":"hjvO5"}],"fvowa":[function(require,module,exports) {
var internalObjectKeys = require("2b43a4e7f50ab5aa");
var enumBugKeys = require("ee3716e9a0f86662");
var hiddenKeys = enumBugKeys.concat("length", "prototype");
// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys);
};

},{"2b43a4e7f50ab5aa":"a7ONk","ee3716e9a0f86662":"8EemN"}],"a7ONk":[function(require,module,exports) {
var uncurryThis = require("ff2aec50c9f8fa21");
var hasOwn = require("c769f8562f7ce869");
var toIndexedObject = require("696f470870859173");
var indexOf = require("e5b63e30a33f8edb").indexOf;
var hiddenKeys = require("b5cbbbf03561e6dc");
var push = uncurryThis([].push);
module.exports = function(object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for(key in O)!hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
    // Don't enum bug & hidden keys
    while(names.length > i)if (hasOwn(O, key = names[i++])) ~indexOf(result, key) || push(result, key);
    return result;
};

},{"ff2aec50c9f8fa21":"jdja0","c769f8562f7ce869":"6CR0z","696f470870859173":"d6f5x","e5b63e30a33f8edb":"lGApG","b5cbbbf03561e6dc":"eKxwq"}],"lGApG":[function(require,module,exports) {
var toIndexedObject = require("204b8bdb6450956");
var toAbsoluteIndex = require("9cb69ef0a4854992");
var lengthOfArrayLike = require("a8c72c120185a270");
// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare -- NaN check
        if (IS_INCLUDES && el != el) while(length > index){
            value = O[index++];
            // eslint-disable-next-line no-self-compare -- NaN check
            if (value != value) return true;
        // Array#indexOf ignores holes, Array#includes - not
        }
        else for(; length > index; index++){
            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
    };
};
module.exports = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
};

},{"204b8bdb6450956":"d6f5x","9cb69ef0a4854992":"6Zg5O","a8c72c120185a270":"fbXJZ"}],"6Zg5O":[function(require,module,exports) {
var toIntegerOrInfinity = require("5012bb7c6c5f3b05");
var max = Math.max;
var min = Math.min;
// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function(index, length) {
    var integer = toIntegerOrInfinity(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

},{"5012bb7c6c5f3b05":"fHl6c"}],"fHl6c":[function(require,module,exports) {
var trunc = require("c7a1e5ed126b20dc");
// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function(argument) {
    var number = +argument;
    // eslint-disable-next-line no-self-compare -- NaN check
    return number !== number || number === 0 ? 0 : trunc(number);
};

},{"c7a1e5ed126b20dc":"gbA7Q"}],"gbA7Q":[function(require,module,exports) {
var ceil = Math.ceil;
var floor = Math.floor;
// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
    var n = +x;
    return (n > 0 ? floor : ceil)(n);
};

},{}],"fbXJZ":[function(require,module,exports) {
var toLength = require("764864721370fb5f");
// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function(obj) {
    return toLength(obj.length);
};

},{"764864721370fb5f":"4lh3h"}],"4lh3h":[function(require,module,exports) {
var toIntegerOrInfinity = require("50df5feaa5c5e27c");
var min = Math.min;
// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function(argument) {
    return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

},{"50df5feaa5c5e27c":"fHl6c"}],"eKxwq":[function(require,module,exports) {
module.exports = {};

},{}],"8EemN":[function(require,module,exports) {
// IE8- don't enum bug keys
module.exports = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
];

},{}],"hIzX6":[function(require,module,exports) {
// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;

},{}],"ib5ns":[function(require,module,exports) {
/* global ActiveXObject -- old IE, WSH */ var anObject = require("89c0bfa637de29ce");
var definePropertiesModule = require("62d11f59c713a87d");
var enumBugKeys = require("b8a095a46b849439");
var hiddenKeys = require("fb6ad2bf4eb974f0");
var html = require("3b3c00550bdbf40f");
var documentCreateElement = require("56afc1e432586794");
var sharedKey = require("15f83fc49275b059");
var GT = ">";
var LT = "<";
var PROTOTYPE = "prototype";
var SCRIPT = "script";
var IE_PROTO = sharedKey("IE_PROTO");
var EmptyConstructor = function() {};
var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function(activeXDocument) {
    activeXDocument.write(scriptTag(""));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak
    return temp;
};
// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement("iframe");
    var JS = "java" + SCRIPT + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
};
// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function() {
    try {
        activeXDocument = new ActiveXObject("htmlfile");
    } catch (error) {}
    NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
     : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH
    var length = enumBugKeys.length;
    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
};
hiddenKeys[IE_PROTO] = true;
// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        // add "__proto__" for Object.getPrototypeOf polyfill
        result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};

},{"89c0bfa637de29ce":"hjvO5","62d11f59c713a87d":"1DPCs","b8a095a46b849439":"8EemN","fb6ad2bf4eb974f0":"eKxwq","3b3c00550bdbf40f":"9Hw6G","56afc1e432586794":"5uUco","15f83fc49275b059":"fDz6R"}],"1DPCs":[function(require,module,exports) {
var DESCRIPTORS = require("e880ea98320fae7a");
var V8_PROTOTYPE_DEFINE_BUG = require("32c9b9d26dd80554");
var definePropertyModule = require("de88b713ccdae160");
var anObject = require("1ec5d06a1075e80a");
var toIndexedObject = require("445b91bdb9c9c7dd");
var objectKeys = require("13b69d165c12cbe9");
// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var props = toIndexedObject(Properties);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while(length > index)definePropertyModule.f(O, key = keys[index++], props[key]);
    return O;
};

},{"e880ea98320fae7a":"6zWS1","32c9b9d26dd80554":"1VIjt","de88b713ccdae160":"2BHbc","1ec5d06a1075e80a":"hjvO5","445b91bdb9c9c7dd":"d6f5x","13b69d165c12cbe9":"dXSLy"}],"dXSLy":[function(require,module,exports) {
var internalObjectKeys = require("772ac4b250876c9e");
var enumBugKeys = require("5bd7095a18e9a0fe");
// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
    return internalObjectKeys(O, enumBugKeys);
};

},{"772ac4b250876c9e":"a7ONk","5bd7095a18e9a0fe":"8EemN"}],"9Hw6G":[function(require,module,exports) {
var getBuiltIn = require("c390d8f8a08e6cb5");
module.exports = getBuiltIn("document", "documentElement");

},{"c390d8f8a08e6cb5":"er1gl"}],"75fqZ":[function(require,module,exports) {
var isObject = require("5303bbfbc460a3ac");
var createNonEnumerableProperty = require("2e2cd7ebb527c6e4");
// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
module.exports = function(O, options) {
    if (isObject(options) && "cause" in options) createNonEnumerableProperty(O, "cause", options.cause);
};

},{"5303bbfbc460a3ac":"alLMh","2e2cd7ebb527c6e4":"kRRdZ"}],"95bJ4":[function(require,module,exports) {
var createNonEnumerableProperty = require("d95bf2cdd9998d72");
var clearErrorStack = require("c92234d110eab9aa");
var ERROR_STACK_INSTALLABLE = require("9c9b308e5d68e6cb");
// non-standard V8
var captureStackTrace = Error.captureStackTrace;
module.exports = function(error, C, stack, dropEntries) {
    if (ERROR_STACK_INSTALLABLE) {
        if (captureStackTrace) captureStackTrace(error, C);
        else createNonEnumerableProperty(error, "stack", clearErrorStack(stack, dropEntries));
    }
};

},{"d95bf2cdd9998d72":"kRRdZ","c92234d110eab9aa":"iM72U","9c9b308e5d68e6cb":"fq1NG"}],"iM72U":[function(require,module,exports) {
var uncurryThis = require("4de16048e7fee86e");
var $Error = Error;
var replace = uncurryThis("".replace);
var TEST = function(arg) {
    return String($Error(arg).stack);
}("zxcasd");
// eslint-disable-next-line redos/no-vulnerable -- safe
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
module.exports = function(stack, dropEntries) {
    if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) while(dropEntries--)stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
    return stack;
};

},{"4de16048e7fee86e":"jdja0"}],"fq1NG":[function(require,module,exports) {
var fails = require("76361b94b15d4290");
var createPropertyDescriptor = require("ab2b801155d774d3");
module.exports = !fails(function() {
    var error = Error("a");
    if (!("stack" in error)) return true;
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
    return error.stack !== 7;
});

},{"76361b94b15d4290":"fy30P","ab2b801155d774d3":"7Ue8a"}],"9aBKZ":[function(require,module,exports) {
var bind = require("64e8bd8c0db98957");
var call = require("54367bdda0623fc3");
var anObject = require("af25b54ab7989040");
var tryToString = require("562ebdd47d12a958");
var isArrayIteratorMethod = require("ce4564a475e868bc");
var lengthOfArrayLike = require("f1f4661dd417e464");
var isPrototypeOf = require("ce94e288bb2fc2a5");
var getIterator = require("4d4d66ecbac18d11");
var getIteratorMethod = require("30a05616831ac6ee");
var iteratorClose = require("51c0b67c4d3f558");
var $TypeError = TypeError;
var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
};
var ResultPrototype = Result.prototype;
module.exports = function(iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_RECORD = !!(options && options.IS_RECORD);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;
    var stop = function(condition) {
        if (iterator) iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
    };
    var callFn = function(value) {
        if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
    };
    if (IS_RECORD) iterator = iterable.iterator;
    else if (IS_ITERATOR) iterator = iterable;
    else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn) throw $TypeError(tryToString(iterable) + " is not iterable");
        // optimisation for array iterators
        if (isArrayIteratorMethod(iterFn)) {
            for(index = 0, length = lengthOfArrayLike(iterable); length > index; index++){
                result = callFn(iterable[index]);
                if (result && isPrototypeOf(ResultPrototype, result)) return result;
            }
            return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
    }
    next = IS_RECORD ? iterable.next : iterator.next;
    while(!(step = call(next, iterator)).done){
        try {
            result = callFn(step.value);
        } catch (error) {
            iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
    }
    return new Result(false);
};

},{"64e8bd8c0db98957":"kjhmo","54367bdda0623fc3":"hzvOQ","af25b54ab7989040":"hjvO5","562ebdd47d12a958":"cyFMR","ce4564a475e868bc":"gWE61","f1f4661dd417e464":"fbXJZ","ce94e288bb2fc2a5":"hViWt","4d4d66ecbac18d11":"6cvcE","30a05616831ac6ee":"45EQX","51c0b67c4d3f558":"8SZwX"}],"gWE61":[function(require,module,exports) {
var wellKnownSymbol = require("15b82a6380a3c672");
var Iterators = require("e1c02770bf9a20e");
var ITERATOR = wellKnownSymbol("iterator");
var ArrayPrototype = Array.prototype;
// check on default Array iterator
module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

},{"15b82a6380a3c672":"daYw1","e1c02770bf9a20e":"6Lzpr"}],"6Lzpr":[function(require,module,exports) {
module.exports = {};

},{}],"6cvcE":[function(require,module,exports) {
var call = require("3e97beb6bc140f7c");
var aCallable = require("c42d35de56beba1e");
var anObject = require("9e4170e3e1e4fc89");
var tryToString = require("1cbc1167c164b02b");
var getIteratorMethod = require("985d3223a8908c3");
var $TypeError = TypeError;
module.exports = function(argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
    if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
    throw $TypeError(tryToString(argument) + " is not iterable");
};

},{"3e97beb6bc140f7c":"hzvOQ","c42d35de56beba1e":"bBfjy","9e4170e3e1e4fc89":"hjvO5","1cbc1167c164b02b":"cyFMR","985d3223a8908c3":"45EQX"}],"45EQX":[function(require,module,exports) {
var classof = require("b90bc128da44cdeb");
var getMethod = require("cea6cc4fae5b04d3");
var isNullOrUndefined = require("3736f2edfd50a3c1");
var Iterators = require("b7b78c992cb04b87");
var wellKnownSymbol = require("4d08c982b5174e76");
var ITERATOR = wellKnownSymbol("iterator");
module.exports = function(it) {
    if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
};

},{"b90bc128da44cdeb":"bi28n","cea6cc4fae5b04d3":"lRimi","3736f2edfd50a3c1":"jrvBZ","b7b78c992cb04b87":"6Lzpr","4d08c982b5174e76":"daYw1"}],"bi28n":[function(require,module,exports) {
var TO_STRING_TAG_SUPPORT = require("fea2df1490efcc30");
var isCallable = require("20dde67365e21ed9");
var classofRaw = require("1376d036560639f0");
var wellKnownSymbol = require("3c0308c4d801d08e");
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
var $Object = Object;
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function() {
    return arguments;
}()) == "Arguments";
// fallback for IE11 Script Access Denied error
var tryGet = function(it, key) {
    try {
        return it[key];
    } catch (error) {}
};
// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
    var O, tag, result;
    return it === undefined ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
};

},{"fea2df1490efcc30":"41m2j","20dde67365e21ed9":"ceVMR","1376d036560639f0":"5grTi","3c0308c4d801d08e":"daYw1"}],"41m2j":[function(require,module,exports) {
var wellKnownSymbol = require("4bcbf3614097c9e5");
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
var test = {};
test[TO_STRING_TAG] = "z";
module.exports = String(test) === "[object z]";

},{"4bcbf3614097c9e5":"daYw1"}],"8SZwX":[function(require,module,exports) {
var call = require("b32d8051c5952129");
var anObject = require("ecb7e1ce93959b03");
var getMethod = require("8429d67a4577db5b");
module.exports = function(iterator, kind, value) {
    var innerResult, innerError;
    anObject(iterator);
    try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
            if (kind === "throw") throw value;
            return value;
        }
        innerResult = call(innerResult, iterator);
    } catch (error) {
        innerError = true;
        innerResult = error;
    }
    if (kind === "throw") throw value;
    if (innerError) throw innerResult;
    anObject(innerResult);
    return value;
};

},{"b32d8051c5952129":"hzvOQ","ecb7e1ce93959b03":"hjvO5","8429d67a4577db5b":"lRimi"}],"bhj1E":[function(require,module,exports) {
var toString = require("dc689acffb123ddf");
module.exports = function(argument, $default) {
    return argument === undefined ? arguments.length < 2 ? "" : $default : toString(argument);
};

},{"dc689acffb123ddf":"kFn6x"}],"kFn6x":[function(require,module,exports) {
var classof = require("126970f670cde1b0");
var $String = String;
module.exports = function(argument) {
    if (classof(argument) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
    return $String(argument);
};

},{"126970f670cde1b0":"bi28n"}],"eISyY":[function(require,module,exports) {
"use strict";
var toIndexedObject = require("3f334318a39c6361");
var addToUnscopables = require("acb8fbc47a13fc81");
var Iterators = require("b15c3b6faf401113");
var InternalStateModule = require("b13bc26e0b1612e2");
var defineProperty = require("9c23d11413b1580a").f;
var defineIterator = require("ecade94a0aabc68e");
var createIterResultObject = require("56d357bdec026615");
var IS_PURE = require("9fc909784f8c599d");
var DESCRIPTORS = require("b4357fb26cef6afa");
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, "Array", function(iterated, kind) {
    setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        index: 0,
        kind: kind // kind
    });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function() {
    var state = getInternalState(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
        state.target = undefined;
        return createIterResultObject(undefined, true);
    }
    if (kind == "keys") return createIterResultObject(index, false);
    if (kind == "values") return createIterResultObject(target[index], false);
    return createIterResultObject([
        index,
        target[index]
    ], false);
}, "values");
// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables("keys");
addToUnscopables("values");
addToUnscopables("entries");
// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== "values") try {
    defineProperty(values, "name", {
        value: "values"
    });
} catch (error) {}

},{"3f334318a39c6361":"d6f5x","acb8fbc47a13fc81":"2SZ85","b15c3b6faf401113":"6Lzpr","b13bc26e0b1612e2":"9cm4f","9c23d11413b1580a":"2BHbc","ecade94a0aabc68e":"lQWIf","56d357bdec026615":"4bxgP","9fc909784f8c599d":"lOkfM","b4357fb26cef6afa":"6zWS1"}],"2SZ85":[function(require,module,exports) {
module.exports = function() {};

},{}],"9cm4f":[function(require,module,exports) {
var NATIVE_WEAK_MAP = require("cdbc2453c6189207");
var global = require("90a9779d2e535f75");
var isObject = require("3a3c45a61d543ce5");
var createNonEnumerableProperty = require("27dd7c2b3174fa08");
var hasOwn = require("aabbfec99126fee4");
var shared = require("d4ce68eaf3c0fb58");
var sharedKey = require("4c52a80580ae363a");
var hiddenKeys = require("ad0167e43116be61");
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;
var enforce = function(it) {
    return has(it) ? get(it) : set(it, {});
};
var getterFor = function(TYPE) {
    return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required");
        return state;
    };
};
if (NATIVE_WEAK_MAP || shared.state) {
    var store = shared.state || (shared.state = new WeakMap());
    /* eslint-disable no-self-assign -- prototype methods protection */ store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    /* eslint-enable no-self-assign -- prototype methods protection */ set = function(it, metadata) {
        if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
    };
    get = function(it) {
        return store.get(it) || {};
    };
    has = function(it) {
        return store.has(it);
    };
} else {
    var STATE = sharedKey("state");
    hiddenKeys[STATE] = true;
    set = function(it, metadata) {
        if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
    };
    get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
    };
    has = function(it) {
        return hasOwn(it, STATE);
    };
}
module.exports = {
    set: set,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
};

},{"cdbc2453c6189207":"llXAC","90a9779d2e535f75":"fGEOS","3a3c45a61d543ce5":"alLMh","27dd7c2b3174fa08":"kRRdZ","aabbfec99126fee4":"6CR0z","d4ce68eaf3c0fb58":"kkX3p","4c52a80580ae363a":"fDz6R","ad0167e43116be61":"eKxwq"}],"llXAC":[function(require,module,exports) {
var global = require("5aee97cabc08d6e");
var isCallable = require("5f3ddcad41434590");
var WeakMap = global.WeakMap;
module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));

},{"5aee97cabc08d6e":"fGEOS","5f3ddcad41434590":"ceVMR"}],"lQWIf":[function(require,module,exports) {
"use strict";
var $ = require("b8f22b47a257d7f");
var call = require("f0b720c76bfa6fac");
var IS_PURE = require("8c8c53c62a129cbd");
var FunctionName = require("b2d149bfca665971");
var isCallable = require("fb00ab883f1defd1");
var createIteratorConstructor = require("2ffa8ef3d974598");
var getPrototypeOf = require("3fce4bf2dac15791");
var setPrototypeOf = require("d38d210f188f5cbc");
var setToStringTag = require("881706ee4619f801");
var createNonEnumerableProperty = require("c1166e5136f7651f");
var defineBuiltIn = require("1cdf44bc23d3c023");
var wellKnownSymbol = require("c53d2fab41e2a737");
var Iterators = require("8ad0929f13fbd5ff");
var IteratorsCore = require("7d087a5be3234ee8");
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
    return this;
};
module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);
    var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch(KIND){
            case KEYS:
                return function keys() {
                    return new IteratorConstructor(this, KIND);
                };
            case VALUES:
                return function values() {
                    return new IteratorConstructor(this, KIND);
                };
            case ENTRIES:
                return function entries() {
                    return new IteratorConstructor(this, KIND);
                };
        }
        return function() {
            return new IteratorConstructor(this);
        };
    };
    var TO_STRING_TAG = NAME + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    // fix native
    if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf) setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
            // Set @@toStringTag to native iterators
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
    }
    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
    if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        else {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
                return call(nativeIterator, this);
            };
        }
    }
    // export additional methods
    if (DEFAULT) {
        methods = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) {
            for(KEY in methods)if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
        } else $({
            target: NAME,
            proto: true,
            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
        }, methods);
    }
    // define iterator
    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, {
        name: DEFAULT
    });
    Iterators[NAME] = defaultIterator;
    return methods;
};

},{"b8f22b47a257d7f":"6O4uB","f0b720c76bfa6fac":"hzvOQ","8c8c53c62a129cbd":"lOkfM","b2d149bfca665971":"23R67","fb00ab883f1defd1":"ceVMR","2ffa8ef3d974598":"c8uW1","3fce4bf2dac15791":"gpCyL","d38d210f188f5cbc":"dBbtF","881706ee4619f801":"3UI75","c1166e5136f7651f":"kRRdZ","1cdf44bc23d3c023":"2VbqH","c53d2fab41e2a737":"daYw1","8ad0929f13fbd5ff":"6Lzpr","7d087a5be3234ee8":"5w0wE"}],"23R67":[function(require,module,exports) {
var DESCRIPTORS = require("3928f2d4678f7af9");
var hasOwn = require("cc984a435dd714a1");
var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn(FunctionPrototype, "name");
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() {}).name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
module.exports = {
    EXISTS: EXISTS,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE
};

},{"3928f2d4678f7af9":"6zWS1","cc984a435dd714a1":"6CR0z"}],"c8uW1":[function(require,module,exports) {
"use strict";
var IteratorPrototype = require("6213b15ffb1c892f").IteratorPrototype;
var create = require("b9d4d9a12662f9ce");
var createPropertyDescriptor = require("b0f840f44ec5a2f9");
var setToStringTag = require("a1cd6d6a243b5bfa");
var Iterators = require("c830a302b2b1713e");
var returnThis = function() {
    return this;
};
module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + " Iterator";
    IteratorConstructor.prototype = create(IteratorPrototype, {
        next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next)
    });
    setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators[TO_STRING_TAG] = returnThis;
    return IteratorConstructor;
};

},{"6213b15ffb1c892f":"5w0wE","b9d4d9a12662f9ce":"ib5ns","b0f840f44ec5a2f9":"7Ue8a","a1cd6d6a243b5bfa":"3UI75","c830a302b2b1713e":"6Lzpr"}],"5w0wE":[function(require,module,exports) {
"use strict";
var fails = require("706b4ad8ef194dfc");
var isCallable = require("2ab75b24343b7ee7");
var isObject = require("c9389ee60b9c9584");
var create = require("a5629ab1b0971ade");
var getPrototypeOf = require("56823eee5ab22857");
var defineBuiltIn = require("db58a3f5a11844dd");
var wellKnownSymbol = require("1a8b3dd45e0639c4");
var IS_PURE = require("1294ff96ab9aeb75");
var ITERATOR = wellKnownSymbol("iterator");
var BUGGY_SAFARI_ITERATORS = false;
// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
/* eslint-disable es/no-array-prototype-keys -- safe */ if ([].keys) {
    arrayIterator = [].keys();
    // Safari 8 has buggy iterators w/o `next`
    if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
    else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
}
var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
    var test = {};
    // FF44- legacy iterators case
    return IteratorPrototype[ITERATOR].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) defineBuiltIn(IteratorPrototype, ITERATOR, function() {
    return this;
});
module.exports = {
    IteratorPrototype: IteratorPrototype,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

},{"706b4ad8ef194dfc":"fy30P","2ab75b24343b7ee7":"ceVMR","c9389ee60b9c9584":"alLMh","a5629ab1b0971ade":"ib5ns","56823eee5ab22857":"gpCyL","db58a3f5a11844dd":"2VbqH","1a8b3dd45e0639c4":"daYw1","1294ff96ab9aeb75":"lOkfM"}],"2VbqH":[function(require,module,exports) {
var createNonEnumerableProperty = require("2e8556e7f31a26e6");
module.exports = function(target, key, value, options) {
    if (options && options.enumerable) target[key] = value;
    else createNonEnumerableProperty(target, key, value);
    return target;
};

},{"2e8556e7f31a26e6":"kRRdZ"}],"3UI75":[function(require,module,exports) {
var TO_STRING_TAG_SUPPORT = require("408a0d97c60a10ed");
var defineProperty = require("41f1ad552d1808ea").f;
var createNonEnumerableProperty = require("92a7601cc0e86d");
var hasOwn = require("16a1597ce974231e");
var toString = require("3dc32778abb4609a");
var wellKnownSymbol = require("8283aab86786dfd0");
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
module.exports = function(it, TAG, STATIC, SET_METHOD) {
    if (it) {
        var target = STATIC ? it : it.prototype;
        if (!hasOwn(target, TO_STRING_TAG)) defineProperty(target, TO_STRING_TAG, {
            configurable: true,
            value: TAG
        });
        if (SET_METHOD && !TO_STRING_TAG_SUPPORT) createNonEnumerableProperty(target, "toString", toString);
    }
};

},{"408a0d97c60a10ed":"41m2j","41f1ad552d1808ea":"2BHbc","92a7601cc0e86d":"kRRdZ","16a1597ce974231e":"6CR0z","3dc32778abb4609a":"arL9r","8283aab86786dfd0":"daYw1"}],"arL9r":[function(require,module,exports) {
"use strict";
var TO_STRING_TAG_SUPPORT = require("20d002d447a8441b");
var classof = require("6ba6a5ae32b12203");
// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? ({}).toString : function toString() {
    return "[object " + classof(this) + "]";
};

},{"20d002d447a8441b":"41m2j","6ba6a5ae32b12203":"bi28n"}],"4bxgP":[function(require,module,exports) {
// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function(value, done) {
    return {
        value: value,
        done: done
    };
};

},{}],"khsXc":[function(require,module,exports) {
// empty

},{}],"NDL2A":[function(require,module,exports) {
// TODO: Remove this module from `core-js@4` since it's split to modules listed below
require("5e4140cfbc27ddeb");
require("6304a1ed1275594b");
require("ec061c62d98c6f70");
require("1fb556d8168cd0d8");
require("a10f2f508dbb0d25");
require("57ec0e5a9c5dd540");

},{"5e4140cfbc27ddeb":"fwle6","6304a1ed1275594b":"46eyo","ec061c62d98c6f70":"ah46Q","1fb556d8168cd0d8":"c5ogP","a10f2f508dbb0d25":"bbxgt","57ec0e5a9c5dd540":"73ont"}],"fwle6":[function(require,module,exports) {
"use strict";
var $ = require("73b56210729b8d6b");
var IS_PURE = require("9e449b5d5ec8d4c9");
var IS_NODE = require("c09c80093be3c424");
var global = require("8bd00aa9d484caa7");
var call = require("c4a383bd0abdab19");
var defineBuiltIn = require("41d5e76a1583b53d");
var setPrototypeOf = require("615f08ba0aa78de1");
var setToStringTag = require("70b1cbf37888a49");
var setSpecies = require("9aaa1925c21aa3c3");
var aCallable = require("53dfcf0406a656db");
var isCallable = require("efa4358e7581766e");
var isObject = require("542185f84fae5c2d");
var anInstance = require("d8b233a7dcc03fdb");
var speciesConstructor = require("1ab99ab46941492c");
var task = require("2da6ef4c887ed4c2").set;
var microtask = require("2f123f380bab23c0");
var hostReportErrors = require("ea6022e576534850");
var perform = require("4c7f47fb1603d722");
var Queue = require("3413dc02521573de");
var InternalStateModule = require("cd2f26d7931e7d7b");
var NativePromiseConstructor = require("128e8da7976ea8e5");
var PromiseConstructorDetection = require("4fe4ba86a2a81b40");
var newPromiseCapabilityModule = require("86103e3dadc44975");
var PROMISE = "Promise";
var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var PromiseConstructor = NativePromiseConstructor;
var PromisePrototype = NativePromisePrototype;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
// helpers
var isThenable = function(it) {
    var then;
    return isObject(it) && isCallable(then = it.then) ? then : false;
};
var callReaction = function(reaction, state) {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var handler = ok ? reaction.ok : reaction.fail;
    var resolve = reaction.resolve;
    var reject = reaction.reject;
    var domain = reaction.domain;
    var result, then, exited;
    try {
        if (handler) {
            if (!ok) {
                if (state.rejection === UNHANDLED) onHandleUnhandled(state);
                state.rejection = HANDLED;
            }
            if (handler === true) result = value;
            else {
                if (domain) domain.enter();
                result = handler(value); // can throw
                if (domain) {
                    domain.exit();
                    exited = true;
                }
            }
            if (result === reaction.promise) reject(TypeError("Promise-chain cycle"));
            else if (then = isThenable(result)) call(then, result, resolve, reject);
            else resolve(result);
        } else reject(value);
    } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
    }
};
var notify = function(state, isReject) {
    if (state.notified) return;
    state.notified = true;
    microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while(reaction = reactions.get())callReaction(reaction, state);
        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(state);
    });
};
var dispatchEvent = function(name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
        event = document.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global.dispatchEvent(event);
    } else event = {
        promise: promise,
        reason: reason
    };
    if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global["on" + name])) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors("Unhandled promise rejection", reason);
};
var onUnhandled = function(state) {
    call(task, global, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
            result = perform(function() {
                if (IS_NODE) process.emit("unhandledRejection", value, promise);
                else dispatchEvent(UNHANDLED_REJECTION, promise, value);
            });
            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
            if (result.error) throw result.value;
        }
    });
};
var isUnhandled = function(state) {
    return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
    call(task, global, function() {
        var promise = state.facade;
        if (IS_NODE) process.emit("rejectionHandled", promise);
        else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
};
var bind = function(fn, state, unwrap) {
    return function(value) {
        fn(state, value, unwrap);
    };
};
var internalReject = function(state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify(state, true);
};
var internalResolve = function(state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
        if (state.facade === value) throw TypeError("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) microtask(function() {
            var wrapper = {
                done: false
            };
            try {
                call(then, value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
            } catch (error) {
                internalReject(wrapper, error, state);
            }
        });
        else {
            state.value = value;
            state.state = FULFILLED;
            notify(state, false);
        }
    } catch (error) {
        internalReject({
            done: false
        }, error, state);
    }
};
// constructor polyfill
if (FORCED_PROMISE_CONSTRUCTOR) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalPromiseState(this);
        try {
            executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
            internalReject(state, error);
        }
    };
    PromisePrototype = PromiseConstructor.prototype;
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    Internal = function Promise(executor) {
        setInternalState(this, {
            type: PROMISE,
            done: false,
            notified: false,
            parent: false,
            reactions: new Queue(),
            rejection: false,
            state: PENDING,
            value: undefined
        });
    };
    // `Promise.prototype.then` method
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process.domain : undefined;
        if (state.state == PENDING) state.reactions.add(reaction);
        else microtask(function() {
            callReaction(reaction, state);
        });
        return reaction.promise;
    });
    OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };
    if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!NATIVE_PROMISE_SUBCLASSING) // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
        defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
                call(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
        // https://github.com/zloirock/core-js/issues/640
        }, {
            unsafe: true
        });
        // make `.constructor === Promise` work for native promise-based APIs
        try {
            delete NativePromisePrototype.constructor;
        } catch (error) {}
        // make `instanceof Promise` work for native promise-based APIs
        if (setPrototypeOf) setPrototypeOf(NativePromisePrototype, PromisePrototype);
    }
}
$({
    global: true,
    constructor: true,
    wrap: true,
    forced: FORCED_PROMISE_CONSTRUCTOR
}, {
    Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

},{"73b56210729b8d6b":"6O4uB","9e449b5d5ec8d4c9":"lOkfM","c09c80093be3c424":"lNKCY","8bd00aa9d484caa7":"fGEOS","c4a383bd0abdab19":"hzvOQ","41d5e76a1583b53d":"2VbqH","615f08ba0aa78de1":"dBbtF","70b1cbf37888a49":"3UI75","9aaa1925c21aa3c3":"aowCG","53dfcf0406a656db":"bBfjy","efa4358e7581766e":"ceVMR","542185f84fae5c2d":"alLMh","d8b233a7dcc03fdb":"cKM0r","1ab99ab46941492c":"h5qMg","2da6ef4c887ed4c2":"i55vS","2f123f380bab23c0":"csyb4","ea6022e576534850":"6FRLW","4c7f47fb1603d722":"aOW9Q","3413dc02521573de":"7CWIJ","cd2f26d7931e7d7b":"9cm4f","128e8da7976ea8e5":"9Sqnz","4fe4ba86a2a81b40":"93il6","86103e3dadc44975":"9k2ug"}],"lNKCY":[function(require,module,exports) {
var process = require("7e668b1819efdc47");
var classof = require("5b30f4d110766795");
module.exports = typeof process != "undefined" && classof(process) == "process";

},{"7e668b1819efdc47":"1htrR","5b30f4d110766795":"5grTi"}],"aowCG":[function(require,module,exports) {
"use strict";
var getBuiltIn = require("9acc34179e7dd77c");
var defineBuiltInAccessor = require("c2c406b0bf0d6d0b");
var wellKnownSymbol = require("82c85c2b53efee2");
var DESCRIPTORS = require("e756d9a99411b873");
var SPECIES = wellKnownSymbol("species");
module.exports = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) defineBuiltInAccessor(Constructor, SPECIES, {
        configurable: true,
        get: function() {
            return this;
        }
    });
};

},{"9acc34179e7dd77c":"er1gl","c2c406b0bf0d6d0b":"g0Rue","82c85c2b53efee2":"daYw1","e756d9a99411b873":"6zWS1"}],"g0Rue":[function(require,module,exports) {
var defineProperty = require("b16235f26daea82d");
module.exports = function(target, name, descriptor) {
    return defineProperty.f(target, name, descriptor);
};

},{"b16235f26daea82d":"2BHbc"}],"cKM0r":[function(require,module,exports) {
var isPrototypeOf = require("97a1283c18c6a889");
var $TypeError = TypeError;
module.exports = function(it, Prototype) {
    if (isPrototypeOf(Prototype, it)) return it;
    throw $TypeError("Incorrect invocation");
};

},{"97a1283c18c6a889":"hViWt"}],"h5qMg":[function(require,module,exports) {
var anObject = require("fb462b37209c23f6");
var aConstructor = require("efbcb4dfe291909a");
var isNullOrUndefined = require("13542f2f3a55a4f0");
var wellKnownSymbol = require("2595650a4a88f89b");
var SPECIES = wellKnownSymbol("species");
// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function(O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
};

},{"fb462b37209c23f6":"hjvO5","efbcb4dfe291909a":"2QyaJ","13542f2f3a55a4f0":"jrvBZ","2595650a4a88f89b":"daYw1"}],"2QyaJ":[function(require,module,exports) {
var isConstructor = require("9399ce30dd2ca9c0");
var tryToString = require("57cce768d58e11f8");
var $TypeError = TypeError;
// `Assert: IsConstructor(argument) is true`
module.exports = function(argument) {
    if (isConstructor(argument)) return argument;
    throw $TypeError(tryToString(argument) + " is not a constructor");
};

},{"9399ce30dd2ca9c0":"2BlAj","57cce768d58e11f8":"cyFMR"}],"2BlAj":[function(require,module,exports) {
var uncurryThis = require("d7289056cdfd2997");
var fails = require("b18d03b899e2bcf2");
var isCallable = require("4dc9a42b4752b60e");
var classof = require("c7ce198349c2eba1");
var getBuiltIn = require("fdc7ac70acca3e86");
var inspectSource = require("93254bd686bb5170");
var noop = function() {};
var empty = [];
var construct = getBuiltIn("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
var isConstructorModern = function isConstructor(argument) {
    if (!isCallable(argument)) return false;
    try {
        construct(noop, empty, argument);
        return true;
    } catch (error) {
        return false;
    }
};
var isConstructorLegacy = function isConstructor(argument) {
    if (!isCallable(argument)) return false;
    switch(classof(argument)){
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
            return false;
    }
    try {
        // we can't check .prototype since constructors produced by .bind haven't it
        // `Function#toString` throws on some built-it function in some legacy engines
        // (for example, `DOMQuad` and similar in FF41-)
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
    } catch (error) {
        return true;
    }
};
isConstructorLegacy.sham = true;
// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function() {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
    }) || called;
}) ? isConstructorLegacy : isConstructorModern;

},{"d7289056cdfd2997":"jdja0","b18d03b899e2bcf2":"fy30P","4dc9a42b4752b60e":"ceVMR","c7ce198349c2eba1":"bi28n","fdc7ac70acca3e86":"er1gl","93254bd686bb5170":"jUEy2"}],"jUEy2":[function(require,module,exports) {
var uncurryThis = require("3a3ec5fce0e60bb2");
var isCallable = require("ba00192ac557010e");
var store = require("43b9e2770e678aef");
var functionToString = uncurryThis(Function.toString);
// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) store.inspectSource = function(it) {
    return functionToString(it);
};
module.exports = store.inspectSource;

},{"3a3ec5fce0e60bb2":"jdja0","ba00192ac557010e":"ceVMR","43b9e2770e678aef":"kkX3p"}],"i55vS":[function(require,module,exports) {
var global = require("a0c3a2c1017228f1");
var apply = require("b626510d70de2109");
var bind = require("1de4c4037b95ed20");
var isCallable = require("4b6210f6e2adb834");
var hasOwn = require("8320df79276c0b7f");
var fails = require("6f7618eaa1576e81");
var html = require("233db04eb0a06703");
var arraySlice = require("a3196e7ec585ba98");
var createElement = require("be31ea832569cc91");
var validateArgumentsLength = require("a3e379bdc70cce49");
var IS_IOS = require("e3b60a7601be7362");
var IS_NODE = require("53a8ea8457027ca0");
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var Dispatch = global.Dispatch;
var Function = global.Function;
var MessageChannel = global.MessageChannel;
var String = global.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var $location, defer, channel, port;
fails(function() {
    // Deno throws a ReferenceError on `location` access without `--location` flag
    $location = global.location;
});
var run = function(id) {
    if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
    }
};
var runner = function(id) {
    return function() {
        run(id);
    };
};
var eventListener = function(event) {
    run(event.data);
};
var globalPostMessageDefer = function(id) {
    // old engines have not location.origin
    global.postMessage(String(id), $location.protocol + "//" + $location.host);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
    set = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
            apply(fn, undefined, args);
        };
        defer(counter);
        return counter;
    };
    clear = function clearImmediate(id) {
        delete queue[id];
    };
    // Node.js 0.8-
    if (IS_NODE) defer = function(id) {
        process.nextTick(runner(id));
    };
    else if (Dispatch && Dispatch.now) defer = function(id) {
        Dispatch.now(runner(id));
    };
    else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (global.addEventListener && isCallable(global.postMessage) && !global.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        global.addEventListener("message", eventListener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in createElement("script")) defer = function(id) {
        html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id);
        };
    };
    else defer = function(id) {
        setTimeout(runner(id), 0);
    };
}
module.exports = {
    set: set,
    clear: clear
};

},{"a0c3a2c1017228f1":"fGEOS","b626510d70de2109":"5V42h","1de4c4037b95ed20":"kjhmo","4b6210f6e2adb834":"ceVMR","8320df79276c0b7f":"6CR0z","6f7618eaa1576e81":"fy30P","233db04eb0a06703":"9Hw6G","a3196e7ec585ba98":"lftup","be31ea832569cc91":"5uUco","a3e379bdc70cce49":"er5tS","e3b60a7601be7362":"4JXCJ","53a8ea8457027ca0":"lNKCY"}],"lftup":[function(require,module,exports) {
var uncurryThis = require("258921f5f716071c");
module.exports = uncurryThis([].slice);

},{"258921f5f716071c":"jdja0"}],"er5tS":[function(require,module,exports) {
var $TypeError = TypeError;
module.exports = function(passed, required) {
    if (passed < required) throw $TypeError("Not enough arguments");
    return passed;
};

},{}],"4JXCJ":[function(require,module,exports) {
var userAgent = require("500d3b96c506e1ae");
// eslint-disable-next-line redos/no-vulnerable -- safe
module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);

},{"500d3b96c506e1ae":"54Cpt"}],"csyb4":[function(require,module,exports) {
var global = require("ac348290eb42e451");
var bind = require("127ed51e631b74a1");
var getOwnPropertyDescriptor = require("d30cc2482dbf6f96").f;
var macrotask = require("3e00e48434d03c2e").set;
var Queue = require("4160aa193362ac5d");
var IS_IOS = require("4dc523308e7507b3");
var IS_IOS_PEBBLE = require("272ce7d6d3db4bd2");
var IS_WEBOS_WEBKIT = require("6771667e2c7e12fe");
var IS_NODE = require("bbc0e10da12371ec");
var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, "queueMicrotask");
var microtask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var notify, toggle, node, promise, then;
// modern engines have queueMicrotask method
if (!microtask) {
    var queue = new Queue();
    var flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process.domain)) parent.exit();
        while(fn = queue.get())try {
            fn();
        } catch (error) {
            if (queue.head) notify();
            throw error;
        }
        if (parent) parent.enter();
    };
    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
    if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
        toggle = true;
        node = document.createTextNode("");
        new MutationObserver(flush).observe(node, {
            characterData: true
        });
        notify = function() {
            node.data = toggle = !toggle;
        };
    // environments with maybe non-completely correct, but existent Promise
    } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
        // Promise.resolve without an argument throws an error in LG WebOS 2
        promise = Promise.resolve(undefined);
        // workaround of WebKit ~ iOS Safari 10.1 bug
        promise.constructor = Promise;
        then = bind(promise.then, promise);
        notify = function() {
            then(flush);
        };
    // Node.js without promises
    } else if (IS_NODE) notify = function() {
        process.nextTick(flush);
    };
    else {
        // `webpack` dev server bug on IE global methods - use bind(fn, global)
        macrotask = bind(macrotask, global);
        notify = function() {
            macrotask(flush);
        };
    }
    microtask = function(fn) {
        if (!queue.head) notify();
        queue.add(fn);
    };
}
module.exports = microtask;

},{"ac348290eb42e451":"fGEOS","127ed51e631b74a1":"kjhmo","d30cc2482dbf6f96":"6zTL3","3e00e48434d03c2e":"i55vS","4160aa193362ac5d":"7CWIJ","4dc523308e7507b3":"4JXCJ","272ce7d6d3db4bd2":"4UVZc","6771667e2c7e12fe":"cZATB","bbc0e10da12371ec":"lNKCY"}],"7CWIJ":[function(require,module,exports) {
var Queue = function() {
    this.head = null;
    this.tail = null;
};
Queue.prototype = {
    add: function(item) {
        var entry = {
            item: item,
            next: null
        };
        var tail = this.tail;
        if (tail) tail.next = entry;
        else this.head = entry;
        this.tail = entry;
    },
    get: function() {
        var entry = this.head;
        if (entry) {
            var next = this.head = entry.next;
            if (next === null) this.tail = null;
            return entry.item;
        }
    }
};
module.exports = Queue;

},{}],"4UVZc":[function(require,module,exports) {
var userAgent = require("b2101c4fe4c0474b");
module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";

},{"b2101c4fe4c0474b":"54Cpt"}],"cZATB":[function(require,module,exports) {
var userAgent = require("ec0573318a05fd02");
module.exports = /web0s(?!.*chrome)/i.test(userAgent);

},{"ec0573318a05fd02":"54Cpt"}],"6FRLW":[function(require,module,exports) {
module.exports = function(a, b) {
    try {
        // eslint-disable-next-line no-console -- safe
        arguments.length == 1 ? console.error(a) : console.error(a, b);
    } catch (error) {}
};

},{}],"aOW9Q":[function(require,module,exports) {
module.exports = function(exec) {
    try {
        return {
            error: false,
            value: exec()
        };
    } catch (error) {
        return {
            error: true,
            value: error
        };
    }
};

},{}],"9Sqnz":[function(require,module,exports) {
var global = require("2aa107a5bb6a958");
module.exports = global.Promise;

},{"2aa107a5bb6a958":"fGEOS"}],"93il6":[function(require,module,exports) {
var global = require("ccce4ff127d55eac");
var NativePromiseConstructor = require("9f70c1967873f3f4");
var isCallable = require("da0311c97538bb");
var isForced = require("65835e53348781d5");
var inspectSource = require("3ce9e95a80a1ec15");
var wellKnownSymbol = require("ab1faf16f436d00f");
var IS_BROWSER = require("daf2008b27c6038");
var IS_DENO = require("a3672b85184e9eaa");
var IS_PURE = require("b295fd681b0a457b");
var V8_VERSION = require("ee8cb836c15b6afd");
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var SPECIES = wellKnownSymbol("species");
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);
var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
    // We need Promise#{ catch, finally } in the pure version for preventing prototype pollution
    if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"])) return true;
    // We can't use @@species feature detection in V8 since it causes
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679
    if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        // Detect correctness of subclassing with @@species support
        var promise = new NativePromiseConstructor(function(resolve) {
            resolve(1);
        });
        var FakePromise = function(exec) {
            exec(function() {}, function() {});
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function() {}) instanceof FakePromise;
        if (!SUBCLASSING) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    }
    return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
});
module.exports = {
    CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
    REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
    SUBCLASSING: SUBCLASSING
};

},{"ccce4ff127d55eac":"fGEOS","9f70c1967873f3f4":"9Sqnz","da0311c97538bb":"ceVMR","65835e53348781d5":"xJExK","3ce9e95a80a1ec15":"jUEy2","ab1faf16f436d00f":"daYw1","daf2008b27c6038":"flcL3","a3672b85184e9eaa":"7oTht","b295fd681b0a457b":"lOkfM","ee8cb836c15b6afd":"3YYAQ"}],"flcL3":[function(require,module,exports) {
var IS_DENO = require("221b66d5ab8aad16");
var IS_NODE = require("b1719bbbab5ee705");
module.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";

},{"221b66d5ab8aad16":"7oTht","b1719bbbab5ee705":"lNKCY"}],"7oTht":[function(require,module,exports) {
/* global Deno -- Deno case */ module.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";

},{}],"9k2ug":[function(require,module,exports) {
"use strict";
var aCallable = require("ec8399fc04a09728");
var $TypeError = TypeError;
var PromiseCapability = function(C) {
    var resolve, reject;
    this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw $TypeError("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
    });
    this.resolve = aCallable(resolve);
    this.reject = aCallable(reject);
};
// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function(C) {
    return new PromiseCapability(C);
};

},{"ec8399fc04a09728":"bBfjy"}],"46eyo":[function(require,module,exports) {
"use strict";
var $ = require("b4f57597ebeb5953");
var call = require("11fac9603352f59");
var aCallable = require("54bf3466c0ca7bff");
var newPromiseCapabilityModule = require("2edefa8fc1e1cda7");
var perform = require("7bc3d3a92c2a49ea");
var iterate = require("2202e3b570c7e12d");
var PROMISE_STATICS_INCORRECT_ITERATION = require("97228c8cd8fe969b");
// `Promise.all` method
// https://tc39.es/ecma262/#sec-promise.all
$({
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION
}, {
    all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var $promiseResolve = aCallable(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
                var index = counter++;
                var alreadyCalled = false;
                remaining++;
                call($promiseResolve, C, promise).then(function(value) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = value;
                    --remaining || resolve(values);
                }, reject);
            });
            --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

},{"b4f57597ebeb5953":"6O4uB","11fac9603352f59":"hzvOQ","54bf3466c0ca7bff":"bBfjy","2edefa8fc1e1cda7":"9k2ug","7bc3d3a92c2a49ea":"aOW9Q","2202e3b570c7e12d":"9aBKZ","97228c8cd8fe969b":"6adAV"}],"6adAV":[function(require,module,exports) {
var NativePromiseConstructor = require("6b919bcfeee10123");
var checkCorrectnessOfIteration = require("3d92c699c4df1206");
var FORCED_PROMISE_CONSTRUCTOR = require("ff02d2b84156dfc2").CONSTRUCTOR;
module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
    NativePromiseConstructor.all(iterable).then(undefined, function() {});
});

},{"6b919bcfeee10123":"9Sqnz","3d92c699c4df1206":"6I05p","ff02d2b84156dfc2":"93il6"}],"6I05p":[function(require,module,exports) {
var wellKnownSymbol = require("68d4e65407cb21e4");
var ITERATOR = wellKnownSymbol("iterator");
var SAFE_CLOSING = false;
try {
    var called = 0;
    var iteratorWithReturn = {
        next: function() {
            return {
                done: !!called++
            };
        },
        "return": function() {
            SAFE_CLOSING = true;
        }
    };
    iteratorWithReturn[ITERATOR] = function() {
        return this;
    };
    // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
    Array.from(iteratorWithReturn, function() {
        throw 2;
    });
} catch (error) {}
module.exports = function(exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
        var object = {};
        object[ITERATOR] = function() {
            return {
                next: function() {
                    return {
                        done: ITERATION_SUPPORT = true
                    };
                }
            };
        };
        exec(object);
    } catch (error) {}
    return ITERATION_SUPPORT;
};

},{"68d4e65407cb21e4":"daYw1"}],"ah46Q":[function(require,module,exports) {
"use strict";
var $ = require("3e46ba19fd2bf022");
var IS_PURE = require("a087f0cad4c75bad");
var FORCED_PROMISE_CONSTRUCTOR = require("4e4017806c2a9abf").CONSTRUCTOR;
var NativePromiseConstructor = require("65c5a5636458a1d7");
var getBuiltIn = require("b3ff7f2da61ffa52");
var isCallable = require("e04416297ef7ddf5");
var defineBuiltIn = require("9ac439b091b2dfba");
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
// `Promise.prototype.catch` method
// https://tc39.es/ecma262/#sec-promise.prototype.catch
$({
    target: "Promise",
    proto: true,
    forced: FORCED_PROMISE_CONSTRUCTOR,
    real: true
}, {
    "catch": function(onRejected) {
        return this.then(undefined, onRejected);
    }
});
// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromiseConstructor)) {
    var method = getBuiltIn("Promise").prototype["catch"];
    if (NativePromisePrototype["catch"] !== method) defineBuiltIn(NativePromisePrototype, "catch", method, {
        unsafe: true
    });
}

},{"3e46ba19fd2bf022":"6O4uB","a087f0cad4c75bad":"lOkfM","4e4017806c2a9abf":"93il6","65c5a5636458a1d7":"9Sqnz","b3ff7f2da61ffa52":"er1gl","e04416297ef7ddf5":"ceVMR","9ac439b091b2dfba":"2VbqH"}],"c5ogP":[function(require,module,exports) {
"use strict";
var $ = require("2fab93c0ae5be9cf");
var call = require("6cf739b06a005daa");
var aCallable = require("e6fde06e5164f7ab");
var newPromiseCapabilityModule = require("40e1d44fcef33538");
var perform = require("ac21dc1aebbf61");
var iterate = require("456e9ca43c35033b");
var PROMISE_STATICS_INCORRECT_ITERATION = require("1fc5eaab508db947");
// `Promise.race` method
// https://tc39.es/ecma262/#sec-promise.race
$({
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION
}, {
    race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var reject = capability.reject;
        var result = perform(function() {
            var $promiseResolve = aCallable(C.resolve);
            iterate(iterable, function(promise) {
                call($promiseResolve, C, promise).then(capability.resolve, reject);
            });
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

},{"2fab93c0ae5be9cf":"6O4uB","6cf739b06a005daa":"hzvOQ","e6fde06e5164f7ab":"bBfjy","40e1d44fcef33538":"9k2ug","ac21dc1aebbf61":"aOW9Q","456e9ca43c35033b":"9aBKZ","1fc5eaab508db947":"6adAV"}],"bbxgt":[function(require,module,exports) {
"use strict";
var $ = require("6a3de37ff06fa8c6");
var call = require("c06f5c875cd810da");
var newPromiseCapabilityModule = require("d7ab42ff0f31938e");
var FORCED_PROMISE_CONSTRUCTOR = require("b8cba7d454b30ee").CONSTRUCTOR;
// `Promise.reject` method
// https://tc39.es/ecma262/#sec-promise.reject
$({
    target: "Promise",
    stat: true,
    forced: FORCED_PROMISE_CONSTRUCTOR
}, {
    reject: function reject(r) {
        var capability = newPromiseCapabilityModule.f(this);
        call(capability.reject, undefined, r);
        return capability.promise;
    }
});

},{"6a3de37ff06fa8c6":"6O4uB","c06f5c875cd810da":"hzvOQ","d7ab42ff0f31938e":"9k2ug","b8cba7d454b30ee":"93il6"}],"73ont":[function(require,module,exports) {
"use strict";
var $ = require("fb101d1ae5e92df4");
var getBuiltIn = require("7802a197cec523c9");
var IS_PURE = require("3f3d7e598069b501");
var NativePromiseConstructor = require("e9447a16cdeef570");
var FORCED_PROMISE_CONSTRUCTOR = require("feffe168aa17b463").CONSTRUCTOR;
var promiseResolve = require("8f5f022243382759");
var PromiseConstructorWrapper = getBuiltIn("Promise");
var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
// `Promise.resolve` method
// https://tc39.es/ecma262/#sec-promise.resolve
$({
    target: "Promise",
    stat: true,
    forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR
}, {
    resolve: function resolve(x) {
        return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
    }
});

},{"fb101d1ae5e92df4":"6O4uB","7802a197cec523c9":"er1gl","3f3d7e598069b501":"lOkfM","e9447a16cdeef570":"9Sqnz","feffe168aa17b463":"93il6","8f5f022243382759":"gz5QV"}],"gz5QV":[function(require,module,exports) {
var anObject = require("4f3f085e78762605");
var isObject = require("7ddddfb8e351337e");
var newPromiseCapability = require("4c80e996348883fc");
module.exports = function(C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
};

},{"4f3f085e78762605":"hjvO5","7ddddfb8e351337e":"alLMh","4c80e996348883fc":"9k2ug"}],"aNkmH":[function(require,module,exports) {
"use strict";
var $ = require("d7a2247e4a2d303f");
var call = require("1da5ba15c2ee9595");
var aCallable = require("86bfd203819c4ae9");
var newPromiseCapabilityModule = require("ce1179c173b2c586");
var perform = require("7fb9a5a1224b553e");
var iterate = require("93684e21efd63a54");
var PROMISE_STATICS_INCORRECT_ITERATION = require("68228bd9024d78c8");
// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$({
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION
}, {
    allSettled: function allSettled(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var promiseResolve = aCallable(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
                var index = counter++;
                var alreadyCalled = false;
                remaining++;
                call(promiseResolve, C, promise).then(function(value) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = {
                        status: "fulfilled",
                        value: value
                    };
                    --remaining || resolve(values);
                }, function(error) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = {
                        status: "rejected",
                        reason: error
                    };
                    --remaining || resolve(values);
                });
            });
            --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

},{"d7a2247e4a2d303f":"6O4uB","1da5ba15c2ee9595":"hzvOQ","86bfd203819c4ae9":"bBfjy","ce1179c173b2c586":"9k2ug","7fb9a5a1224b553e":"aOW9Q","93684e21efd63a54":"9aBKZ","68228bd9024d78c8":"6adAV"}],"6nvNo":[function(require,module,exports) {
"use strict";
var $ = require("c84ac14e91b0a563");
var call = require("bdb328679cfd8968");
var aCallable = require("8a164c2e71673629");
var getBuiltIn = require("ea3366382a2dafe4");
var newPromiseCapabilityModule = require("dc55db1acd0bdf6e");
var perform = require("1f44874646e216f4");
var iterate = require("78474a7c38036906");
var PROMISE_STATICS_INCORRECT_ITERATION = require("36d4812977faefa8");
var PROMISE_ANY_ERROR = "No one promise resolved";
// `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any
$({
    target: "Promise",
    stat: true,
    forced: PROMISE_STATICS_INCORRECT_ITERATION
}, {
    any: function any(iterable) {
        var C = this;
        var AggregateError = getBuiltIn("AggregateError");
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var promiseResolve = aCallable(C.resolve);
            var errors = [];
            var counter = 0;
            var remaining = 1;
            var alreadyResolved = false;
            iterate(iterable, function(promise) {
                var index = counter++;
                var alreadyRejected = false;
                remaining++;
                call(promiseResolve, C, promise).then(function(value) {
                    if (alreadyRejected || alreadyResolved) return;
                    alreadyResolved = true;
                    resolve(value);
                }, function(error) {
                    if (alreadyRejected || alreadyResolved) return;
                    alreadyRejected = true;
                    errors[index] = error;
                    --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
                });
            });
            --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

},{"c84ac14e91b0a563":"6O4uB","bdb328679cfd8968":"hzvOQ","8a164c2e71673629":"bBfjy","ea3366382a2dafe4":"er1gl","dc55db1acd0bdf6e":"9k2ug","1f44874646e216f4":"aOW9Q","78474a7c38036906":"9aBKZ","36d4812977faefa8":"6adAV"}],"abmdO":[function(require,module,exports) {
"use strict";
var $ = require("7597a4941a4da29b");
var IS_PURE = require("efab4c93ab426432");
var NativePromiseConstructor = require("909dcfb2c3795011");
var fails = require("f39e8d6ee2e636bf");
var getBuiltIn = require("b1a4ec4daa563a97");
var isCallable = require("7c3d8cac9786673f");
var speciesConstructor = require("cc8d78196f25ae42");
var promiseResolve = require("56a138839b64be57");
var defineBuiltIn = require("4c35dcff66ba7c56");
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromiseConstructor && fails(function() {
    // eslint-disable-next-line unicorn/no-thenable -- required for testing
    NativePromisePrototype["finally"].call({
        then: function() {}
    }, function() {});
});
// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$({
    target: "Promise",
    proto: true,
    real: true,
    forced: NON_GENERIC
}, {
    "finally": function(onFinally) {
        var C = speciesConstructor(this, getBuiltIn("Promise"));
        var isFunction = isCallable(onFinally);
        return this.then(isFunction ? function(x) {
            return promiseResolve(C, onFinally()).then(function() {
                return x;
            });
        } : onFinally, isFunction ? function(e) {
            return promiseResolve(C, onFinally()).then(function() {
                throw e;
            });
        } : onFinally);
    }
});
// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromiseConstructor)) {
    var method = getBuiltIn("Promise").prototype["finally"];
    if (NativePromisePrototype["finally"] !== method) defineBuiltIn(NativePromisePrototype, "finally", method, {
        unsafe: true
    });
}

},{"7597a4941a4da29b":"6O4uB","efab4c93ab426432":"lOkfM","909dcfb2c3795011":"9Sqnz","f39e8d6ee2e636bf":"fy30P","b1a4ec4daa563a97":"er1gl","7c3d8cac9786673f":"ceVMR","cc8d78196f25ae42":"h5qMg","56a138839b64be57":"gz5QV","4c35dcff66ba7c56":"2VbqH"}],"1Sesg":[function(require,module,exports) {
"use strict";
var charAt = require("4a355062570b6de4").charAt;
var toString = require("9f92de0cd44ca6e2");
var InternalStateModule = require("7fcfc74b0e6ec701");
var defineIterator = require("94990c6b318cbc4a");
var createIterResultObject = require("d7e4d7f38e1d8fa3");
var STRING_ITERATOR = "String Iterator";
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, "String", function(iterated) {
    setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString(iterated),
        index: 0
    });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
    var state = getInternalState(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return createIterResultObject(undefined, true);
    point = charAt(string, index);
    state.index += point.length;
    return createIterResultObject(point, false);
});

},{"4a355062570b6de4":"g0LLN","9f92de0cd44ca6e2":"kFn6x","7fcfc74b0e6ec701":"9cm4f","94990c6b318cbc4a":"lQWIf","d7e4d7f38e1d8fa3":"4bxgP"}],"g0LLN":[function(require,module,exports) {
var uncurryThis = require("641521c7c636147b");
var toIntegerOrInfinity = require("52061c1684d03be2");
var toString = require("14acb2ea4f2b5ac2");
var requireObjectCoercible = require("1954eb8c87b61990");
var charAt = uncurryThis("".charAt);
var charCodeAt = uncurryThis("".charCodeAt);
var stringSlice = uncurryThis("".slice);
var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
        var S = toString(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : undefined;
        first = charCodeAt(S, position);
        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
};
module.exports = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
};

},{"641521c7c636147b":"jdja0","52061c1684d03be2":"fHl6c","14acb2ea4f2b5ac2":"kFn6x","1954eb8c87b61990":"30Lwm"}],"aRnAU":[function(require,module,exports) {
require("522a861d7a1eea34");
var DOMIterables = require("4098efbbde6988a2");
var global = require("5192aad854141d2f");
var classof = require("31e7aaee407f5593");
var createNonEnumerableProperty = require("f5906f6741b7aeb4");
var Iterators = require("3dd60b074776260f");
var wellKnownSymbol = require("a91befdceb7664e5");
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
for(var COLLECTION_NAME in DOMIterables){
    var Collection = global[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;
    if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    Iterators[COLLECTION_NAME] = Iterators.Array;
}

},{"522a861d7a1eea34":"eISyY","4098efbbde6988a2":"efnEg","5192aad854141d2f":"fGEOS","31e7aaee407f5593":"bi28n","f5906f6741b7aeb4":"kRRdZ","3dd60b074776260f":"6Lzpr","a91befdceb7664e5":"daYw1"}],"efnEg":[function(require,module,exports) {
// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
};

},{}],"cNudy":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = onErrorResumeNext;
function onErrorResumeNext(fn) {
    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    try {
        var result = fn.call(context);
        if (typeof result.then === "function") return new Promise(function(resolve) {
            result.then(resolve, function() {
                return resolve();
            });
        });
        else return result;
    } catch (err) {}
}
module.exports = exports.default;
module.exports.default = exports.default;

},{}],"jQGXv":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("3fa6aaa7c66e64b9");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("5d00fab02ff6aa63"));
var _asyncToGenerator2 = _interopRequireDefault(require("170c3a112ef2e082"));
var _classCallCheck2 = _interopRequireDefault(require("a36bd322f99dec6e"));
var _createClass2 = _interopRequireDefault(require("ba77c96ec4d9480"));
var _memoizeOne = _interopRequireDefault(require("a3fad396d8dd6339"));
var _AudioContextConsumer = _interopRequireDefault(require("e9b251c266bb6b7b"));
/* eslint no-await-in-loop: "off" */ var _default = /*#__PURE__*/ function() {
    function _default(_ref) {
        var audioContext = _ref.audioContext, ponyfill = _ref.ponyfill;
        (0, _classCallCheck2.default)(this, _default);
        this.consumer = null;
        this.paused = false;
        this.queue = [];
        this.getAudioContext = (0, _memoizeOne.default)(function() {
            return audioContext || new ponyfill.AudioContext();
        });
    }
    (0, _createClass2.default)(_default, [
        {
            key: "pause",
            value: function pause() {
                this.paused = true;
                this.consumer && this.consumer.pause();
            }
        },
        {
            key: "push",
            value: function push(utterance) {
                this.queue.push(utterance);
                this.startConsumer();
            }
        },
        {
            key: "resume",
            value: function resume() {
                this.paused = false;
                if (this.consumer) this.consumer.resume();
                else this.startConsumer();
            }
        },
        {
            key: "speaking",
            get: function get() {
                return !!this.consumer;
            }
        },
        {
            key: "startConsumer",
            value: function() {
                var _startConsumer = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee() {
                    return _regenerator.default.wrap(function _callee$(_context) {
                        while(true)switch(_context.prev = _context.next){
                            case 0:
                                if (!(!this.paused && this.queue.length && !this.consumer)) {
                                    _context.next = 7;
                                    break;
                                }
                                this.consumer = new _AudioContextConsumer.default(this.getAudioContext());
                                _context.next = 4;
                                return this.consumer.start(this.queue);
                            case 4:
                                this.consumer = null;
                                _context.next = 0;
                                break;
                            case 7:
                            case "end":
                                return _context.stop();
                        }
                    }, _callee, this);
                }));
                function startConsumer() {
                    return _startConsumer.apply(this, arguments);
                }
                return startConsumer;
            }()
        },
        {
            key: "stop",
            value: function stop() {
                this.queue.splice(0);
                this.consumer && this.consumer.stop();
            }
        }
    ]);
    return _default;
}();
exports.default = _default;

},{"3fa6aaa7c66e64b9":"1hUHf","5d00fab02ff6aa63":"iN2WL","170c3a112ef2e082":"jaYFv","a36bd322f99dec6e":"7zlNi","ba77c96ec4d9480":"b694u","a3fad396d8dd6339":"eUz19","e9b251c266bb6b7b":"jh6ry"}],"eUz19":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>memoizeOne);
var safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
    if (first === second) return true;
    if (safeIsNaN(first) && safeIsNaN(second)) return true;
    return false;
}
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) return false;
    for(var i = 0; i < newInputs.length; i++){
        if (!isEqual(newInputs[i], lastInputs[i])) return false;
    }
    return true;
}
function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) isEqual = areInputsEqual;
    var cache = null;
    function memoized() {
        var newArgs = [];
        for(var _i = 0; _i < arguments.length; _i++)newArgs[_i] = arguments[_i];
        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) return cache.lastResult;
        var lastResult = resultFn.apply(this, newArgs);
        cache = {
            lastResult: lastResult,
            lastArgs: newArgs,
            lastThis: this
        };
        return lastResult;
    }
    memoized.clear = function clear() {
        cache = null;
    };
    return memoized;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jh6ry":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("b9868d11ce47e347");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("f151a7071175e976"));
var _asyncToGenerator2 = _interopRequireDefault(require("58c6fd5f0ed9fe64"));
var _classCallCheck2 = _interopRequireDefault(require("ecca627928d88df3"));
var _createClass2 = _interopRequireDefault(require("da17fe016b45fbd9"));
/* eslint no-await-in-loop: "off" */ var _default = /*#__PURE__*/ function() {
    function _default(audioContext) {
        (0, _classCallCheck2.default)(this, _default);
        this.audioContext = audioContext;
    }
    (0, _createClass2.default)(_default, [
        {
            key: "pause",
            value: function pause() {
                this.audioContext && this.audioContext.suspend();
                this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent("pause"));
            }
        },
        {
            key: "resume",
            value: function resume() {
                this.audioContext && this.audioContext.resume();
                this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent("resume"));
            }
        },
        {
            key: "start",
            value: function() {
                var _start = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee(queue) {
                    var utterance;
                    return _regenerator.default.wrap(function _callee$(_context) {
                        while(true)switch(_context.prev = _context.next){
                            case 0:
                                if (!(utterance = queue.shift())) {
                                    _context.next = 7;
                                    break;
                                }
                                this.playingUtterance = utterance;
                                _context.next = 4;
                                return utterance.play(this.audioContext);
                            case 4:
                                this.playingUtterance = null;
                                _context.next = 0;
                                break;
                            case 7:
                            case "end":
                                return _context.stop();
                        }
                    }, _callee, this);
                }));
                function start(_x) {
                    return _start.apply(this, arguments);
                }
                return start;
            }()
        },
        {
            key: "stop",
            value: function stop() {
                this.playingUtterance && this.playingUtterance.stop();
                if (this.audioContext.state === "suspended") // Play -> Pause -> Cancel (stop)
                // This would generate these events: "start", "pause", "end"
                // Without this code, the "end" event will not emit until resume() is called
                // Cancelling an unstarted utterance will not emit any "start" or "end" event
                this.audioContext.resume();
            }
        }
    ]);
    return _default;
}();
exports.default = _default;

},{"b9868d11ce47e347":"1hUHf","f151a7071175e976":"iN2WL","58c6fd5f0ed9fe64":"jaYFv","ecca627928d88df3":"7zlNi","da17fe016b45fbd9":"b694u"}],"7EDr3":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("bc501b23f6ac697e");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _default;
var _regenerator = _interopRequireDefault(require("6e2ea4a99341dfd9"));
var _asyncToGenerator2 = _interopRequireDefault(require("ef6d3c5d85c8745e"));
var _SpeechSynthesisVoice = _interopRequireDefault(require("bde7c5a83a00e314"));
/* eslint no-magic-numbers: ["error", { "ignore": [0, 1, -1] }] */ function fetchCustomVoices(_x) {
    return _fetchCustomVoices.apply(this, arguments);
}
function _fetchCustomVoices() {
    _fetchCustomVoices = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee(_ref) {
        var customVoiceHostname, deploymentId, region, subscriptionKey, hostname, res;
        return _regenerator.default.wrap(function _callee$(_context) {
            while(true)switch(_context.prev = _context.next){
                case 0:
                    customVoiceHostname = _ref.customVoiceHostname, deploymentId = _ref.deploymentId, region = _ref.region, subscriptionKey = _ref.subscriptionKey;
                    hostname = customVoiceHostname || "".concat(region, ".customvoice.api.speech.microsoft.com"); // Although encodeURI on a hostname doesn't work as expected for hostname, at least, it will fail peacefully.
                    _context.next = 4;
                    return fetch("https://".concat(encodeURI(hostname), "/api/texttospeech/v2.0/endpoints/").concat(encodeURIComponent(deploymentId)), {
                        headers: {
                            accept: "application/json",
                            "ocp-apim-subscription-key": subscriptionKey
                        }
                    });
                case 4:
                    res = _context.sent;
                    if (res.ok) {
                        _context.next = 7;
                        break;
                    }
                    throw new Error("Failed to fetch custom voices");
                case 7:
                    return _context.abrupt("return", res.json());
                case 8:
                case "end":
                    return _context.stop();
            }
        }, _callee);
    }));
    return _fetchCustomVoices.apply(this, arguments);
}
function _default(_x2) {
    return _ref3.apply(this, arguments);
}
function _ref3() {
    _ref3 = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee2(_ref2) {
        var customVoiceHostname, deploymentId, region, subscriptionKey, _yield$fetchCustomVoi, models;
        return _regenerator.default.wrap(function _callee2$(_context2) {
            while(true)switch(_context2.prev = _context2.next){
                case 0:
                    customVoiceHostname = _ref2.customVoiceHostname, deploymentId = _ref2.deploymentId, region = _ref2.region, subscriptionKey = _ref2.subscriptionKey;
                    _context2.next = 3;
                    return fetchCustomVoices({
                        customVoiceHostname: customVoiceHostname,
                        deploymentId: deploymentId,
                        region: region,
                        subscriptionKey: subscriptionKey
                    });
                case 3:
                    _yield$fetchCustomVoi = _context2.sent;
                    models = _yield$fetchCustomVoi.models;
                    return _context2.abrupt("return", models.map(function(_ref4) {
                        var gender = _ref4.properties.Gender, lang = _ref4.locale, voiceURI = _ref4.name;
                        return new _SpeechSynthesisVoice.default({
                            gender: gender,
                            lang: lang,
                            voiceURI: voiceURI
                        });
                    }).sort(function(_ref5, _ref6) {
                        var x = _ref5.name;
                        var y = _ref6.name;
                        return x > y ? 1 : x < y ? -1 : 0;
                    }));
                case 6:
                case "end":
                    return _context2.stop();
            }
        }, _callee2);
    }));
    return _ref3.apply(this, arguments);
}

},{"bc501b23f6ac697e":"1hUHf","6e2ea4a99341dfd9":"iN2WL","ef6d3c5d85c8745e":"jaYFv","bde7c5a83a00e314":"4qqR7"}],"4qqR7":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("4f8c8d2f9bdac8ab");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("e9cd49c7b9b0fd9c"));
var _createClass2 = _interopRequireDefault(require("bbd2310f8654911d"));
var _default = /*#__PURE__*/ function() {
    function _default(_ref) {
        var gender = _ref.gender, lang = _ref.lang, voiceURI = _ref.voiceURI;
        (0, _classCallCheck2.default)(this, _default);
        this._default = false;
        this._gender = gender;
        this._lang = lang;
        this._localService = false;
        this._name = voiceURI;
        this._voiceURI = voiceURI;
    }
    (0, _createClass2.default)(_default, [
        {
            key: "default",
            get: function get() {
                return this._default;
            }
        },
        {
            key: "gender",
            get: function get() {
                return this._gender;
            }
        },
        {
            key: "lang",
            get: function get() {
                return this._lang;
            }
        },
        {
            key: "localService",
            get: function get() {
                return this._localService;
            }
        },
        {
            key: "name",
            get: function get() {
                return this._name;
            }
        },
        {
            key: "voiceURI",
            get: function get() {
                return this._voiceURI;
            }
        }
    ]);
    return _default;
}();
exports.default = _default;

},{"4f8c8d2f9bdac8ab":"1hUHf","e9cd49c7b9b0fd9c":"7zlNi","bbd2310f8654911d":"b694u"}],"76WXp":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("2994be7b02a1675c");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = fetchVoices;
var _regenerator = _interopRequireDefault(require("d8eeca42f226f38b"));
var _defineProperty2 = _interopRequireDefault(require("ac9f401abb960a45"));
var _asyncToGenerator2 = _interopRequireDefault(require("c7dff857bd279eba"));
var _SpeechSynthesisVoice = _interopRequireDefault(require("439e379f4fa5fc6d"));
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function fetchVoices(_x) {
    return _fetchVoices.apply(this, arguments);
}
function _fetchVoices() {
    _fetchVoices = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee(_ref) {
        var authorizationToken, region, speechSynthesisHostname, subscriptionKey, hostname, res, voices;
        return _regenerator.default.wrap(function _callee$(_context) {
            while(true)switch(_context.prev = _context.next){
                case 0:
                    authorizationToken = _ref.authorizationToken, region = _ref.region, speechSynthesisHostname = _ref.speechSynthesisHostname, subscriptionKey = _ref.subscriptionKey;
                    // Although encodeURI on a hostname doesn't work as expected for hostname, at least, it will fail peacefully.
                    hostname = speechSynthesisHostname || "".concat(encodeURI(region), ".tts.speech.microsoft.com");
                    _context.next = 4;
                    return fetch("https://".concat(hostname, "/cognitiveservices/voices/list"), {
                        headers: _objectSpread({
                            "content-type": "application/json"
                        }, authorizationToken ? {
                            authorization: "Bearer ".concat(authorizationToken)
                        } : {
                            "Ocp-Apim-Subscription-Key": subscriptionKey
                        })
                    });
                case 4:
                    res = _context.sent;
                    if (res.ok) {
                        _context.next = 7;
                        break;
                    }
                    throw new Error("Failed to fetch voices");
                case 7:
                    _context.next = 9;
                    return res.json();
                case 9:
                    voices = _context.sent;
                    return _context.abrupt("return", voices.map(function(_ref2) {
                        var gender = _ref2.Gender, lang = _ref2.Locale, voiceURI = _ref2.Name;
                        return new _SpeechSynthesisVoice.default({
                            gender: gender,
                            lang: lang,
                            voiceURI: voiceURI
                        });
                    }).sort(function(_ref3, _ref4) {
                        var x = _ref3.name;
                        var y = _ref4.name;
                        return x > y ? 1 : x < y ? -1 : 0;
                    }));
                case 11:
                case "end":
                    return _context.stop();
            }
        }, _callee);
    }));
    return _fetchVoices.apply(this, arguments);
}

},{"2994be7b02a1675c":"1hUHf","d8eeca42f226f38b":"iN2WL","ac9f401abb960a45":"3d8OR","c7dff857bd279eba":"jaYFv","439e379f4fa5fc6d":"4qqR7"}],"kIQZq":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("763506373d36b34a");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = patchOptions;
var _regenerator = _interopRequireDefault(require("c004ded262ff3ba9"));
var _defineProperty2 = _interopRequireDefault(require("d998d507236c8f50"));
var _asyncToGenerator2 = _interopRequireDefault(require("57f110f4ecedf078"));
var _objectWithoutProperties2 = _interopRequireDefault(require("2da32bd4ffcd79be"));
var _resolveFunctionOrReturnValue = _interopRequireDefault(require("adc3e7f239d24492"));
var _excluded = [
    "authorizationToken",
    "credentials",
    "looseEvent",
    "looseEvents",
    "region",
    "subscriptionKey"
];
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
var shouldWarnOnSubscriptionKey = true;
function patchOptions() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var authorizationToken = _ref.authorizationToken, credentials = _ref.credentials, looseEvent = _ref.looseEvent, looseEvents = _ref.looseEvents, _ref$region = _ref.region, region = _ref$region === void 0 ? "westus" : _ref$region, subscriptionKey = _ref.subscriptionKey, otherOptions = (0, _objectWithoutProperties2.default)(_ref, _excluded);
    if (typeof looseEvent !== "undefined") {
        console.warn('web-speech-cognitive-services: The option "looseEvent" should be named as "looseEvents".');
        looseEvents = looseEvent;
    }
    if (!credentials) {
        if (!authorizationToken && !subscriptionKey) throw new Error("web-speech-cognitive-services: Credentials must be specified.");
        else {
            console.warn("web-speech-cognitive-services: We are deprecating authorizationToken, region, and subscriptionKey. Please use credentials instead. The deprecated option will be removed on or after 2020-11-14.");
            credentials = /*#__PURE__*/ function() {
                var _ref2 = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee() {
                    return _regenerator.default.wrap(function _callee$(_context) {
                        while(true)switch(_context.prev = _context.next){
                            case 0:
                                if (!authorizationToken) {
                                    _context.next = 8;
                                    break;
                                }
                                _context.next = 3;
                                return (0, _resolveFunctionOrReturnValue.default)(authorizationToken);
                            case 3:
                                _context.t1 = _context.sent;
                                _context.t2 = region;
                                _context.t0 = {
                                    authorizationToken: _context.t1,
                                    region: _context.t2
                                };
                                _context.next = 13;
                                break;
                            case 8:
                                _context.t3 = region;
                                _context.next = 11;
                                return (0, _resolveFunctionOrReturnValue.default)(subscriptionKey);
                            case 11:
                                _context.t4 = _context.sent;
                                _context.t0 = {
                                    region: _context.t3,
                                    subscriptionKey: _context.t4
                                };
                            case 13:
                                return _context.abrupt("return", _context.t0);
                            case 14:
                            case "end":
                                return _context.stop();
                        }
                    }, _callee);
                }));
                return function credentials() {
                    return _ref2.apply(this, arguments);
                };
            }();
        }
    }
    return _objectSpread(_objectSpread({}, otherOptions), {}, {
        fetchCredentials: function() {
            var _fetchCredentials = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee2() {
                var _yield$resolveFunctio, authorizationToken, customVoiceHostname, region, speechRecognitionHostname, speechSynthesisHostname, subscriptionKey, resolvedCredentials;
                return _regenerator.default.wrap(function _callee2$(_context2) {
                    while(true)switch(_context2.prev = _context2.next){
                        case 0:
                            _context2.next = 2;
                            return (0, _resolveFunctionOrReturnValue.default)(credentials);
                        case 2:
                            _yield$resolveFunctio = _context2.sent;
                            authorizationToken = _yield$resolveFunctio.authorizationToken;
                            customVoiceHostname = _yield$resolveFunctio.customVoiceHostname;
                            region = _yield$resolveFunctio.region;
                            speechRecognitionHostname = _yield$resolveFunctio.speechRecognitionHostname;
                            speechSynthesisHostname = _yield$resolveFunctio.speechSynthesisHostname;
                            subscriptionKey = _yield$resolveFunctio.subscriptionKey;
                            if (!(!authorizationToken && !subscriptionKey || authorizationToken && subscriptionKey)) {
                                _context2.next = 13;
                                break;
                            }
                            throw new Error('web-speech-cognitive-services: Either "authorizationToken" or "subscriptionKey" must be provided.');
                        case 13:
                            if (!(!region && !(speechRecognitionHostname && speechSynthesisHostname))) {
                                _context2.next = 17;
                                break;
                            }
                            throw new Error('web-speech-cognitive-services: Either "region" or "speechRecognitionHostname" and "speechSynthesisHostname" must be set.');
                        case 17:
                            if (!(region && (customVoiceHostname || speechRecognitionHostname || speechSynthesisHostname))) {
                                _context2.next = 21;
                                break;
                            }
                            throw new Error('web-speech-cognitive-services: Only either "region" or "customVoiceHostname", "speechRecognitionHostname" and "speechSynthesisHostname" can be set.');
                        case 21:
                            if (!authorizationToken) {
                                _context2.next = 26;
                                break;
                            }
                            if (!(typeof authorizationToken !== "string")) {
                                _context2.next = 24;
                                break;
                            }
                            throw new Error('web-speech-cognitive-services: "authorizationToken" must be a string.');
                        case 24:
                            _context2.next = 28;
                            break;
                        case 26:
                            if (!(typeof subscriptionKey !== "string")) {
                                _context2.next = 28;
                                break;
                            }
                            throw new Error('web-speech-cognitive-services: "subscriptionKey" must be a string.');
                        case 28:
                            if (shouldWarnOnSubscriptionKey && subscriptionKey) {
                                console.warn("web-speech-cognitive-services: In production environment, subscription key should not be used, authorization token should be used instead.");
                                shouldWarnOnSubscriptionKey = false;
                            }
                            resolvedCredentials = authorizationToken ? {
                                authorizationToken: authorizationToken
                            } : {
                                subscriptionKey: subscriptionKey
                            };
                            if (region) resolvedCredentials.region = region;
                            else {
                                resolvedCredentials.customVoiceHostname = customVoiceHostname;
                                resolvedCredentials.speechRecognitionHostname = speechRecognitionHostname;
                                resolvedCredentials.speechSynthesisHostname = speechSynthesisHostname;
                            }
                            return _context2.abrupt("return", resolvedCredentials);
                        case 32:
                        case "end":
                            return _context2.stop();
                    }
                }, _callee2);
            }));
            function fetchCredentials() {
                return _fetchCredentials.apply(this, arguments);
            }
            return fetchCredentials;
        }(),
        looseEvents: looseEvents
    });
}

},{"763506373d36b34a":"1hUHf","c004ded262ff3ba9":"iN2WL","d998d507236c8f50":"3d8OR","57f110f4ecedf078":"jaYFv","2da32bd4ffcd79be":"1fltp","adc3e7f239d24492":"i1iQn"}],"1fltp":[function(require,module,exports) {
var objectWithoutPropertiesLoose = require("b9490b668092bbe");
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{"b9490b668092bbe":"9zTWl"}],"9zTWl":[function(require,module,exports) {
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"i1iQn":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = resolveFunctionOrReturnValue;
function resolveFunctionOrReturnValue(fnOrValue) {
    return typeof fnOrValue === "function" ? fnOrValue() : fnOrValue;
}

},{}],"4fVgH":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("6fa5bc143e01c0f0");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _createClass2 = _interopRequireDefault(require("d3532d629d32607d"));
var _classCallCheck2 = _interopRequireDefault(require("2f25f1bc2a6cd0c1"));
var _inherits2 = _interopRequireDefault(require("6a12dd2e7f1d73e9"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("a84d59f596ceed05"));
var _getPrototypeOf2 = _interopRequireDefault(require("9235d569de93b98c"));
var _es = require("8316e7b148326ed2");
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return (0, _possibleConstructorReturn2.default)(this, result);
    };
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
var SpeechSynthesisEvent = /*#__PURE__*/ function(_Event) {
    (0, _inherits2.default)(SpeechSynthesisEvent, _Event);
    var _super = _createSuper(SpeechSynthesisEvent);
    function SpeechSynthesisEvent(type) {
        (0, _classCallCheck2.default)(this, SpeechSynthesisEvent);
        return _super.call(this, type);
    }
    return (0, _createClass2.default)(SpeechSynthesisEvent);
}(_es.Event);
exports.default = SpeechSynthesisEvent;

},{"6fa5bc143e01c0f0":"1hUHf","d3532d629d32607d":"b694u","2f25f1bc2a6cd0c1":"7zlNi","6a12dd2e7f1d73e9":"bQ802","a84d59f596ceed05":"kJc1U","9235d569de93b98c":"g7YIw","8316e7b148326ed2":"iVIs8"}],"l3D6T":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("e743a05d5ff48c43");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("ac8ae598fcd03099"));
var _asyncToGenerator2 = _interopRequireDefault(require("c4fba1f033df916f"));
var _classCallCheck2 = _interopRequireDefault(require("32e432946e79feeb"));
var _createClass2 = _interopRequireDefault(require("801d2fb29c630d4d"));
var _inherits2 = _interopRequireDefault(require("d0ae28e5e8e7841f"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("2bcff1e31fe4e0be"));
var _getPrototypeOf2 = _interopRequireDefault(require("9dace641223188a9"));
var _es = require("e335a5fb9d010f96");
var _eventAsPromise = _interopRequireDefault(require("8cfe085196410e8"));
var _fetchSpeechData = _interopRequireDefault(require("81dddaa9e0a25c78"));
var _SpeechSynthesisEvent = _interopRequireDefault(require("1d8f8c02a5aaea75"));
var _subscribeEvent = _interopRequireDefault(require("2f561b758f27c597"));
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return (0, _possibleConstructorReturn2.default)(this, result);
    };
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function asyncDecodeAudioData(audioContext, arrayBuffer) {
    return new Promise(function(resolve, reject) {
        var promise = audioContext.decodeAudioData(arrayBuffer, resolve, reject); // Newer implementation of "decodeAudioData" will return a Promise
        promise && typeof promise.then === "function" && resolve(promise);
    });
}
function playDecoded(audioContext, audioBuffer, source) {
    return new Promise(function(resolve, reject) {
        var audioContextClosed = new _eventAsPromise.default();
        var sourceEnded = new _eventAsPromise.default();
        var unsubscribe = (0, _subscribeEvent.default)(audioContext, "statechange", function(_ref) {
            var state = _ref.target.state;
            return state === "closed" && audioContextClosed.eventListener();
        });
        try {
            source.buffer = audioBuffer; // "ended" may not fire if the underlying AudioContext is closed prematurely
            source.onended = sourceEnded.eventListener;
            source.connect(audioContext.destination);
            source.start(0);
            Promise.race([
                audioContextClosed.upcoming(),
                sourceEnded.upcoming()
            ]).then(resolve);
        } catch (err) {
            reject(err);
        } finally{
            unsubscribe();
        }
    });
}
var SpeechSynthesisUtterance = /*#__PURE__*/ function(_EventTarget) {
    (0, _inherits2.default)(SpeechSynthesisUtterance, _EventTarget);
    var _super = _createSuper(SpeechSynthesisUtterance);
    function SpeechSynthesisUtterance(text) {
        var _this;
        (0, _classCallCheck2.default)(this, SpeechSynthesisUtterance);
        _this = _super.call(this);
        _this._lang = null;
        _this._pitch = 1;
        _this._rate = 1;
        _this._voice = null;
        _this._volume = 1;
        _this.text = text;
        _this.onboundary = null;
        _this.onend = null;
        _this.onerror = null;
        _this.onmark = null;
        _this.onpause = null;
        _this.onresume = null;
        _this.onstart = null;
        return _this;
    }
    (0, _createClass2.default)(SpeechSynthesisUtterance, [
        {
            key: "lang",
            get: function get() {
                return this._lang;
            },
            set: function set(value) {
                this._lang = value;
            }
        },
        {
            key: "onboundary",
            get: function get() {
                return (0, _es.getEventAttributeValue)(this, "boundary");
            },
            set: function set(value) {
                (0, _es.setEventAttributeValue)(this, "boundary", value);
            }
        },
        {
            key: "onend",
            get: function get() {
                return (0, _es.getEventAttributeValue)(this, "end");
            },
            set: function set(value) {
                (0, _es.setEventAttributeValue)(this, "end", value);
            }
        },
        {
            key: "onerror",
            get: function get() {
                return (0, _es.getEventAttributeValue)(this, "error");
            },
            set: function set(value) {
                (0, _es.setEventAttributeValue)(this, "error", value);
            }
        },
        {
            key: "onmark",
            get: function get() {
                return (0, _es.getEventAttributeValue)(this, "mark");
            },
            set: function set(value) {
                (0, _es.setEventAttributeValue)(this, "mark", value);
            }
        },
        {
            key: "onpause",
            get: function get() {
                return (0, _es.getEventAttributeValue)(this, "pause");
            },
            set: function set(value) {
                (0, _es.setEventAttributeValue)(this, "pause", value);
            }
        },
        {
            key: "onresume",
            get: function get() {
                return (0, _es.getEventAttributeValue)(this, "resume");
            },
            set: function set(value) {
                (0, _es.setEventAttributeValue)(this, "resume", value);
            }
        },
        {
            key: "onstart",
            get: function get() {
                return (0, _es.getEventAttributeValue)(this, "start");
            },
            set: function set(value) {
                (0, _es.setEventAttributeValue)(this, "start", value);
            }
        },
        {
            key: "pitch",
            get: function get() {
                return this._pitch;
            },
            set: function set(value) {
                this._pitch = value;
            }
        },
        {
            key: "rate",
            get: function get() {
                return this._rate;
            },
            set: function set(value) {
                this._rate = value;
            }
        },
        {
            key: "voice",
            get: function get() {
                return this._voice;
            },
            set: function set(value) {
                this._voice = value;
            }
        },
        {
            key: "volume",
            get: function get() {
                return this._volume;
            },
            set: function set(value) {
                this._volume = value;
            }
        },
        {
            key: "preload",
            value: function preload(_ref2) {
                var deploymentId = _ref2.deploymentId, fetchCredentials = _ref2.fetchCredentials, outputFormat = _ref2.outputFormat;
                this.arrayBufferPromise = (0, _fetchSpeechData.default)({
                    fetchCredentials: fetchCredentials,
                    deploymentId: deploymentId,
                    lang: this.lang || window.navigator.language,
                    outputFormat: outputFormat,
                    pitch: this.pitch,
                    rate: this.rate,
                    text: this.text,
                    voice: this.voice && this.voice.voiceURI,
                    volume: this.volume
                }); // We need to call "catch" to make sure the Promise is running.
                // We will ignore the reject result and handled in play() later.
                this.arrayBufferPromise.catch();
            }
        },
        {
            key: "play",
            value: function() {
                var _play = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee(audioContext) {
                    var source, audioBuffer;
                    return _regenerator.default.wrap(function _callee$(_context) {
                        while(true)switch(_context.prev = _context.next){
                            case 0:
                                _context.prev = 0;
                                // We should emit "start" event even if preload() failed.
                                this.dispatchEvent(new _SpeechSynthesisEvent.default("start")); // HACK: iOS requires bufferSourceNode to be constructed before decoding data.
                                source = audioContext.createBufferSource();
                                _context.t0 = asyncDecodeAudioData;
                                _context.t1 = audioContext;
                                _context.next = 7;
                                return this.arrayBufferPromise;
                            case 7:
                                _context.t2 = _context.sent;
                                _context.next = 10;
                                return (0, _context.t0)(_context.t1, _context.t2);
                            case 10:
                                audioBuffer = _context.sent;
                                this._playingSource = source;
                                _context.next = 14;
                                return playDecoded(audioContext, audioBuffer, source);
                            case 14:
                                this._playingSource = null;
                                this.dispatchEvent(new _SpeechSynthesisEvent.default("end"));
                                _context.next = 21;
                                break;
                            case 18:
                                _context.prev = 18;
                                _context.t3 = _context["catch"](0);
                                // "message" is not in spec but to provide a friendly message.
                                this.dispatchEvent(new ErrorEvent("error", {
                                    error: "synthesis-failed",
                                    message: _context.t3.stack
                                }));
                            case 21:
                            case "end":
                                return _context.stop();
                        }
                    }, _callee, this, [
                        [
                            0,
                            18
                        ]
                    ]);
                }));
                function play(_x) {
                    return _play.apply(this, arguments);
                }
                return play;
            }()
        },
        {
            key: "stop",
            value: function stop() {
                this._playingSource && this._playingSource.stop();
            }
        }
    ]);
    return SpeechSynthesisUtterance;
}(_es.EventTarget);
var _default = SpeechSynthesisUtterance;
exports.default = _default;

},{"e743a05d5ff48c43":"1hUHf","ac8ae598fcd03099":"iN2WL","c4fba1f033df916f":"jaYFv","32e432946e79feeb":"7zlNi","801d2fb29c630d4d":"b694u","d0ae28e5e8e7841f":"bQ802","2bcff1e31fe4e0be":"kJc1U","9dace641223188a9":"g7YIw","e335a5fb9d010f96":"iVIs8","8cfe085196410e8":"2qbL6","81dddaa9e0a25c78":"jKRN0","1d8f8c02a5aaea75":"4fVgH","2f561b758f27c597":"g4NcF"}],"2qbL6":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _pDefer = _interopRequireDefault(require("a4af19c7c7e4b315"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var EventAsPromise = /*#__PURE__*/ function() {
    function EventAsPromise() {
        var _this = this;
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, EventAsPromise);
        this.defers = [];
        this.upcomingDeferred = null;
        this.eventListener = this.eventListener.bind(this);
        this.options = options;
        this.one = this.one.bind(this);
        this.upcoming = this.upcoming.bind(this);
        this[Symbol.iterator] = function() {
            return {
                next: function next() {
                    return {
                        done: false,
                        value: _this.upcoming()
                    };
                }
            };
        };
    }
    _createClass(EventAsPromise, [
        {
            key: "eventListener",
            value: function eventListener(event) {
                var deferred = this.defers.shift();
                var args = this.options.array ? [].slice.call(arguments) : event;
                deferred && deferred.resolve(args);
                if (this.upcomingDeferred) {
                    this.upcomingDeferred.resolve(args);
                    this.upcomingDeferred = null;
                }
            }
        },
        {
            key: "one",
            value: function one() {
                var deferred = (0, _pDefer.default)();
                this.defers.push(deferred);
                return deferred.promise;
            }
        },
        {
            key: "upcoming",
            value: function upcoming() {
                if (!this.upcomingDeferred) this.upcomingDeferred = (0, _pDefer.default)();
                return this.upcomingDeferred.promise;
            }
        }
    ]);
    return EventAsPromise;
}();
exports.default = EventAsPromise;
module.exports = exports.default;
module.exports.default = exports.default;

},{"a4af19c7c7e4b315":"39oqM"}],"39oqM":[function(require,module,exports) {
// The MIT License (MIT)
//
// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// This piece of code is adopted from https://github.com/sindresorhus/p-defer
// The reason why we need to fork it is because:
// - The original package published to NPM is not ES5-compliant
//    - Due to the use of arrow functions
// - create-react-app@1 does not play nice with packages that are not ES5-compliant
//    - create-react-app@2 do play nice, but it was so new that most of the people are still on @1
// Criteria to remove this package:
// - When create-react-app@2 become mainstream, or,
// - When p-defer start publishing a ES5-compliant version on NPM
"use strict";
module.exports = function() {
    var ret = {};
    ret.promise = new Promise(function(resolve, reject) {
        ret.resolve = resolve;
        ret.reject = reject;
    });
    return ret;
};

},{}],"jKRN0":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("47abcdbad4b24fb");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _default;
var _regenerator = _interopRequireDefault(require("bc0c6c3e59c86b70"));
var _defineProperty2 = _interopRequireDefault(require("a1d7574e408909d1"));
var _asyncToGenerator2 = _interopRequireDefault(require("9218ffe1b427c6eb"));
var _base64Arraybuffer = require("54168d7be87b27ee");
var _buildSSML = _interopRequireDefault(require("9e3e9279e2dbbf28"));
var _isSSML = _interopRequireDefault(require("2eec0bb63caab82f"));
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
var DEFAULT_LANGUAGE = "en-US";
var DEFAULT_OUTPUT_FORMAT = "riff-16khz-16bit-mono-pcm";
var DEFAULT_VOICE = "Microsoft Server Speech Text to Speech Voice (en-US, AriaNeural)";
var EMPTY_MP3_BASE64 = "SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU3LjU2LjEwMQAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU3LjY0AAAAAAAAAAAAAAAAJAUHAAAAAAAAAYYoRBqpAAAAAAD/+xDEAAPAAAGkAAAAIAAANIAAAARMQU1FMy45OS41VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7EMQpg8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";
function _default(_x) {
    return _ref2.apply(this, arguments);
}
function _ref2() {
    _ref2 = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee(_ref) {
        var deploymentId, fetchCredentials, _ref$lang, lang, _ref$outputFormat, outputFormat, pitch, rate, text, _ref$voice, voice, volume, _yield$fetchCredentia, authorizationToken, region, speechSynthesisHostname, subscriptionKey, ssml, hostname, search, url, res;
        return _regenerator.default.wrap(function _callee$(_context) {
            while(true)switch(_context.prev = _context.next){
                case 0:
                    deploymentId = _ref.deploymentId, fetchCredentials = _ref.fetchCredentials, _ref$lang = _ref.lang, lang = _ref$lang === void 0 ? DEFAULT_LANGUAGE : _ref$lang, _ref$outputFormat = _ref.outputFormat, outputFormat = _ref$outputFormat === void 0 ? DEFAULT_OUTPUT_FORMAT : _ref$outputFormat, pitch = _ref.pitch, rate = _ref.rate, text = _ref.text, _ref$voice = _ref.voice, voice = _ref$voice === void 0 ? DEFAULT_VOICE : _ref$voice, volume = _ref.volume;
                    if (text) {
                        _context.next = 3;
                        break;
                    }
                    return _context.abrupt("return", (0, _base64Arraybuffer.decode)(EMPTY_MP3_BASE64));
                case 3:
                    _context.next = 5;
                    return fetchCredentials();
                case 5:
                    _yield$fetchCredentia = _context.sent;
                    authorizationToken = _yield$fetchCredentia.authorizationToken;
                    region = _yield$fetchCredentia.region;
                    speechSynthesisHostname = _yield$fetchCredentia.speechSynthesisHostname;
                    subscriptionKey = _yield$fetchCredentia.subscriptionKey;
                    if (!(authorizationToken && subscriptionKey || !authorizationToken && !subscriptionKey)) {
                        _context.next = 14;
                        break;
                    }
                    throw new Error('Only "authorizationToken" or "subscriptionKey" should be set.');
                case 14:
                    if (!(region && speechSynthesisHostname || !region && !speechSynthesisHostname)) {
                        _context.next = 16;
                        break;
                    }
                    throw new Error('Only "region" or "speechSynthesisHostnamename" should be set.');
                case 16:
                    ssml = (0, _isSSML.default)(text) ? text : (0, _buildSSML.default)({
                        lang: lang,
                        pitch: pitch,
                        rate: rate,
                        text: text,
                        voice: voice,
                        volume: volume
                    }); // Although calling encodeURI on hostname does not actually works, it fails faster and safer.
                    hostname = speechSynthesisHostname || (deploymentId ? "".concat(encodeURI(region), ".voice.speech.microsoft.com") : "".concat(encodeURI(region), ".tts.speech.microsoft.com"));
                    search = deploymentId ? "?deploymentId=".concat(encodeURI(deploymentId)) : "";
                    url = "https://".concat(hostname, "/cognitiveservices/v1").concat(search);
                    _context.next = 22;
                    return fetch(url, {
                        headers: _objectSpread({
                            "Content-Type": "application/ssml+xml",
                            "X-Microsoft-OutputFormat": outputFormat
                        }, authorizationToken ? {
                            Authorization: "Bearer ".concat(authorizationToken)
                        } : {
                            "Ocp-Apim-Subscription-Key": subscriptionKey
                        }),
                        method: "POST",
                        body: ssml
                    });
                case 22:
                    res = _context.sent;
                    if (res.ok) {
                        _context.next = 25;
                        break;
                    }
                    throw new Error("web-speech-cognitive-services: Failed to syntheis speech, server returned ".concat(res.status));
                case 25:
                    return _context.abrupt("return", res.arrayBuffer());
                case 26:
                case "end":
                    return _context.stop();
            }
        }, _callee);
    }));
    return _ref2.apply(this, arguments);
}

},{"47abcdbad4b24fb":"1hUHf","bc0c6c3e59c86b70":"iN2WL","a1d7574e408909d1":"3d8OR","9218ffe1b427c6eb":"jaYFv","54168d7be87b27ee":"fq6n6","9e3e9279e2dbbf28":"91lKa","2eec0bb63caab82f":"eiPEv"}],"fq6n6":[function(require,module,exports) {
/*
 * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "encode", ()=>encode);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
// Use a lookup table to find the index.
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for(var i = 0; i < chars.length; i++)lookup[chars.charCodeAt(i)] = i;
var encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
    for(i = 0; i < len; i += 3){
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) base64 = base64.substring(0, base64.length - 1) + "=";
    else if (len % 3 === 1) base64 = base64.substring(0, base64.length - 2) + "==";
    return base64;
};
var decode = function(base64) {
    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") bufferLength--;
    }
    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for(i = 0; i < len; i += 4){
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"91lKa":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = buildSSML;
/* eslint no-magic-numbers: ["error", { "ignore": [0, 1, 100] }] */ // Cognitive Services does not support unsigned percentage
// It must be converted into +/- first.
function relativePercentage(value) {
    var relative = Math.round((value - 1) * 100);
    if (relative >= 0) relative = "+" + relative;
    return relative + "%";
}
function buildSSML(_ref) {
    var lang = _ref.lang, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? 1 : _ref$pitch, _ref$rate = _ref.rate, rate = _ref$rate === void 0 ? 1 : _ref$rate, text = _ref.text, voice = _ref.voice, volume = _ref.volume;
    return '<speak version="1.0" xml:lang="'.concat(lang, '">\n  <voice xml:lang="').concat(lang, '" name="').concat(voice, '">\n    <prosody pitch="').concat(relativePercentage(pitch), '" rate="').concat(relativePercentage(rate), '" volume="').concat(relativePercentage(volume), '">\n      ').concat(text, "\n    </prosody>\n  </voice>\n</speak>");
}

},{}],"eiPEv":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isSSML;
var SPEAK_TAG_PATTERN = /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*<speak([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]|\/?>)/;
var XML_PROLOG_PATTERN = /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*<\?xml[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/;
function isSSML(text) {
    return SPEAK_TAG_PATTERN.test(text) || XML_PROLOG_PATTERN.test(text);
}

},{}],"g4NcF":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = subscribeEvent;
function subscribeEvent(target, name, handler) {
    target.addEventListener(name, handler);
    return function() {
        return target.removeEventListener(name, handler);
    };
}

},{}],"l7XW8":[function(require,module,exports) {
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.asrMachine = void 0;
const xstate_1 = require("f141a23d423257fc");
const getToken_1 = require("147fa810ef4c6e9f");
const SpeechToText_1 = require("657ab96be08240be");
const REGION = "northeurope";
exports.asrMachine = (0, xstate_1.createMachine)({
    id: "asr",
    types: {
        context: {},
        events: {}
    },
    context: ({ input })=>({
            asrDefaultCompleteTimeout: input.asrDefaultCompleteTimeout || 0,
            asrDefaultNoInputTimeout: input.asrDefaultNoInputTimeout || 5000,
            locale: input.locale || "en-US",
            audioContext: input.audioContext,
            azureCredentials: input.azureCredentials
        }),
    initial: "GetToken",
    on: {
        READY: {
            target: ".Ready",
            actions: [
                (0, xstate_1.assign)({
                    wsaASR: ({ event })=>event.value.wsaASR,
                    wsaGrammarList: ({ event })=>event.value.wsaGrammarList
                }),
                (0, xstate_1.sendParent)({
                    type: "ASR_READY"
                })
            ]
        }
    },
    states: {
        Fail: {},
        Ready: {
            on: {
                START: {
                    target: "Recognising",
                    actions: (0, xstate_1.assign)({
                        params: ({ event })=>event.value
                    })
                }
            }
        },
        Recognising: {
            initial: "WaitForRecogniser",
            invoke: {
                id: "recStart",
                input: ({ context })=>({
                        wsaASR: context.wsaASR,
                        wsaGrammarList: context.wsaGrammarList,
                        locale: context.locale,
                        phrases: (context.params || {}).hints || []
                    }),
                src: "recStart"
            },
            exit: "recStop",
            on: {
                RESULT: {
                    actions: [
                        (0, xstate_1.assign)({
                            result: ({ event })=>event.value
                        }),
                        (0, xstate_1.cancel)("completeTimeout")
                    ],
                    target: ".Match"
                },
                RECOGNISED: {
                    target: "Ready",
                    actions: [
                        (0, xstate_1.sendParent)(({ context })=>({
                                type: "RECOGNISED",
                                value: context.result
                            }))
                    ]
                },
                CONTROL: {
                    target: "Pause"
                },
                NOINPUT: {
                    actions: (0, xstate_1.sendParent)({
                        type: "ASR_NOINPUT"
                    }),
                    target: "Ready"
                }
            },
            states: {
                WaitForRecogniser: {
                    on: {
                        STARTED: {
                            target: "NoInput",
                            actions: [
                                (0, xstate_1.assign)({
                                    wsaASRinstance: ({ event })=>event.value.wsaASRinstance
                                }),
                                (0, xstate_1.sendParent)({
                                    type: "ASR_STARTED"
                                })
                            ]
                        }
                    }
                },
                NoInput: {
                    entry: [
                        (0, xstate_1.raise)({
                            type: "NOINPUT"
                        }, {
                            delay: ({ context })=>(context.params || {}).noInputTimeout || context.asrDefaultNoInputTimeout,
                            id: "timeout"
                        })
                    ],
                    on: {
                        STARTSPEECH: {
                            target: "InProgress",
                            actions: (0, xstate_1.cancel)("completeTimeout")
                        }
                    },
                    exit: [
                        (0, xstate_1.cancel)("timeout")
                    ]
                },
                InProgress: {
                    entry: ()=>console.debug("[ASR] in progress")
                },
                Match: {
                    entry: [
                        ({ context })=>console.debug("RECOGNISED will be sent in (ms)", (context.params || {}).completeTimeout || context.asrDefaultCompleteTimeout),
                        (0, xstate_1.raise)({
                            type: "RECOGNISED"
                        }, {
                            delay: ({ context })=>(context.params || {}).completeTimeout || context.asrDefaultCompleteTimeout,
                            id: "completeTimeout"
                        })
                    ]
                }
            }
        },
        Pause: {
            entry: (0, xstate_1.sendParent)({
                type: "ASR_PAUSED"
            }),
            on: {
                CONTROL: {
                    target: "Recognising"
                }
            }
        },
        GetToken: {
            invoke: {
                id: "getAuthorizationToken",
                input: ({ context })=>({
                        credentials: context.azureCredentials
                    }),
                src: "getToken",
                onDone: {
                    target: "Ponyfill",
                    actions: [
                        (0, xstate_1.assign)(({ event })=>{
                            return {
                                azureAuthorizationToken: event.output
                            };
                        })
                    ]
                },
                onError: {
                    target: "Fail"
                }
            }
        },
        Ponyfill: {
            invoke: {
                id: "ponyASR",
                src: "ponyfill",
                input: ({ context })=>({
                        audioContext: context.audioContext,
                        azureAuthorizationToken: context.azureAuthorizationToken,
                        locale: context.locale
                    })
            }
        }
    }
}, {
    actions: {
        recStop: ({ context })=>{
            context.wsaASRinstance.abort();
            console.debug("[ASR] stopped");
        }
    },
    actors: {
        getToken: getToken_1.getToken,
        ponyfill: (0, xstate_1.fromCallback)(({ sendBack, input })=>__awaiter(void 0, void 0, void 0, function*() {
                const { SpeechGrammarList, SpeechRecognition } = (0, SpeechToText_1.default)({
                    audioContext: input.audioContext,
                    credentials: {
                        region: REGION,
                        authorizationToken: input.azureAuthorizationToken
                    }
                });
                sendBack({
                    type: "READY",
                    value: {
                        wsaASR: SpeechRecognition,
                        wsaGrammarList: SpeechGrammarList
                    }
                });
                console.debug("[ASR] READY");
            })),
        recStart: (0, xstate_1.fromCallback)(({ sendBack, input })=>{
            let asr = new input.wsaASR();
            asr.grammars = new input.wsaGrammarList();
            asr.grammars.phrases = input.phrases || [];
            asr.lang = input.locale;
            asr.continuous = true;
            asr.interimResults = true;
            asr.onresult = function(event) {
                if (event.results[event.results.length - 1].isFinal) {
                    const transcript = event.results.map((x)=>x[0].transcript.replace(/\.$/, "")).join(" ");
                    const confidence = event.results.map((x)=>x[0].confidence).reduce((a, b)=>a + b) / event.results.length;
                    const res = [
                        {
                            utterance: transcript,
                            confidence: confidence
                        }
                    ];
                    sendBack({
                        type: "RESULT",
                        value: res
                    });
                    console.debug("[ASR] RESULT (pre-final)", res);
                } else sendBack({
                    type: "STARTSPEECH"
                });
            };
            asr.addEventListener("start", ()=>{
                sendBack({
                    type: "STARTED",
                    value: {
                        wsaASRinstance: asr
                    }
                });
            });
            // receive((event) => {
            //   console.debug("bla");
            //   if (event.type === "STOP") {
            //     asr.abort();
            //   }
            // });
            asr.start();
        })
    }
});

},{"f141a23d423257fc":"aP1sj","147fa810ef4c6e9f":"a233R","657ab96be08240be":"fKhCL"}],"fKhCL":[function(require,module,exports) {
"use strict";
var _typeof = require("fde148cf089d2f30");
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createSpeechRecognitionPonyfillFromRecognizer", {
    enumerable: true,
    get: function get() {
        return _createSpeechRecognitionPonyfill.createSpeechRecognitionPonyfillFromRecognizer;
    }
});
exports.default = void 0;
var _createSpeechRecognitionPonyfill = _interopRequireWildcard(require("98bf2a014004550b"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj)if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
        else newObj[key] = obj[key];
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
var _default = _createSpeechRecognitionPonyfill.default;
exports.default = _default;

},{"fde148cf089d2f30":"64MFb","98bf2a014004550b":"crM3h"}],"crM3h":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("6297db204a514748");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createSpeechRecognitionPonyfillFromRecognizer = createSpeechRecognitionPonyfillFromRecognizer;
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("de3b514a267d04a0"));
var _toConsumableArray2 = _interopRequireDefault(require("900f15de68cfad87"));
var _defineProperty2 = _interopRequireDefault(require("912ad363d45e7b50"));
var _asyncToGenerator2 = _interopRequireDefault(require("53c7ea4570514e10"));
var _createClass2 = _interopRequireDefault(require("993994f1926c419f"));
var _classCallCheck2 = _interopRequireDefault(require("f13fb2d185a2be3d"));
var _inherits2 = _interopRequireDefault(require("edaad932fa789c4b"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("f5d71beae43c04ed"));
var _getPrototypeOf2 = _interopRequireDefault(require("3377945f42070eaa"));
var _es = require("4f4b65b414e7104c");
var _cognitiveServiceEventResultToWebSpeechRecognitionResultList = _interopRequireDefault(require("2a54d8b5e9c740ed"));
var _createPromiseQueue = _interopRequireDefault(require("cda6bcc296d46db7"));
var _patchOptions2 = _interopRequireDefault(require("3f98356c8c7bdc38"));
var _SpeechGrammarList = _interopRequireDefault(require("aa8dc9f3ebd0b084"));
var _SpeechSDK = _interopRequireDefault(require("2f56c54d558b9657"));
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return (0, _possibleConstructorReturn2.default)(this, result);
    };
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
// https://docs.microsoft.com/en-us/javascript/api/microsoft-cognitiveservices-speech-sdk/speechconfig?view=azure-node-latest#outputformat
// {
//   "RecognitionStatus": "Success",
//   "Offset": 900000,
//   "Duration": 49000000,
//   "NBest": [
//     {
//       "Confidence": 0.738919,
//       "Lexical": "second",
//       "ITN": "second",
//       "MaskedITN": "second",
//       "Display": "Second."
//     }
//   ]
// }
// {
//   "RecognitionStatus": "InitialSilenceTimeout",
//   "Offset": 50000000,
//   "Duration": 0
// }
var AudioConfig = _SpeechSDK.default.AudioConfig, OutputFormat = _SpeechSDK.default.OutputFormat, ResultReason = _SpeechSDK.default.ResultReason, SpeechConfig = _SpeechSDK.default.SpeechConfig, SpeechRecognizer = _SpeechSDK.default.SpeechRecognizer;
function serializeRecognitionResult(_ref) {
    var duration = _ref.duration, errorDetails = _ref.errorDetails, json = _ref.json, offset = _ref.offset, properties = _ref.properties, reason = _ref.reason, resultId = _ref.resultId, text = _ref.text;
    return {
        duration: duration,
        errorDetails: errorDetails,
        json: JSON.parse(json),
        offset: offset,
        properties: properties,
        reason: reason,
        resultId: resultId,
        text: text
    };
}
function averageAmplitude(arrayBuffer) {
    var array = new Int16Array(arrayBuffer);
    return [].reduce.call(array, function(averageAmplitude, amplitude) {
        return averageAmplitude + Math.abs(amplitude);
    }, 0) / array.length;
}
function cognitiveServicesAsyncToPromise(fn) {
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        return new Promise(function(resolve, reject) {
            return fn.apply(void 0, args.concat([
                resolve,
                reject
            ]));
        });
    };
}
var SpeechRecognitionEvent = /*#__PURE__*/ function(_Event) {
    (0, _inherits2.default)(SpeechRecognitionEvent, _Event);
    var _super = _createSuper(SpeechRecognitionEvent);
    function SpeechRecognitionEvent(type) {
        var _this;
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, data = _ref2.data, emma = _ref2.emma, interpretation = _ref2.interpretation, resultIndex = _ref2.resultIndex, results = _ref2.results;
        (0, _classCallCheck2.default)(this, SpeechRecognitionEvent);
        _this = _super.call(this, type);
        _this.data = data;
        _this.emma = emma;
        _this.interpretation = interpretation;
        _this.resultIndex = resultIndex;
        _this.results = results;
        return _this;
    }
    return (0, _createClass2.default)(SpeechRecognitionEvent);
}(_es.Event);
function prepareAudioConfig(audioConfig) {
    var originalAttach = audioConfig.attach;
    var boundOriginalAttach = audioConfig.attach.bind(audioConfig);
    var firstChunk;
    var muted; // We modify "attach" function and detect when audible chunk is read.
    // We will only modify "attach" function once.
    audioConfig.attach = /*#__PURE__*/ (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee2() {
        var reader;
        return _regenerator.default.wrap(function _callee2$(_context2) {
            while(true)switch(_context2.prev = _context2.next){
                case 0:
                    _context2.next = 2;
                    return boundOriginalAttach();
                case 2:
                    reader = _context2.sent;
                    return _context2.abrupt("return", _objectSpread(_objectSpread({}, reader), {}, {
                        read: function() {
                            var _read = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee() {
                                var chunk;
                                return _regenerator.default.wrap(function _callee$(_context) {
                                    while(true)switch(_context.prev = _context.next){
                                        case 0:
                                            _context.next = 2;
                                            return reader.read();
                                        case 2:
                                            chunk = _context.sent;
                                            // The magic number 150 is measured by:
                                            // 1. Set microphone volume to 0
                                            // 2. Observe the amplitude (100-110) for the first few chunks
                                            //    (There is a short static caught when turning on the microphone)
                                            // 3. Set the number a bit higher than the observation
                                            if (!firstChunk && averageAmplitude(chunk.buffer) > 150) {
                                                audioConfig.events.onEvent({
                                                    name: "FirstAudibleChunk"
                                                });
                                                firstChunk = true;
                                            }
                                            if (!muted) {
                                                _context.next = 6;
                                                break;
                                            }
                                            return _context.abrupt("return", {
                                                buffer: new ArrayBuffer(0),
                                                isEnd: true,
                                                timeReceived: Date.now()
                                            });
                                        case 6:
                                            return _context.abrupt("return", chunk);
                                        case 7:
                                        case "end":
                                            return _context.stop();
                                    }
                                }, _callee);
                            }));
                            function read() {
                                return _read.apply(this, arguments);
                            }
                            return read;
                        }()
                    }));
                case 4:
                case "end":
                    return _context2.stop();
            }
        }, _callee2);
    }));
    return {
        audioConfig: audioConfig,
        pause: function pause() {
            muted = true;
        },
        unprepare: function unprepare() {
            audioConfig.attach = originalAttach;
        }
    };
}
function createSpeechRecognitionPonyfillFromRecognizer(_ref4) {
    var createRecognizer = _ref4.createRecognizer, enableTelemetry = _ref4.enableTelemetry, looseEvents = _ref4.looseEvents, referenceGrammars = _ref4.referenceGrammars, textNormalization = _ref4.textNormalization;
    // If enableTelemetry is set to null or non-boolean, we will default to true.
    SpeechRecognizer.enableTelemetry(enableTelemetry !== false);
    var SpeechRecognition = /*#__PURE__*/ function(_EventTarget) {
        (0, _inherits2.default)(SpeechRecognition, _EventTarget);
        var _super2 = _createSuper(SpeechRecognition);
        function SpeechRecognition() {
            var _this2;
            (0, _classCallCheck2.default)(this, SpeechRecognition);
            _this2 = _super2.call(this);
            _this2._continuous = false;
            _this2._interimResults = false;
            _this2._lang = typeof window !== "undefined" ? window.document.documentElement.getAttribute("lang") || window.navigator.language : "en-US";
            _this2._grammars = new _SpeechGrammarList.default();
            _this2._maxAlternatives = 1;
            return _this2;
        }
        (0, _createClass2.default)(SpeechRecognition, [
            {
                key: "emitCognitiveServices",
                value: function emitCognitiveServices(type, event) {
                    this.dispatchEvent(new SpeechRecognitionEvent("cognitiveservices", {
                        data: _objectSpread(_objectSpread({}, event), {}, {
                            type: type
                        })
                    }));
                }
            },
            {
                key: "continuous",
                get: function get() {
                    return this._continuous;
                },
                set: function set(value) {
                    this._continuous = value;
                }
            },
            {
                key: "grammars",
                get: function get() {
                    return this._grammars;
                },
                set: function set(value) {
                    if (value instanceof _SpeechGrammarList.default) this._grammars = value;
                    else throw new Error("The provided value is not of type 'SpeechGrammarList'");
                }
            },
            {
                key: "interimResults",
                get: function get() {
                    return this._interimResults;
                },
                set: function set(value) {
                    this._interimResults = value;
                }
            },
            {
                key: "maxAlternatives",
                get: function get() {
                    return this._maxAlternatives;
                },
                set: function set(value) {
                    this._maxAlternatives = value;
                }
            },
            {
                key: "lang",
                get: function get() {
                    return this._lang;
                },
                set: function set(value) {
                    this._lang = value;
                }
            },
            {
                key: "onaudioend",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "audioend");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "audioend", value);
                }
            },
            {
                key: "onaudiostart",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "audiostart");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "audiostart", value);
                }
            },
            {
                key: "oncognitiveservices",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "cognitiveservices");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "cognitiveservices", value);
                }
            },
            {
                key: "onend",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "end");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "end", value);
                }
            },
            {
                key: "onerror",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "error");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "error", value);
                }
            },
            {
                key: "onresult",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "result");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "result", value);
                }
            },
            {
                key: "onsoundend",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "soundend");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "soundend", value);
                }
            },
            {
                key: "onsoundstart",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "soundstart");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "soundstart", value);
                }
            },
            {
                key: "onspeechend",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "speechend");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "speechend", value);
                }
            },
            {
                key: "onspeechstart",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "speechstart");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "speechstart", value);
                }
            },
            {
                key: "onstart",
                get: function get() {
                    return (0, _es.getEventAttributeValue)(this, "start");
                },
                set: function set(value) {
                    (0, _es.setEventAttributeValue)(this, "start", value);
                }
            },
            {
                key: "start",
                value: function start() {
                    var _this3 = this;
                    this._startOnce().catch(function(err) {
                        _this3.dispatchEvent(new ErrorEvent("error", {
                            error: err,
                            message: err && (err.stack || err.message)
                        }));
                    });
                }
            },
            {
                key: "_startOnce",
                value: function() {
                    var _startOnce2 = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee3() {
                        var _this4 = this;
                        var recognizer, _prepareAudioConfig, pause, unprepare, queue, soundStarted, speechStarted, stopping, _recognizer$audioConf, detachAudioConfigEvent, phrases, dynamicGrammar, audioStarted, finalEvent, finalizedResults, _loop, loop, _ret;
                        return _regenerator.default.wrap(function _callee3$(_context4) {
                            while(true)switch(_context4.prev = _context4.next){
                                case 0:
                                    _context4.next = 2;
                                    return createRecognizer(this.lang);
                                case 2:
                                    recognizer = _context4.sent;
                                    _prepareAudioConfig = prepareAudioConfig(recognizer.audioConfig), pause = _prepareAudioConfig.pause, unprepare = _prepareAudioConfig.unprepare;
                                    _context4.prev = 4;
                                    queue = (0, _createPromiseQueue.default)();
                                    _recognizer$audioConf = recognizer.audioConfig.events.attach(function(event) {
                                        var name = event.name;
                                        if (name === "AudioSourceReadyEvent") queue.push({
                                            audioSourceReady: {}
                                        });
                                        else if (name === "AudioSourceOffEvent") queue.push({
                                            audioSourceOff: {}
                                        });
                                        else if (name === "FirstAudibleChunk") queue.push({
                                            firstAudibleChunk: {}
                                        });
                                    }), detachAudioConfigEvent = _recognizer$audioConf.detach;
                                    recognizer.canceled = function(_, _ref5) {
                                        var errorDetails = _ref5.errorDetails, offset = _ref5.offset, reason = _ref5.reason, sessionId = _ref5.sessionId;
                                        queue.push({
                                            canceled: {
                                                errorDetails: errorDetails,
                                                offset: offset,
                                                reason: reason,
                                                sessionId: sessionId
                                            }
                                        });
                                    };
                                    recognizer.recognized = function(_, _ref6) {
                                        var offset = _ref6.offset, result = _ref6.result, sessionId = _ref6.sessionId;
                                        queue.push({
                                            recognized: {
                                                offset: offset,
                                                result: serializeRecognitionResult(result),
                                                sessionId: sessionId
                                            }
                                        });
                                    };
                                    recognizer.recognizing = function(_, _ref7) {
                                        var offset = _ref7.offset, result = _ref7.result, sessionId = _ref7.sessionId;
                                        queue.push({
                                            recognizing: {
                                                offset: offset,
                                                result: serializeRecognitionResult(result),
                                                sessionId: sessionId
                                            }
                                        });
                                    };
                                    recognizer.sessionStarted = function(_, _ref8) {
                                        var sessionId = _ref8.sessionId;
                                        queue.push({
                                            sessionStarted: {
                                                sessionId: sessionId
                                            }
                                        });
                                    };
                                    recognizer.sessionStopped = function(_, _ref9) {
                                        var sessionId = _ref9.sessionId;
                                        // "sessionStopped" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.
                                        queue.push({
                                            sessionStopped: {
                                                sessionId: sessionId
                                            }
                                        });
                                    };
                                    recognizer.speechStartDetected = function(_, _ref10) {
                                        var offset = _ref10.offset, sessionId = _ref10.sessionId;
                                        queue.push({
                                            speechStartDetected: {
                                                offset: offset,
                                                sessionId: sessionId
                                            }
                                        });
                                    };
                                    recognizer.speechEndDetected = function(_, _ref11) {
                                        var sessionId = _ref11.sessionId;
                                        // "speechEndDetected" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.
                                        // Update: "speechEndDetected" is fired for DLSpeech.listenOnceAsync()
                                        queue.push({
                                            speechEndDetected: {
                                                sessionId: sessionId
                                            }
                                        });
                                    };
                                    phrases = this.grammars.phrases; // HACK: We are using the internal of SpeechRecognizer because they did not expose it
                                    dynamicGrammar = recognizer.privReco.dynamicGrammar;
                                    referenceGrammars && referenceGrammars.length && dynamicGrammar.addReferenceGrammar(referenceGrammars);
                                    phrases && phrases.length && dynamicGrammar.addPhrase(phrases);
                                    _context4.next = 20;
                                    return cognitiveServicesAsyncToPromise(recognizer.startContinuousRecognitionAsync.bind(recognizer))();
                                case 20:
                                    if (recognizer.stopContinuousRecognitionAsync) {
                                        this.abort = function() {
                                            return queue.push({
                                                abort: {}
                                            });
                                        };
                                        this.stop = function() {
                                            return queue.push({
                                                stop: {}
                                            });
                                        };
                                    } else this.abort = this.stop = undefined;
                                    finalizedResults = [];
                                    _loop = /*#__PURE__*/ _regenerator.default.mark(function _loop(loop) {
                                        var event, abort, audioSourceOff, audioSourceReady, canceled, firstAudibleChunk, recognized, recognizing, stop, errorMessage, result, recognizable;
                                        return _regenerator.default.wrap(function _loop$(_context3) {
                                            while(true)switch(_context3.prev = _context3.next){
                                                case 0:
                                                    _context3.next = 2;
                                                    return queue.shift();
                                                case 2:
                                                    event = _context3.sent;
                                                    abort = event.abort, audioSourceOff = event.audioSourceOff, audioSourceReady = event.audioSourceReady, canceled = event.canceled, firstAudibleChunk = event.firstAudibleChunk, recognized = event.recognized, recognizing = event.recognizing, stop = event.stop; // We are emitting event "cognitiveservices" for debugging purpose.
                                                    Object.keys(event).forEach(function(name) {
                                                        return _this4.emitCognitiveServices(name, event[name]);
                                                    });
                                                    errorMessage = canceled && canceled.errorDetails;
                                                    if (!/Permission[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]denied/.test(errorMessage || "")) {
                                                        _context3.next = 9;
                                                        break;
                                                    }
                                                    // If microphone is not allowed, we should not emit "start" event.
                                                    finalEvent = {
                                                        error: "not-allowed",
                                                        type: "error"
                                                    };
                                                    return _context3.abrupt("return", "break");
                                                case 9:
                                                    if (!loop) _this4.dispatchEvent(new SpeechRecognitionEvent("start"));
                                                    if (!errorMessage) {
                                                        _context3.next = 15;
                                                        break;
                                                    }
                                                    if (/1006/.test(errorMessage)) {
                                                        if (!audioStarted) {
                                                            _this4.dispatchEvent(new SpeechRecognitionEvent("audiostart"));
                                                            _this4.dispatchEvent(new SpeechRecognitionEvent("audioend"));
                                                        }
                                                        finalEvent = {
                                                            error: "network",
                                                            type: "error"
                                                        };
                                                    } else finalEvent = {
                                                        error: "unknown",
                                                        type: "error"
                                                    };
                                                    return _context3.abrupt("return", "break");
                                                case 15:
                                                    if (!(abort || stop)) {
                                                        _context3.next = 22;
                                                        break;
                                                    }
                                                    if (abort) {
                                                        finalEvent = {
                                                            error: "aborted",
                                                            type: "error"
                                                        }; // If we are aborting, we will ignore lingering recognizing/recognized events. But if we are stopping, we need them.
                                                        stopping = "abort";
                                                    } else {
                                                        // When we pause, we will send { isEnd: true }, Speech Services will send us "recognized" event.
                                                        pause();
                                                        stopping = "stop";
                                                    } // Abort should not be dispatched without support of "stopContinuousRecognitionAsync".
                                                    // But for defensive purpose, we make sure "stopContinuousRecognitionAsync" is available before we can call.
                                                    if (!(abort && recognizer.stopContinuousRecognitionAsync)) {
                                                        _context3.next = 20;
                                                        break;
                                                    }
                                                    _context3.next = 20;
                                                    return cognitiveServicesAsyncToPromise(recognizer.stopContinuousRecognitionAsync.bind(recognizer))();
                                                case 20:
                                                    _context3.next = 61;
                                                    break;
                                                case 22:
                                                    if (!audioSourceReady) {
                                                        _context3.next = 27;
                                                        break;
                                                    }
                                                    _this4.dispatchEvent(new SpeechRecognitionEvent("audiostart"));
                                                    audioStarted = true;
                                                    _context3.next = 61;
                                                    break;
                                                case 27:
                                                    if (!firstAudibleChunk) {
                                                        _context3.next = 32;
                                                        break;
                                                    }
                                                    _this4.dispatchEvent(new SpeechRecognitionEvent("soundstart"));
                                                    soundStarted = true;
                                                    _context3.next = 61;
                                                    break;
                                                case 32:
                                                    if (!audioSourceOff) {
                                                        _context3.next = 40;
                                                        break;
                                                    }
                                                    // Looks like we don't need this line and all the tests are still working.
                                                    // Guessing probably stopping is already truthy.
                                                    // stopping = true;
                                                    speechStarted && _this4.dispatchEvent(new SpeechRecognitionEvent("speechend"));
                                                    soundStarted && _this4.dispatchEvent(new SpeechRecognitionEvent("soundend"));
                                                    audioStarted && _this4.dispatchEvent(new SpeechRecognitionEvent("audioend"));
                                                    audioStarted = soundStarted = speechStarted = false;
                                                    return _context3.abrupt("return", "break");
                                                case 40:
                                                    if (!(stopping !== "abort")) {
                                                        _context3.next = 61;
                                                        break;
                                                    }
                                                    if (!(recognized && recognized.result && recognized.result.reason === ResultReason.NoMatch)) {
                                                        _context3.next = 45;
                                                        break;
                                                    }
                                                    finalEvent = {
                                                        error: "no-speech",
                                                        type: "error"
                                                    };
                                                    _context3.next = 61;
                                                    break;
                                                case 45:
                                                    if (!(recognized || recognizing)) {
                                                        _context3.next = 61;
                                                        break;
                                                    }
                                                    if (!audioStarted) {
                                                        // Unconfirmed prevention of quirks
                                                        _this4.dispatchEvent(new SpeechRecognitionEvent("audiostart"));
                                                        audioStarted = true;
                                                    }
                                                    if (!soundStarted) {
                                                        _this4.dispatchEvent(new SpeechRecognitionEvent("soundstart"));
                                                        soundStarted = true;
                                                    }
                                                    if (!speechStarted) {
                                                        _this4.dispatchEvent(new SpeechRecognitionEvent("speechstart"));
                                                        speechStarted = true;
                                                    }
                                                    if (!recognized) {
                                                        _context3.next = 60;
                                                        break;
                                                    }
                                                    result = (0, _cognitiveServiceEventResultToWebSpeechRecognitionResultList.default)(recognized.result, {
                                                        maxAlternatives: _this4.maxAlternatives,
                                                        textNormalization: textNormalization
                                                    });
                                                    recognizable = !!result[0].transcript;
                                                    if (recognizable) {
                                                        finalizedResults = [].concat((0, _toConsumableArray2.default)(finalizedResults), [
                                                            result
                                                        ]);
                                                        _this4.continuous && _this4.dispatchEvent(new SpeechRecognitionEvent("result", {
                                                            results: finalizedResults
                                                        }));
                                                    } // If it is continuous, we just sent the finalized results. So we don't need to send it again after "audioend" event.
                                                    if (_this4.continuous && recognizable) finalEvent = null;
                                                    else finalEvent = {
                                                        results: finalizedResults,
                                                        type: "result"
                                                    };
                                                    if (!(!_this4.continuous && recognizer.stopContinuousRecognitionAsync)) {
                                                        _context3.next = 57;
                                                        break;
                                                    }
                                                    _context3.next = 57;
                                                    return cognitiveServicesAsyncToPromise(recognizer.stopContinuousRecognitionAsync.bind(recognizer))();
                                                case 57:
                                                    // If event order can be loosened, we can send the recognized event as soon as we receive it.
                                                    // 1. If it is not recognizable (no-speech), we should send an "error" event just before "end" event. We will not loosen "error" events.
                                                    if (looseEvents && finalEvent && recognizable) {
                                                        _this4.dispatchEvent(new SpeechRecognitionEvent(finalEvent.type, finalEvent));
                                                        finalEvent = null;
                                                    }
                                                    _context3.next = 61;
                                                    break;
                                                case 60:
                                                    if (recognizing) _this4.interimResults && _this4.dispatchEvent(new SpeechRecognitionEvent("result", {
                                                        results: [].concat((0, _toConsumableArray2.default)(finalizedResults), [
                                                            (0, _cognitiveServiceEventResultToWebSpeechRecognitionResultList.default)(recognizing.result, {
                                                                maxAlternatives: _this4.maxAlternatives,
                                                                textNormalization: textNormalization
                                                            })
                                                        ])
                                                    }));
                                                case 61:
                                                case "end":
                                                    return _context3.stop();
                                            }
                                        }, _loop);
                                    });
                                    loop = 0;
                                case 24:
                                    if (!(!stopping || audioStarted)) {
                                        _context4.next = 32;
                                        break;
                                    }
                                    return _context4.delegateYield(_loop(loop), "t0", 26);
                                case 26:
                                    _ret = _context4.t0;
                                    if (!(_ret === "break")) {
                                        _context4.next = 29;
                                        break;
                                    }
                                    return _context4.abrupt("break", 32);
                                case 29:
                                    loop++;
                                    _context4.next = 24;
                                    break;
                                case 32:
                                    if (speechStarted) this.dispatchEvent(new SpeechRecognitionEvent("speechend"));
                                    if (soundStarted) this.dispatchEvent(new SpeechRecognitionEvent("soundend"));
                                    if (audioStarted) this.dispatchEvent(new SpeechRecognitionEvent("audioend"));
                                    if (finalEvent) {
                                        if (finalEvent.type === "result" && !finalEvent.results.length) finalEvent = {
                                            error: "no-speech",
                                            type: "error"
                                        };
                                        if (finalEvent.type === "error") this.dispatchEvent(new ErrorEvent("error", finalEvent));
                                        else this.dispatchEvent(new SpeechRecognitionEvent(finalEvent.type, finalEvent));
                                    } // Even though there is no "start" event emitted, we will still emit "end" event
                                    // This is mainly for "microphone blocked" story.
                                    this.dispatchEvent(new SpeechRecognitionEvent("end"));
                                    detachAudioConfigEvent();
                                    _context4.next = 44;
                                    break;
                                case 40:
                                    _context4.prev = 40;
                                    _context4.t1 = _context4["catch"](4);
                                    // Logging out the erorr because Speech SDK would fail silently.
                                    console.error(_context4.t1);
                                    throw _context4.t1;
                                case 44:
                                    _context4.prev = 44;
                                    unprepare();
                                    recognizer.dispose();
                                    return _context4.finish(44);
                                case 48:
                                case "end":
                                    return _context4.stop();
                            }
                        }, _callee3, this, [
                            [
                                4,
                                40,
                                44,
                                48
                            ]
                        ]);
                    }));
                    function _startOnce() {
                        return _startOnce2.apply(this, arguments);
                    }
                    return _startOnce;
                }()
            }
        ]);
        return SpeechRecognition;
    }(_es.EventTarget);
    return {
        SpeechGrammarList: _SpeechGrammarList.default,
        SpeechRecognition: SpeechRecognition,
        SpeechRecognitionEvent: SpeechRecognitionEvent
    };
}
var _default = function _default(options) {
    var _patchOptions = (0, _patchOptions2.default)(options), _patchOptions$audioCo = _patchOptions.audioConfig, audioConfig = _patchOptions$audioCo === void 0 ? AudioConfig.fromDefaultMicrophoneInput() : _patchOptions$audioCo, _patchOptions$enableT = _patchOptions.enableTelemetry, enableTelemetry = _patchOptions$enableT === void 0 ? true : _patchOptions$enableT, fetchCredentials = _patchOptions.fetchCredentials, looseEvents = _patchOptions.looseEvents, referenceGrammars = _patchOptions.referenceGrammars, speechRecognitionEndpointId = _patchOptions.speechRecognitionEndpointId, _patchOptions$textNor = _patchOptions.textNormalization, textNormalization = _patchOptions$textNor === void 0 ? "display" : _patchOptions$textNor;
    if (!audioConfig && (!window.navigator.mediaDevices || !window.navigator.mediaDevices.getUserMedia)) {
        console.warn("web-speech-cognitive-services: This browser does not support WebRTC and it will not work with Cognitive Services Speech Services.");
        return {};
    }
    var createRecognizer = /*#__PURE__*/ function() {
        var _ref12 = (0, _asyncToGenerator2.default)(/*#__PURE__*/ _regenerator.default.mark(function _callee4(lang) {
            var _yield$fetchCredentia, authorizationToken, region, speechRecognitionHostname, subscriptionKey, speechConfig, host;
            return _regenerator.default.wrap(function _callee4$(_context5) {
                while(true)switch(_context5.prev = _context5.next){
                    case 0:
                        _context5.next = 2;
                        return fetchCredentials();
                    case 2:
                        _yield$fetchCredentia = _context5.sent;
                        authorizationToken = _yield$fetchCredentia.authorizationToken;
                        region = _yield$fetchCredentia.region;
                        speechRecognitionHostname = _yield$fetchCredentia.speechRecognitionHostname;
                        subscriptionKey = _yield$fetchCredentia.subscriptionKey;
                        if (speechRecognitionHostname) {
                            host = {
                                hostname: speechRecognitionHostname,
                                port: 443,
                                protocol: "wss:"
                            };
                            if (authorizationToken) {
                                speechConfig = SpeechConfig.fromHost(host);
                                speechConfig.authorizationToken = authorizationToken;
                            } else speechConfig = SpeechConfig.fromHost(host, subscriptionKey);
                        } else speechConfig = authorizationToken ? SpeechConfig.fromAuthorizationToken(authorizationToken, region) : SpeechConfig.fromSubscription(subscriptionKey, region);
                        if (speechRecognitionEndpointId) speechConfig.endpointId = speechRecognitionEndpointId;
                        speechConfig.outputFormat = OutputFormat.Detailed;
                        speechConfig.speechRecognitionLanguage = lang || "en-US";
                        return _context5.abrupt("return", new SpeechRecognizer(speechConfig, audioConfig));
                    case 12:
                    case "end":
                        return _context5.stop();
                }
            }, _callee4);
        }));
        return function createRecognizer(_x) {
            return _ref12.apply(this, arguments);
        };
    }();
    return createSpeechRecognitionPonyfillFromRecognizer({
        audioConfig: audioConfig,
        createRecognizer: createRecognizer,
        enableTelemetry: enableTelemetry,
        looseEvents: looseEvents,
        referenceGrammars: referenceGrammars,
        textNormalization: textNormalization
    });
};
exports.default = _default;

},{"6297db204a514748":"1hUHf","de3b514a267d04a0":"iN2WL","900f15de68cfad87":"fb7ej","912ad363d45e7b50":"3d8OR","53c7ea4570514e10":"jaYFv","993994f1926c419f":"b694u","f13fb2d185a2be3d":"7zlNi","edaad932fa789c4b":"bQ802","f5d71beae43c04ed":"kJc1U","3377945f42070eaa":"g7YIw","4f4b65b414e7104c":"iVIs8","2a54d8b5e9c740ed":"gXKmj","cda6bcc296d46db7":"58iBd","3f98356c8c7bdc38":"kIQZq","aa8dc9f3ebd0b084":"9CYwx","2f56c54d558b9657":"4RAYx"}],"gXKmj":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("5590892d20d161f4");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _default;
var _arrayToMap = _interopRequireDefault(require("d8093ce0664c21df"));
var _SpeechSDK = _interopRequireDefault(require("53d1aa218fbd6233"));
var _SpeechSDK$ResultReas = _SpeechSDK.default.ResultReason, RecognizingSpeech = _SpeechSDK$ResultReas.RecognizingSpeech, RecognizedSpeech = _SpeechSDK$ResultReas.RecognizedSpeech;
function _default(result) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$maxAlternatives = _ref.maxAlternatives, maxAlternatives = _ref$maxAlternatives === void 0 ? Infinity : _ref$maxAlternatives, _ref$textNormalizatio = _ref.textNormalization, textNormalization = _ref$textNormalizatio === void 0 ? "display" : _ref$textNormalizatio;
    if (result.reason === RecognizingSpeech || result.reason === RecognizedSpeech && !result.json.NBest) {
        var resultList = [
            {
                confidence: 0.5,
                transcript: result.text
            }
        ];
        if (result.reason === RecognizedSpeech) resultList.isFinal = true;
        return resultList;
    } else if (result.reason === RecognizedSpeech) {
        var _resultList = (0, _arrayToMap.default)((result.json.NBest || []).slice(0, maxAlternatives).map(function(_ref2) {
            var confidence = _ref2.Confidence, display = _ref2.Display, itn = _ref2.ITN, lexical = _ref2.Lexical, maskedITN = _ref2.MaskedITN;
            return {
                confidence: confidence,
                transcript: textNormalization === "itn" ? itn : textNormalization === "lexical" ? lexical : textNormalization === "maskeditn" ? maskedITN : display
            };
        }), {
            isFinal: true
        });
        return _resultList;
    }
    return [];
}

},{"5590892d20d161f4":"1hUHf","d8093ce0664c21df":"4U0YC","53d1aa218fbd6233":"4RAYx"}],"4U0YC":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("7c73db5a8ffafe19");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _default;
var _defineProperty2 = _interopRequireDefault(require("cc174c9fe641d13a"));
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _default(array, extras) {
    var map = _objectSpread(_objectSpread(_objectSpread({}, [].reduce.call(array, function(map, value, index) {
        map[index] = value;
        return map;
    }, {})), extras), {}, (0, _defineProperty2.default)({
        length: array.length
    }, Symbol.iterator, function() {
        return [].slice.call(map)[Symbol.iterator]();
    }));
    return map;
}

},{"7c73db5a8ffafe19":"1hUHf","cc174c9fe641d13a":"3d8OR"}],"4RAYx":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _microsoftCognitiveservicesSpeech = require("1cc57f5406ae92f1");
// We are only importing what we need.
var _default = {
    AudioConfig: _microsoftCognitiveservicesSpeech.AudioConfig,
    OutputFormat: _microsoftCognitiveservicesSpeech.OutputFormat,
    ResultReason: _microsoftCognitiveservicesSpeech.ResultReason,
    SpeechConfig: _microsoftCognitiveservicesSpeech.SpeechConfig,
    SpeechRecognizer: _microsoftCognitiveservicesSpeech.SpeechRecognizer
};
exports.default = _default;

},{"1cc57f5406ae92f1":"hu0na"}],"hu0na":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !exports1.hasOwnProperty(p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var Exports_1 = require("879fd77b7572015");
var Exports_2 = require("569858e598848fb9");
// Common.Storage.SetLocalStorage(new Common.Browser.LocalStorage());
// Common.Storage.SetSessionStorage(new Common.Browser.SessionStorage());
Exports_2.Events.instance.attachConsoleListener(new Exports_1.ConsoleLoggingListener());
// Speech SDK API
__exportStar(require("970e687073978075"), exports);

},{"879fd77b7572015":"9oZeQ","569858e598848fb9":"5Bedw","970e687073978075":"hxkc3"}],"9oZeQ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !exports1.hasOwnProperty(p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(require("6c4da11a931c6f43"), exports);
__exportStar(require("181b28e9bcde9fa3"), exports);
__exportStar(require("e3676f0d421be407"), exports);
__exportStar(require("4c7d76fbb99755f1"), exports);
__exportStar(require("2ab2cc0e8540c17"), exports);
__exportStar(require("85e2715c6408d4ee"), exports);
__exportStar(require("717d7f942db8f1ea"), exports);
__exportStar(require("cf4d137c3e03f781"), exports);
__exportStar(require("7f9d02a3b0a58abd"), exports);
__exportStar(require("9abe811523c11cc"), exports);
__exportStar(require("cc8c84eefe215299"), exports);

},{"6c4da11a931c6f43":"kGEGt","181b28e9bcde9fa3":"9YorG","e3676f0d421be407":"acSp9","4c7d76fbb99755f1":"bXen4","2ab2cc0e8540c17":"2qbKj","85e2715c6408d4ee":"bs0H1","717d7f942db8f1ea":"9VGwj","cf4d137c3e03f781":"a8xgF","7f9d02a3b0a58abd":"jQVwA","9abe811523c11cc":"dZptl","cc8c84eefe215299":"4qzsv"}],"kGEGt":[function(require,module,exports) {
"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-assignment */ // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConsoleLoggingListener = void 0;
var fs = __importStar(require("d93d4df842ffb9f0"));
var LogLevel_1 = require("1a3c2d13aae75384");
var Contracts_1 = require("5ac5fbbcaa13b5ec");
var ConsoleLoggingListener = /** @class */ function() {
    function ConsoleLoggingListener(logLevelFilter) {
        if (logLevelFilter === void 0) logLevelFilter = LogLevel_1.LogLevel.None;
        this.privLogPath = undefined;
        this.privEnableConsoleOutput = true;
        this.privLogLevelFilter = logLevelFilter;
    }
    Object.defineProperty(ConsoleLoggingListener.prototype, "logPath", {
        set: function(path) {
            Contracts_1.Contracts.throwIfNullOrUndefined(fs.openSync, "\nFile System access not available");
            this.privLogPath = path;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConsoleLoggingListener.prototype, "enableConsoleOutput", {
        set: function(enableOutput) {
            this.privEnableConsoleOutput = enableOutput;
        },
        enumerable: false,
        configurable: true
    });
    ConsoleLoggingListener.prototype.onEvent = function(event) {
        if (event.eventType >= this.privLogLevelFilter) {
            var log = this.toString(event);
            if (!!this.privLogPath) fs.writeFileSync(this.privLogPath, log + "\n", {
                flag: "a+"
            });
            if (this.privEnableConsoleOutput) switch(event.eventType){
                case LogLevel_1.LogLevel.Debug:
                    // eslint-disable-next-line no-console
                    console.debug(log);
                    break;
                case LogLevel_1.LogLevel.Info:
                    // eslint-disable-next-line no-console
                    console.info(log);
                    break;
                case LogLevel_1.LogLevel.Warning:
                    // eslint-disable-next-line no-console
                    console.warn(log);
                    break;
                case LogLevel_1.LogLevel.Error:
                    // eslint-disable-next-line no-console
                    console.error(log);
                    break;
                default:
                    // eslint-disable-next-line no-console
                    console.log(log);
                    break;
            }
        }
    };
    ConsoleLoggingListener.prototype.toString = function(event) {
        var logFragments = [
            "" + event.eventTime,
            "" + event.name
        ];
        var e = event;
        for(var prop in e)if (prop && event.hasOwnProperty(prop) && prop !== "eventTime" && prop !== "eventType" && prop !== "eventId" && prop !== "name" && prop !== "constructor") {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            var value = e[prop];
            var valueToLog = "<NULL>";
            if (value !== undefined && value !== null) {
                if (typeof value === "number" || typeof value === "string") valueToLog = value.toString();
                else valueToLog = JSON.stringify(value);
            }
            logFragments.push(prop + ": " + valueToLog);
        }
        return logFragments.join(" | ");
    };
    return ConsoleLoggingListener;
}();
exports.ConsoleLoggingListener = ConsoleLoggingListener;

},{"d93d4df842ffb9f0":"jhUEF","1a3c2d13aae75384":"12n5C","5ac5fbbcaa13b5ec":"4jwu5"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"12n5C":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LogLevel = void 0;
var Exports_1 = require("e6712278d1492671");
Object.defineProperty(exports, "LogLevel", {
    enumerable: true,
    get: function() {
        return Exports_1.EventType;
    }
});

},{"e6712278d1492671":"5Bedw"}],"5Bedw":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !exports1.hasOwnProperty(p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(require("aed2f6c6979f2222"), exports);
__exportStar(require("cb29dc3ad9795e6e"), exports);
__exportStar(require("d9e7f1c7a4097fdc"), exports);
__exportStar(require("313ea3b4f3ebcc09"), exports);
__exportStar(require("beb9bf7b5e737534"), exports);
__exportStar(require("716b74c40789ffdd"), exports);
__exportStar(require("1dd1885d01eb556"), exports);
__exportStar(require("f7712b2ef321a73e"), exports);
__exportStar(require("e4d24294f4eacc0d"), exports);
__exportStar(require("2ad68d4029f20baf"), exports);
__exportStar(require("991968911739d1a3"), exports);
__exportStar(require("bf7d97c5bcdb1476"), exports);
__exportStar(require("f5e9ef19dc137083"), exports);
__exportStar(require("31fb80ab6f39ed53"), exports);
__exportStar(require("b0e2fa79f21cf604"), exports);
__exportStar(require("4f891a4e25c8083f"), exports);
__exportStar(require("f7d1a1ecc5abe516"), exports);
__exportStar(require("f2c44f7fca2c99"), exports);
__exportStar(require("bd36426827eaa8c9"), exports);
__exportStar(require("c46cb601ef748c10"), exports);
__exportStar(require("70bd1a128e696ddf"), exports);
__exportStar(require("822ac26455856692"), exports);
__exportStar(require("305dc30177294d11"), exports);
__exportStar(require("8770fb77750d00f1"), exports);
__exportStar(require("8bb3045a4c7abf12"), exports);
__exportStar(require("9e7bc415c508052e"), exports);
var TranslationStatus_1 = require("e8caf8cd5c231c77");
Object.defineProperty(exports, "TranslationStatus", {
    enumerable: true,
    get: function() {
        return TranslationStatus_1.TranslationStatus;
    }
});
__exportStar(require("4722553d7270014f"), exports);
__exportStar(require("9d5dc8d951994898"), exports);
__exportStar(require("b4061919421a31c6"), exports);
__exportStar(require("b986b8b4d2090b1e"), exports);
__exportStar(require("2b6bab0358e051b1"), exports);

},{"aed2f6c6979f2222":"5pzEV","cb29dc3ad9795e6e":"d4ewN","d9e7f1c7a4097fdc":"1Mi5U","313ea3b4f3ebcc09":"bM43i","beb9bf7b5e737534":"jZCOZ","716b74c40789ffdd":"cBT2n","1dd1885d01eb556":"fyy92","f7712b2ef321a73e":"5LYGn","e4d24294f4eacc0d":"a9eyX","2ad68d4029f20baf":"dLGUL","991968911739d1a3":"bwtD8","bf7d97c5bcdb1476":"376z0","f5e9ef19dc137083":"6yYWM","31fb80ab6f39ed53":"lGeFl","b0e2fa79f21cf604":"cz2qC","4f891a4e25c8083f":"4mkjg","f7d1a1ecc5abe516":"5oOgk","f2c44f7fca2c99":"7rYVn","bd36426827eaa8c9":"5UJMu","c46cb601ef748c10":"2k7ok","70bd1a128e696ddf":"lrUbr","822ac26455856692":"BjAdk","305dc30177294d11":"bCIYp","8770fb77750d00f1":"7RJqM","8bb3045a4c7abf12":"034Ao","9e7bc415c508052e":"dPj8n","e8caf8cd5c231c77":"kKQWF","4722553d7270014f":"6YGbc","9d5dc8d951994898":"WeS9P","b4061919421a31c6":"I27Va","b986b8b4d2090b1e":"hhldP","2b6bab0358e051b1":"joIRE"}],"5pzEV":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AudioStreamNodeErrorEvent = exports.AudioStreamNodeDetachedEvent = exports.AudioStreamNodeAttachedEvent = exports.AudioStreamNodeAttachingEvent = exports.AudioStreamNodeEvent = exports.AudioSourceErrorEvent = exports.AudioSourceOffEvent = exports.AudioSourceReadyEvent = exports.AudioSourceInitializingEvent = exports.AudioSourceEvent = void 0;
/* eslint-disable max-classes-per-file */ var PlatformEvent_1 = require("9306d1a2eea8ad73");
var AudioSourceEvent = /** @class */ function(_super) {
    __extends(AudioSourceEvent, _super);
    function AudioSourceEvent(eventName, audioSourceId, eventType) {
        if (eventType === void 0) eventType = PlatformEvent_1.EventType.Info;
        var _this = _super.call(this, eventName, eventType) || this;
        _this.privAudioSourceId = audioSourceId;
        return _this;
    }
    Object.defineProperty(AudioSourceEvent.prototype, "audioSourceId", {
        get: function() {
            return this.privAudioSourceId;
        },
        enumerable: false,
        configurable: true
    });
    return AudioSourceEvent;
}(PlatformEvent_1.PlatformEvent);
exports.AudioSourceEvent = AudioSourceEvent;
var AudioSourceInitializingEvent = /** @class */ function(_super) {
    __extends(AudioSourceInitializingEvent, _super);
    function AudioSourceInitializingEvent(audioSourceId) {
        return _super.call(this, "AudioSourceInitializingEvent", audioSourceId) || this;
    }
    return AudioSourceInitializingEvent;
}(AudioSourceEvent);
exports.AudioSourceInitializingEvent = AudioSourceInitializingEvent;
var AudioSourceReadyEvent = /** @class */ function(_super) {
    __extends(AudioSourceReadyEvent, _super);
    function AudioSourceReadyEvent(audioSourceId) {
        return _super.call(this, "AudioSourceReadyEvent", audioSourceId) || this;
    }
    return AudioSourceReadyEvent;
}(AudioSourceEvent);
exports.AudioSourceReadyEvent = AudioSourceReadyEvent;
var AudioSourceOffEvent = /** @class */ function(_super) {
    __extends(AudioSourceOffEvent, _super);
    function AudioSourceOffEvent(audioSourceId) {
        return _super.call(this, "AudioSourceOffEvent", audioSourceId) || this;
    }
    return AudioSourceOffEvent;
}(AudioSourceEvent);
exports.AudioSourceOffEvent = AudioSourceOffEvent;
var AudioSourceErrorEvent = /** @class */ function(_super) {
    __extends(AudioSourceErrorEvent, _super);
    function AudioSourceErrorEvent(audioSourceId, error) {
        var _this = _super.call(this, "AudioSourceErrorEvent", audioSourceId, PlatformEvent_1.EventType.Error) || this;
        _this.privError = error;
        return _this;
    }
    Object.defineProperty(AudioSourceErrorEvent.prototype, "error", {
        get: function() {
            return this.privError;
        },
        enumerable: false,
        configurable: true
    });
    return AudioSourceErrorEvent;
}(AudioSourceEvent);
exports.AudioSourceErrorEvent = AudioSourceErrorEvent;
var AudioStreamNodeEvent = /** @class */ function(_super) {
    __extends(AudioStreamNodeEvent, _super);
    function AudioStreamNodeEvent(eventName, audioSourceId, audioNodeId) {
        var _this = _super.call(this, eventName, audioSourceId) || this;
        _this.privAudioNodeId = audioNodeId;
        return _this;
    }
    Object.defineProperty(AudioStreamNodeEvent.prototype, "audioNodeId", {
        get: function() {
            return this.privAudioNodeId;
        },
        enumerable: false,
        configurable: true
    });
    return AudioStreamNodeEvent;
}(AudioSourceEvent);
exports.AudioStreamNodeEvent = AudioStreamNodeEvent;
var AudioStreamNodeAttachingEvent = /** @class */ function(_super) {
    __extends(AudioStreamNodeAttachingEvent, _super);
    function AudioStreamNodeAttachingEvent(audioSourceId, audioNodeId) {
        return _super.call(this, "AudioStreamNodeAttachingEvent", audioSourceId, audioNodeId) || this;
    }
    return AudioStreamNodeAttachingEvent;
}(AudioStreamNodeEvent);
exports.AudioStreamNodeAttachingEvent = AudioStreamNodeAttachingEvent;
var AudioStreamNodeAttachedEvent = /** @class */ function(_super) {
    __extends(AudioStreamNodeAttachedEvent, _super);
    function AudioStreamNodeAttachedEvent(audioSourceId, audioNodeId) {
        return _super.call(this, "AudioStreamNodeAttachedEvent", audioSourceId, audioNodeId) || this;
    }
    return AudioStreamNodeAttachedEvent;
}(AudioStreamNodeEvent);
exports.AudioStreamNodeAttachedEvent = AudioStreamNodeAttachedEvent;
var AudioStreamNodeDetachedEvent = /** @class */ function(_super) {
    __extends(AudioStreamNodeDetachedEvent, _super);
    function AudioStreamNodeDetachedEvent(audioSourceId, audioNodeId) {
        return _super.call(this, "AudioStreamNodeDetachedEvent", audioSourceId, audioNodeId) || this;
    }
    return AudioStreamNodeDetachedEvent;
}(AudioStreamNodeEvent);
exports.AudioStreamNodeDetachedEvent = AudioStreamNodeDetachedEvent;
var AudioStreamNodeErrorEvent = /** @class */ function(_super) {
    __extends(AudioStreamNodeErrorEvent, _super);
    function AudioStreamNodeErrorEvent(audioSourceId, audioNodeId, error) {
        var _this = _super.call(this, "AudioStreamNodeErrorEvent", audioSourceId, audioNodeId) || this;
        _this.privError = error;
        return _this;
    }
    Object.defineProperty(AudioStreamNodeErrorEvent.prototype, "error", {
        get: function() {
            return this.privError;
        },
        enumerable: false,
        configurable: true
    });
    return AudioStreamNodeErrorEvent;
}(AudioStreamNodeEvent);
exports.AudioStreamNodeErrorEvent = AudioStreamNodeErrorEvent;

},{"9306d1a2eea8ad73":"lrUbr"}],"lrUbr":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PlatformEvent = exports.EventType = void 0;
var Guid_1 = require("8e15a7f47e71afd0");
var EventType;
(function(EventType) {
    EventType[EventType["Debug"] = 0] = "Debug";
    EventType[EventType["Info"] = 1] = "Info";
    EventType[EventType["Warning"] = 2] = "Warning";
    EventType[EventType["Error"] = 3] = "Error";
    EventType[EventType["None"] = 4] = "None";
})(EventType = exports.EventType || (exports.EventType = {}));
var PlatformEvent = /** @class */ function() {
    function PlatformEvent(eventName, eventType) {
        this.privName = eventName;
        this.privEventId = Guid_1.createNoDashGuid();
        this.privEventTime = new Date().toISOString();
        this.privEventType = eventType;
        this.privMetadata = {};
    }
    Object.defineProperty(PlatformEvent.prototype, "name", {
        get: function() {
            return this.privName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlatformEvent.prototype, "eventId", {
        get: function() {
            return this.privEventId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlatformEvent.prototype, "eventTime", {
        get: function() {
            return this.privEventTime;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlatformEvent.prototype, "eventType", {
        get: function() {
            return this.privEventType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlatformEvent.prototype, "metadata", {
        get: function() {
            return this.privMetadata;
        },
        enumerable: false,
        configurable: true
    });
    return PlatformEvent;
}();
exports.PlatformEvent = PlatformEvent;

},{"8e15a7f47e71afd0":"dLGUL"}],"dLGUL":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createNoDashGuid = exports.createGuid = void 0;
var uuid_1 = require("692eac9f4aeb6fc8");
var createGuid = function() {
    return uuid_1.v4();
};
exports.createGuid = createGuid;
var createNoDashGuid = function() {
    return createGuid().replace(new RegExp("-", "g"), "").toUpperCase();
};
exports.createNoDashGuid = createNoDashGuid;

},{"692eac9f4aeb6fc8":"2WTb6"}],"2WTb6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>(0, _v1JsDefault.default));
parcelHelpers.export(exports, "v3", ()=>(0, _v3JsDefault.default));
parcelHelpers.export(exports, "v4", ()=>(0, _v4JsDefault.default));
parcelHelpers.export(exports, "v5", ()=>(0, _v5JsDefault.default));
parcelHelpers.export(exports, "NIL", ()=>(0, _nilJsDefault.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
parcelHelpers.export(exports, "validate", ()=>(0, _validateJsDefault.default));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJsDefault.default));
parcelHelpers.export(exports, "parse", ()=>(0, _parseJsDefault.default));
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":"1Rpto","./v3.js":"hbrrN","./v4.js":"k8xLp","./v5.js":"eIIrc","./nil.js":"hnEew","./version.js":"fVeae","./validate.js":"fpS43","./stringify.js":"4ZH7N","./parse.js":"383Y8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Rpto":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js"); // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;
let _clockseq; // Previous uuid creation time
let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189
    if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || (0, _rngJsDefault.default))();
        if (node == null) // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
        node = _nodeId = [
            seedBytes[0] | 0x01,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
        ];
        if (clockseq == null) // Per 4.2.2, randomize (14 bit) clockseq
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) clockseq = clockseq + 1 & 0x3fff;
     // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) nsecs = 0;
     // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000; // `time_low`
    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`
    const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`
    b[i++] = clockseq & 0xff; // `node`
    for(let n = 0; n < 6; ++n)b[i + n] = node[n];
    return buf || (0, _stringifyJs.unsafeStringify)(b);
}
exports.default = v1;

},{"./rng.js":"73jYm","./stringify.js":"4ZH7N","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"73jYm":[function(require,module,exports) {
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>rng);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    return getRandomValues(rnds8);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ZH7N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeStringify", ()=>unsafeStringify);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"fpS43","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fpS43":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === "string" && (0, _regexJsDefault.default).test(uuid);
}
exports.default = validate;

},{"./regex.js":"2DBgd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2DBgd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hbrrN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _v35Js = require("./v35.js");
var _v35JsDefault = parcelHelpers.interopDefault(_v35Js);
var _md5Js = require("./md5.js");
var _md5JsDefault = parcelHelpers.interopDefault(_md5Js);
const v3 = (0, _v35JsDefault.default)("v3", 0x30, (0, _md5JsDefault.default));
exports.default = v3;

},{"./v35.js":"eoqHW","./md5.js":"a5ntc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eoqHW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DNS", ()=>DNS);
parcelHelpers.export(exports, "URL", ()=>URL);
parcelHelpers.export(exports, "default", ()=>v35);
var _stringifyJs = require("./stringify.js");
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    const bytes = [];
    for(let i = 0; i < str.length; ++i)bytes.push(str.charCodeAt(i));
    return bytes;
}
const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
const URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") value = stringToBytes(value);
        if (typeof namespace === "string") namespace = (0, _parseJsDefault.default)(namespace);
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
         // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;
        if (buf) {
            offset = offset || 0;
            for(let i = 0; i < 16; ++i)buf[offset + i] = bytes[i];
            return buf;
        }
        return (0, _stringifyJs.unsafeStringify)(bytes);
    } // Function#name is not settable on some platforms (#270)
    try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
    } catch (err) {} // For CommonJS default export support
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
}

},{"./stringify.js":"4ZH7N","./parse.js":"383Y8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"383Y8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
function parse(uuid) {
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Invalid UUID");
    let v;
    const arr = new Uint8Array(16); // Parse ########-....-....-....-............
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 0xff;
    arr[2] = v >>> 8 & 0xff;
    arr[3] = v & 0xff; // Parse ........-####-....-....-............
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 0xff; // Parse ........-....-####-....-............
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 0xff; // Parse ........-....-....-####-............
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 0xff; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
    arr[11] = v / 0x100000000 & 0xff;
    arr[12] = v >>> 24 & 0xff;
    arr[13] = v >>> 16 & 0xff;
    arr[14] = v >>> 8 & 0xff;
    arr[15] = v & 0xff;
    return arr;
}
exports.default = parse;

},{"./validate.js":"fpS43","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a5ntc":[function(require,module,exports) {
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function md5(bytes) {
    if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
        bytes = new Uint8Array(msg.length);
        for(let i = 0; i < msg.length; ++i)bytes[i] = msg.charCodeAt(i);
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */ function md5ToHexEncodedArray(input) {
    const output = [];
    const length32 = input.length * 32;
    const hexTab = "0123456789abcdef";
    for(let i = 0; i < length32; i += 8){
        const x = input[i >> 5] >>> i % 32 & 0xff;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
        output.push(hex);
    }
    return output;
}
/**
 * Calculate output length with padding and bit length
 */ function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */ function wordsToMd5(x, len) {
    /* append padding */ x[len >> 5] |= 0x80 << len % 32;
    x[getOutputLength(len) - 1] = len;
    let a = 1732584193;
    let b = -271733879;
    let c = -1732584194;
    let d = 271733878;
    for(let i = 0; i < x.length; i += 16){
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
    }
    return [
        a,
        b,
        c,
        d
    ];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */ function bytesToWords(input) {
    if (input.length === 0) return [];
    const length8 = input.length * 8;
    const output = new Uint32Array(getOutputLength(length8));
    for(let i = 0; i < length8; i += 8)output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
    return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */ function safeAdd(x, y) {
    const lsw = (x & 0xffff) + (y & 0xffff);
    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */ function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */ function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
exports.default = md5;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k8xLp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeJs = require("./native.js");
var _nativeJsDefault = parcelHelpers.interopDefault(_nativeJs);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
function v4(options, buf, offset) {
    if ((0, _nativeJsDefault.default).randomUUID && !buf && !options) return (0, _nativeJsDefault.default).randomUUID();
    options = options || {};
    const rnds = options.random || (options.rng || (0, _rngJsDefault.default))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, _stringifyJs.unsafeStringify)(rnds);
}
exports.default = v4;

},{"./native.js":"h7uJa","./rng.js":"73jYm","./stringify.js":"4ZH7N","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h7uJa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports.default = {
    randomUUID
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eIIrc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _v35Js = require("./v35.js");
var _v35JsDefault = parcelHelpers.interopDefault(_v35Js);
var _sha1Js = require("./sha1.js");
var _sha1JsDefault = parcelHelpers.interopDefault(_sha1Js);
const v5 = (0, _v35JsDefault.default)("v5", 0x50, (0, _sha1JsDefault.default));
exports.default = v5;

},{"./v35.js":"eoqHW","./sha1.js":"gvBS6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gvBS6":[function(require,module,exports) {
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function f(s, x, y, z) {
    switch(s){
        case 0:
            return x & y ^ ~x & z;
        case 1:
            return x ^ y ^ z;
        case 2:
            return x & y ^ x & z ^ y & z;
        case 3:
            return x ^ y ^ z;
    }
}
function ROTL(x, n) {
    return x << n | x >>> 32 - n;
}
function sha1(bytes) {
    const K = [
        0x5a827999,
        0x6ed9eba1,
        0x8f1bbcdc,
        0xca62c1d6
    ];
    const H = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
        bytes = [];
        for(let i = 0; i < msg.length; ++i)bytes.push(msg.charCodeAt(i));
    } else if (!Array.isArray(bytes)) // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
    bytes.push(0x80);
    const l = bytes.length / 4 + 2;
    const N = Math.ceil(l / 16);
    const M = new Array(N);
    for(let i = 0; i < N; ++i){
        const arr = new Uint32Array(16);
        for(let j = 0; j < 16; ++j)arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        M[i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
    for(let i = 0; i < N; ++i){
        const W = new Uint32Array(80);
        for(let t = 0; t < 16; ++t)W[t] = M[i][t];
        for(let t = 16; t < 80; ++t)W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for(let t = 0; t < 80; ++t){
            const s = Math.floor(t / 20);
            const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
    }
    return [
        H[0] >> 24 & 0xff,
        H[0] >> 16 & 0xff,
        H[0] >> 8 & 0xff,
        H[0] & 0xff,
        H[1] >> 24 & 0xff,
        H[1] >> 16 & 0xff,
        H[1] >> 8 & 0xff,
        H[1] & 0xff,
        H[2] >> 24 & 0xff,
        H[2] >> 16 & 0xff,
        H[2] >> 8 & 0xff,
        H[2] & 0xff,
        H[3] >> 24 & 0xff,
        H[3] >> 16 & 0xff,
        H[3] >> 8 & 0xff,
        H[3] & 0xff,
        H[4] >> 24 & 0xff,
        H[4] >> 16 & 0xff,
        H[4] >> 8 & 0xff,
        H[4] & 0xff
    ];
}
exports.default = sha1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hnEew":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = "00000000-0000-0000-0000-000000000000";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fVeae":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
function version(uuid) {
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Invalid UUID");
    return parseInt(uuid.slice(14, 15), 16);
}
exports.default = version;

},{"./validate.js":"fpS43","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d4ewN":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionMessageSentEvent = exports.ConnectionMessageReceivedEvent = exports.ConnectionEstablishErrorEvent = exports.ConnectionErrorEvent = exports.ConnectionClosedEvent = exports.ConnectionEstablishedEvent = exports.ConnectionStartEvent = exports.ConnectionEvent = exports.ServiceEvent = void 0;
var PlatformEvent_1 = require("3515fd025da7358c");
var ServiceEvent = /** @class */ function(_super) {
    __extends(ServiceEvent, _super);
    function ServiceEvent(eventName, jsonstring, eventType) {
        if (eventType === void 0) eventType = PlatformEvent_1.EventType.Info;
        var _this = _super.call(this, eventName, eventType) || this;
        _this.privJsonResult = jsonstring;
        return _this;
    }
    Object.defineProperty(ServiceEvent.prototype, "jsonString", {
        get: function() {
            return this.privJsonResult;
        },
        enumerable: false,
        configurable: true
    });
    return ServiceEvent;
}(PlatformEvent_1.PlatformEvent);
exports.ServiceEvent = ServiceEvent;
var ConnectionEvent = /** @class */ function(_super) {
    __extends(ConnectionEvent, _super);
    function ConnectionEvent(eventName, connectionId, eventType) {
        if (eventType === void 0) eventType = PlatformEvent_1.EventType.Info;
        var _this = _super.call(this, eventName, eventType) || this;
        _this.privConnectionId = connectionId;
        return _this;
    }
    Object.defineProperty(ConnectionEvent.prototype, "connectionId", {
        get: function() {
            return this.privConnectionId;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectionEvent;
}(PlatformEvent_1.PlatformEvent);
exports.ConnectionEvent = ConnectionEvent;
var ConnectionStartEvent = /** @class */ function(_super) {
    __extends(ConnectionStartEvent, _super);
    function ConnectionStartEvent(connectionId, uri, headers) {
        var _this = _super.call(this, "ConnectionStartEvent", connectionId) || this;
        _this.privUri = uri;
        _this.privHeaders = headers;
        return _this;
    }
    Object.defineProperty(ConnectionStartEvent.prototype, "uri", {
        get: function() {
            return this.privUri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionStartEvent.prototype, "headers", {
        get: function() {
            return this.privHeaders;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectionStartEvent;
}(ConnectionEvent);
exports.ConnectionStartEvent = ConnectionStartEvent;
var ConnectionEstablishedEvent = /** @class */ function(_super) {
    __extends(ConnectionEstablishedEvent, _super);
    function ConnectionEstablishedEvent(connectionId) {
        return _super.call(this, "ConnectionEstablishedEvent", connectionId) || this;
    }
    return ConnectionEstablishedEvent;
}(ConnectionEvent);
exports.ConnectionEstablishedEvent = ConnectionEstablishedEvent;
var ConnectionClosedEvent = /** @class */ function(_super) {
    __extends(ConnectionClosedEvent, _super);
    function ConnectionClosedEvent(connectionId, statusCode, reason) {
        var _this = _super.call(this, "ConnectionClosedEvent", connectionId, PlatformEvent_1.EventType.Debug) || this;
        _this.privReason = reason;
        _this.privStatusCode = statusCode;
        return _this;
    }
    Object.defineProperty(ConnectionClosedEvent.prototype, "reason", {
        get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionClosedEvent.prototype, "statusCode", {
        get: function() {
            return this.privStatusCode;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectionClosedEvent;
}(ConnectionEvent);
exports.ConnectionClosedEvent = ConnectionClosedEvent;
var ConnectionErrorEvent = /** @class */ function(_super) {
    __extends(ConnectionErrorEvent, _super);
    function ConnectionErrorEvent(connectionId, message, type) {
        var _this = _super.call(this, "ConnectionErrorEvent", connectionId, PlatformEvent_1.EventType.Debug) || this;
        _this.privMessage = message;
        _this.privType = type;
        return _this;
    }
    Object.defineProperty(ConnectionErrorEvent.prototype, "message", {
        get: function() {
            return this.privMessage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionErrorEvent.prototype, "type", {
        get: function() {
            return this.privType;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectionErrorEvent;
}(ConnectionEvent);
exports.ConnectionErrorEvent = ConnectionErrorEvent;
var ConnectionEstablishErrorEvent = /** @class */ function(_super) {
    __extends(ConnectionEstablishErrorEvent, _super);
    function ConnectionEstablishErrorEvent(connectionId, statuscode, reason) {
        var _this = _super.call(this, "ConnectionEstablishErrorEvent", connectionId, PlatformEvent_1.EventType.Error) || this;
        _this.privStatusCode = statuscode;
        _this.privReason = reason;
        return _this;
    }
    Object.defineProperty(ConnectionEstablishErrorEvent.prototype, "reason", {
        get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionEstablishErrorEvent.prototype, "statusCode", {
        get: function() {
            return this.privStatusCode;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectionEstablishErrorEvent;
}(ConnectionEvent);
exports.ConnectionEstablishErrorEvent = ConnectionEstablishErrorEvent;
var ConnectionMessageReceivedEvent = /** @class */ function(_super) {
    __extends(ConnectionMessageReceivedEvent, _super);
    function ConnectionMessageReceivedEvent(connectionId, networkReceivedTimeISO, message) {
        var _this = _super.call(this, "ConnectionMessageReceivedEvent", connectionId) || this;
        _this.privNetworkReceivedTime = networkReceivedTimeISO;
        _this.privMessage = message;
        return _this;
    }
    Object.defineProperty(ConnectionMessageReceivedEvent.prototype, "networkReceivedTime", {
        get: function() {
            return this.privNetworkReceivedTime;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessageReceivedEvent.prototype, "message", {
        get: function() {
            return this.privMessage;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectionMessageReceivedEvent;
}(ConnectionEvent);
exports.ConnectionMessageReceivedEvent = ConnectionMessageReceivedEvent;
var ConnectionMessageSentEvent = /** @class */ function(_super) {
    __extends(ConnectionMessageSentEvent, _super);
    function ConnectionMessageSentEvent(connectionId, networkSentTimeISO, message) {
        var _this = _super.call(this, "ConnectionMessageSentEvent", connectionId) || this;
        _this.privNetworkSentTime = networkSentTimeISO;
        _this.privMessage = message;
        return _this;
    }
    Object.defineProperty(ConnectionMessageSentEvent.prototype, "networkSentTime", {
        get: function() {
            return this.privNetworkSentTime;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessageSentEvent.prototype, "message", {
        get: function() {
            return this.privMessage;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectionMessageSentEvent;
}(ConnectionEvent);
exports.ConnectionMessageSentEvent = ConnectionMessageSentEvent;

},{"3515fd025da7358c":"lrUbr"}],"1Mi5U":[function(require,module,exports) {
"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-return */ // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionMessage = exports.MessageType = void 0;
var Error_1 = require("1fd4c855d33f64ce");
var Guid_1 = require("37279633eb773841");
var MessageType;
(function(MessageType) {
    MessageType[MessageType["Text"] = 0] = "Text";
    MessageType[MessageType["Binary"] = 1] = "Binary";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
var ConnectionMessage = /** @class */ function() {
    function ConnectionMessage(messageType, body, headers, id) {
        this.privBody = null;
        if (messageType === MessageType.Text && body && !(typeof body === "string")) throw new Error_1.InvalidOperationError("Payload must be a string");
        if (messageType === MessageType.Binary && body && !(body instanceof ArrayBuffer)) throw new Error_1.InvalidOperationError("Payload must be ArrayBuffer");
        this.privMessageType = messageType;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.privBody = body;
        this.privHeaders = headers ? headers : {};
        this.privId = id ? id : Guid_1.createNoDashGuid();
        switch(this.messageType){
            case MessageType.Binary:
                this.privSize = this.binaryBody !== null ? this.binaryBody.byteLength : 0;
                break;
            case MessageType.Text:
                this.privSize = this.textBody.length;
        }
    }
    Object.defineProperty(ConnectionMessage.prototype, "messageType", {
        get: function() {
            return this.privMessageType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessage.prototype, "headers", {
        get: function() {
            return this.privHeaders;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessage.prototype, "body", {
        get: function() {
            return this.privBody;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessage.prototype, "textBody", {
        get: function() {
            if (this.privMessageType === MessageType.Binary) throw new Error_1.InvalidOperationError("Not supported for binary message");
            return this.privBody;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessage.prototype, "binaryBody", {
        get: function() {
            if (this.privMessageType === MessageType.Text) throw new Error_1.InvalidOperationError("Not supported for text message");
            return this.privBody;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessage.prototype, "id", {
        get: function() {
            return this.privId;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectionMessage;
}();
exports.ConnectionMessage = ConnectionMessage;

},{"1fd4c855d33f64ce":"fyy92","37279633eb773841":"dLGUL"}],"fyy92":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ObjectDisposedError = exports.InvalidOperationError = exports.ArgumentNullError = void 0;
/* eslint-disable max-classes-per-file */ /**
 * The error that is thrown when an argument passed in is null.
 *
 * @export
 * @class ArgumentNullError
 * @extends {Error}
 */ var ArgumentNullError = /** @class */ function(_super) {
    __extends(ArgumentNullError, _super);
    /**
     * Creates an instance of ArgumentNullError.
     *
     * @param {string} argumentName - Name of the argument that is null
     *
     * @memberOf ArgumentNullError
     */ function ArgumentNullError(argumentName) {
        var _this = _super.call(this, argumentName) || this;
        _this.name = "ArgumentNull";
        _this.message = argumentName;
        return _this;
    }
    return ArgumentNullError;
}(Error);
exports.ArgumentNullError = ArgumentNullError;
/**
 * The error that is thrown when an invalid operation is performed in the code.
 *
 * @export
 * @class InvalidOperationError
 * @extends {Error}
 */ var InvalidOperationError = /** @class */ function(_super) {
    __extends(InvalidOperationError, _super);
    /**
     * Creates an instance of InvalidOperationError.
     *
     * @param {string} error - The error
     *
     * @memberOf InvalidOperationError
     */ function InvalidOperationError(error) {
        var _this = _super.call(this, error) || this;
        _this.name = "InvalidOperation";
        _this.message = error;
        return _this;
    }
    return InvalidOperationError;
}(Error);
exports.InvalidOperationError = InvalidOperationError;
/**
 * The error that is thrown when an object is disposed.
 *
 * @export
 * @class ObjectDisposedError
 * @extends {Error}
 */ var ObjectDisposedError = /** @class */ function(_super) {
    __extends(ObjectDisposedError, _super);
    /**
     * Creates an instance of ObjectDisposedError.
     *
     * @param {string} objectName - The object that is disposed
     * @param {string} error - The error
     *
     * @memberOf ObjectDisposedError
     */ function ObjectDisposedError(objectName, error) {
        var _this = _super.call(this, error) || this;
        _this.name = objectName + "ObjectDisposed";
        _this.message = error;
        return _this;
    }
    return ObjectDisposedError;
}(Error);
exports.ObjectDisposedError = ObjectDisposedError;

},{}],"bM43i":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionOpenResponse = void 0;
var ConnectionOpenResponse = /** @class */ function() {
    function ConnectionOpenResponse(statusCode, reason) {
        this.privStatusCode = statusCode;
        this.privReason = reason;
    }
    Object.defineProperty(ConnectionOpenResponse.prototype, "statusCode", {
        get: function() {
            return this.privStatusCode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionOpenResponse.prototype, "reason", {
        get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectionOpenResponse;
}();
exports.ConnectionOpenResponse = ConnectionOpenResponse;

},{}],"jZCOZ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DeferralMap = void 0;
/**
 * The error that is thrown when an argument passed in is null.
 *
 * @export
 * @class DefferalMap
 */ var DeferralMap = /** @class */ function() {
    function DeferralMap() {
        this.privMap = {};
    }
    DeferralMap.prototype.add = function(id, deferral) {
        this.privMap[id] = deferral;
    };
    DeferralMap.prototype.getId = function(id) {
        return this.privMap[id];
    };
    DeferralMap.prototype.complete = function(id, result) {
        try {
            this.privMap[id].resolve(result);
        } catch (error) {
            this.privMap[id].reject(error);
        } finally{
            this.privMap[id] = undefined;
        }
    };
    return DeferralMap;
}();
exports.DeferralMap = DeferralMap;

},{}],"cBT2n":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SendingAgentContextMessageEvent = exports.DialogEvent = void 0;
var PlatformEvent_1 = require("9ba947b650ff4c63");
var DialogEvent = /** @class */ function(_super) {
    __extends(DialogEvent, _super);
    function DialogEvent(eventName, eventType) {
        if (eventType === void 0) eventType = PlatformEvent_1.EventType.Info;
        return _super.call(this, eventName, eventType) || this;
    }
    return DialogEvent;
}(PlatformEvent_1.PlatformEvent);
exports.DialogEvent = DialogEvent;
var SendingAgentContextMessageEvent = /** @class */ function(_super) {
    __extends(SendingAgentContextMessageEvent, _super);
    function SendingAgentContextMessageEvent(agentConfig) {
        var _this = _super.call(this, "SendingAgentContextMessageEvent") || this;
        _this.privAgentConfig = agentConfig;
        return _this;
    }
    Object.defineProperty(SendingAgentContextMessageEvent.prototype, "agentConfig", {
        get: function() {
            return this.privAgentConfig;
        },
        enumerable: false,
        configurable: true
    });
    return SendingAgentContextMessageEvent;
}(DialogEvent);
exports.SendingAgentContextMessageEvent = SendingAgentContextMessageEvent;

},{"9ba947b650ff4c63":"lrUbr"}],"5LYGn":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Events = void 0;
var Error_1 = require("8d3fd377de323ea2");
var EventSource_1 = require("8b4f2b610212b542");
var Events = /** @class */ function() {
    function Events() {}
    Events.setEventSource = function(eventSource) {
        if (!eventSource) throw new Error_1.ArgumentNullError("eventSource");
        Events.privInstance = eventSource;
    };
    Object.defineProperty(Events, "instance", {
        get: function() {
            return Events.privInstance;
        },
        enumerable: false,
        configurable: true
    });
    Events.privInstance = new EventSource_1.EventSource();
    return Events;
}();
exports.Events = Events;

},{"8d3fd377de323ea2":"fyy92","8b4f2b610212b542":"a9eyX"}],"a9eyX":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EventSource = void 0;
var Error_1 = require("6fbbabacebf8252f");
var Guid_1 = require("9d76acf04b1d0a7f");
var EventSource = /** @class */ function() {
    function EventSource(metadata) {
        this.privEventListeners = {};
        this.privIsDisposed = false;
        this.privConsoleListener = undefined;
        this.privMetadata = metadata;
    }
    EventSource.prototype.onEvent = function(event) {
        if (this.isDisposed()) throw new Error_1.ObjectDisposedError("EventSource");
        if (this.metadata) {
            for(var paramName in this.metadata)if (paramName) {
                if (event.metadata) {
                    if (!event.metadata[paramName]) event.metadata[paramName] = this.metadata[paramName];
                }
            }
        }
        for(var eventId in this.privEventListeners)if (eventId && this.privEventListeners[eventId]) this.privEventListeners[eventId](event);
    };
    EventSource.prototype.attach = function(onEventCallback) {
        var _this = this;
        var id = Guid_1.createNoDashGuid();
        this.privEventListeners[id] = onEventCallback;
        return {
            detach: function() {
                delete _this.privEventListeners[id];
                return Promise.resolve();
            }
        };
    };
    EventSource.prototype.attachListener = function(listener) {
        return this.attach(function(e) {
            return listener.onEvent(e);
        });
    };
    EventSource.prototype.attachConsoleListener = function(listener) {
        if (!!this.privConsoleListener) this.privConsoleListener.detach(); // Detach implementation for eventListeners is synchronous
        this.privConsoleListener = this.attach(function(e) {
            return listener.onEvent(e);
        });
        return this.privConsoleListener;
    };
    EventSource.prototype.isDisposed = function() {
        return this.privIsDisposed;
    };
    EventSource.prototype.dispose = function() {
        this.privEventListeners = null;
        this.privIsDisposed = true;
    };
    Object.defineProperty(EventSource.prototype, "metadata", {
        get: function() {
            return this.privMetadata;
        },
        enumerable: false,
        configurable: true
    });
    return EventSource;
}();
exports.EventSource = EventSource;

},{"6fbbabacebf8252f":"fyy92","9d76acf04b1d0a7f":"dLGUL"}],"bwtD8":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"376z0":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionState = void 0;
var ConnectionState;
(function(ConnectionState) {
    ConnectionState[ConnectionState["None"] = 0] = "None";
    ConnectionState[ConnectionState["Connected"] = 1] = "Connected";
    ConnectionState[ConnectionState["Connecting"] = 2] = "Connecting";
    ConnectionState[ConnectionState["Disconnected"] = 3] = "Disconnected";
})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));

},{}],"6yYWM":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"lGeFl":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"cz2qC":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"4mkjg":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"5oOgk":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"7rYVn":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"5UJMu":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"2k7ok":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.List = void 0;
var Error_1 = require("41a83c905dba18eb");
var List = /** @class */ function() {
    function List(list) {
        this.privSubscriptionIdCounter = 0;
        this.privAddSubscriptions = {};
        this.privRemoveSubscriptions = {};
        this.privDisposedSubscriptions = {};
        this.privDisposeReason = null;
        this.privList = [];
        // copy the list rather than taking as is.
        if (list) for(var _i = 0, list_1 = list; _i < list_1.length; _i++){
            var item = list_1[_i];
            this.privList.push(item);
        }
    }
    List.prototype.get = function(itemIndex) {
        this.throwIfDisposed();
        return this.privList[itemIndex];
    };
    List.prototype.first = function() {
        return this.get(0);
    };
    List.prototype.last = function() {
        return this.get(this.length() - 1);
    };
    List.prototype.add = function(item) {
        this.throwIfDisposed();
        this.insertAt(this.privList.length, item);
    };
    List.prototype.insertAt = function(index, item) {
        this.throwIfDisposed();
        if (index === 0) this.privList.unshift(item);
        else if (index === this.privList.length) this.privList.push(item);
        else this.privList.splice(index, 0, item);
        this.triggerSubscriptions(this.privAddSubscriptions);
    };
    List.prototype.removeFirst = function() {
        this.throwIfDisposed();
        return this.removeAt(0);
    };
    List.prototype.removeLast = function() {
        this.throwIfDisposed();
        return this.removeAt(this.length() - 1);
    };
    List.prototype.removeAt = function(index) {
        this.throwIfDisposed();
        return this.remove(index, 1)[0];
    };
    List.prototype.remove = function(index, count) {
        this.throwIfDisposed();
        var removedElements = this.privList.splice(index, count);
        this.triggerSubscriptions(this.privRemoveSubscriptions);
        return removedElements;
    };
    List.prototype.clear = function() {
        this.throwIfDisposed();
        this.remove(0, this.length());
    };
    List.prototype.length = function() {
        this.throwIfDisposed();
        return this.privList.length;
    };
    List.prototype.onAdded = function(addedCallback) {
        var _this = this;
        this.throwIfDisposed();
        var subscriptionId = this.privSubscriptionIdCounter++;
        this.privAddSubscriptions[subscriptionId] = addedCallback;
        return {
            detach: function() {
                delete _this.privAddSubscriptions[subscriptionId];
                return Promise.resolve();
            }
        };
    };
    List.prototype.onRemoved = function(removedCallback) {
        var _this = this;
        this.throwIfDisposed();
        var subscriptionId = this.privSubscriptionIdCounter++;
        this.privRemoveSubscriptions[subscriptionId] = removedCallback;
        return {
            detach: function() {
                delete _this.privRemoveSubscriptions[subscriptionId];
                return Promise.resolve();
            }
        };
    };
    List.prototype.onDisposed = function(disposedCallback) {
        var _this = this;
        this.throwIfDisposed();
        var subscriptionId = this.privSubscriptionIdCounter++;
        this.privDisposedSubscriptions[subscriptionId] = disposedCallback;
        return {
            detach: function() {
                delete _this.privDisposedSubscriptions[subscriptionId];
                return Promise.resolve();
            }
        };
    };
    List.prototype.join = function(seperator) {
        this.throwIfDisposed();
        return this.privList.join(seperator);
    };
    List.prototype.toArray = function() {
        var cloneCopy = Array();
        this.privList.forEach(function(val) {
            cloneCopy.push(val);
        });
        return cloneCopy;
    };
    List.prototype.any = function(callback) {
        this.throwIfDisposed();
        if (callback) return this.where(callback).length() > 0;
        else return this.length() > 0;
    };
    List.prototype.all = function(callback) {
        this.throwIfDisposed();
        return this.where(callback).length() === this.length();
    };
    List.prototype.forEach = function(callback) {
        this.throwIfDisposed();
        for(var i = 0; i < this.length(); i++)callback(this.privList[i], i);
    };
    List.prototype.select = function(callback) {
        this.throwIfDisposed();
        var selectList = [];
        for(var i = 0; i < this.privList.length; i++)selectList.push(callback(this.privList[i], i));
        return new List(selectList);
    };
    List.prototype.where = function(callback) {
        this.throwIfDisposed();
        var filteredList = new List();
        for(var i = 0; i < this.privList.length; i++)if (callback(this.privList[i], i)) filteredList.add(this.privList[i]);
        return filteredList;
    };
    List.prototype.orderBy = function(compareFn) {
        this.throwIfDisposed();
        var clonedArray = this.toArray();
        var orderedArray = clonedArray.sort(compareFn);
        return new List(orderedArray);
    };
    List.prototype.orderByDesc = function(compareFn) {
        this.throwIfDisposed();
        return this.orderBy(function(a, b) {
            return compareFn(b, a);
        });
    };
    List.prototype.clone = function() {
        this.throwIfDisposed();
        return new List(this.toArray());
    };
    List.prototype.concat = function(list) {
        this.throwIfDisposed();
        return new List(this.privList.concat(list.toArray()));
    };
    List.prototype.concatArray = function(array) {
        this.throwIfDisposed();
        return new List(this.privList.concat(array));
    };
    List.prototype.isDisposed = function() {
        return this.privList == null;
    };
    List.prototype.dispose = function(reason) {
        if (!this.isDisposed()) {
            this.privDisposeReason = reason;
            this.privList = null;
            this.privAddSubscriptions = null;
            this.privRemoveSubscriptions = null;
            this.triggerSubscriptions(this.privDisposedSubscriptions);
        }
    };
    List.prototype.throwIfDisposed = function() {
        if (this.isDisposed()) throw new Error_1.ObjectDisposedError("List", this.privDisposeReason);
    };
    List.prototype.triggerSubscriptions = function(subscriptions) {
        if (subscriptions) {
            for(var subscriptionId in subscriptions)if (subscriptionId) subscriptions[subscriptionId]();
        }
    };
    return List;
}();
exports.List = List;

},{"41a83c905dba18eb":"fyy92"}],"BjAdk":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.marshalPromiseToCallbacks = exports.Sink = exports.Deferred = exports.PromiseResultEventSource = exports.PromiseResult = exports.PromiseState = void 0;
/* eslint-disable max-classes-per-file, @typescript-eslint/typedef */ var PromiseState;
(function(PromiseState) {
    PromiseState[PromiseState["None"] = 0] = "None";
    PromiseState[PromiseState["Resolved"] = 1] = "Resolved";
    PromiseState[PromiseState["Rejected"] = 2] = "Rejected";
})(PromiseState = exports.PromiseState || (exports.PromiseState = {}));
var PromiseResult = /** @class */ function() {
    function PromiseResult(promiseResultEventSource) {
        var _this = this;
        this.throwIfError = function() {
            if (_this.isError) throw _this.error;
        };
        promiseResultEventSource.on(function(result) {
            if (!_this.privIsCompleted) {
                _this.privIsCompleted = true;
                _this.privIsError = false;
                _this.privResult = result;
            }
        }, function(error) {
            if (!_this.privIsCompleted) {
                _this.privIsCompleted = true;
                _this.privIsError = true;
                _this.privError = error;
            }
        });
    }
    Object.defineProperty(PromiseResult.prototype, "isCompleted", {
        get: function() {
            return this.privIsCompleted;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PromiseResult.prototype, "isError", {
        get: function() {
            return this.privIsError;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PromiseResult.prototype, "error", {
        get: function() {
            return this.privError;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PromiseResult.prototype, "result", {
        get: function() {
            return this.privResult;
        },
        enumerable: false,
        configurable: true
    });
    return PromiseResult;
}();
exports.PromiseResult = PromiseResult;
var PromiseResultEventSource = /** @class */ function() {
    function PromiseResultEventSource() {
        var _this = this;
        this.setResult = function(result) {
            _this.privOnSetResult(result);
        };
        this.setError = function(error) {
            _this.privOnSetError(error);
        };
        this.on = function(onSetResult, onSetError) {
            _this.privOnSetResult = onSetResult;
            _this.privOnSetError = onSetError;
        };
    }
    return PromiseResultEventSource;
}();
exports.PromiseResultEventSource = PromiseResultEventSource;
var Deferred = /** @class */ function() {
    function Deferred() {
        var _this = this;
        this.resolve = function(result) {
            _this.privResolve(result);
            return _this;
        };
        this.reject = function(error) {
            _this.privReject(error);
            return _this;
        };
        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
        this.privPromise = new Promise(function(resolve, reject) {
            _this.privResolve = resolve;
            _this.privReject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function() {
            return this.privPromise;
        },
        enumerable: false,
        configurable: true
    });
    return Deferred;
}();
exports.Deferred = Deferred;
var Sink = /** @class */ function() {
    function Sink() {
        this.privState = PromiseState.None;
        this.privPromiseResult = null;
        this.privPromiseResultEvents = null;
        this.privSuccessHandlers = [];
        this.privErrorHandlers = [];
        this.privPromiseResultEvents = new PromiseResultEventSource();
        this.privPromiseResult = new PromiseResult(this.privPromiseResultEvents);
    }
    Object.defineProperty(Sink.prototype, "state", {
        get: function() {
            return this.privState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sink.prototype, "result", {
        get: function() {
            return this.privPromiseResult;
        },
        enumerable: false,
        configurable: true
    });
    Sink.prototype.resolve = function(result) {
        if (this.privState !== PromiseState.None) throw new Error("'Cannot resolve a completed promise'");
        this.privState = PromiseState.Resolved;
        this.privPromiseResultEvents.setResult(result);
        for(var i = 0; i < this.privSuccessHandlers.length; i++)this.executeSuccessCallback(result, this.privSuccessHandlers[i], this.privErrorHandlers[i]);
        this.detachHandlers();
    };
    Sink.prototype.reject = function(error) {
        if (this.privState !== PromiseState.None) throw new Error("'Cannot reject a completed promise'");
        this.privState = PromiseState.Rejected;
        this.privPromiseResultEvents.setError(error);
        for(var _i = 0, _a = this.privErrorHandlers; _i < _a.length; _i++){
            var errorHandler = _a[_i];
            this.executeErrorCallback(error, errorHandler);
        }
        this.detachHandlers();
    };
    Sink.prototype.on = function(successCallback, errorCallback) {
        if (successCallback == null) // eslint-disable-next-line @typescript-eslint/no-empty-function
        successCallback = function() {};
        if (this.privState === PromiseState.None) {
            this.privSuccessHandlers.push(successCallback);
            this.privErrorHandlers.push(errorCallback);
        } else {
            if (this.privState === PromiseState.Resolved) this.executeSuccessCallback(this.privPromiseResult.result, successCallback, errorCallback);
            else if (this.privState === PromiseState.Rejected) this.executeErrorCallback(this.privPromiseResult.error, errorCallback);
            this.detachHandlers();
        }
    };
    Sink.prototype.executeSuccessCallback = function(result, successCallback, errorCallback) {
        try {
            successCallback(result);
        } catch (e) {
            this.executeErrorCallback("'Unhandled callback error: " + e + "'", errorCallback);
        }
    };
    Sink.prototype.executeErrorCallback = function(error, errorCallback) {
        if (errorCallback) try {
            errorCallback(error);
        } catch (e) {
            throw new Error("'Unhandled callback error: " + e + ". InnerError: " + error + "'");
        }
        else throw new Error("'Unhandled error: " + error + "'");
    };
    Sink.prototype.detachHandlers = function() {
        this.privErrorHandlers = [];
        this.privSuccessHandlers = [];
    };
    return Sink;
}();
exports.Sink = Sink;
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function marshalPromiseToCallbacks(promise, cb, err) {
    promise.then(function(val) {
        try {
            if (!!cb) cb(val);
        } catch (error) {
            if (!!err) try {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                } else err(error);
            // eslint-disable-next-line no-empty
            } catch (error) {}
        }
    }, function(error) {
        if (!!err) try {
            if (error instanceof Error) {
                var typedError = error;
                err(typedError.name + ": " + typedError.message);
            } else err(error);
        // eslint-disable-next-line no-empty
        } catch (error) {}
    });
}
exports.marshalPromiseToCallbacks = marshalPromiseToCallbacks;

},{}],"bCIYp":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Queue = void 0;
var Error_1 = require("8b56e94e0f7ea92");
var List_1 = require("50745348b06f0c2d");
var Promise_1 = require("4cf783c0f7c84c7a");
var SubscriberType;
(function(SubscriberType) {
    SubscriberType[SubscriberType["Dequeue"] = 0] = "Dequeue";
    SubscriberType[SubscriberType["Peek"] = 1] = "Peek";
})(SubscriberType || (SubscriberType = {}));
var Queue = /** @class */ function() {
    function Queue(list) {
        var _this = this;
        this.privPromiseStore = new List_1.List();
        this.privIsDrainInProgress = false;
        this.privIsDisposing = false;
        this.privDisposeReason = null;
        this.privList = list ? list : new List_1.List();
        this.privDetachables = [];
        this.privSubscribers = new List_1.List();
        this.privDetachables.push(this.privList.onAdded(function() {
            return _this.drain();
        }));
    }
    Queue.prototype.enqueue = function(item) {
        this.throwIfDispose();
        this.enqueueFromPromise(new Promise(function(resolve) {
            return resolve(item);
        }));
    };
    Queue.prototype.enqueueFromPromise = function(promise) {
        var _this = this;
        this.throwIfDispose();
        promise.then(function(val) {
            _this.privList.add(val);
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        }, function() {});
    };
    Queue.prototype.dequeue = function() {
        this.throwIfDispose();
        var deferredSubscriber = new Promise_1.Deferred();
        if (this.privSubscribers) {
            this.privSubscribers.add({
                deferral: deferredSubscriber,
                type: SubscriberType.Dequeue
            });
            this.drain();
        }
        return deferredSubscriber.promise;
    };
    Queue.prototype.peek = function() {
        this.throwIfDispose();
        var deferredSubscriber = new Promise_1.Deferred();
        var subs = this.privSubscribers;
        if (subs) {
            this.privSubscribers.add({
                deferral: deferredSubscriber,
                type: SubscriberType.Peek
            });
            this.drain();
        }
        return deferredSubscriber.promise;
    };
    Queue.prototype.length = function() {
        this.throwIfDispose();
        return this.privList.length();
    };
    Queue.prototype.isDisposed = function() {
        return this.privSubscribers == null;
    };
    Queue.prototype.drainAndDispose = function(pendingItemProcessor, reason) {
        return __awaiter(this, void 0, void 0, function() {
            var subs, subscriber, _i, _a, detachable, promiseArray_1;
            var _this = this;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        if (!(!this.isDisposed() && !this.privIsDisposing)) return [
                            3 /*break*/ ,
                            5
                        ];
                        this.privDisposeReason = reason;
                        this.privIsDisposing = true;
                        subs = this.privSubscribers;
                        if (subs) {
                            while(subs.length() > 0){
                                subscriber = subs.removeFirst();
                                // TODO: this needs work (Resolve(null) instead?).
                                subscriber.deferral.resolve(undefined);
                            // subscriber.deferral.reject("Disposed");
                            }
                            // note: this block assumes cooperative multitasking, i.e.,
                            // between the if-statement and the assignment there are no
                            // thread switches.
                            // Reason is that between the initial const = this.; and this
                            // point there is the derral.resolve() operation that might have
                            // caused recursive calls to the Queue, especially, calling
                            // Dispose() on the queue alredy (which would reset the var
                            // here to null!).
                            // That should generally hold true for javascript...
                            if (this.privSubscribers === subs) this.privSubscribers = subs;
                        }
                        _i = 0, _a = this.privDetachables;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [
                            3 /*break*/ ,
                            4
                        ];
                        detachable = _a[_i];
                        return [
                            4 /*yield*/ ,
                            detachable.detach()
                        ];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [
                            3 /*break*/ ,
                            1
                        ];
                    case 4:
                        if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {
                            promiseArray_1 = [];
                            this.privPromiseStore.toArray().forEach(function(wrapper) {
                                promiseArray_1.push(wrapper);
                            });
                            return [
                                2 /*return*/ ,
                                Promise.all(promiseArray_1).finally(function() {
                                    _this.privSubscribers = null;
                                    _this.privList.forEach(function(item) {
                                        pendingItemProcessor(item);
                                    });
                                    _this.privList = null;
                                    return;
                                }).then()
                            ];
                        } else {
                            this.privSubscribers = null;
                            this.privList = null;
                        }
                        _b.label = 5;
                    case 5:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    Queue.prototype.dispose = function(reason) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.drainAndDispose(null, reason)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    Queue.prototype.drain = function() {
        if (!this.privIsDrainInProgress && !this.privIsDisposing) {
            this.privIsDrainInProgress = true;
            var subs = this.privSubscribers;
            var lists = this.privList;
            if (subs && lists) {
                while(lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing){
                    var subscriber = subs.removeFirst();
                    if (subscriber.type === SubscriberType.Peek) subscriber.deferral.resolve(lists.first());
                    else {
                        var dequeuedItem = lists.removeFirst();
                        subscriber.deferral.resolve(dequeuedItem);
                    }
                }
                // note: this block assumes cooperative multitasking, i.e.,
                // between the if-statement and the assignment there are no
                // thread switches.
                // Reason is that between the initial const = this.; and this
                // point there is the derral.resolve() operation that might have
                // caused recursive calls to the Queue, especially, calling
                // Dispose() on the queue alredy (which would reset the var
                // here to null!).
                // That should generally hold true for javascript...
                if (this.privSubscribers === subs) this.privSubscribers = subs;
                // note: this block assumes cooperative multitasking, i.e.,
                // between the if-statement and the assignment there are no
                // thread switches.
                // Reason is that between the initial const = this.; and this
                // point there is the derral.resolve() operation that might have
                // caused recursive calls to the Queue, especially, calling
                // Dispose() on the queue alredy (which would reset the var
                // here to null!).
                // That should generally hold true for javascript...
                if (this.privList === lists) this.privList = lists;
            }
            this.privIsDrainInProgress = false;
        }
    };
    Queue.prototype.throwIfDispose = function() {
        if (this.isDisposed()) {
            if (this.privDisposeReason) throw new Error_1.InvalidOperationError(this.privDisposeReason);
            throw new Error_1.ObjectDisposedError("Queue");
        } else if (this.privIsDisposing) throw new Error_1.InvalidOperationError("Queue disposing");
    };
    return Queue;
}();
exports.Queue = Queue;

},{"8b56e94e0f7ea92":"fyy92","50745348b06f0c2d":"2k7ok","4cf783c0f7c84c7a":"BjAdk"}],"7RJqM":[function(require,module,exports) {
"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-assignment */ // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RawWebsocketMessage = void 0;
var ConnectionMessage_1 = require("a60b31b99ee3db54");
var Error_1 = require("4a4a3677df540d98");
var Guid_1 = require("e3e0506ba414f36");
var RawWebsocketMessage = /** @class */ function() {
    function RawWebsocketMessage(messageType, payload, id) {
        this.privPayload = null;
        if (!payload) throw new Error_1.ArgumentNullError("payload");
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (messageType === ConnectionMessage_1.MessageType.Binary && payload.__proto__.constructor.name !== "ArrayBuffer") throw new Error_1.InvalidOperationError("Payload must be ArrayBuffer");
        if (messageType === ConnectionMessage_1.MessageType.Text && !(typeof payload === "string")) throw new Error_1.InvalidOperationError("Payload must be a string");
        this.privMessageType = messageType;
        this.privPayload = payload;
        this.privId = id ? id : Guid_1.createNoDashGuid();
    }
    Object.defineProperty(RawWebsocketMessage.prototype, "messageType", {
        get: function() {
            return this.privMessageType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RawWebsocketMessage.prototype, "payload", {
        get: function() {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return this.privPayload;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RawWebsocketMessage.prototype, "textContent", {
        get: function() {
            if (this.privMessageType === ConnectionMessage_1.MessageType.Binary) throw new Error_1.InvalidOperationError("Not supported for binary message");
            return this.privPayload;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RawWebsocketMessage.prototype, "binaryContent", {
        get: function() {
            if (this.privMessageType === ConnectionMessage_1.MessageType.Text) throw new Error_1.InvalidOperationError("Not supported for text message");
            return this.privPayload;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RawWebsocketMessage.prototype, "id", {
        get: function() {
            return this.privId;
        },
        enumerable: false,
        configurable: true
    });
    return RawWebsocketMessage;
}();
exports.RawWebsocketMessage = RawWebsocketMessage;

},{"a60b31b99ee3db54":"1Mi5U","4a4a3677df540d98":"fyy92","e3e0506ba414f36":"dLGUL"}],"034Ao":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RiffPcmEncoder = void 0;
var RiffPcmEncoder = /** @class */ function() {
    function RiffPcmEncoder(actualSampleRate, desiredSampleRate) {
        this.privActualSampleRate = actualSampleRate;
        this.privDesiredSampleRate = desiredSampleRate;
    }
    RiffPcmEncoder.prototype.encode = function(actualAudioFrame) {
        var audioFrame = this.downSampleAudioFrame(actualAudioFrame, this.privActualSampleRate, this.privDesiredSampleRate);
        if (!audioFrame) return null;
        var audioLength = audioFrame.length * 2;
        var buffer = new ArrayBuffer(audioLength);
        var view = new DataView(buffer);
        this.floatTo16BitPCM(view, 0, audioFrame);
        return buffer;
    };
    RiffPcmEncoder.prototype.setString = function(view, offset, str) {
        for(var i = 0; i < str.length; i++)view.setUint8(offset + i, str.charCodeAt(i));
    };
    RiffPcmEncoder.prototype.floatTo16BitPCM = function(view, offset, input) {
        for(var i = 0; i < input.length; i++, offset += 2){
            var s = Math.max(-1, Math.min(1, input[i]));
            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
    };
    RiffPcmEncoder.prototype.downSampleAudioFrame = function(srcFrame, srcRate, dstRate) {
        if (!srcFrame) return null;
        if (dstRate === srcRate || dstRate > srcRate) return srcFrame;
        var ratio = srcRate / dstRate;
        var dstLength = Math.round(srcFrame.length / ratio);
        var dstFrame = new Float32Array(dstLength);
        var srcOffset = 0;
        var dstOffset = 0;
        while(dstOffset < dstLength){
            var nextSrcOffset = Math.round((dstOffset + 1) * ratio);
            var accum = 0;
            var count = 0;
            while(srcOffset < nextSrcOffset && srcOffset < srcFrame.length){
                accum += srcFrame[srcOffset++];
                count++;
            }
            dstFrame[dstOffset++] = accum / count;
        }
        return dstFrame;
    };
    return RiffPcmEncoder;
}();
exports.RiffPcmEncoder = RiffPcmEncoder;

},{}],"dPj8n":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Stream = void 0;
var Error_1 = require("f9fe7de1fd6d7cf4");
var Guid_1 = require("ea6dd14db53a71d");
var Queue_1 = require("d0d337491705810b");
var Stream = /** @class */ function() {
    function Stream(streamId) {
        this.privIsWriteEnded = false;
        this.privIsReadEnded = false;
        this.privId = streamId ? streamId : Guid_1.createNoDashGuid();
        this.privReaderQueue = new Queue_1.Queue();
    }
    Object.defineProperty(Stream.prototype, "isClosed", {
        get: function() {
            return this.privIsWriteEnded;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "isReadEnded", {
        get: function() {
            return this.privIsReadEnded;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "id", {
        get: function() {
            return this.privId;
        },
        enumerable: false,
        configurable: true
    });
    Stream.prototype.close = function() {
        if (!this.privIsWriteEnded) {
            this.writeStreamChunk({
                buffer: null,
                isEnd: true,
                timeReceived: Date.now()
            });
            this.privIsWriteEnded = true;
        }
    };
    Stream.prototype.writeStreamChunk = function(streamChunk) {
        this.throwIfClosed();
        if (!this.privReaderQueue.isDisposed()) try {
            this.privReaderQueue.enqueue(streamChunk);
        } catch (e) {
        // Do nothing
        }
    };
    Stream.prototype.read = function() {
        var _this = this;
        if (this.privIsReadEnded) throw new Error_1.InvalidOperationError("Stream read has already finished");
        return this.privReaderQueue.dequeue().then(function(streamChunk) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            if (!(streamChunk === undefined || streamChunk.isEnd)) return [
                                3 /*break*/ ,
                                2
                            ];
                            return [
                                4 /*yield*/ ,
                                this.privReaderQueue.dispose("End of stream reached")
                            ];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            return [
                                2 /*return*/ ,
                                streamChunk
                            ];
                    }
                });
            });
        });
    };
    Stream.prototype.readEnded = function() {
        if (!this.privIsReadEnded) {
            this.privIsReadEnded = true;
            this.privReaderQueue = new Queue_1.Queue();
        }
    };
    Stream.prototype.throwIfClosed = function() {
        if (this.privIsWriteEnded) throw new Error_1.InvalidOperationError("Stream closed");
    };
    return Stream;
}();
exports.Stream = Stream;

},{"f9fe7de1fd6d7cf4":"fyy92","ea6dd14db53a71d":"dLGUL","d0d337491705810b":"bCIYp"}],"kKQWF":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationStatus = void 0;
/**
 * Defines translation status.
 * @class TranslationStatus
 */ var TranslationStatus;
(function(TranslationStatus) {
    /**
     * @member TranslationStatus.Success
     */ TranslationStatus[TranslationStatus["Success"] = 0] = "Success";
    /**
     * @member TranslationStatus.Error
     */ TranslationStatus[TranslationStatus["Error"] = 1] = "Error";
})(TranslationStatus = exports.TranslationStatus || (exports.TranslationStatus = {}));

},{}],"6YGbc":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChunkedArrayBufferStream = void 0;
var Exports_1 = require("aa001d2f9ff4d763");
var ChunkedArrayBufferStream = /** @class */ function(_super) {
    __extends(ChunkedArrayBufferStream, _super);
    function ChunkedArrayBufferStream(targetChunkSize, streamId) {
        var _this = _super.call(this, streamId) || this;
        _this.privTargetChunkSize = targetChunkSize;
        _this.privNextBufferReadyBytes = 0;
        return _this;
    }
    ChunkedArrayBufferStream.prototype.writeStreamChunk = function(chunk) {
        // No pending write, and the buffer is the right size so write it.
        if (chunk.isEnd || 0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize) {
            _super.prototype.writeStreamChunk.call(this, chunk);
            return;
        }
        var bytesCopiedFromBuffer = 0;
        while(bytesCopiedFromBuffer < chunk.buffer.byteLength){
            // Fill the next buffer.
            if (undefined === this.privNextBufferToWrite) {
                this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);
                this.privNextBufferStartTime = chunk.timeReceived;
            }
            // Find out how many bytes we can copy into the read buffer.
            var bytesToCopy = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);
            var targetView = new Uint8Array(this.privNextBufferToWrite);
            var sourceView = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));
            targetView.set(sourceView, this.privNextBufferReadyBytes);
            this.privNextBufferReadyBytes += bytesToCopy;
            bytesCopiedFromBuffer += bytesToCopy;
            // Are we ready to write?
            if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {
                _super.prototype.writeStreamChunk.call(this, {
                    buffer: this.privNextBufferToWrite,
                    isEnd: false,
                    timeReceived: this.privNextBufferStartTime
                });
                this.privNextBufferReadyBytes = 0;
                this.privNextBufferToWrite = undefined;
            }
        }
    };
    ChunkedArrayBufferStream.prototype.close = function() {
        // Send whatever is pending, then close the base class.
        if (0 !== this.privNextBufferReadyBytes && !this.isClosed) _super.prototype.writeStreamChunk.call(this, {
            buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),
            isEnd: false,
            timeReceived: this.privNextBufferStartTime
        });
        _super.prototype.close.call(this);
    };
    return ChunkedArrayBufferStream;
}(Exports_1.Stream);
exports.ChunkedArrayBufferStream = ChunkedArrayBufferStream;

},{"aa001d2f9ff4d763":"5Bedw"}],"WeS9P":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"I27Va":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Timeout = void 0;
var Timeout = /** @class */ function() {
    function Timeout() {}
    Timeout.load = function() {
        // Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.
        var scheduledTimeoutFunctions = new Map([
            [
                0,
                function() {}
            ]
        ]); // eslint-disable-line @typescript-eslint/no-empty-function
        var unhandledRequests = new Map();
        // eslint-disable-next-line
        var workerScript = '!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=14)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error(\'There is no interval scheduled with the given id "\'.concat(e,\'".\'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error(\'There is no timeout scheduled with the given id "\'.concat(e,\'".\'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if("performance"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o="performance"in self?performance.now():Date.now();o>n?postMessage({id:null,method:"call",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){"use strict";n.r(t);var r=n(2);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)"default"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)"default"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)"default"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)"default"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)"default"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(11);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(1);for(var i in o)"default"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)"default"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener("message",({data:e})=>{try{if("clear"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if("set"!==e.method)throw new Error(\'The given method "\'.concat(e.method,\'" is not supported\'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);';
        var workerUrl = "data:text/javascript;base64," + btoa(workerScript);
        var worker = new Worker(workerUrl);
        worker.addEventListener("message", function(_a) {
            var data = _a.data;
            if (Timeout.isCallNotification(data)) {
                var timerId = data.params.timerId;
                var idOrFunc = scheduledTimeoutFunctions.get(timerId);
                if (typeof idOrFunc === "number") {
                    var unhandledTimerId = unhandledRequests.get(idOrFunc);
                    if (unhandledTimerId === undefined || unhandledTimerId !== timerId) throw new Error("The timer is in an undefined state.");
                } else if (typeof idOrFunc !== "undefined") {
                    idOrFunc();
                    // A timeout can be safely deleted because it is only called once.
                    scheduledTimeoutFunctions.delete(timerId);
                } else throw new Error("The timer is in an undefined state.");
            } else if (Timeout.isClearResponse(data)) {
                var id = data.id;
                var unhandledTimerId = unhandledRequests.get(id);
                if (unhandledTimerId === undefined) throw new Error("The timer is in an undefined state.");
                unhandledRequests.delete(id);
                scheduledTimeoutFunctions.delete(unhandledTimerId);
            } else {
                var message = data.error.message;
                throw new Error(message);
            }
        });
        var clearTimeout = function(timerId) {
            var id = Math.random();
            unhandledRequests.set(id, timerId);
            scheduledTimeoutFunctions.set(timerId, id);
            worker.postMessage({
                id: id,
                method: "clear",
                params: {
                    timerId: timerId
                }
            });
        };
        var setTimeout = function(func, delay) {
            var timerId = Math.random();
            scheduledTimeoutFunctions.set(timerId, func);
            worker.postMessage({
                id: null,
                method: "set",
                params: {
                    delay: delay,
                    now: performance.now(),
                    timerId: timerId
                }
            });
            return timerId;
        };
        return {
            clearTimeout: clearTimeout,
            setTimeout: setTimeout
        };
    };
    Timeout.loadWorkerTimers = function() {
        return function() {
            if (Timeout.workerTimers !== null) return Timeout.workerTimers;
            Timeout.workerTimers = Timeout.load();
            return Timeout.workerTimers;
        };
    };
    Timeout.isCallNotification = function(message) {
        return message.method !== undefined && message.method === "call";
    };
    Timeout.isClearResponse = function(message) {
        return message.error === null && typeof message.id === "number";
    };
    Timeout.workerTimers = null;
    Timeout.clearTimeout = function(timerId) {
        return Timeout.timers().clearTimeout(timerId);
    };
    Timeout.setTimeout = function(func, delay) {
        return Timeout.timers().setTimeout(func, delay);
    };
    Timeout.timers = Timeout.loadWorkerTimers();
    return Timeout;
}();
exports.Timeout = Timeout;

},{}],"hhldP":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OCSPCacheUpdateErrorEvent = exports.OCSPResponseRetrievedEvent = exports.OCSPCacheFetchErrorEvent = exports.OCSPVerificationFailedEvent = exports.OCSPCacheHitEvent = exports.OCSPCacheEntryNeedsRefreshEvent = exports.OCSPCacheEntryExpiredEvent = exports.OCSPWSUpgradeStartedEvent = exports.OCSPStapleReceivedEvent = exports.OCSPCacheUpdateCompleteEvent = exports.OCSPDiskCacheStoreEvent = exports.OCSPMemoryCacheStoreEvent = exports.OCSPCacheUpdateNeededEvent = exports.OCSPDiskCacheHitEvent = exports.OCSPCacheMissEvent = exports.OCSPMemoryCacheHitEvent = exports.OCSPEvent = void 0;
/* eslint-disable max-classes-per-file */ var PlatformEvent_1 = require("bdab39a9fef2e6c6");
var OCSPEvent = /** @class */ function(_super) {
    __extends(OCSPEvent, _super);
    function OCSPEvent(eventName, eventType, signature) {
        var _this = _super.call(this, eventName, eventType) || this;
        _this.privSignature = signature;
        return _this;
    }
    return OCSPEvent;
}(PlatformEvent_1.PlatformEvent);
exports.OCSPEvent = OCSPEvent;
var OCSPMemoryCacheHitEvent = /** @class */ function(_super) {
    __extends(OCSPMemoryCacheHitEvent, _super);
    function OCSPMemoryCacheHitEvent(signature) {
        return _super.call(this, "OCSPMemoryCacheHitEvent", PlatformEvent_1.EventType.Debug, signature) || this;
    }
    return OCSPMemoryCacheHitEvent;
}(OCSPEvent);
exports.OCSPMemoryCacheHitEvent = OCSPMemoryCacheHitEvent;
var OCSPCacheMissEvent = /** @class */ function(_super) {
    __extends(OCSPCacheMissEvent, _super);
    function OCSPCacheMissEvent(signature) {
        return _super.call(this, "OCSPCacheMissEvent", PlatformEvent_1.EventType.Debug, signature) || this;
    }
    return OCSPCacheMissEvent;
}(OCSPEvent);
exports.OCSPCacheMissEvent = OCSPCacheMissEvent;
var OCSPDiskCacheHitEvent = /** @class */ function(_super) {
    __extends(OCSPDiskCacheHitEvent, _super);
    function OCSPDiskCacheHitEvent(signature) {
        return _super.call(this, "OCSPDiskCacheHitEvent", PlatformEvent_1.EventType.Debug, signature) || this;
    }
    return OCSPDiskCacheHitEvent;
}(OCSPEvent);
exports.OCSPDiskCacheHitEvent = OCSPDiskCacheHitEvent;
var OCSPCacheUpdateNeededEvent = /** @class */ function(_super) {
    __extends(OCSPCacheUpdateNeededEvent, _super);
    function OCSPCacheUpdateNeededEvent(signature) {
        return _super.call(this, "OCSPCacheUpdateNeededEvent", PlatformEvent_1.EventType.Debug, signature) || this;
    }
    return OCSPCacheUpdateNeededEvent;
}(OCSPEvent);
exports.OCSPCacheUpdateNeededEvent = OCSPCacheUpdateNeededEvent;
var OCSPMemoryCacheStoreEvent = /** @class */ function(_super) {
    __extends(OCSPMemoryCacheStoreEvent, _super);
    function OCSPMemoryCacheStoreEvent(signature) {
        return _super.call(this, "OCSPMemoryCacheStoreEvent", PlatformEvent_1.EventType.Debug, signature) || this;
    }
    return OCSPMemoryCacheStoreEvent;
}(OCSPEvent);
exports.OCSPMemoryCacheStoreEvent = OCSPMemoryCacheStoreEvent;
var OCSPDiskCacheStoreEvent = /** @class */ function(_super) {
    __extends(OCSPDiskCacheStoreEvent, _super);
    function OCSPDiskCacheStoreEvent(signature) {
        return _super.call(this, "OCSPDiskCacheStoreEvent", PlatformEvent_1.EventType.Debug, signature) || this;
    }
    return OCSPDiskCacheStoreEvent;
}(OCSPEvent);
exports.OCSPDiskCacheStoreEvent = OCSPDiskCacheStoreEvent;
var OCSPCacheUpdateCompleteEvent = /** @class */ function(_super) {
    __extends(OCSPCacheUpdateCompleteEvent, _super);
    function OCSPCacheUpdateCompleteEvent(signature) {
        return _super.call(this, "OCSPCacheUpdateCompleteEvent", PlatformEvent_1.EventType.Debug, signature) || this;
    }
    return OCSPCacheUpdateCompleteEvent;
}(OCSPEvent);
exports.OCSPCacheUpdateCompleteEvent = OCSPCacheUpdateCompleteEvent;
var OCSPStapleReceivedEvent = /** @class */ function(_super) {
    __extends(OCSPStapleReceivedEvent, _super);
    function OCSPStapleReceivedEvent() {
        return _super.call(this, "OCSPStapleReceivedEvent", PlatformEvent_1.EventType.Debug, "") || this;
    }
    return OCSPStapleReceivedEvent;
}(OCSPEvent);
exports.OCSPStapleReceivedEvent = OCSPStapleReceivedEvent;
var OCSPWSUpgradeStartedEvent = /** @class */ function(_super) {
    __extends(OCSPWSUpgradeStartedEvent, _super);
    function OCSPWSUpgradeStartedEvent(serialNumber) {
        return _super.call(this, "OCSPWSUpgradeStartedEvent", PlatformEvent_1.EventType.Debug, serialNumber) || this;
    }
    return OCSPWSUpgradeStartedEvent;
}(OCSPEvent);
exports.OCSPWSUpgradeStartedEvent = OCSPWSUpgradeStartedEvent;
var OCSPCacheEntryExpiredEvent = /** @class */ function(_super) {
    __extends(OCSPCacheEntryExpiredEvent, _super);
    function OCSPCacheEntryExpiredEvent(serialNumber, expireTime) {
        var _this = _super.call(this, "OCSPCacheEntryExpiredEvent", PlatformEvent_1.EventType.Debug, serialNumber) || this;
        _this.privExpireTime = expireTime;
        return _this;
    }
    return OCSPCacheEntryExpiredEvent;
}(OCSPEvent);
exports.OCSPCacheEntryExpiredEvent = OCSPCacheEntryExpiredEvent;
var OCSPCacheEntryNeedsRefreshEvent = /** @class */ function(_super) {
    __extends(OCSPCacheEntryNeedsRefreshEvent, _super);
    function OCSPCacheEntryNeedsRefreshEvent(serialNumber, startTime, expireTime) {
        var _this = _super.call(this, "OCSPCacheEntryNeedsRefreshEvent", PlatformEvent_1.EventType.Debug, serialNumber) || this;
        _this.privExpireTime = expireTime;
        _this.privStartTime = startTime;
        return _this;
    }
    return OCSPCacheEntryNeedsRefreshEvent;
}(OCSPEvent);
exports.OCSPCacheEntryNeedsRefreshEvent = OCSPCacheEntryNeedsRefreshEvent;
var OCSPCacheHitEvent = /** @class */ function(_super) {
    __extends(OCSPCacheHitEvent, _super);
    function OCSPCacheHitEvent(serialNumber, startTime, expireTime) {
        var _this = _super.call(this, "OCSPCacheHitEvent", PlatformEvent_1.EventType.Debug, serialNumber) || this;
        _this.privExpireTime = expireTime;
        _this.privExpireTimeString = new Date(expireTime).toLocaleDateString();
        _this.privStartTime = startTime;
        _this.privStartTimeString = new Date(startTime).toLocaleTimeString();
        return _this;
    }
    return OCSPCacheHitEvent;
}(OCSPEvent);
exports.OCSPCacheHitEvent = OCSPCacheHitEvent;
var OCSPVerificationFailedEvent = /** @class */ function(_super) {
    __extends(OCSPVerificationFailedEvent, _super);
    function OCSPVerificationFailedEvent(serialNumber, error) {
        var _this = _super.call(this, "OCSPVerificationFailedEvent", PlatformEvent_1.EventType.Debug, serialNumber) || this;
        _this.privError = error;
        return _this;
    }
    return OCSPVerificationFailedEvent;
}(OCSPEvent);
exports.OCSPVerificationFailedEvent = OCSPVerificationFailedEvent;
var OCSPCacheFetchErrorEvent = /** @class */ function(_super) {
    __extends(OCSPCacheFetchErrorEvent, _super);
    function OCSPCacheFetchErrorEvent(serialNumber, error) {
        var _this = _super.call(this, "OCSPCacheFetchErrorEvent", PlatformEvent_1.EventType.Debug, serialNumber) || this;
        _this.privError = error;
        return _this;
    }
    return OCSPCacheFetchErrorEvent;
}(OCSPEvent);
exports.OCSPCacheFetchErrorEvent = OCSPCacheFetchErrorEvent;
var OCSPResponseRetrievedEvent = /** @class */ function(_super) {
    __extends(OCSPResponseRetrievedEvent, _super);
    function OCSPResponseRetrievedEvent(serialNumber) {
        return _super.call(this, "OCSPResponseRetrievedEvent", PlatformEvent_1.EventType.Debug, serialNumber) || this;
    }
    return OCSPResponseRetrievedEvent;
}(OCSPEvent);
exports.OCSPResponseRetrievedEvent = OCSPResponseRetrievedEvent;
var OCSPCacheUpdateErrorEvent = /** @class */ function(_super) {
    __extends(OCSPCacheUpdateErrorEvent, _super);
    function OCSPCacheUpdateErrorEvent(serialNumber, error) {
        var _this = _super.call(this, "OCSPCacheUpdateErrorEvent", PlatformEvent_1.EventType.Debug, serialNumber) || this;
        _this.privError = error;
        return _this;
    }
    return OCSPCacheUpdateErrorEvent;
}(OCSPEvent);
exports.OCSPCacheUpdateErrorEvent = OCSPCacheUpdateErrorEvent;

},{"bdab39a9fef2e6c6":"lrUbr"}],"joIRE":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BackgroundEvent = void 0;
var Exports_1 = require("2037e176f9e7dd5e");
var BackgroundEvent = /** @class */ function(_super) {
    __extends(BackgroundEvent, _super);
    function BackgroundEvent(error) {
        var _this = _super.call(this, "BackgroundEvent", Exports_1.EventType.Error) || this;
        _this.privError = error;
        return _this;
    }
    Object.defineProperty(BackgroundEvent.prototype, "error", {
        get: function() {
            return this.privError;
        },
        enumerable: false,
        configurable: true
    });
    return BackgroundEvent;
}(Exports_1.PlatformEvent);
exports.BackgroundEvent = BackgroundEvent;

},{"2037e176f9e7dd5e":"5Bedw"}],"4jwu5":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Contracts = void 0;
/**
 * @class Contracts
 * @private
 */ var Contracts = /** @class */ function() {
    function Contracts() {}
    Contracts.throwIfNullOrUndefined = function(param, name) {
        if (param === undefined || param === null) throw new Error("throwIfNullOrUndefined:" + name);
    };
    Contracts.throwIfNull = function(param, name) {
        if (param === null) throw new Error("throwIfNull:" + name);
    };
    Contracts.throwIfNullOrWhitespace = function(param, name) {
        Contracts.throwIfNullOrUndefined(param, name);
        if (("" + param).trim().length < 1) throw new Error("throwIfNullOrWhitespace:" + name);
    };
    Contracts.throwIfNullOrTooLong = function(param, name, maxLength) {
        Contracts.throwIfNullOrUndefined(param, name);
        if (("" + param).length > maxLength) throw new Error("throwIfNullOrTooLong:" + name + " (more than " + maxLength.toString() + " characters)");
    };
    Contracts.throwIfNullOrTooShort = function(param, name, minLength) {
        Contracts.throwIfNullOrUndefined(param, name);
        if (("" + param).length < minLength) throw new Error("throwIfNullOrTooShort:" + name + " (less than " + minLength.toString() + " characters)");
    };
    Contracts.throwIfDisposed = function(isDisposed) {
        if (isDisposed) throw new Error("the object is already disposed");
    };
    Contracts.throwIfArrayEmptyOrWhitespace = function(array, name) {
        Contracts.throwIfNullOrUndefined(array, name);
        if (array.length === 0) throw new Error("throwIfArrayEmptyOrWhitespace:" + name);
        for(var _i = 0, array_1 = array; _i < array_1.length; _i++){
            var item = array_1[_i];
            Contracts.throwIfNullOrWhitespace(item, name);
        }
    };
    Contracts.throwIfFileDoesNotExist = function(param, name) {
        Contracts.throwIfNullOrWhitespace(param, name);
    // TODO check for file existence.
    };
    Contracts.throwIfNotUndefined = function(param, name) {
        if (param !== undefined) throw new Error("throwIfNotUndefined:" + name);
    };
    return Contracts;
}();
exports.Contracts = Contracts;

},{}],"9YorG":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"acSp9":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MicAudioSource = exports.AudioWorkletSourceURLPropertyName = void 0;
var Exports_1 = require("96332212d6909846");
var Exports_2 = require("e7c0d738aa737c80");
var AudioStreamFormat_1 = require("2f46a3e1f5f8c62c");
exports.AudioWorkletSourceURLPropertyName = "MICROPHONE-WorkletSourceUrl";
var MicAudioSource = /** @class */ function() {
    function MicAudioSource(privRecorder, deviceId, audioSourceId, mediaStream) {
        this.privRecorder = privRecorder;
        this.deviceId = deviceId;
        this.privStreams = {};
        this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;
        this.privId = audioSourceId ? audioSourceId : Exports_2.createNoDashGuid();
        this.privEvents = new Exports_2.EventSource();
        this.privMediaStream = mediaStream || null;
        this.privIsClosing = false;
    }
    Object.defineProperty(MicAudioSource.prototype, "format", {
        get: function() {
            return Promise.resolve(MicAudioSource.AUDIOFORMAT);
        },
        enumerable: false,
        configurable: true
    });
    MicAudioSource.prototype.turnOn = function() {
        var _this = this;
        if (this.privInitializeDeferral) return this.privInitializeDeferral.promise;
        this.privInitializeDeferral = new Exports_2.Deferred();
        try {
            this.createAudioContext();
        } catch (error) {
            if (error instanceof Error) {
                var typedError = error;
                this.privInitializeDeferral.reject(typedError.name + ": " + typedError.message);
            } else this.privInitializeDeferral.reject(error);
            return this.privInitializeDeferral.promise;
        }
        var nav = window.navigator;
        var getUserMedia = // eslint-disable-next-line
        nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia;
        if (!!nav.mediaDevices) getUserMedia = function(constraints, successCallback, errorCallback) {
            nav.mediaDevices.getUserMedia(constraints).then(successCallback).catch(errorCallback);
        };
        if (!getUserMedia) {
            var errorMsg = "Browser does not support getUserMedia.";
            this.privInitializeDeferral.reject(errorMsg);
            this.onEvent(new Exports_2.AudioSourceErrorEvent(errorMsg, "")); // mic initialized error - no streamid at this point
        } else {
            var next = function() {
                _this.onEvent(new Exports_2.AudioSourceInitializingEvent(_this.privId)); // no stream id
                if (_this.privMediaStream && _this.privMediaStream.active) {
                    _this.onEvent(new Exports_2.AudioSourceReadyEvent(_this.privId));
                    _this.privInitializeDeferral.resolve();
                } else getUserMedia({
                    audio: _this.deviceId ? {
                        deviceId: _this.deviceId
                    } : true,
                    video: false
                }, function(mediaStream) {
                    _this.privMediaStream = mediaStream;
                    _this.onEvent(new Exports_2.AudioSourceReadyEvent(_this.privId));
                    _this.privInitializeDeferral.resolve();
                }, function(error) {
                    var errorMsg = "Error occurred during microphone initialization: " + error;
                    _this.privInitializeDeferral.reject(errorMsg);
                    _this.onEvent(new Exports_2.AudioSourceErrorEvent(_this.privId, errorMsg));
                });
            };
            if (this.privContext.state === "suspended") // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.
            // https://github.com/WebAudio/web-audio-api/issues/790
            this.privContext.resume().then(next).catch(function(reason) {
                _this.privInitializeDeferral.reject("Failed to initialize audio context: " + reason);
            });
            else next();
        }
        return this.privInitializeDeferral.promise;
    };
    MicAudioSource.prototype.id = function() {
        return this.privId;
    };
    MicAudioSource.prototype.attach = function(audioNodeId) {
        var _this = this;
        this.onEvent(new Exports_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
        return this.listen(audioNodeId).then(function(stream) {
            _this.onEvent(new Exports_2.AudioStreamNodeAttachedEvent(_this.privId, audioNodeId));
            return {
                detach: function() {
                    return __awaiter(_this, void 0, void 0, function() {
                        return __generator(this, function(_a) {
                            stream.readEnded();
                            delete this.privStreams[audioNodeId];
                            this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
                            return [
                                2 /*return*/ ,
                                this.turnOff()
                            ];
                        });
                    });
                },
                id: function() {
                    return audioNodeId;
                },
                read: function() {
                    return stream.read();
                }
            };
        });
    };
    MicAudioSource.prototype.detach = function(audioNodeId) {
        if (audioNodeId && this.privStreams[audioNodeId]) {
            this.privStreams[audioNodeId].close();
            delete this.privStreams[audioNodeId];
            this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
        }
    };
    MicAudioSource.prototype.turnOff = function() {
        return __awaiter(this, void 0, void 0, function() {
            var streamId, stream;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        for(streamId in this.privStreams)if (streamId) {
                            stream = this.privStreams[streamId];
                            if (stream) stream.close();
                        }
                        this.onEvent(new Exports_2.AudioSourceOffEvent(this.privId)); // no stream now
                        if (!this.privInitializeDeferral) return [
                            3 /*break*/ ,
                            2
                        ];
                        // Correctly handle when browser forces mic off before turnOn() completes
                        // eslint-disable-next-line @typescript-eslint/await-thenable
                        return [
                            4 /*yield*/ ,
                            this.privInitializeDeferral
                        ];
                    case 1:
                        // Correctly handle when browser forces mic off before turnOn() completes
                        // eslint-disable-next-line @typescript-eslint/await-thenable
                        _a.sent();
                        this.privInitializeDeferral = null;
                        _a.label = 2;
                    case 2:
                        return [
                            4 /*yield*/ ,
                            this.destroyAudioContext()
                        ];
                    case 3:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    Object.defineProperty(MicAudioSource.prototype, "events", {
        get: function() {
            return this.privEvents;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MicAudioSource.prototype, "deviceInfo", {
        get: function() {
            return this.getMicrophoneLabel().then(function(label) {
                return {
                    bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,
                    channelcount: MicAudioSource.AUDIOFORMAT.channels,
                    connectivity: Exports_1.connectivity.Unknown,
                    manufacturer: "Speech SDK",
                    model: label,
                    samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,
                    type: Exports_1.type.Microphones
                };
            });
        },
        enumerable: false,
        configurable: true
    });
    MicAudioSource.prototype.setProperty = function(name, value) {
        if (name === exports.AudioWorkletSourceURLPropertyName) this.privRecorder.setWorkletUrl(value);
        else throw new Error("Property '" + name + "' is not supported on Microphone.");
    };
    MicAudioSource.prototype.getMicrophoneLabel = function() {
        var _this = this;
        var defaultMicrophoneName = "microphone";
        // If we did this already, return the value.
        if (this.privMicrophoneLabel !== undefined) return Promise.resolve(this.privMicrophoneLabel);
        // If the stream isn't currently running, we can't query devices because security.
        if (this.privMediaStream === undefined || !this.privMediaStream.active) return Promise.resolve(defaultMicrophoneName);
        // Setup a default
        this.privMicrophoneLabel = defaultMicrophoneName;
        // Get the id of the device running the audio track.
        var microphoneDeviceId = this.privMediaStream.getTracks()[0].getSettings().deviceId;
        // If the browser doesn't support getting the device ID, set a default and return.
        if (undefined === microphoneDeviceId) return Promise.resolve(this.privMicrophoneLabel);
        var deferred = new Exports_2.Deferred();
        // Enumerate the media devices.
        navigator.mediaDevices.enumerateDevices().then(function(devices) {
            for(var _i = 0, devices_1 = devices; _i < devices_1.length; _i++){
                var device = devices_1[_i];
                if (device.deviceId === microphoneDeviceId) {
                    // Found the device
                    _this.privMicrophoneLabel = device.label;
                    break;
                }
            }
            deferred.resolve(_this.privMicrophoneLabel);
        }, function() {
            return deferred.resolve(_this.privMicrophoneLabel);
        });
        return deferred.promise;
    };
    MicAudioSource.prototype.listen = function(audioNodeId) {
        return __awaiter(this, void 0, void 0, function() {
            var stream, result;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.turnOn()
                        ];
                    case 1:
                        _a.sent();
                        stream = new Exports_2.ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);
                        this.privStreams[audioNodeId] = stream;
                        try {
                            this.privRecorder.record(this.privContext, this.privMediaStream, stream);
                        } catch (error) {
                            this.onEvent(new Exports_2.AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));
                            throw error;
                        }
                        result = stream;
                        return [
                            2 /*return*/ ,
                            result
                        ];
                }
            });
        });
    };
    MicAudioSource.prototype.onEvent = function(event) {
        this.privEvents.onEvent(event);
        Exports_2.Events.instance.onEvent(event);
    };
    MicAudioSource.prototype.createAudioContext = function() {
        if (!!this.privContext) return;
        this.privContext = AudioStreamFormat_1.AudioStreamFormatImpl.getAudioContext(MicAudioSource.AUDIOFORMAT.samplesPerSec);
    };
    MicAudioSource.prototype.destroyAudioContext = function() {
        return __awaiter(this, void 0, void 0, function() {
            var hasClose;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!this.privContext) return [
                            2 /*return*/ 
                        ];
                        this.privRecorder.releaseMediaResources(this.privContext);
                        hasClose = false;
                        if ("close" in this.privContext) hasClose = true;
                        if (!hasClose) return [
                            3 /*break*/ ,
                            3
                        ];
                        if (!!this.privIsClosing) return [
                            3 /*break*/ ,
                            2
                        ];
                        // The audio context close may take enough time that the close is called twice
                        this.privIsClosing = true;
                        return [
                            4 /*yield*/ ,
                            this.privContext.close()
                        ];
                    case 1:
                        _a.sent();
                        this.privContext = null;
                        this.privIsClosing = false;
                        _a.label = 2;
                    case 2:
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 3:
                        if (!(null !== this.privContext && this.privContext.state === "running")) return [
                            3 /*break*/ ,
                            5
                        ];
                        // Suspend actually takes a callback, but analogous to the
                        // resume method, it'll be only fired if suspend is called
                        // in a direct response to a user action. The later is not always
                        // the case, as TurnOff is also called, when we receive an
                        // end-of-speech message from the service. So, doing a best effort
                        // fire-and-forget here.
                        return [
                            4 /*yield*/ ,
                            this.privContext.suspend()
                        ];
                    case 4:
                        // Suspend actually takes a callback, but analogous to the
                        // resume method, it'll be only fired if suspend is called
                        // in a direct response to a user action. The later is not always
                        // the case, as TurnOff is also called, when we receive an
                        // end-of-speech message from the service. So, doing a best effort
                        // fire-and-forget here.
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    MicAudioSource.AUDIOFORMAT = AudioStreamFormat_1.AudioStreamFormat.getDefaultInputFormat();
    return MicAudioSource;
}();
exports.MicAudioSource = MicAudioSource;

},{"96332212d6909846":"7Qpvn","e7c0d738aa737c80":"5Bedw","2f46a3e1f5f8c62c":"8hTlD"}],"7Qpvn":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !exports1.hasOwnProperty(p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AutoDetectSourceLanguagesOpenRangeOptionName = exports.ForceDictationPropertyName = exports.ServicePropertiesPropertyName = exports.CancellationErrorCodePropertyName = exports.OutputFormatPropertyName = void 0;
// Make sure not to export internal modules.
//
__exportStar(require("d7446f61ce1d09ea"), exports);
__exportStar(require("f0c2ea4f71204bf"), exports);
__exportStar(require("8f8da5da9f9982da"), exports);
__exportStar(require("1bade2cdede69b97"), exports);
__exportStar(require("436f875d435682b7"), exports);
__exportStar(require("53576e74880971e6"), exports);
__exportStar(require("4de2f2c0e63f51a8"), exports);
__exportStar(require("bb6e67d87f631001"), exports);
__exportStar(require("e4d1d31734b5e5a"), exports);
__exportStar(require("64f6c95d7b624224"), exports);
__exportStar(require("1644e7785cbbf931"), exports);
__exportStar(require("a1af160995227022"), exports);
__exportStar(require("3d3c82661e2bd688"), exports);
__exportStar(require("8976bf3c5a3f1ec5"), exports);
__exportStar(require("6a29acf49d37b3bb"), exports);
__exportStar(require("92b8e04587fa6d39"), exports);
__exportStar(require("f14643f9ee762393"), exports);
__exportStar(require("eda83e7fab9ee607"), exports);
__exportStar(require("d43f8f13fa74e0a8"), exports);
__exportStar(require("14e10634f4d91616"), exports);
__exportStar(require("acafdd69f3fc8cd"), exports);
__exportStar(require("b1c7f2c44ab9bee7"), exports);
__exportStar(require("9c6dc72036d0473c"), exports);
__exportStar(require("c0774c93e1820906"), exports);
__exportStar(require("b5cc155ff35e70f7"), exports);
__exportStar(require("91768eaf174526c"), exports);
__exportStar(require("fe5be7610e184149"), exports);
__exportStar(require("1ad99f4acb9a400f"), exports);
__exportStar(require("df1bccbfcf4a316c"), exports);
__exportStar(require("7feea2e6de7dd474"), exports);
__exportStar(require("72594c49c1e6705b"), exports);
__exportStar(require("abd192a188a9c1b3"), exports);
__exportStar(require("13f347cdd744b475"), exports);
__exportStar(require("b6f42d49463f3234"), exports);
__exportStar(require("2bfefeb8f8d32077"), exports);
__exportStar(require("a995c9071c2c0e9b"), exports);
__exportStar(require("5b20a6515b012dc5"), exports);
__exportStar(require("a69060a83451f192"), exports);
__exportStar(require("a269914e396f422a"), exports);
__exportStar(require("28def719815b715"), exports);
__exportStar(require("2807474ad2b72d35"), exports);
__exportStar(require("281f7a69c1b5df48"), exports);
__exportStar(require("55e6e7f2f6519e1f"), exports);
__exportStar(require("b192c857f070f3c6"), exports);
__exportStar(require("54279f9f8c9e08a7"), exports);
__exportStar(require("e3f887594af643d1"), exports);
__exportStar(require("1e48a06cae2beff5"), exports);
__exportStar(require("be3da0a0fce1caf6"), exports);
__exportStar(require("d1721e3fb66fc491"), exports);
__exportStar(require("8087713619212791"), exports);
__exportStar(require("5a74c295d803f1d3"), exports);
__exportStar(require("c06e7e8bf38ae2b0"), exports);
exports.OutputFormatPropertyName = "OutputFormat";
exports.CancellationErrorCodePropertyName = "CancellationErrorCode";
exports.ServicePropertiesPropertyName = "ServiceProperties";
exports.ForceDictationPropertyName = "ForceDictation";
exports.AutoDetectSourceLanguagesOpenRangeOptionName = "OpenRange";

},{"d7446f61ce1d09ea":"dufh6","f0c2ea4f71204bf":"dOXCx","8f8da5da9f9982da":"aABbg","1bade2cdede69b97":"8XZDh","436f875d435682b7":"aGAvC","53576e74880971e6":"7c91F","4de2f2c0e63f51a8":"93Yn9","bb6e67d87f631001":"josuk","e4d1d31734b5e5a":"jhVVj","64f6c95d7b624224":"bBuji","1644e7785cbbf931":"6oUM0","a1af160995227022":"i2u5g","3d3c82661e2bd688":"d1suG","8976bf3c5a3f1ec5":"879mH","6a29acf49d37b3bb":"iBtpn","92b8e04587fa6d39":"4oKER","f14643f9ee762393":"kFQr4","eda83e7fab9ee607":"7TCCI","d43f8f13fa74e0a8":"2Rx5K","14e10634f4d91616":"4ei81","acafdd69f3fc8cd":"2lckn","b1c7f2c44ab9bee7":"4FONh","9c6dc72036d0473c":"fJFN0","c0774c93e1820906":"hRB6D","b5cc155ff35e70f7":"4C8Vr","91768eaf174526c":"4w193","fe5be7610e184149":"jrCMe","1ad99f4acb9a400f":"exHmu","df1bccbfcf4a316c":"lcJkz","7feea2e6de7dd474":"7rbYP","72594c49c1e6705b":"1jQIe","abd192a188a9c1b3":"dURiZ","13f347cdd744b475":"8IhMg","b6f42d49463f3234":"inGQx","2bfefeb8f8d32077":"gt38A","a995c9071c2c0e9b":"jRCey","5b20a6515b012dc5":"URaEO","a69060a83451f192":"10zvM","a269914e396f422a":"8XnIu","28def719815b715":"bM9va","2807474ad2b72d35":"ikpLJ","281f7a69c1b5df48":"2G6zp","55e6e7f2f6519e1f":"6ZKjA","b192c857f070f3c6":"gpb6A","54279f9f8c9e08a7":"dekBZ","e3f887594af643d1":"2IlJz","1e48a06cae2beff5":"a9wm8","be3da0a0fce1caf6":"7AtoI","d1721e3fb66fc491":"gI7gQ","8087713619212791":"36zGl","5a74c295d803f1d3":"9mgJt","c06e7e8bf38ae2b0":"fHZDC"}],"dufh6":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CognitiveSubscriptionKeyAuthentication = void 0;
var Exports_1 = require("a71a0e63288ff31");
var HeaderNames_1 = require("aa54a736c9d2e30");
var IAuthentication_1 = require("150a89a3995dac");
/**
 * @class
 */ var CognitiveSubscriptionKeyAuthentication = /** @class */ function() {
    /**
     * Creates and initializes an instance of the CognitiveSubscriptionKeyAuthentication class.
     * @constructor
     * @param {string} subscriptionKey - The subscription key
     */ function CognitiveSubscriptionKeyAuthentication(subscriptionKey) {
        if (!subscriptionKey) throw new Exports_1.ArgumentNullError("subscriptionKey");
        this.privAuthInfo = new IAuthentication_1.AuthInfo(HeaderNames_1.HeaderNames.AuthKey, subscriptionKey);
    }
    /**
     * Fetches the subscription key.
     * @member
     * @function
     * @public
     * @param {string} authFetchEventId - The id to fetch.
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    CognitiveSubscriptionKeyAuthentication.prototype.fetch = function(authFetchEventId) {
        return Promise.resolve(this.privAuthInfo);
    };
    /**
     * Fetches the subscription key.
     * @member
     * @function
     * @public
     * @param {string} authFetchEventId - The id to fetch.
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    CognitiveSubscriptionKeyAuthentication.prototype.fetchOnExpiry = function(authFetchEventId) {
        return Promise.resolve(this.privAuthInfo);
    };
    return CognitiveSubscriptionKeyAuthentication;
}();
exports.CognitiveSubscriptionKeyAuthentication = CognitiveSubscriptionKeyAuthentication;

},{"a71a0e63288ff31":"5Bedw","aa54a736c9d2e30":"bNYHA","150a89a3995dac":"aABbg"}],"bNYHA":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HeaderNames = void 0;
var HeaderNames = /** @class */ function() {
    function HeaderNames() {}
    HeaderNames.AuthKey = "Ocp-Apim-Subscription-Key";
    HeaderNames.Authorization = "Authorization";
    HeaderNames.SpIDAuthKey = "Apim-Subscription-Id";
    HeaderNames.ConnectionId = "X-ConnectionId";
    HeaderNames.ContentType = "Content-Type";
    HeaderNames.CustomCommandsAppId = "X-CommandsAppId";
    HeaderNames.Path = "Path";
    HeaderNames.RequestId = "X-RequestId";
    HeaderNames.RequestStreamId = "X-StreamId";
    HeaderNames.RequestTimestamp = "X-Timestamp";
    return HeaderNames;
}();
exports.HeaderNames = HeaderNames;

},{}],"aABbg":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AuthInfo = void 0;
var AuthInfo = /** @class */ function() {
    function AuthInfo(headerName, token) {
        this.privHeaderName = headerName;
        this.privToken = token;
    }
    Object.defineProperty(AuthInfo.prototype, "headerName", {
        get: function() {
            return this.privHeaderName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AuthInfo.prototype, "token", {
        get: function() {
            return this.privToken;
        },
        enumerable: false,
        configurable: true
    });
    return AuthInfo;
}();
exports.AuthInfo = AuthInfo;

},{}],"dOXCx":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CognitiveTokenAuthentication = void 0;
var Exports_1 = require("3b3c477d0dade1e3");
var IAuthentication_1 = require("58b68e876397b9bf");
var HeaderNames_1 = require("dd425cf4379f92c9");
var CognitiveTokenAuthentication = /** @class */ function() {
    function CognitiveTokenAuthentication(fetchCallback, fetchOnExpiryCallback) {
        if (!fetchCallback) throw new Exports_1.ArgumentNullError("fetchCallback");
        if (!fetchOnExpiryCallback) throw new Exports_1.ArgumentNullError("fetchOnExpiryCallback");
        this.privFetchCallback = fetchCallback;
        this.privFetchOnExpiryCallback = fetchOnExpiryCallback;
    }
    CognitiveTokenAuthentication.prototype.fetch = function(authFetchEventId) {
        return this.privFetchCallback(authFetchEventId).then(function(token) {
            return new IAuthentication_1.AuthInfo(HeaderNames_1.HeaderNames.Authorization, token === undefined ? undefined : CognitiveTokenAuthentication.privTokenPrefix + token);
        });
    };
    CognitiveTokenAuthentication.prototype.fetchOnExpiry = function(authFetchEventId) {
        return this.privFetchOnExpiryCallback(authFetchEventId).then(function(token) {
            return new IAuthentication_1.AuthInfo(HeaderNames_1.HeaderNames.Authorization, token === undefined ? undefined : CognitiveTokenAuthentication.privTokenPrefix + token);
        });
    };
    CognitiveTokenAuthentication.privTokenPrefix = "bearer ";
    return CognitiveTokenAuthentication;
}();
exports.CognitiveTokenAuthentication = CognitiveTokenAuthentication;

},{"3b3c477d0dade1e3":"5Bedw","58b68e876397b9bf":"aABbg","dd425cf4379f92c9":"bNYHA"}],"8XZDh":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"aGAvC":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"7c91F":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntentConnectionFactory = void 0;
var Exports_1 = require("f7883ea8ac903554");
var Exports_2 = require("8e2966fd3818326a");
var ConnectionFactoryBase_1 = require("228ba935d48384e7");
var Exports_3 = require("94c93038af012350");
var HeaderNames_1 = require("a38f3fbc3865aa23");
var IntentConnectionFactory = /** @class */ function(_super) {
    __extends(IntentConnectionFactory, _super);
    function IntentConnectionFactory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IntentConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        var endpoint = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint);
        if (!endpoint) {
            var region = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_IntentRegion);
            var hostSuffix = ConnectionFactoryBase_1.ConnectionFactoryBase.getHostSuffix(region);
            var host = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".sr.speech" + hostSuffix);
            endpoint = host + "/speech/recognition/interactive/cognitiveservices/v1";
        }
        var queryParams = {
            format: "simple",
            language: config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage)
        };
        this.setCommonUrlParams(config, queryParams, endpoint);
        var headers = {};
        if (authInfo.token !== undefined && authInfo.token !== "") headers[authInfo.headerName] = authInfo.token;
        headers[HeaderNames_1.HeaderNames.ConnectionId] = connectionId;
        config.parameters.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Url, endpoint);
        var enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
        return new Exports_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_3.WebsocketMessageFormatter(), Exports_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    };
    IntentConnectionFactory.prototype.getSpeechRegionFromIntentRegion = function(intentRegion) {
        switch(intentRegion){
            case "West US":
            case "US West":
            case "westus":
                return "uswest";
            case "West US 2":
            case "US West 2":
            case "westus2":
                return "uswest2";
            case "South Central US":
            case "US South Central":
            case "southcentralus":
                return "ussouthcentral";
            case "West Central US":
            case "US West Central":
            case "westcentralus":
                return "uswestcentral";
            case "East US":
            case "US East":
            case "eastus":
                return "useast";
            case "East US 2":
            case "US East 2":
            case "eastus2":
                return "useast2";
            case "West Europe":
            case "Europe West":
            case "westeurope":
                return "europewest";
            case "North Europe":
            case "Europe North":
            case "northeurope":
                return "europenorth";
            case "Brazil South":
            case "South Brazil":
            case "southbrazil":
                return "brazilsouth";
            case "Australia East":
            case "East Australia":
            case "eastaustralia":
                return "australiaeast";
            case "Southeast Asia":
            case "Asia Southeast":
            case "southeastasia":
                return "asiasoutheast";
            case "East Asia":
            case "Asia East":
            case "eastasia":
                return "asiaeast";
            default:
                return intentRegion;
        }
    };
    return IntentConnectionFactory;
}(ConnectionFactoryBase_1.ConnectionFactoryBase);
exports.IntentConnectionFactory = IntentConnectionFactory;

},{"f7883ea8ac903554":"9oZeQ","8e2966fd3818326a":"hxkc3","228ba935d48384e7":"hvoIt","94c93038af012350":"7Qpvn","a38f3fbc3865aa23":"bNYHA"}],"hxkc3":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
var AudioConfig_1 = require("a32d91ab22a9122b");
Object.defineProperty(exports, "AudioConfig", {
    enumerable: true,
    get: function() {
        return AudioConfig_1.AudioConfig;
    }
});
var AudioStreamFormat_1 = require("ad5df0b8fa076d8f");
Object.defineProperty(exports, "AudioStreamFormat", {
    enumerable: true,
    get: function() {
        return AudioStreamFormat_1.AudioStreamFormat;
    }
});
Object.defineProperty(exports, "AudioFormatTag", {
    enumerable: true,
    get: function() {
        return AudioStreamFormat_1.AudioFormatTag;
    }
});
var AudioInputStream_1 = require("e5a883f33a8489ec");
Object.defineProperty(exports, "AudioInputStream", {
    enumerable: true,
    get: function() {
        return AudioInputStream_1.AudioInputStream;
    }
});
Object.defineProperty(exports, "PullAudioInputStream", {
    enumerable: true,
    get: function() {
        return AudioInputStream_1.PullAudioInputStream;
    }
});
Object.defineProperty(exports, "PushAudioInputStream", {
    enumerable: true,
    get: function() {
        return AudioInputStream_1.PushAudioInputStream;
    }
});
var AudioOutputStream_1 = require("abd5fdd2e3f23262");
Object.defineProperty(exports, "AudioOutputStream", {
    enumerable: true,
    get: function() {
        return AudioOutputStream_1.AudioOutputStream;
    }
});
Object.defineProperty(exports, "PullAudioOutputStream", {
    enumerable: true,
    get: function() {
        return AudioOutputStream_1.PullAudioOutputStream;
    }
});
Object.defineProperty(exports, "PushAudioOutputStream", {
    enumerable: true,
    get: function() {
        return AudioOutputStream_1.PushAudioOutputStream;
    }
});
var CancellationReason_1 = require("eb590543e39b1fec");
Object.defineProperty(exports, "CancellationReason", {
    enumerable: true,
    get: function() {
        return CancellationReason_1.CancellationReason;
    }
});
var PullAudioInputStreamCallback_1 = require("4d42777241e6b892");
Object.defineProperty(exports, "PullAudioInputStreamCallback", {
    enumerable: true,
    get: function() {
        return PullAudioInputStreamCallback_1.PullAudioInputStreamCallback;
    }
});
var PushAudioOutputStreamCallback_1 = require("a9c86e3d960d733d");
Object.defineProperty(exports, "PushAudioOutputStreamCallback", {
    enumerable: true,
    get: function() {
        return PushAudioOutputStreamCallback_1.PushAudioOutputStreamCallback;
    }
});
var KeywordRecognitionModel_1 = require("41b2e52ce4ad332d");
Object.defineProperty(exports, "KeywordRecognitionModel", {
    enumerable: true,
    get: function() {
        return KeywordRecognitionModel_1.KeywordRecognitionModel;
    }
});
var SessionEventArgs_1 = require("8342323ece1ca83b");
Object.defineProperty(exports, "SessionEventArgs", {
    enumerable: true,
    get: function() {
        return SessionEventArgs_1.SessionEventArgs;
    }
});
var RecognitionEventArgs_1 = require("b4aed4a45932a09");
Object.defineProperty(exports, "RecognitionEventArgs", {
    enumerable: true,
    get: function() {
        return RecognitionEventArgs_1.RecognitionEventArgs;
    }
});
var OutputFormat_1 = require("d74bdbb58e273830");
Object.defineProperty(exports, "OutputFormat", {
    enumerable: true,
    get: function() {
        return OutputFormat_1.OutputFormat;
    }
});
var IntentRecognitionEventArgs_1 = require("430e8cae4809eb23");
Object.defineProperty(exports, "IntentRecognitionEventArgs", {
    enumerable: true,
    get: function() {
        return IntentRecognitionEventArgs_1.IntentRecognitionEventArgs;
    }
});
var RecognitionResult_1 = require("3a2e260357c769d9");
Object.defineProperty(exports, "RecognitionResult", {
    enumerable: true,
    get: function() {
        return RecognitionResult_1.RecognitionResult;
    }
});
var SpeechRecognitionResult_1 = require("9a5a7a69ac5a6f59");
Object.defineProperty(exports, "SpeechRecognitionResult", {
    enumerable: true,
    get: function() {
        return SpeechRecognitionResult_1.SpeechRecognitionResult;
    }
});
var IntentRecognitionResult_1 = require("a73d974ef8d74285");
Object.defineProperty(exports, "IntentRecognitionResult", {
    enumerable: true,
    get: function() {
        return IntentRecognitionResult_1.IntentRecognitionResult;
    }
});
var LanguageUnderstandingModel_1 = require("3516fc0aaef3702a");
Object.defineProperty(exports, "LanguageUnderstandingModel", {
    enumerable: true,
    get: function() {
        return LanguageUnderstandingModel_1.LanguageUnderstandingModel;
    }
});
var SpeechRecognitionEventArgs_1 = require("33404302a5d051a6");
Object.defineProperty(exports, "SpeechRecognitionEventArgs", {
    enumerable: true,
    get: function() {
        return SpeechRecognitionEventArgs_1.SpeechRecognitionEventArgs;
    }
});
Object.defineProperty(exports, "ConversationTranscriptionEventArgs", {
    enumerable: true,
    get: function() {
        return SpeechRecognitionEventArgs_1.ConversationTranscriptionEventArgs;
    }
});
Object.defineProperty(exports, "MeetingTranscriptionEventArgs", {
    enumerable: true,
    get: function() {
        return SpeechRecognitionEventArgs_1.MeetingTranscriptionEventArgs;
    }
});
var SpeechRecognitionCanceledEventArgs_1 = require("e728a6829f553325");
Object.defineProperty(exports, "SpeechRecognitionCanceledEventArgs", {
    enumerable: true,
    get: function() {
        return SpeechRecognitionCanceledEventArgs_1.SpeechRecognitionCanceledEventArgs;
    }
});
var TranslationRecognitionEventArgs_1 = require("e96182d78af58e86");
Object.defineProperty(exports, "TranslationRecognitionEventArgs", {
    enumerable: true,
    get: function() {
        return TranslationRecognitionEventArgs_1.TranslationRecognitionEventArgs;
    }
});
var TranslationSynthesisEventArgs_1 = require("c6071a5e874e248c");
Object.defineProperty(exports, "TranslationSynthesisEventArgs", {
    enumerable: true,
    get: function() {
        return TranslationSynthesisEventArgs_1.TranslationSynthesisEventArgs;
    }
});
var TranslationRecognitionResult_1 = require("3a1bded2477b2d42");
Object.defineProperty(exports, "TranslationRecognitionResult", {
    enumerable: true,
    get: function() {
        return TranslationRecognitionResult_1.TranslationRecognitionResult;
    }
});
var TranslationSynthesisResult_1 = require("8b45aca7b50aac80");
Object.defineProperty(exports, "TranslationSynthesisResult", {
    enumerable: true,
    get: function() {
        return TranslationSynthesisResult_1.TranslationSynthesisResult;
    }
});
var ResultReason_1 = require("2b079b6df8ca1354");
Object.defineProperty(exports, "ResultReason", {
    enumerable: true,
    get: function() {
        return ResultReason_1.ResultReason;
    }
});
var SpeechConfig_1 = require("be552e72b9a39cc8");
Object.defineProperty(exports, "SpeechConfig", {
    enumerable: true,
    get: function() {
        return SpeechConfig_1.SpeechConfig;
    }
});
Object.defineProperty(exports, "SpeechConfigImpl", {
    enumerable: true,
    get: function() {
        return SpeechConfig_1.SpeechConfigImpl;
    }
});
var SpeechTranslationConfig_1 = require("a785b57d963237fd");
Object.defineProperty(exports, "SpeechTranslationConfig", {
    enumerable: true,
    get: function() {
        return SpeechTranslationConfig_1.SpeechTranslationConfig;
    }
});
Object.defineProperty(exports, "SpeechTranslationConfigImpl", {
    enumerable: true,
    get: function() {
        return SpeechTranslationConfig_1.SpeechTranslationConfigImpl;
    }
});
var PropertyCollection_1 = require("d1e8c382877d2a0a");
Object.defineProperty(exports, "PropertyCollection", {
    enumerable: true,
    get: function() {
        return PropertyCollection_1.PropertyCollection;
    }
});
var PropertyId_1 = require("74f167f036e59a37");
Object.defineProperty(exports, "PropertyId", {
    enumerable: true,
    get: function() {
        return PropertyId_1.PropertyId;
    }
});
var Recognizer_1 = require("8413a20a0d3963c");
Object.defineProperty(exports, "Recognizer", {
    enumerable: true,
    get: function() {
        return Recognizer_1.Recognizer;
    }
});
var SpeechRecognizer_1 = require("928ee175d0dd6cad");
Object.defineProperty(exports, "SpeechRecognizer", {
    enumerable: true,
    get: function() {
        return SpeechRecognizer_1.SpeechRecognizer;
    }
});
var IntentRecognizer_1 = require("e4d1c646d9ae369a");
Object.defineProperty(exports, "IntentRecognizer", {
    enumerable: true,
    get: function() {
        return IntentRecognizer_1.IntentRecognizer;
    }
});
var VoiceProfileType_1 = require("75df04bb96a0e5e3");
Object.defineProperty(exports, "VoiceProfileType", {
    enumerable: true,
    get: function() {
        return VoiceProfileType_1.VoiceProfileType;
    }
});
var TranslationRecognizer_1 = require("84f46634e092f158");
Object.defineProperty(exports, "TranslationRecognizer", {
    enumerable: true,
    get: function() {
        return TranslationRecognizer_1.TranslationRecognizer;
    }
});
var Translations_1 = require("c883de21c802b719");
Object.defineProperty(exports, "Translations", {
    enumerable: true,
    get: function() {
        return Translations_1.Translations;
    }
});
var NoMatchReason_1 = require("104e6e1ae8b0c407");
Object.defineProperty(exports, "NoMatchReason", {
    enumerable: true,
    get: function() {
        return NoMatchReason_1.NoMatchReason;
    }
});
var NoMatchDetails_1 = require("bda8765716fccee8");
Object.defineProperty(exports, "NoMatchDetails", {
    enumerable: true,
    get: function() {
        return NoMatchDetails_1.NoMatchDetails;
    }
});
var TranslationRecognitionCanceledEventArgs_1 = require("e0976e4d2fd0a9ac");
Object.defineProperty(exports, "TranslationRecognitionCanceledEventArgs", {
    enumerable: true,
    get: function() {
        return TranslationRecognitionCanceledEventArgs_1.TranslationRecognitionCanceledEventArgs;
    }
});
var IntentRecognitionCanceledEventArgs_1 = require("aa995ddd072105c2");
Object.defineProperty(exports, "IntentRecognitionCanceledEventArgs", {
    enumerable: true,
    get: function() {
        return IntentRecognitionCanceledEventArgs_1.IntentRecognitionCanceledEventArgs;
    }
});
var CancellationDetailsBase_1 = require("b20ff94c04d28d8d");
Object.defineProperty(exports, "CancellationDetailsBase", {
    enumerable: true,
    get: function() {
        return CancellationDetailsBase_1.CancellationDetailsBase;
    }
});
var CancellationDetails_1 = require("9c8de386332ae695");
Object.defineProperty(exports, "CancellationDetails", {
    enumerable: true,
    get: function() {
        return CancellationDetails_1.CancellationDetails;
    }
});
var CancellationErrorCodes_1 = require("cbdcceb1a2f50526");
Object.defineProperty(exports, "CancellationErrorCode", {
    enumerable: true,
    get: function() {
        return CancellationErrorCodes_1.CancellationErrorCode;
    }
});
var ConnectionEventArgs_1 = require("3a3a65c174bf42dc");
Object.defineProperty(exports, "ConnectionEventArgs", {
    enumerable: true,
    get: function() {
        return ConnectionEventArgs_1.ConnectionEventArgs;
    }
});
var ServiceEventArgs_1 = require("96375e9f70f63aa8");
Object.defineProperty(exports, "ServiceEventArgs", {
    enumerable: true,
    get: function() {
        return ServiceEventArgs_1.ServiceEventArgs;
    }
});
var Connection_1 = require("5a4e231f5ad6cc8d");
Object.defineProperty(exports, "Connection", {
    enumerable: true,
    get: function() {
        return Connection_1.Connection;
    }
});
var PhraseListGrammar_1 = require("460f29573d33311");
Object.defineProperty(exports, "PhraseListGrammar", {
    enumerable: true,
    get: function() {
        return PhraseListGrammar_1.PhraseListGrammar;
    }
});
var DialogServiceConfig_1 = require("c6a3e66242c78ad1");
Object.defineProperty(exports, "DialogServiceConfig", {
    enumerable: true,
    get: function() {
        return DialogServiceConfig_1.DialogServiceConfig;
    }
});
var BotFrameworkConfig_1 = require("3518fc47e6bf9824");
Object.defineProperty(exports, "BotFrameworkConfig", {
    enumerable: true,
    get: function() {
        return BotFrameworkConfig_1.BotFrameworkConfig;
    }
});
var CustomCommandsConfig_1 = require("11d1f36fa99f8201");
Object.defineProperty(exports, "CustomCommandsConfig", {
    enumerable: true,
    get: function() {
        return CustomCommandsConfig_1.CustomCommandsConfig;
    }
});
var DialogServiceConnector_1 = require("457479588b1f3817");
Object.defineProperty(exports, "DialogServiceConnector", {
    enumerable: true,
    get: function() {
        return DialogServiceConnector_1.DialogServiceConnector;
    }
});
var ActivityReceivedEventArgs_1 = require("a182224b4788e475");
Object.defineProperty(exports, "ActivityReceivedEventArgs", {
    enumerable: true,
    get: function() {
        return ActivityReceivedEventArgs_1.ActivityReceivedEventArgs;
    }
});
var TurnStatusReceivedEventArgs_1 = require("274f79f3cc171534");
Object.defineProperty(exports, "TurnStatusReceivedEventArgs", {
    enumerable: true,
    get: function() {
        return TurnStatusReceivedEventArgs_1.TurnStatusReceivedEventArgs;
    }
});
var ServicePropertyChannel_1 = require("60696c4b321b0e9b");
Object.defineProperty(exports, "ServicePropertyChannel", {
    enumerable: true,
    get: function() {
        return ServicePropertyChannel_1.ServicePropertyChannel;
    }
});
var ProfanityOption_1 = require("dc30e47f36f5639d");
Object.defineProperty(exports, "ProfanityOption", {
    enumerable: true,
    get: function() {
        return ProfanityOption_1.ProfanityOption;
    }
});
var BaseAudioPlayer_1 = require("6b117ca465cb6781");
Object.defineProperty(exports, "BaseAudioPlayer", {
    enumerable: true,
    get: function() {
        return BaseAudioPlayer_1.BaseAudioPlayer;
    }
});
var ConnectionMessageEventArgs_1 = require("8c4e4bf40e3bd6b7");
Object.defineProperty(exports, "ConnectionMessageEventArgs", {
    enumerable: true,
    get: function() {
        return ConnectionMessageEventArgs_1.ConnectionMessageEventArgs;
    }
});
var ConnectionMessage_1 = require("f3948debc84cfd21");
Object.defineProperty(exports, "ConnectionMessage", {
    enumerable: true,
    get: function() {
        return ConnectionMessage_1.ConnectionMessage;
    }
});
var VoiceProfile_1 = require("ebcc32e5a5378965");
Object.defineProperty(exports, "VoiceProfile", {
    enumerable: true,
    get: function() {
        return VoiceProfile_1.VoiceProfile;
    }
});
var VoiceProfileEnrollmentResult_1 = require("b64b3b6cedba779a");
Object.defineProperty(exports, "VoiceProfileEnrollmentResult", {
    enumerable: true,
    get: function() {
        return VoiceProfileEnrollmentResult_1.VoiceProfileEnrollmentResult;
    }
});
Object.defineProperty(exports, "VoiceProfileEnrollmentCancellationDetails", {
    enumerable: true,
    get: function() {
        return VoiceProfileEnrollmentResult_1.VoiceProfileEnrollmentCancellationDetails;
    }
});
var VoiceProfileResult_1 = require("7ddb02911fe54f6");
Object.defineProperty(exports, "VoiceProfileResult", {
    enumerable: true,
    get: function() {
        return VoiceProfileResult_1.VoiceProfileResult;
    }
});
Object.defineProperty(exports, "VoiceProfileCancellationDetails", {
    enumerable: true,
    get: function() {
        return VoiceProfileResult_1.VoiceProfileCancellationDetails;
    }
});
var VoiceProfilePhraseResult_1 = require("2b2059bb5938a334");
Object.defineProperty(exports, "VoiceProfilePhraseResult", {
    enumerable: true,
    get: function() {
        return VoiceProfilePhraseResult_1.VoiceProfilePhraseResult;
    }
});
var VoiceProfileClient_1 = require("891e0bde46a30c66");
Object.defineProperty(exports, "VoiceProfileClient", {
    enumerable: true,
    get: function() {
        return VoiceProfileClient_1.VoiceProfileClient;
    }
});
var SpeakerRecognizer_1 = require("bfc6bdebc96f3b08");
Object.defineProperty(exports, "SpeakerRecognizer", {
    enumerable: true,
    get: function() {
        return SpeakerRecognizer_1.SpeakerRecognizer;
    }
});
var SpeakerIdentificationModel_1 = require("8ce102af5f4fd1f0");
Object.defineProperty(exports, "SpeakerIdentificationModel", {
    enumerable: true,
    get: function() {
        return SpeakerIdentificationModel_1.SpeakerIdentificationModel;
    }
});
var SpeakerVerificationModel_1 = require("cbad8501b7cfd3fa");
Object.defineProperty(exports, "SpeakerVerificationModel", {
    enumerable: true,
    get: function() {
        return SpeakerVerificationModel_1.SpeakerVerificationModel;
    }
});
var AutoDetectSourceLanguageConfig_1 = require("c2237bb5ebb773f");
Object.defineProperty(exports, "AutoDetectSourceLanguageConfig", {
    enumerable: true,
    get: function() {
        return AutoDetectSourceLanguageConfig_1.AutoDetectSourceLanguageConfig;
    }
});
var AutoDetectSourceLanguageResult_1 = require("36939877168c3389");
Object.defineProperty(exports, "AutoDetectSourceLanguageResult", {
    enumerable: true,
    get: function() {
        return AutoDetectSourceLanguageResult_1.AutoDetectSourceLanguageResult;
    }
});
var SourceLanguageConfig_1 = require("753203e534a0522f");
Object.defineProperty(exports, "SourceLanguageConfig", {
    enumerable: true,
    get: function() {
        return SourceLanguageConfig_1.SourceLanguageConfig;
    }
});
var SpeakerRecognitionResult_1 = require("24ae2468e8b14083");
Object.defineProperty(exports, "SpeakerRecognitionResult", {
    enumerable: true,
    get: function() {
        return SpeakerRecognitionResult_1.SpeakerRecognitionResult;
    }
});
Object.defineProperty(exports, "SpeakerRecognitionResultType", {
    enumerable: true,
    get: function() {
        return SpeakerRecognitionResult_1.SpeakerRecognitionResultType;
    }
});
Object.defineProperty(exports, "SpeakerRecognitionCancellationDetails", {
    enumerable: true,
    get: function() {
        return SpeakerRecognitionResult_1.SpeakerRecognitionCancellationDetails;
    }
});
var Exports_1 = require("58657fa72f43f7f5");
Object.defineProperty(exports, "Conversation", {
    enumerable: true,
    get: function() {
        return Exports_1.Conversation;
    }
});
Object.defineProperty(exports, "ConversationExpirationEventArgs", {
    enumerable: true,
    get: function() {
        return Exports_1.ConversationExpirationEventArgs;
    }
});
Object.defineProperty(exports, "ConversationParticipantsChangedEventArgs", {
    enumerable: true,
    get: function() {
        return Exports_1.ConversationParticipantsChangedEventArgs;
    }
});
Object.defineProperty(exports, "ConversationTranslationCanceledEventArgs", {
    enumerable: true,
    get: function() {
        return Exports_1.ConversationTranslationCanceledEventArgs;
    }
});
Object.defineProperty(exports, "ConversationTranslationEventArgs", {
    enumerable: true,
    get: function() {
        return Exports_1.ConversationTranslationEventArgs;
    }
});
Object.defineProperty(exports, "ConversationTranslationResult", {
    enumerable: true,
    get: function() {
        return Exports_1.ConversationTranslationResult;
    }
});
Object.defineProperty(exports, "ConversationTranslator", {
    enumerable: true,
    get: function() {
        return Exports_1.ConversationTranslator;
    }
});
Object.defineProperty(exports, "ConversationTranscriber", {
    enumerable: true,
    get: function() {
        return Exports_1.ConversationTranscriber;
    }
});
Object.defineProperty(exports, "ConversationTranscriptionResult", {
    enumerable: true,
    get: function() {
        return Exports_1.ConversationTranscriptionResult;
    }
});
Object.defineProperty(exports, "Meeting", {
    enumerable: true,
    get: function() {
        return Exports_1.Meeting;
    }
});
Object.defineProperty(exports, "MeetingTranscriber", {
    enumerable: true,
    get: function() {
        return Exports_1.MeetingTranscriber;
    }
});
Object.defineProperty(exports, "Participant", {
    enumerable: true,
    get: function() {
        return Exports_1.Participant;
    }
});
Object.defineProperty(exports, "ParticipantChangedReason", {
    enumerable: true,
    get: function() {
        return Exports_1.ParticipantChangedReason;
    }
});
Object.defineProperty(exports, "User", {
    enumerable: true,
    get: function() {
        return Exports_1.User;
    }
});
var SpeechSynthesisOutputFormat_1 = require("3467a30a51f5da02");
Object.defineProperty(exports, "SpeechSynthesisOutputFormat", {
    enumerable: true,
    get: function() {
        return SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat;
    }
});
var SpeechSynthesizer_1 = require("120b04eb0f212f43");
Object.defineProperty(exports, "SpeechSynthesizer", {
    enumerable: true,
    get: function() {
        return SpeechSynthesizer_1.SpeechSynthesizer;
    }
});
var SynthesisResult_1 = require("7d886df082cde87");
Object.defineProperty(exports, "SynthesisResult", {
    enumerable: true,
    get: function() {
        return SynthesisResult_1.SynthesisResult;
    }
});
var SpeechSynthesisResult_1 = require("7412f3b88da24fab");
Object.defineProperty(exports, "SpeechSynthesisResult", {
    enumerable: true,
    get: function() {
        return SpeechSynthesisResult_1.SpeechSynthesisResult;
    }
});
var SpeechSynthesisEventArgs_1 = require("6e8f2a01a836d688");
Object.defineProperty(exports, "SpeechSynthesisEventArgs", {
    enumerable: true,
    get: function() {
        return SpeechSynthesisEventArgs_1.SpeechSynthesisEventArgs;
    }
});
var SpeechSynthesisWordBoundaryEventArgs_1 = require("47b07751dd026b0c");
Object.defineProperty(exports, "SpeechSynthesisWordBoundaryEventArgs", {
    enumerable: true,
    get: function() {
        return SpeechSynthesisWordBoundaryEventArgs_1.SpeechSynthesisWordBoundaryEventArgs;
    }
});
var SpeechSynthesisBookmarkEventArgs_1 = require("643e74d87a073965");
Object.defineProperty(exports, "SpeechSynthesisBookmarkEventArgs", {
    enumerable: true,
    get: function() {
        return SpeechSynthesisBookmarkEventArgs_1.SpeechSynthesisBookmarkEventArgs;
    }
});
var SpeechSynthesisVisemeEventArgs_1 = require("9f6dc017580b80ae");
Object.defineProperty(exports, "SpeechSynthesisVisemeEventArgs", {
    enumerable: true,
    get: function() {
        return SpeechSynthesisVisemeEventArgs_1.SpeechSynthesisVisemeEventArgs;
    }
});
var SpeechSynthesisBoundaryType_1 = require("4d7e2a763926713b");
Object.defineProperty(exports, "SpeechSynthesisBoundaryType", {
    enumerable: true,
    get: function() {
        return SpeechSynthesisBoundaryType_1.SpeechSynthesisBoundaryType;
    }
});
var SynthesisVoicesResult_1 = require("bb273a30fbf7c553");
Object.defineProperty(exports, "SynthesisVoicesResult", {
    enumerable: true,
    get: function() {
        return SynthesisVoicesResult_1.SynthesisVoicesResult;
    }
});
var VoiceInfo_1 = require("ab4f40ae9da9cdcb");
Object.defineProperty(exports, "VoiceInfo", {
    enumerable: true,
    get: function() {
        return VoiceInfo_1.VoiceInfo;
    }
});
var SpeakerAudioDestination_1 = require("1f2bc3aa7d88742b");
Object.defineProperty(exports, "SpeakerAudioDestination", {
    enumerable: true,
    get: function() {
        return SpeakerAudioDestination_1.SpeakerAudioDestination;
    }
});
var ConversationTranscriptionCanceledEventArgs_1 = require("694caf3353535039");
Object.defineProperty(exports, "ConversationTranscriptionCanceledEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationTranscriptionCanceledEventArgs_1.ConversationTranscriptionCanceledEventArgs;
    }
});
var MeetingTranscriptionCanceledEventArgs_1 = require("5ed1147ed6569b63");
Object.defineProperty(exports, "MeetingTranscriptionCanceledEventArgs", {
    enumerable: true,
    get: function() {
        return MeetingTranscriptionCanceledEventArgs_1.MeetingTranscriptionCanceledEventArgs;
    }
});
var PronunciationAssessmentGradingSystem_1 = require("f4d8dfc3e747d502");
Object.defineProperty(exports, "PronunciationAssessmentGradingSystem", {
    enumerable: true,
    get: function() {
        return PronunciationAssessmentGradingSystem_1.PronunciationAssessmentGradingSystem;
    }
});
var PronunciationAssessmentGranularity_1 = require("7b658addf32f153b");
Object.defineProperty(exports, "PronunciationAssessmentGranularity", {
    enumerable: true,
    get: function() {
        return PronunciationAssessmentGranularity_1.PronunciationAssessmentGranularity;
    }
});
var PronunciationAssessmentConfig_1 = require("3b447206e8ff3484");
Object.defineProperty(exports, "PronunciationAssessmentConfig", {
    enumerable: true,
    get: function() {
        return PronunciationAssessmentConfig_1.PronunciationAssessmentConfig;
    }
});
var PronunciationAssessmentResult_1 = require("85ff3c3c8557118f");
Object.defineProperty(exports, "PronunciationAssessmentResult", {
    enumerable: true,
    get: function() {
        return PronunciationAssessmentResult_1.PronunciationAssessmentResult;
    }
});
var LanguageIdMode_1 = require("2dc4157f9ff7035");
Object.defineProperty(exports, "LanguageIdMode", {
    enumerable: true,
    get: function() {
        return LanguageIdMode_1.LanguageIdMode;
    }
});
var Diagnostics_1 = require("660b9fbe16487486");
Object.defineProperty(exports, "Diagnostics", {
    enumerable: true,
    get: function() {
        return Diagnostics_1.Diagnostics;
    }
});
var LogLevel_1 = require("744b37ce532f6018");
Object.defineProperty(exports, "LogLevel", {
    enumerable: true,
    get: function() {
        return LogLevel_1.LogLevel;
    }
});

},{"a32d91ab22a9122b":"eM6bc","ad5df0b8fa076d8f":"8hTlD","e5a883f33a8489ec":"bJIxO","abd5fdd2e3f23262":"budsd","eb590543e39b1fec":"5OehU","4d42777241e6b892":"eCjma","a9c86e3d960d733d":"aVqBm","41b2e52ce4ad332d":"hsmdR","8342323ece1ca83b":"fxJH6","b4aed4a45932a09":"4D5lW","d74bdbb58e273830":"03ptH","430e8cae4809eb23":"bhX5f","3a2e260357c769d9":"fSJf9","9a5a7a69ac5a6f59":"8mOF8","a73d974ef8d74285":"92lob","3516fc0aaef3702a":"6y7mJ","33404302a5d051a6":"jG3r6","e728a6829f553325":"4R5tA","e96182d78af58e86":"h3kua","c6071a5e874e248c":"dN2sU","3a1bded2477b2d42":"bX84V","8b45aca7b50aac80":"7z8gi","2b079b6df8ca1354":"d3kNo","be552e72b9a39cc8":"fULPg","a785b57d963237fd":"2hkll","d1e8c382877d2a0a":"jfzZ9","74f167f036e59a37":"6Rdzq","8413a20a0d3963c":"c5ver","928ee175d0dd6cad":"hfqQW","e4d1c646d9ae369a":"1Ea8Z","75df04bb96a0e5e3":"8wwPQ","84f46634e092f158":"68FZq","c883de21c802b719":"gon5O","104e6e1ae8b0c407":"eevn2","bda8765716fccee8":"i3GJV","e0976e4d2fd0a9ac":"iKuA1","aa995ddd072105c2":"f9DIh","b20ff94c04d28d8d":"9oXOl","9c8de386332ae695":"aLF5A","cbdcceb1a2f50526":"bs4bZ","3a3a65c174bf42dc":"fFQRG","96375e9f70f63aa8":"l2QCH","5a4e231f5ad6cc8d":"6O7VR","460f29573d33311":"bvcgC","c6a3e66242c78ad1":"5hc1l","3518fc47e6bf9824":"5hvMW","11d1f36fa99f8201":"3KSme","457479588b1f3817":"bUp2i","a182224b4788e475":"5H9ue","274f79f3cc171534":"2T7cQ","60696c4b321b0e9b":"aWjLW","dc30e47f36f5639d":"4bTun","6b117ca465cb6781":"ijOdN","8c4e4bf40e3bd6b7":"7I85W","f3948debc84cfd21":"1bz2k","ebcc32e5a5378965":"4IE1Y","b64b3b6cedba779a":"gwi39","7ddb02911fe54f6":"64Gqz","2b2059bb5938a334":"d4ZYO","891e0bde46a30c66":"fwssW","bfc6bdebc96f3b08":"4Swpn","8ce102af5f4fd1f0":"1Gp2N","cbad8501b7cfd3fa":"6zwRo","c2237bb5ebb773f":"lQ8xM","36939877168c3389":"grZnn","753203e534a0522f":"exfsc","24ae2468e8b14083":"aUAOO","58657fa72f43f7f5":"6pz5J","3467a30a51f5da02":"6ejj7","120b04eb0f212f43":"alKVB","7d886df082cde87":"iMoxM","7412f3b88da24fab":"7Bjmi","6e8f2a01a836d688":"g0l5f","47b07751dd026b0c":"lkrUn","643e74d87a073965":"jVnhb","9f6dc017580b80ae":"eAa7l","4d7e2a763926713b":"gPzKL","bb273a30fbf7c553":"1gNhu","ab4f40ae9da9cdcb":"1oVyt","1f2bc3aa7d88742b":"5tT7p","694caf3353535039":"33B6B","5ed1147ed6569b63":"bhLqE","f4d8dfc3e747d502":"8TV5m","7b658addf32f153b":"bOGVv","3b447206e8ff3484":"jCQGZ","85ff3c3c8557118f":"r0TWP","2dc4157f9ff7035":"k14Gx","660b9fbe16487486":"5DSuL","744b37ce532f6018":"12n5C"}],"eM6bc":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AudioOutputConfigImpl = exports.AudioConfigImpl = exports.AudioConfig = void 0;
var Exports_1 = require("4bec964099193ef9");
var Contracts_1 = require("1f309633a1b6b5d1");
var Exports_2 = require("dc24366a534df36e");
var AudioFileWriter_1 = require("9a8d5a6bc2712cda");
var AudioInputStream_1 = require("33de1a8351cf21c6");
var AudioOutputStream_1 = require("d8c96b86c671fb5f");
/**
 * Represents audio input configuration used for specifying what type of input to use (microphone, file, stream).
 * @class AudioConfig
 * Updated in version 1.11.0
 */ var AudioConfig = /** @class */ function() {
    function AudioConfig() {}
    /**
     * Creates an AudioConfig object representing the default microphone on the system.
     * @member AudioConfig.fromDefaultMicrophoneInput
     * @function
     * @public
     * @returns {AudioConfig} The audio input configuration being created.
     */ AudioConfig.fromDefaultMicrophoneInput = function() {
        var pcmRecorder = new Exports_1.PcmRecorder(true);
        return new AudioConfigImpl(new Exports_1.MicAudioSource(pcmRecorder));
    };
    /**
     * Creates an AudioConfig object representing a microphone with the specified device ID.
     * @member AudioConfig.fromMicrophoneInput
     * @function
     * @public
     * @param {string | undefined} deviceId - Specifies the device ID of the microphone to be used.
     * Default microphone is used the value is omitted.
     * @returns {AudioConfig} The audio input configuration being created.
     */ AudioConfig.fromMicrophoneInput = function(deviceId) {
        var pcmRecorder = new Exports_1.PcmRecorder(true);
        return new AudioConfigImpl(new Exports_1.MicAudioSource(pcmRecorder, deviceId));
    };
    /**
     * Creates an AudioConfig object representing the specified file.
     * @member AudioConfig.fromWavFileInput
     * @function
     * @public
     * @param {File} fileName - Specifies the audio input file. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */ AudioConfig.fromWavFileInput = function(file, name) {
        if (name === void 0) name = "unnamedBuffer.wav";
        return new AudioConfigImpl(new Exports_1.FileAudioSource(file, name));
    };
    /**
     * Creates an AudioConfig object representing the specified stream.
     * @member AudioConfig.fromStreamInput
     * @function
     * @public
     * @param {AudioInputStream | PullAudioInputStreamCallback | MediaStream} audioStream - Specifies the custom audio input
     * stream. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */ AudioConfig.fromStreamInput = function(audioStream) {
        if (audioStream instanceof Exports_2.PullAudioInputStreamCallback) return new AudioConfigImpl(new AudioInputStream_1.PullAudioInputStreamImpl(audioStream));
        if (audioStream instanceof Exports_2.AudioInputStream) return new AudioConfigImpl(audioStream);
        if (typeof MediaStream !== "undefined" && audioStream instanceof MediaStream) {
            var pcmRecorder = new Exports_1.PcmRecorder(false);
            return new AudioConfigImpl(new Exports_1.MicAudioSource(pcmRecorder, null, null, audioStream));
        }
        throw new Error("Not Supported Type");
    };
    /**
     * Creates an AudioConfig object representing the default speaker.
     * @member AudioConfig.fromDefaultSpeakerOutput
     * @function
     * @public
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */ AudioConfig.fromDefaultSpeakerOutput = function() {
        return new AudioOutputConfigImpl(new Exports_2.SpeakerAudioDestination());
    };
    /**
     * Creates an AudioConfig object representing the custom IPlayer object.
     * You can use the IPlayer object to control pause, resume, etc.
     * @member AudioConfig.fromSpeakerOutput
     * @function
     * @public
     * @param {IPlayer} player - the IPlayer object for playback.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.12.0
     */ AudioConfig.fromSpeakerOutput = function(player) {
        if (player === undefined) return AudioConfig.fromDefaultSpeakerOutput();
        if (player instanceof Exports_2.SpeakerAudioDestination) return new AudioOutputConfigImpl(player);
        throw new Error("Not Supported Type");
    };
    /**
     * Creates an AudioConfig object representing a specified output audio file
     * @member AudioConfig.fromAudioFileOutput
     * @function
     * @public
     * @param {PathLike} filename - the filename of the output audio file
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */ AudioConfig.fromAudioFileOutput = function(filename) {
        return new AudioOutputConfigImpl(new AudioFileWriter_1.AudioFileWriter(filename));
    };
    /**
     * Creates an AudioConfig object representing a specified audio output stream
     * @member AudioConfig.fromStreamOutput
     * @function
     * @public
     * @param {AudioOutputStream | PushAudioOutputStreamCallback} audioStream - Specifies the custom audio output
     * stream.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */ AudioConfig.fromStreamOutput = function(audioStream) {
        if (audioStream instanceof Exports_2.PushAudioOutputStreamCallback) return new AudioOutputConfigImpl(new AudioOutputStream_1.PushAudioOutputStreamImpl(audioStream));
        if (audioStream instanceof Exports_2.PushAudioOutputStream) return new AudioOutputConfigImpl(audioStream);
        if (audioStream instanceof Exports_2.PullAudioOutputStream) return new AudioOutputConfigImpl(audioStream);
        throw new Error("Not Supported Type");
    };
    return AudioConfig;
}();
exports.AudioConfig = AudioConfig;
/**
 * Represents audio input stream used for custom audio input configurations.
 * @private
 * @class AudioConfigImpl
 */ var AudioConfigImpl = /** @class */ function(_super) {
    __extends(AudioConfigImpl, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioSource} source - An audio source.
     */ function AudioConfigImpl(source) {
        var _this = _super.call(this) || this;
        _this.privSource = source;
        return _this;
    }
    Object.defineProperty(AudioConfigImpl.prototype, "format", {
        /**
         * Format information for the audio
         */ get: function() {
            return this.privSource.format;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @member AudioConfigImpl.prototype.close
     * @function
     * @public
     */ AudioConfigImpl.prototype.close = function(cb, err) {
        this.privSource.turnOff().then(function() {
            if (!!cb) cb();
        }, function(error) {
            if (!!err) err(error);
        });
    };
    /**
     * @member AudioConfigImpl.prototype.id
     * @function
     * @public
     */ AudioConfigImpl.prototype.id = function() {
        return this.privSource.id();
    };
    /**
     * @member AudioConfigImpl.prototype.turnOn
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */ AudioConfigImpl.prototype.turnOn = function() {
        return this.privSource.turnOn();
    };
    /**
     * @member AudioConfigImpl.prototype.attach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     * @returns {Promise<IAudioStreamNode>} A promise.
     */ AudioConfigImpl.prototype.attach = function(audioNodeId) {
        return this.privSource.attach(audioNodeId);
    };
    /**
     * @member AudioConfigImpl.prototype.detach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     */ AudioConfigImpl.prototype.detach = function(audioNodeId) {
        return this.privSource.detach(audioNodeId);
    };
    /**
     * @member AudioConfigImpl.prototype.turnOff
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */ AudioConfigImpl.prototype.turnOff = function() {
        return this.privSource.turnOff();
    };
    Object.defineProperty(AudioConfigImpl.prototype, "events", {
        /**
         * @member AudioConfigImpl.prototype.events
         * @function
         * @public
         * @returns {EventSource<AudioSourceEvent>} An event source for audio events.
         */ get: function() {
            return this.privSource.events;
        },
        enumerable: false,
        configurable: true
    });
    AudioConfigImpl.prototype.setProperty = function(name, value) {
        Contracts_1.Contracts.throwIfNull(value, "value");
        if (undefined !== this.privSource.setProperty) this.privSource.setProperty(name, value);
        else throw new Error("This AudioConfig instance does not support setting properties.");
    };
    AudioConfigImpl.prototype.getProperty = function(name, def) {
        if (undefined !== this.privSource.getProperty) return this.privSource.getProperty(name, def);
        else throw new Error("This AudioConfig instance does not support getting properties.");
        return def;
    };
    Object.defineProperty(AudioConfigImpl.prototype, "deviceInfo", {
        get: function() {
            return this.privSource.deviceInfo;
        },
        enumerable: false,
        configurable: true
    });
    return AudioConfigImpl;
}(AudioConfig);
exports.AudioConfigImpl = AudioConfigImpl;
var AudioOutputConfigImpl = /** @class */ function(_super) {
    __extends(AudioOutputConfigImpl, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioDestination} destination - An audio destination.
     */ function AudioOutputConfigImpl(destination) {
        var _this = _super.call(this) || this;
        _this.privDestination = destination;
        return _this;
    }
    Object.defineProperty(AudioOutputConfigImpl.prototype, "format", {
        set: function(format) {
            this.privDestination.format = format;
        },
        enumerable: false,
        configurable: true
    });
    AudioOutputConfigImpl.prototype.write = function(buffer) {
        this.privDestination.write(buffer);
    };
    AudioOutputConfigImpl.prototype.close = function() {
        this.privDestination.close();
    };
    AudioOutputConfigImpl.prototype.id = function() {
        return this.privDestination.id();
    };
    AudioOutputConfigImpl.prototype.setProperty = function() {
        throw new Error("This AudioConfig instance does not support setting properties.");
    };
    AudioOutputConfigImpl.prototype.getProperty = function() {
        throw new Error("This AudioConfig instance does not support getting properties.");
    };
    return AudioOutputConfigImpl;
}(AudioConfig);
exports.AudioOutputConfigImpl = AudioOutputConfigImpl;

},{"4bec964099193ef9":"9oZeQ","1f309633a1b6b5d1":"4jwu5","dc24366a534df36e":"hxkc3","9a8d5a6bc2712cda":"byi0Y","33de1a8351cf21c6":"bJIxO","d8c96b86c671fb5f":"budsd"}],"byi0Y":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AudioFileWriter = void 0;
var fs = __importStar(require("d4caf16ed44045fc"));
var Contracts_1 = require("97be06e232d00f24");
var AudioFileWriter = /** @class */ function() {
    function AudioFileWriter(filename) {
        Contracts_1.Contracts.throwIfNullOrUndefined(fs.openSync, "\nFile System access not available, please use Push or PullAudioOutputStream");
        this.privFd = fs.openSync(filename, "w");
    }
    Object.defineProperty(AudioFileWriter.prototype, "format", {
        set: function(format) {
            Contracts_1.Contracts.throwIfNotUndefined(this.privAudioFormat, "format is already set");
            this.privAudioFormat = format;
            var headerOffset = 0;
            if (this.privAudioFormat.hasHeader) headerOffset = this.privAudioFormat.header.byteLength;
            if (this.privFd !== undefined) this.privWriteStream = fs.createWriteStream("", {
                fd: this.privFd,
                start: headerOffset,
                autoClose: false
            });
        },
        enumerable: false,
        configurable: true
    });
    AudioFileWriter.prototype.write = function(buffer) {
        Contracts_1.Contracts.throwIfNullOrUndefined(this.privAudioFormat, "must set format before writing.");
        if (this.privWriteStream !== undefined) this.privWriteStream.write(new Uint8Array(buffer.slice(0)));
    };
    AudioFileWriter.prototype.close = function() {
        var _this = this;
        if (this.privFd !== undefined) {
            this.privWriteStream.on("finish", function() {
                if (_this.privAudioFormat.hasHeader) {
                    _this.privAudioFormat.updateHeader(_this.privWriteStream.bytesWritten);
                    fs.writeSync(_this.privFd, new Int8Array(_this.privAudioFormat.header), 0, _this.privAudioFormat.header.byteLength, 0);
                }
                fs.closeSync(_this.privFd);
                _this.privFd = undefined;
            });
            this.privWriteStream.end();
        }
    };
    AudioFileWriter.prototype.id = function() {
        return this.privId;
    };
    return AudioFileWriter;
}();
exports.AudioFileWriter = AudioFileWriter;

},{"d4caf16ed44045fc":"jhUEF","97be06e232d00f24":"4jwu5"}],"bJIxO":[function(require,module,exports) {
var Buffer = require("72eedbeac5598df2").Buffer;
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PullAudioInputStreamImpl = exports.PullAudioInputStream = exports.PushAudioInputStreamImpl = exports.PushAudioInputStream = exports.AudioInputStream = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("c42872dbf891ec5f");
var Exports_2 = require("379d3b22091e15e2");
var Guid_1 = require("bcced3d1523db9e2");
var Exports_3 = require("5a05e4014c9ea3f9");
var AudioStreamFormat_1 = require("8207261b6180c28d");
/**
 * Represents audio input stream used for custom audio input configurations.
 * @class AudioInputStream
 */ var AudioInputStream = /** @class */ function() {
    /**
     * Creates and initializes an instance.
     * @constructor
     */ function AudioInputStream() {
        return;
    }
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member AudioInputStream.createPushStream
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The audio input stream being created.
     */ AudioInputStream.createPushStream = function(format) {
        return PushAudioInputStream.create(format);
    };
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for read()
     * and close() methods.
     * @member AudioInputStream.createPullStream
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from
     * PullAudioInputStreamCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from
     * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The audio input stream being created.
     */ AudioInputStream.createPullStream = function(callback, format) {
        return PullAudioInputStream.create(callback, format);
    // throw new Error("Oops");
    };
    return AudioInputStream;
}();
exports.AudioInputStream = AudioInputStream;
/**
 * Represents memory backed push audio input stream used for custom audio input configurations.
 * @class PushAudioInputStream
 */ var PushAudioInputStream = /** @class */ function(_super) {
    __extends(PushAudioInputStream, _super);
    function PushAudioInputStream() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member PushAudioInputStream.create
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the
     * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The push audio input stream being created.
     */ PushAudioInputStream.create = function(format) {
        return new PushAudioInputStreamImpl(format);
    };
    return PushAudioInputStream;
}(AudioInputStream);
exports.PushAudioInputStream = PushAudioInputStream;
/**
 * Represents memory backed push audio input stream used for custom audio input configurations.
 * @private
 * @class PushAudioInputStreamImpl
 */ var PushAudioInputStreamImpl = /** @class */ function(_super) {
    __extends(PushAudioInputStreamImpl, _super);
    /**
     * Creates and initalizes an instance with the given values.
     * @constructor
     * @param {AudioStreamFormat} format - The audio stream format.
     */ function PushAudioInputStreamImpl(format) {
        var _this = _super.call(this) || this;
        if (format === undefined) _this.privFormat = AudioStreamFormat_1.AudioStreamFormatImpl.getDefaultInputFormat();
        else _this.privFormat = format;
        _this.privEvents = new Exports_2.EventSource();
        _this.privId = Guid_1.createNoDashGuid();
        _this.privStream = new Exports_2.ChunkedArrayBufferStream(_this.privFormat.avgBytesPerSec / 10);
        return _this;
    }
    Object.defineProperty(PushAudioInputStreamImpl.prototype, "format", {
        /**
         * Format information for the audio
         */ get: function() {
            return Promise.resolve(this.privFormat);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PushAudioInputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */ PushAudioInputStreamImpl.prototype.write = function(dataBuffer) {
        this.privStream.writeStreamChunk({
            buffer: dataBuffer,
            isEnd: false,
            timeReceived: Date.now()
        });
    };
    /**
     * Closes the stream.
     * @member PushAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */ PushAudioInputStreamImpl.prototype.close = function() {
        this.privStream.close();
    };
    PushAudioInputStreamImpl.prototype.id = function() {
        return this.privId;
    };
    PushAudioInputStreamImpl.prototype.turnOn = function() {
        this.onEvent(new Exports_2.AudioSourceInitializingEvent(this.privId)); // no stream id
        this.onEvent(new Exports_2.AudioSourceReadyEvent(this.privId));
        return;
    };
    PushAudioInputStreamImpl.prototype.attach = function(audioNodeId) {
        return __awaiter(this, void 0, void 0, function() {
            var stream;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.onEvent(new Exports_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
                        return [
                            4 /*yield*/ ,
                            this.turnOn()
                        ];
                    case 1:
                        _a.sent();
                        stream = this.privStream;
                        this.onEvent(new Exports_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
                        return [
                            2 /*return*/ ,
                            {
                                detach: function() {
                                    return __awaiter(_this, void 0, void 0, function() {
                                        return __generator(this, function(_a) {
                                            this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
                                            return [
                                                2 /*return*/ ,
                                                this.turnOff()
                                            ];
                                        });
                                    });
                                },
                                id: function() {
                                    return audioNodeId;
                                },
                                read: function() {
                                    return stream.read();
                                }
                            }
                        ];
                }
            });
        });
    };
    PushAudioInputStreamImpl.prototype.detach = function(audioNodeId) {
        this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
    };
    PushAudioInputStreamImpl.prototype.turnOff = function() {
        return;
    };
    Object.defineProperty(PushAudioInputStreamImpl.prototype, "events", {
        get: function() {
            return this.privEvents;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PushAudioInputStreamImpl.prototype, "deviceInfo", {
        get: function() {
            return Promise.resolve({
                bitspersample: this.privFormat.bitsPerSample,
                channelcount: this.privFormat.channels,
                connectivity: Exports_1.connectivity.Unknown,
                manufacturer: "Speech SDK",
                model: "PushStream",
                samplerate: this.privFormat.samplesPerSec,
                type: Exports_1.type.Stream
            });
        },
        enumerable: false,
        configurable: true
    });
    PushAudioInputStreamImpl.prototype.onEvent = function(event) {
        this.privEvents.onEvent(event);
        Exports_2.Events.instance.onEvent(event);
    };
    PushAudioInputStreamImpl.prototype.toBuffer = function(arrayBuffer) {
        var buf = Buffer.alloc(arrayBuffer.byteLength);
        var view = new Uint8Array(arrayBuffer);
        for(var i = 0; i < buf.length; ++i)buf[i] = view[i];
        return buf;
    };
    return PushAudioInputStreamImpl;
}(PushAudioInputStream);
exports.PushAudioInputStreamImpl = PushAudioInputStreamImpl;
/*
 * Represents audio input stream used for custom audio input configurations.
 * @class PullAudioInputStream
 */ var PullAudioInputStream = /** @class */ function(_super) {
    __extends(PullAudioInputStream, _super);
    /**
     * Creates and initializes and instance.
     * @constructor
     */ function PullAudioInputStream() {
        return _super.call(this) || this;
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @member PullAudioInputStream.create
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The push audio input stream being created.
     */ PullAudioInputStream.create = function(callback, format) {
        return new PullAudioInputStreamImpl(callback, format);
    };
    return PullAudioInputStream;
}(AudioInputStream);
exports.PullAudioInputStream = PullAudioInputStream;
/**
 * Represents audio input stream used for custom audio input configurations.
 * @private
 * @class PullAudioInputStreamImpl
 */ var PullAudioInputStreamImpl = /** @class */ function(_super) {
    __extends(PullAudioInputStreamImpl, _super);
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @constructor
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     */ function PullAudioInputStreamImpl(callback, format) {
        var _this = _super.call(this) || this;
        if (undefined === format) _this.privFormat = Exports_3.AudioStreamFormat.getDefaultInputFormat();
        else _this.privFormat = format;
        _this.privEvents = new Exports_2.EventSource();
        _this.privId = Guid_1.createNoDashGuid();
        _this.privCallback = callback;
        _this.privIsClosed = false;
        _this.privBufferSize = _this.privFormat.avgBytesPerSec / 10;
        return _this;
    }
    Object.defineProperty(PullAudioInputStreamImpl.prototype, "format", {
        /**
         * Format information for the audio
         */ get: function() {
            return Promise.resolve(this.privFormat);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Closes the stream.
     * @member PullAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */ PullAudioInputStreamImpl.prototype.close = function() {
        this.privIsClosed = true;
        this.privCallback.close();
    };
    PullAudioInputStreamImpl.prototype.id = function() {
        return this.privId;
    };
    PullAudioInputStreamImpl.prototype.turnOn = function() {
        this.onEvent(new Exports_2.AudioSourceInitializingEvent(this.privId)); // no stream id
        this.onEvent(new Exports_2.AudioSourceReadyEvent(this.privId));
        return;
    };
    PullAudioInputStreamImpl.prototype.attach = function(audioNodeId) {
        return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.onEvent(new Exports_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
                        return [
                            4 /*yield*/ ,
                            this.turnOn()
                        ];
                    case 1:
                        _a.sent();
                        this.onEvent(new Exports_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
                        return [
                            2 /*return*/ ,
                            {
                                detach: function() {
                                    _this.privCallback.close();
                                    _this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(_this.privId, audioNodeId));
                                    return _this.turnOff();
                                },
                                id: function() {
                                    return audioNodeId;
                                },
                                read: function() {
                                    var totalBytes = 0;
                                    var transmitBuff;
                                    // Until we have the minimum number of bytes to send in a transmission, keep asking for more.
                                    while(totalBytes < _this.privBufferSize){
                                        // Sizing the read buffer to the delta between the perfect size and what's left means we won't ever get too much
                                        // data back.
                                        var readBuff = new ArrayBuffer(_this.privBufferSize - totalBytes);
                                        var pulledBytes = _this.privCallback.read(readBuff);
                                        // If there is no return buffer yet defined, set the return buffer to the that was just populated.
                                        // This was, if we have enough data there's no copy penalty, but if we don't we have a buffer that's the
                                        // preferred size allocated.
                                        if (undefined === transmitBuff) transmitBuff = readBuff;
                                        else {
                                            // Not the first bite at the apple, so fill the return buffer with the data we got back.
                                            var intView = new Int8Array(transmitBuff);
                                            intView.set(new Int8Array(readBuff), totalBytes);
                                        }
                                        // If there are no bytes to read, just break out and be done.
                                        if (0 === pulledBytes) break;
                                        totalBytes += pulledBytes;
                                    }
                                    return Promise.resolve({
                                        buffer: transmitBuff.slice(0, totalBytes),
                                        isEnd: _this.privIsClosed || totalBytes === 0,
                                        timeReceived: Date.now()
                                    });
                                }
                            }
                        ];
                }
            });
        });
    };
    PullAudioInputStreamImpl.prototype.detach = function(audioNodeId) {
        this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
    };
    PullAudioInputStreamImpl.prototype.turnOff = function() {
        return;
    };
    Object.defineProperty(PullAudioInputStreamImpl.prototype, "events", {
        get: function() {
            return this.privEvents;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PullAudioInputStreamImpl.prototype, "deviceInfo", {
        get: function() {
            return Promise.resolve({
                bitspersample: this.privFormat.bitsPerSample,
                channelcount: this.privFormat.channels,
                connectivity: Exports_1.connectivity.Unknown,
                manufacturer: "Speech SDK",
                model: "PullStream",
                samplerate: this.privFormat.samplesPerSec,
                type: Exports_1.type.Stream
            });
        },
        enumerable: false,
        configurable: true
    });
    PullAudioInputStreamImpl.prototype.onEvent = function(event) {
        this.privEvents.onEvent(event);
        Exports_2.Events.instance.onEvent(event);
    };
    return PullAudioInputStreamImpl;
}(PullAudioInputStream);
exports.PullAudioInputStreamImpl = PullAudioInputStreamImpl;

},{"72eedbeac5598df2":"fYxS4","c42872dbf891ec5f":"7Qpvn","379d3b22091e15e2":"5Bedw","bcced3d1523db9e2":"dLGUL","5a05e4014c9ea3f9":"hxkc3","8207261b6180c28d":"8hTlD"}],"fYxS4":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("5e03d16b1726c279");
const ieee754 = require("43141a143b550a58");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"5e03d16b1726c279":"2Xa9g","43141a143b550a58":"jY0CC"}],"2Xa9g":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"jY0CC":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"8hTlD":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AudioStreamFormatImpl = exports.AudioStreamFormat = exports.AudioFormatTag = void 0;
// eslint-disable-next-line max-classes-per-file
var AudioFormatTag;
(function(AudioFormatTag) {
    AudioFormatTag[AudioFormatTag["PCM"] = 1] = "PCM";
    AudioFormatTag[AudioFormatTag["MuLaw"] = 2] = "MuLaw";
    AudioFormatTag[AudioFormatTag["Siren"] = 3] = "Siren";
    AudioFormatTag[AudioFormatTag["MP3"] = 4] = "MP3";
    AudioFormatTag[AudioFormatTag["SILKSkype"] = 5] = "SILKSkype";
    AudioFormatTag[AudioFormatTag["OGG_OPUS"] = 6] = "OGG_OPUS";
    AudioFormatTag[AudioFormatTag["WEBM_OPUS"] = 7] = "WEBM_OPUS";
    AudioFormatTag[AudioFormatTag["ALaw"] = 8] = "ALaw";
    AudioFormatTag[AudioFormatTag["FLAC"] = 9] = "FLAC";
    AudioFormatTag[AudioFormatTag["OPUS"] = 10] = "OPUS";
})(AudioFormatTag = exports.AudioFormatTag || (exports.AudioFormatTag = {}));
/**
 * Represents audio stream format used for custom audio input configurations.
 * @class AudioStreamFormat
 */ var AudioStreamFormat = /** @class */ function() {
    function AudioStreamFormat() {}
    /**
     * Creates an audio stream format object representing the default audio stream
     * format (16KHz 16bit mono PCM).
     * @member AudioStreamFormat.getDefaultInputFormat
     * @function
     * @public
     * @returns {AudioStreamFormat} The audio stream format being created.
     */ AudioStreamFormat.getDefaultInputFormat = function() {
        return AudioStreamFormatImpl.getDefaultInputFormat();
    };
    /**
     * Creates an audio stream format object with the specified format characteristics.
     * @member AudioStreamFormat.getWaveFormat
     * @function
     * @public
     * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
     * @param {number} bitsPerSample - Bits per sample, typically 16.
     * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
     * uses one channel and stereo data uses two channels.
     * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
     * @returns {AudioStreamFormat} The audio stream format being created.
     */ AudioStreamFormat.getWaveFormat = function(samplesPerSecond, bitsPerSample, channels, format) {
        return new AudioStreamFormatImpl(samplesPerSecond, bitsPerSample, channels, format);
    };
    /**
     * Creates an audio stream format object with the specified pcm waveformat characteristics.
     * @member AudioStreamFormat.getWaveFormatPCM
     * @function
     * @public
     * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
     * @param {number} bitsPerSample - Bits per sample, typically 16.
     * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
     * uses one channel and stereo data uses two channels.
     * @returns {AudioStreamFormat} The audio stream format being created.
     */ AudioStreamFormat.getWaveFormatPCM = function(samplesPerSecond, bitsPerSample, channels) {
        return new AudioStreamFormatImpl(samplesPerSecond, bitsPerSample, channels);
    };
    return AudioStreamFormat;
}();
exports.AudioStreamFormat = AudioStreamFormat;
/**
 * @private
 * @class AudioStreamFormatImpl
 */ var AudioStreamFormatImpl = /** @class */ function(_super) {
    __extends(AudioStreamFormatImpl, _super);
    /**
     * Creates an instance with the given values.
     * @constructor
     * @param {number} samplesPerSec - Samples per second.
     * @param {number} bitsPerSample - Bits per sample.
     * @param {number} channels - Number of channels.
     * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
     */ function AudioStreamFormatImpl(samplesPerSec, bitsPerSample, channels, format) {
        if (samplesPerSec === void 0) samplesPerSec = 16000;
        if (bitsPerSample === void 0) bitsPerSample = 16;
        if (channels === void 0) channels = 1;
        if (format === void 0) format = AudioFormatTag.PCM;
        var _this = _super.call(this) || this;
        var isWavFormat = true;
        /* 1 for PCM; 6 for alaw; 7 for mulaw */ switch(format){
            case AudioFormatTag.PCM:
                _this.formatTag = 1;
                break;
            case AudioFormatTag.ALaw:
                _this.formatTag = 6;
                break;
            case AudioFormatTag.MuLaw:
                _this.formatTag = 7;
                break;
            default:
                isWavFormat = false;
        }
        _this.bitsPerSample = bitsPerSample;
        _this.samplesPerSec = samplesPerSec;
        _this.channels = channels;
        _this.avgBytesPerSec = _this.samplesPerSec * _this.channels * (_this.bitsPerSample / 8);
        _this.blockAlign = _this.channels * Math.max(_this.bitsPerSample, 8);
        if (isWavFormat) {
            _this.privHeader = new ArrayBuffer(44);
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView
            var view = new DataView(_this.privHeader);
            /* RIFF identifier */ _this.setString(view, 0, "RIFF");
            /* file length */ view.setUint32(4, 0, true);
            /* RIFF type & Format */ _this.setString(view, 8, "WAVEfmt ");
            /* format chunk length */ view.setUint32(16, 16, true);
            /* audio format */ view.setUint16(20, _this.formatTag, true);
            /* channel count */ view.setUint16(22, _this.channels, true);
            /* sample rate */ view.setUint32(24, _this.samplesPerSec, true);
            /* byte rate (sample rate * block align) */ view.setUint32(28, _this.avgBytesPerSec, true);
            /* block align (channel count * bytes per sample) */ view.setUint16(32, _this.channels * (_this.bitsPerSample / 8), true);
            /* bits per sample */ view.setUint16(34, _this.bitsPerSample, true);
            /* data chunk identifier */ _this.setString(view, 36, "data");
            /* data chunk length */ view.setUint32(40, 0, true);
        }
        return _this;
    }
    /**
     * Retrieves the default input format.
     * @member AudioStreamFormatImpl.getDefaultInputFormat
     * @function
     * @public
     * @returns {AudioStreamFormatImpl} The default input format.
     */ AudioStreamFormatImpl.getDefaultInputFormat = function() {
        return new AudioStreamFormatImpl();
    };
    /**
     * Creates an audio context appropriate to current browser
     * @member AudioStreamFormatImpl.getAudioContext
     * @function
     * @public
     * @returns {AudioContext} An audio context instance
     */ /* eslint-disable */ AudioStreamFormatImpl.getAudioContext = function(sampleRate) {
        // Workaround for Speech SDK bug in Safari.
        var AudioContext = window.AudioContext // our preferred impl
         || window.webkitAudioContext // fallback, mostly when on Safari
         || false; // could not find.
        // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext
        if (!!AudioContext) {
            if (sampleRate !== undefined && navigator.mediaDevices.getSupportedConstraints().sampleRate) return new AudioContext({
                sampleRate: sampleRate
            });
            else return new AudioContext();
        } else throw new Error("Browser does not support Web Audio API (AudioContext is not available).");
    };
    /* eslint-enable */ /**
     * Closes the configuration object.
     * @member AudioStreamFormatImpl.prototype.close
     * @function
     * @public
     */ AudioStreamFormatImpl.prototype.close = function() {
        return;
    };
    Object.defineProperty(AudioStreamFormatImpl.prototype, "header", {
        get: function() {
            return this.privHeader;
        },
        enumerable: false,
        configurable: true
    });
    AudioStreamFormatImpl.prototype.setString = function(view, offset, str) {
        for(var i = 0; i < str.length; i++)view.setUint8(offset + i, str.charCodeAt(i));
    };
    return AudioStreamFormatImpl;
}(AudioStreamFormat);
exports.AudioStreamFormatImpl = AudioStreamFormatImpl;

},{}],"budsd":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PushAudioOutputStreamImpl = exports.PushAudioOutputStream = exports.PullAudioOutputStreamImpl = exports.PullAudioOutputStream = exports.AudioOutputStream = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("50ca48a04a9081c5");
var Contracts_1 = require("ae5ce87bc92b63e9");
var AudioOutputFormat_1 = require("5adc6a8bb5e1334e");
/**
 * Represents audio output stream used for custom audio output configurations.
 * @class AudioOutputStream
 */ var AudioOutputStream = /** @class */ function() {
    /**
     * Creates and initializes an instance.
     * @constructor
     */ function AudioOutputStream() {
        return;
    }
    /**
     * Creates a memory backed PullAudioOutputStream with the specified audio format.
     * @member AudioOutputStream.createPullStream
     * @function
     * @public
     * @returns {PullAudioOutputStream} The audio output stream being created.
     */ AudioOutputStream.createPullStream = function() {
        return PullAudioOutputStream.create();
    };
    return AudioOutputStream;
}();
exports.AudioOutputStream = AudioOutputStream;
/**
 * Represents memory backed push audio output stream used for custom audio output configurations.
 * @class PullAudioOutputStream
 */ var PullAudioOutputStream = /** @class */ function(_super) {
    __extends(PullAudioOutputStream, _super);
    function PullAudioOutputStream() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a memory backed PullAudioOutputStream with the specified audio format.
     * @member PullAudioOutputStream.create
     * @function
     * @public
     * @returns {PullAudioOutputStream} The push audio output stream being created.
     */ PullAudioOutputStream.create = function() {
        return new PullAudioOutputStreamImpl();
    };
    return PullAudioOutputStream;
}(AudioOutputStream);
exports.PullAudioOutputStream = PullAudioOutputStream;
/**
 * Represents memory backed push audio output stream used for custom audio output configurations.
 * @private
 * @class PullAudioOutputStreamImpl
 */ var PullAudioOutputStreamImpl = /** @class */ function(_super) {
    __extends(PullAudioOutputStreamImpl, _super);
    /**
     * Creates and initializes an instance with the given values.
     * @constructor
     */ function PullAudioOutputStreamImpl() {
        var _this = _super.call(this) || this;
        _this.privId = Exports_1.createNoDashGuid();
        _this.privStream = new Exports_1.Stream();
        return _this;
    }
    Object.defineProperty(PullAudioOutputStreamImpl.prototype, "format", {
        /**
         * Format information for the audio
         */ get: function() {
            return this.privFormat;
        },
        /**
         * Sets the format information to the stream. For internal use only.
         * @param {AudioStreamFormat} format - the format to be set.
         */ set: function(format) {
            if (format === undefined || format === null) this.privFormat = AudioOutputFormat_1.AudioOutputFormatImpl.getDefaultOutputFormat();
            this.privFormat = format;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PullAudioOutputStreamImpl.prototype, "isClosed", {
        /**
         * Checks if the stream is closed
         * @member PullAudioOutputStreamImpl.prototype.isClosed
         * @property
         * @public
         */ get: function() {
            return this.privStream.isClosed;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Gets the id of the stream
     * @member PullAudioOutputStreamImpl.prototype.id
     * @property
     * @public
     */ PullAudioOutputStreamImpl.prototype.id = function() {
        return this.privId;
    };
    /**
     * Reads audio data from the internal buffer.
     * @member PullAudioOutputStreamImpl.prototype.read
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - An ArrayBuffer to store the read data.
     * @returns {Promise<number>} - Audio buffer length has been read.
     */ PullAudioOutputStreamImpl.prototype.read = function(dataBuffer) {
        return __awaiter(this, void 0, void 0, function() {
            var intView, totalBytes, chunk, tmpBuffer;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        intView = new Int8Array(dataBuffer);
                        totalBytes = 0;
                        if (this.privLastChunkView !== undefined) {
                            if (this.privLastChunkView.length > dataBuffer.byteLength) {
                                intView.set(this.privLastChunkView.slice(0, dataBuffer.byteLength));
                                this.privLastChunkView = this.privLastChunkView.slice(dataBuffer.byteLength);
                                return [
                                    2 /*return*/ ,
                                    Promise.resolve(dataBuffer.byteLength)
                                ];
                            }
                            intView.set(this.privLastChunkView);
                            totalBytes = this.privLastChunkView.length;
                            this.privLastChunkView = undefined;
                        }
                        _a.label = 1;
                    case 1:
                        if (!(totalBytes < dataBuffer.byteLength && !this.privStream.isReadEnded)) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privStream.read()
                        ];
                    case 2:
                        chunk = _a.sent();
                        if (chunk !== undefined && !chunk.isEnd) {
                            tmpBuffer = void 0;
                            if (chunk.buffer.byteLength > dataBuffer.byteLength - totalBytes) {
                                tmpBuffer = chunk.buffer.slice(0, dataBuffer.byteLength - totalBytes);
                                this.privLastChunkView = new Int8Array(chunk.buffer.slice(dataBuffer.byteLength - totalBytes));
                            } else tmpBuffer = chunk.buffer;
                            intView.set(new Int8Array(tmpBuffer), totalBytes);
                            totalBytes += tmpBuffer.byteLength;
                        } else this.privStream.readEnded();
                        return [
                            3 /*break*/ ,
                            1
                        ];
                    case 3:
                        return [
                            2 /*return*/ ,
                            totalBytes
                        ];
                }
            });
        });
    };
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PullAudioOutputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */ PullAudioOutputStreamImpl.prototype.write = function(dataBuffer) {
        Contracts_1.Contracts.throwIfNullOrUndefined(this.privStream, "must set format before writing");
        this.privStream.writeStreamChunk({
            buffer: dataBuffer,
            isEnd: false,
            timeReceived: Date.now()
        });
    };
    /**
     * Closes the stream.
     * @member PullAudioOutputStreamImpl.prototype.close
     * @function
     * @public
     */ PullAudioOutputStreamImpl.prototype.close = function() {
        this.privStream.close();
    };
    return PullAudioOutputStreamImpl;
}(PullAudioOutputStream);
exports.PullAudioOutputStreamImpl = PullAudioOutputStreamImpl;
/*
 * Represents audio output stream used for custom audio output configurations.
 * @class PushAudioOutputStream
 */ var PushAudioOutputStream = /** @class */ function(_super) {
    __extends(PushAudioOutputStream, _super);
    /**
     * Creates and initializes and instance.
     * @constructor
     */ function PushAudioOutputStream() {
        return _super.call(this) || this;
    }
    /**
     * Creates a PushAudioOutputStream that delegates to the specified callback interface for
     * write() and close() methods.
     * @member PushAudioOutputStream.create
     * @function
     * @public
     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
     * derived from PushAudioOutputStreamCallback
     * @returns {PushAudioOutputStream} The push audio output stream being created.
     */ PushAudioOutputStream.create = function(callback) {
        return new PushAudioOutputStreamImpl(callback);
    };
    return PushAudioOutputStream;
}(AudioOutputStream);
exports.PushAudioOutputStream = PushAudioOutputStream;
/**
 * Represents audio output stream used for custom audio output configurations.
 * @private
 * @class PushAudioOutputStreamImpl
 */ var PushAudioOutputStreamImpl = /** @class */ function(_super) {
    __extends(PushAudioOutputStreamImpl, _super);
    /**
     * Creates a PushAudioOutputStream that delegates to the specified callback interface for
     * read() and close() methods.
     * @constructor
     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
     * derived from PushAudioOutputStreamCallback
     */ function PushAudioOutputStreamImpl(callback) {
        var _this = _super.call(this) || this;
        _this.privId = Exports_1.createNoDashGuid();
        _this.privCallback = callback;
        return _this;
    }
    Object.defineProperty(PushAudioOutputStreamImpl.prototype, "format", {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        set: function(format) {},
        enumerable: false,
        configurable: true
    });
    PushAudioOutputStreamImpl.prototype.write = function(buffer) {
        if (!!this.privCallback.write) this.privCallback.write(buffer);
    };
    PushAudioOutputStreamImpl.prototype.close = function() {
        if (!!this.privCallback.close) this.privCallback.close();
    };
    PushAudioOutputStreamImpl.prototype.id = function() {
        return this.privId;
    };
    return PushAudioOutputStreamImpl;
}(PushAudioOutputStream);
exports.PushAudioOutputStreamImpl = PushAudioOutputStreamImpl;

},{"50ca48a04a9081c5":"5Bedw","ae5ce87bc92b63e9":"4jwu5","5adc6a8bb5e1334e":"lrOQK"}],"lrOQK":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AudioOutputFormatImpl = void 0;
var SpeechSynthesisOutputFormat_1 = require("326f89ae70497d3a");
var AudioStreamFormat_1 = require("b509e7d1aef620d9");
/**
 * @private
 * @class AudioOutputFormatImpl
 * Updated in version 1.17.0
 */ // eslint-disable-next-line max-classes-per-file
var AudioOutputFormatImpl = /** @class */ function(_super) {
    __extends(AudioOutputFormatImpl, _super);
    /**
     * Creates an instance with the given values.
     * @constructor
     * @param formatTag
     * @param {number} channels - Number of channels.
     * @param {number} samplesPerSec - Samples per second.
     * @param {number} avgBytesPerSec - Average bytes per second.
     * @param {number} blockAlign - Block alignment.
     * @param {number} bitsPerSample - Bits per sample.
     * @param {string} audioFormatString - Audio format string
     * @param {string} requestAudioFormatString - Audio format string sent to service.
     * @param {boolean} hasHeader - If the format has header or not.
     */ function AudioOutputFormatImpl(formatTag, channels, samplesPerSec, avgBytesPerSec, blockAlign, bitsPerSample, audioFormatString, requestAudioFormatString, hasHeader) {
        var _this = _super.call(this, samplesPerSec, bitsPerSample, channels, formatTag) || this;
        _this.formatTag = formatTag;
        _this.avgBytesPerSec = avgBytesPerSec;
        _this.blockAlign = blockAlign;
        _this.priAudioFormatString = audioFormatString;
        _this.priRequestAudioFormatString = requestAudioFormatString;
        _this.priHasHeader = hasHeader;
        return _this;
    }
    AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat = function(speechSynthesisOutputFormat) {
        if (speechSynthesisOutputFormat === undefined) return AudioOutputFormatImpl.getDefaultOutputFormat();
        return AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(AudioOutputFormatImpl.SpeechSynthesisOutputFormatToString[speechSynthesisOutputFormat]);
    };
    AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString = function(speechSynthesisOutputFormatString) {
        switch(speechSynthesisOutputFormatString){
            case "raw-8khz-8bit-mono-mulaw":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.MuLaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "riff-16khz-16kbps-mono-siren":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.Siren, 1, 16000, 2000, 40, 0, speechSynthesisOutputFormatString, "audio-16khz-16kbps-mono-siren", true);
            case "audio-16khz-16kbps-mono-siren":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.Siren, 1, 16000, 2000, 40, 0, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-16khz-32kbitrate-mono-mp3":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.MP3, 1, 16000, 4096, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-16khz-128kbitrate-mono-mp3":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.MP3, 1, 16000, 16384, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-16khz-64kbitrate-mono-mp3":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.MP3, 1, 16000, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-24khz-48kbitrate-mono-mp3":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.MP3, 1, 24000, 6144, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-24khz-96kbitrate-mono-mp3":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.MP3, 1, 24000, 12288, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-24khz-160kbitrate-mono-mp3":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.MP3, 1, 24000, 20480, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "raw-16khz-16bit-mono-truesilk":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.SILKSkype, 1, 16000, 32000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "riff-8khz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 8000, 16000, 2, 16, speechSynthesisOutputFormatString, "raw-8khz-16bit-mono-pcm", true);
            case "riff-24khz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 24000, 48000, 2, 16, speechSynthesisOutputFormatString, "raw-24khz-16bit-mono-pcm", true);
            case "riff-8khz-8bit-mono-mulaw":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.MuLaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, "raw-8khz-8bit-mono-mulaw", true);
            case "raw-16khz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 16000, 32000, 2, 16, speechSynthesisOutputFormatString, "raw-16khz-16bit-mono-pcm", false);
            case "raw-24khz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 24000, 48000, 2, 16, speechSynthesisOutputFormatString, "raw-24khz-16bit-mono-pcm", false);
            case "raw-8khz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 8000, 16000, 2, 16, speechSynthesisOutputFormatString, "raw-8khz-16bit-mono-pcm", false);
            case "ogg-16khz-16bit-mono-opus":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.OGG_OPUS, 1, 16000, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "ogg-24khz-16bit-mono-opus":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.OGG_OPUS, 1, 24000, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "raw-48khz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 48000, 96000, 2, 16, speechSynthesisOutputFormatString, "raw-48khz-16bit-mono-pcm", false);
            case "riff-48khz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 48000, 96000, 2, 16, speechSynthesisOutputFormatString, "raw-48khz-16bit-mono-pcm", true);
            case "audio-48khz-96kbitrate-mono-mp3":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.MP3, 1, 48000, 12288, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-48khz-192kbitrate-mono-mp3":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.MP3, 1, 48000, 24576, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "ogg-48khz-16bit-mono-opus":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.OGG_OPUS, 1, 48000, 12000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "webm-16khz-16bit-mono-opus":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.WEBM_OPUS, 1, 16000, 4000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "webm-24khz-16bit-mono-opus":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.WEBM_OPUS, 1, 24000, 6000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "webm-24khz-16bit-24kbps-mono-opus":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.WEBM_OPUS, 1, 24000, 3000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-16khz-16bit-32kbps-mono-opus":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.OPUS, 1, 16000, 4000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-24khz-16bit-48kbps-mono-opus":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.OPUS, 1, 24000, 6000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-24khz-16bit-24kbps-mono-opus":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.OPUS, 1, 24000, 3000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-24khz-16bit-mono-flac":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.FLAC, 1, 24000, 24000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "audio-48khz-16bit-mono-flac":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.FLAC, 1, 48000, 30000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "raw-24khz-16bit-mono-truesilk":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.SILKSkype, 1, 24000, 48000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "raw-8khz-8bit-mono-alaw":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.ALaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "riff-8khz-8bit-mono-alaw":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.ALaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, "raw-8khz-8bit-mono-alaw", true);
            case "raw-22050hz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "riff-22050hz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, speechSynthesisOutputFormatString, "raw-22050hz-16bit-mono-pcm", true);
            case "raw-44100hz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
            case "riff-44100hz-16bit-mono-pcm":
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, speechSynthesisOutputFormatString, "raw-44100hz-16bit-mono-pcm", true);
            case "riff-16khz-16bit-mono-pcm":
            default:
                return new AudioOutputFormatImpl(AudioStreamFormat_1.AudioFormatTag.PCM, 1, 16000, 32000, 2, 16, "riff-16khz-16bit-mono-pcm", "raw-16khz-16bit-mono-pcm", true);
        }
    };
    AudioOutputFormatImpl.getDefaultOutputFormat = function() {
        return AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(typeof window !== "undefined" ? "audio-24khz-48kbitrate-mono-mp3" : "riff-16khz-16bit-mono-pcm");
    };
    Object.defineProperty(AudioOutputFormatImpl.prototype, "hasHeader", {
        /**
         * Specifies if this audio output format has a header
         * @boolean AudioOutputFormatImpl.prototype.hasHeader
         * @function
         * @public
         */ get: function() {
            return this.priHasHeader;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AudioOutputFormatImpl.prototype, "header", {
        /**
         * Specifies the header of this format
         * @ArrayBuffer AudioOutputFormatImpl.prototype.header
         * @function
         * @public
         */ get: function() {
            if (this.hasHeader) return this.privHeader;
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Updates the header based on the audio length
     * @member AudioOutputFormatImpl.updateHeader
     * @function
     * @public
     * @param {number} audioLength - the audio length
     */ AudioOutputFormatImpl.prototype.updateHeader = function(audioLength) {
        if (this.priHasHeader) {
            var view = new DataView(this.privHeader);
            view.setUint32(4, audioLength + this.privHeader.byteLength - 8, true);
            view.setUint32(40, audioLength, true);
        }
    };
    Object.defineProperty(AudioOutputFormatImpl.prototype, "requestAudioFormatString", {
        /**
         * Specifies the audio format string to be sent to the service
         * @string AudioOutputFormatImpl.prototype.requestAudioFormatString
         * @function
         * @public
         */ get: function() {
            return this.priRequestAudioFormatString;
        },
        enumerable: false,
        configurable: true
    });
    AudioOutputFormatImpl.SpeechSynthesisOutputFormatToString = (_a = {}, _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw] = "raw-8khz-8bit-mono-mulaw", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren] = "riff-16khz-16kbps-mono-siren", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren] = "audio-16khz-16kbps-mono-siren", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3] = "audio-16khz-32kbitrate-mono-mp3", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3] = "audio-16khz-128kbitrate-mono-mp3", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3] = "audio-16khz-64kbitrate-mono-mp3", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3] = "audio-24khz-48kbitrate-mono-mp3", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3] = "audio-24khz-96kbitrate-mono-mp3", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3] = "audio-24khz-160kbitrate-mono-mp3", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk] = "raw-16khz-16bit-mono-truesilk", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm] = "riff-16khz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm] = "riff-8khz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm] = "riff-24khz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw] = "riff-8khz-8bit-mono-mulaw", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm] = "raw-16khz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm] = "raw-24khz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm] = "raw-8khz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus] = "ogg-16khz-16bit-mono-opus", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus] = "ogg-24khz-16bit-mono-opus", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm] = "raw-48khz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm] = "riff-48khz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3] = "audio-48khz-96kbitrate-mono-mp3", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3] = "audio-48khz-192kbitrate-mono-mp3", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus] = "ogg-48khz-16bit-mono-opus", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus] = "webm-16khz-16bit-mono-opus", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus] = "webm-24khz-16bit-mono-opus", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus] = "webm-24khz-16bit-24kbps-mono-opus", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk] = "raw-24khz-16bit-mono-truesilk", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw] = "raw-8khz-8bit-mono-alaw", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw] = "riff-8khz-8bit-mono-alaw", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus] = "audio-16khz-16bit-32kbps-mono-opus", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus] = "audio-24khz-16bit-48kbps-mono-opus", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus] = "audio-24khz-16bit-24kbps-mono-opus", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm] = "raw-22050hz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm] = "riff-22050hz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm] = "raw-44100hz-16bit-mono-pcm", _a[SpeechSynthesisOutputFormat_1.SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm] = "riff-44100hz-16bit-mono-pcm", _a);
    return AudioOutputFormatImpl;
}(AudioStreamFormat_1.AudioStreamFormatImpl);
exports.AudioOutputFormatImpl = AudioOutputFormatImpl;

},{"326f89ae70497d3a":"6ejj7","b509e7d1aef620d9":"8hTlD"}],"6ejj7":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechSynthesisOutputFormat = void 0;
/**
 * Define speech synthesis audio output formats.
 * @enum SpeechSynthesisOutputFormat
 * Updated in version 1.17.0
 */ var SpeechSynthesisOutputFormat;
(function(SpeechSynthesisOutputFormat) {
    /**
     * raw-8khz-8bit-mono-mulaw
     * @member SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw,
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw8Khz8BitMonoMULaw"] = 0] = "Raw8Khz8BitMonoMULaw";
    /**
     * riff-16khz-16kbps-mono-siren
     * @note Unsupported by the service. Do not use this value.
     * @member SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff16Khz16KbpsMonoSiren"] = 1] = "Riff16Khz16KbpsMonoSiren";
    /**
     * audio-16khz-16kbps-mono-siren
     * @note Unsupported by the service. Do not use this value.
     * @member SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio16Khz16KbpsMonoSiren"] = 2] = "Audio16Khz16KbpsMonoSiren";
    /**
     * audio-16khz-32kbitrate-mono-mp3
     * @member SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio16Khz32KBitRateMonoMp3"] = 3] = "Audio16Khz32KBitRateMonoMp3";
    /**
     * audio-16khz-128kbitrate-mono-mp3
     * @member SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio16Khz128KBitRateMonoMp3"] = 4] = "Audio16Khz128KBitRateMonoMp3";
    /**
     * audio-16khz-64kbitrate-mono-mp3
     * @member SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio16Khz64KBitRateMonoMp3"] = 5] = "Audio16Khz64KBitRateMonoMp3";
    /**
     * audio-24khz-48kbitrate-mono-mp3
     * @member SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio24Khz48KBitRateMonoMp3"] = 6] = "Audio24Khz48KBitRateMonoMp3";
    /**
     * audio-24khz-96kbitrate-mono-mp3
     * @member SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio24Khz96KBitRateMonoMp3"] = 7] = "Audio24Khz96KBitRateMonoMp3";
    /**
     * audio-24khz-160kbitrate-mono-mp3
     * @member SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio24Khz160KBitRateMonoMp3"] = 8] = "Audio24Khz160KBitRateMonoMp3";
    /**
     * raw-16khz-16bit-mono-truesilk
     * @member SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw16Khz16BitMonoTrueSilk"] = 9] = "Raw16Khz16BitMonoTrueSilk";
    /**
     * riff-16khz-16bit-mono-pcm
     * @member SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff16Khz16BitMonoPcm"] = 10] = "Riff16Khz16BitMonoPcm";
    /**
     * riff-8khz-16bit-mono-pcm
     * @member SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff8Khz16BitMonoPcm"] = 11] = "Riff8Khz16BitMonoPcm";
    /**
     * riff-24khz-16bit-mono-pcm
     * @member SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff24Khz16BitMonoPcm"] = 12] = "Riff24Khz16BitMonoPcm";
    /**
     * riff-8khz-8bit-mono-mulaw
     * @member SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff8Khz8BitMonoMULaw"] = 13] = "Riff8Khz8BitMonoMULaw";
    /**
     * raw-16khz-16bit-mono-pcm
     * @member SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw16Khz16BitMonoPcm"] = 14] = "Raw16Khz16BitMonoPcm";
    /**
     * raw-24khz-16bit-mono-pcm
     * @member SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw24Khz16BitMonoPcm"] = 15] = "Raw24Khz16BitMonoPcm";
    /**
     * raw-8khz-16bit-mono-pcm
     * @member SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw8Khz16BitMonoPcm"] = 16] = "Raw8Khz16BitMonoPcm";
    /**
     * ogg-16khz-16bit-mono-opus
     * @member SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Ogg16Khz16BitMonoOpus"] = 17] = "Ogg16Khz16BitMonoOpus";
    /**
     * ogg-24khz-16bit-mono-opus
     * @member SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Ogg24Khz16BitMonoOpus"] = 18] = "Ogg24Khz16BitMonoOpus";
    /**
     * raw-48khz-16bit-mono-pcm
     * @member SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw48Khz16BitMonoPcm"] = 19] = "Raw48Khz16BitMonoPcm";
    /**
     * riff-48khz-16bit-mono-pcm
     * @member SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff48Khz16BitMonoPcm"] = 20] = "Riff48Khz16BitMonoPcm";
    /**
     * audio-48khz-96kbitrate-mono-mp3
     * @member SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio48Khz96KBitRateMonoMp3"] = 21] = "Audio48Khz96KBitRateMonoMp3";
    /**
     * audio-48khz-192kbitrate-mono-mp3
     * @member SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio48Khz192KBitRateMonoMp3"] = 22] = "Audio48Khz192KBitRateMonoMp3";
    /**
     * ogg-48khz-16bit-mono-opus
     * Added in version 1.16.0
     * @member SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Ogg48Khz16BitMonoOpus"] = 23] = "Ogg48Khz16BitMonoOpus";
    /**
     * webm-16khz-16bit-mono-opus
     * Added in version 1.16.0
     * @member SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Webm16Khz16BitMonoOpus"] = 24] = "Webm16Khz16BitMonoOpus";
    /**
     * webm-24khz-16bit-mono-opus
     * Added in version 1.16.0
     * @member SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Webm24Khz16BitMonoOpus"] = 25] = "Webm24Khz16BitMonoOpus";
    /**
     * raw-24khz-16bit-mono-truesilk
     * Added in version 1.17.0
     * @member SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw24Khz16BitMonoTrueSilk"] = 26] = "Raw24Khz16BitMonoTrueSilk";
    /**
     * raw-8khz-8bit-mono-alaw
     * Added in version 1.17.0
     * @member SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw8Khz8BitMonoALaw"] = 27] = "Raw8Khz8BitMonoALaw";
    /**
     * riff-8khz-8bit-mono-alaw
     * Added in version 1.17.0
     * @member SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff8Khz8BitMonoALaw"] = 28] = "Riff8Khz8BitMonoALaw";
    /**
     * webm-24khz-16bit-24kbps-mono-opus
     * Audio compressed by OPUS codec in a webm container, with bitrate of 24kbps, optimized for IoT scenario.
     * Added in version 1.19.0
     * @member SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Webm24Khz16Bit24KbpsMonoOpus"] = 29] = "Webm24Khz16Bit24KbpsMonoOpus";
    /**
     * audio-16khz-16bit-32kbps-mono-opus
     * Audio compressed by OPUS codec without container, with bitrate of 32kbps.
     * Added in version 1.20.0
     * @member SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio16Khz16Bit32KbpsMonoOpus"] = 30] = "Audio16Khz16Bit32KbpsMonoOpus";
    /**
     * audio-24khz-16bit-48kbps-mono-opus
     * Audio compressed by OPUS codec without container, with bitrate of 48kbps.
     * Added in version 1.20.0
     * @member SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio24Khz16Bit48KbpsMonoOpus"] = 31] = "Audio24Khz16Bit48KbpsMonoOpus";
    /**
     * audio-24khz-16bit-24kbps-mono-opus
     * Audio compressed by OPUS codec without container, with bitrate of 24kbps.
     * Added in version 1.20.0
     * @member SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio24Khz16Bit24KbpsMonoOpus"] = 32] = "Audio24Khz16Bit24KbpsMonoOpus";
    /**
     * raw-22050hz-16bit-mono-pcm
     * Raw PCM audio at 22050Hz sampling rate and 16-bit depth.
     * Added in version 1.22.0
     * @member SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw22050Hz16BitMonoPcm"] = 33] = "Raw22050Hz16BitMonoPcm";
    /**
     * riff-22050hz-16bit-mono-pcm
     * PCM audio at 22050Hz sampling rate and 16-bit depth, with RIFF header.
     * Added in version 1.22.0
     * @member SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff22050Hz16BitMonoPcm"] = 34] = "Riff22050Hz16BitMonoPcm";
    /**
     * raw-44100hz-16bit-mono-pcm
     * Raw PCM audio at 44100Hz sampling rate and 16-bit depth.
     * Added in version 1.22.0
     * @member SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw44100Hz16BitMonoPcm"] = 35] = "Raw44100Hz16BitMonoPcm";
    /**
     * riff-44100hz-16bit-mono-pcm
     * PCM audio at 44100Hz sampling rate and 16-bit depth, with RIFF header.
     * Added in version 1.22.0
     * @member SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm
     */ SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff44100Hz16BitMonoPcm"] = 36] = "Riff44100Hz16BitMonoPcm";
})(SpeechSynthesisOutputFormat = exports.SpeechSynthesisOutputFormat || (exports.SpeechSynthesisOutputFormat = {}));

},{}],"5OehU":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CancellationReason = void 0;
/**
 * Defines the possible reasons a recognition result might be canceled.
 * @class CancellationReason
 */ var CancellationReason;
(function(CancellationReason) {
    /**
     * Indicates that an error occurred during speech recognition.
     * @member CancellationReason.Error
     */ CancellationReason[CancellationReason["Error"] = 0] = "Error";
    /**
     * Indicates that the end of the audio stream was reached.
     * @member CancellationReason.EndOfStream
     */ CancellationReason[CancellationReason["EndOfStream"] = 1] = "EndOfStream";
})(CancellationReason = exports.CancellationReason || (exports.CancellationReason = {}));

},{}],"eCjma":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PullAudioInputStreamCallback = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/**
 * An abstract base class that defines callback methods (read() and close()) for
 * custom audio input streams).
 * @class PullAudioInputStreamCallback
 */ var PullAudioInputStreamCallback = /** @class */ function() {
    function PullAudioInputStreamCallback() {}
    return PullAudioInputStreamCallback;
}();
exports.PullAudioInputStreamCallback = PullAudioInputStreamCallback;

},{}],"aVqBm":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PushAudioOutputStreamCallback = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/**
 * An abstract base class that defines callback methods (write() and close()) for
 * custom audio output streams).
 * @class PushAudioOutputStreamCallback
 */ var PushAudioOutputStreamCallback = /** @class */ function() {
    function PushAudioOutputStreamCallback() {}
    return PushAudioOutputStreamCallback;
}();
exports.PushAudioOutputStreamCallback = PushAudioOutputStreamCallback;

},{}],"hsmdR":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KeywordRecognitionModel = void 0;
var Contracts_1 = require("2d643e5938853940");
/**
 * Represents a keyword recognition model for recognizing when
 * the user says a keyword to initiate further speech recognition.
 * @class KeywordRecognitionModel
 */ var KeywordRecognitionModel = /** @class */ function() {
    /**
     * Create and initializes a new instance.
     * @constructor
     */ function KeywordRecognitionModel() {
        this.privDisposed = false;
        return;
    }
    /**
     * Creates a keyword recognition model using the specified filename.
     * @member KeywordRecognitionModel.fromFile
     * @function
     * @public
     * @param {string} fileName - A string that represents file name for the keyword recognition model.
     * Note, the file can point to a zip file in which case the model
     * will be extracted from the zip.
     * @returns {KeywordRecognitionModel} The keyword recognition model being created.
     */ KeywordRecognitionModel.fromFile = function(fileName) {
        Contracts_1.Contracts.throwIfFileDoesNotExist(fileName, "fileName");
        throw new Error("Not yet implemented.");
    };
    /**
     * Creates a keyword recognition model using the specified filename.
     * @member KeywordRecognitionModel.fromStream
     * @function
     * @public
     * @param {string} file - A File that represents file for the keyword recognition model.
     * Note, the file can point to a zip file in which case the model will be extracted from the zip.
     * @returns {KeywordRecognitionModel} The keyword recognition model being created.
     */ KeywordRecognitionModel.fromStream = function(file) {
        Contracts_1.Contracts.throwIfNull(file, "file");
        throw new Error("Not yet implemented.");
    };
    /**
     * Dispose of associated resources.
     * @member KeywordRecognitionModel.prototype.close
     * @function
     * @public
     */ KeywordRecognitionModel.prototype.close = function() {
        if (this.privDisposed) return;
        this.privDisposed = true;
    };
    return KeywordRecognitionModel;
}();
exports.KeywordRecognitionModel = KeywordRecognitionModel;

},{"2d643e5938853940":"4jwu5"}],"fxJH6":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SessionEventArgs = void 0;
/**
 * Defines content for session events like SessionStarted/Stopped, SoundStarted/Stopped.
 * @class SessionEventArgs
 */ var SessionEventArgs = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} sessionId - The session id.
     */ function SessionEventArgs(sessionId) {
        this.privSessionId = sessionId;
    }
    Object.defineProperty(SessionEventArgs.prototype, "sessionId", {
        /**
         * Represents the session identifier.
         * @member SessionEventArgs.prototype.sessionId
         * @function
         * @public
         * @returns {string} Represents the session identifier.
         */ get: function() {
            return this.privSessionId;
        },
        enumerable: false,
        configurable: true
    });
    return SessionEventArgs;
}();
exports.SessionEventArgs = SessionEventArgs;

},{}],"4D5lW":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecognitionEventArgs = void 0;
var Exports_1 = require("d3ded2962d3006a0");
/**
 * Defines payload for session events like Speech Start/End Detected
 * @class
 */ var RecognitionEventArgs = /** @class */ function(_super) {
    __extends(RecognitionEventArgs, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */ function RecognitionEventArgs(offset, sessionId) {
        var _this = _super.call(this, sessionId) || this;
        _this.privOffset = offset;
        return _this;
    }
    Object.defineProperty(RecognitionEventArgs.prototype, "offset", {
        /**
         * Represents the message offset
         * @member RecognitionEventArgs.prototype.offset
         * @function
         * @public
         */ get: function() {
            return this.privOffset;
        },
        enumerable: false,
        configurable: true
    });
    return RecognitionEventArgs;
}(Exports_1.SessionEventArgs);
exports.RecognitionEventArgs = RecognitionEventArgs;

},{"d3ded2962d3006a0":"hxkc3"}],"03ptH":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OutputFormat = void 0;
/**
 * Define Speech Recognizer output formats.
 * @class OutputFormat
 */ var OutputFormat;
(function(OutputFormat) {
    /**
     * @member OutputFormat.Simple
     */ OutputFormat[OutputFormat["Simple"] = 0] = "Simple";
    /**
     * @member OutputFormat.Detailed
     */ OutputFormat[OutputFormat["Detailed"] = 1] = "Detailed";
})(OutputFormat = exports.OutputFormat || (exports.OutputFormat = {}));

},{}],"bhX5f":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntentRecognitionEventArgs = void 0;
var Exports_1 = require("a31fbf54386de6dc");
/**
 * Intent recognition result event arguments.
 * @class
 */ var IntentRecognitionEventArgs = /** @class */ function(_super) {
    __extends(IntentRecognitionEventArgs, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param result - The result of the intent recognition.
     * @param offset - The offset.
     * @param sessionId - The session id.
     */ function IntentRecognitionEventArgs(result, offset, sessionId) {
        var _this = _super.call(this, offset, sessionId) || this;
        _this.privResult = result;
        return _this;
    }
    Object.defineProperty(IntentRecognitionEventArgs.prototype, "result", {
        /**
         * Represents the intent recognition result.
         * @member IntentRecognitionEventArgs.prototype.result
         * @function
         * @public
         * @returns {IntentRecognitionResult} Represents the intent recognition result.
         */ get: function() {
            return this.privResult;
        },
        enumerable: false,
        configurable: true
    });
    return IntentRecognitionEventArgs;
}(Exports_1.RecognitionEventArgs);
exports.IntentRecognitionEventArgs = IntentRecognitionEventArgs;

},{"a31fbf54386de6dc":"hxkc3"}],"fSJf9":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecognitionResult = void 0;
/**
 * Defines result of speech recognition.
 * @class RecognitionResult
 */ var RecognitionResult = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */ function RecognitionResult(resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {
        this.privResultId = resultId;
        this.privReason = reason;
        this.privText = text;
        this.privDuration = duration;
        this.privOffset = offset;
        this.privLanguage = language;
        this.privLanguageDetectionConfidence = languageDetectionConfidence;
        this.privErrorDetails = errorDetails;
        this.privJson = json;
        this.privProperties = properties;
    }
    Object.defineProperty(RecognitionResult.prototype, "resultId", {
        /**
         * Specifies the result identifier.
         * @member RecognitionResult.prototype.resultId
         * @function
         * @public
         * @returns {string} Specifies the result identifier.
         */ get: function() {
            return this.privResultId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionResult.prototype, "reason", {
        /**
         * Specifies status of the result.
         * @member RecognitionResult.prototype.reason
         * @function
         * @public
         * @returns {ResultReason} Specifies status of the result.
         */ get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionResult.prototype, "text", {
        /**
         * Presents the recognized text in the result.
         * @member RecognitionResult.prototype.text
         * @function
         * @public
         * @returns {string} Presents the recognized text in the result.
         */ get: function() {
            return this.privText;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionResult.prototype, "duration", {
        /**
         * Duration of recognized speech in 100 nano second increments.
         * @member RecognitionResult.prototype.duration
         * @function
         * @public
         * @returns {number} Duration of recognized speech in 100 nano second increments.
         */ get: function() {
            return this.privDuration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionResult.prototype, "offset", {
        /**
         * Offset of recognized speech in 100 nano second increments.
         * @member RecognitionResult.prototype.offset
         * @function
         * @public
         * @returns {number} Offset of recognized speech in 100 nano second increments.
         */ get: function() {
            return this.privOffset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionResult.prototype, "language", {
        /**
         * Primary Language detected.
         * @member RecognitionResult.prototype.language
         * @function
         * @public
         * @returns {string} language detected.
         */ get: function() {
            return this.privLanguage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionResult.prototype, "languageDetectionConfidence", {
        /**
         * Primary Language detection confidence (Unknown, Low, Medium, High).
         * @member RecognitionResult.prototype.languageDetectionConfidence
         * @function
         * @public
         * @returns {string} detection confidence strength.
         */ get: function() {
            return this.privLanguageDetectionConfidence;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionResult.prototype, "errorDetails", {
        /**
         * In case of an unsuccessful recognition, provides details of the occurred error.
         * @member RecognitionResult.prototype.errorDetails
         * @function
         * @public
         * @returns {string} a brief description of an error.
         */ get: function() {
            return this.privErrorDetails;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionResult.prototype, "json", {
        /**
         * A string containing Json serialized recognition result as it was received from the service.
         * @member RecognitionResult.prototype.json
         * @function
         * @private
         * @returns {string} Json serialized representation of the result.
         */ get: function() {
            return this.privJson;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionResult.prototype, "properties", {
        /**
         * The set of properties exposed in the result.
         * @member RecognitionResult.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The set of properties exposed in the result.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    return RecognitionResult;
}();
exports.RecognitionResult = RecognitionResult;

},{}],"8mOF8":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechRecognitionResult = void 0;
var Exports_1 = require("849e4f782a732ab4");
/**
 * Defines result of speech recognition.
 * @class SpeechRecognitionResult
 */ var SpeechRecognitionResult = /** @class */ function(_super) {
    __extends(SpeechRecognitionResult, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription, if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */ function SpeechRecognitionResult(resultId, reason, text, duration, offset, language, languageDetectionConfidence, speakerId, errorDetails, json, properties) {
        var _this = _super.call(this, resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) || this;
        _this.privSpeakerId = speakerId;
        return _this;
    }
    Object.defineProperty(SpeechRecognitionResult.prototype, "speakerId", {
        /**
         * speaker id from conversation transcription/id scenarios
         * @member SpeechRecognitionResult.prototype.speakerId
         * @function
         * @public
         * @returns {string} id of speaker in given result
         */ get: function() {
            return this.privSpeakerId;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechRecognitionResult;
}(Exports_1.RecognitionResult);
exports.SpeechRecognitionResult = SpeechRecognitionResult;

},{"849e4f782a732ab4":"hxkc3"}],"92lob":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntentRecognitionResult = void 0;
var Exports_1 = require("d03255e01c9c58c7");
/**
 * Intent recognition result.
 * @class
 */ var IntentRecognitionResult = /** @class */ function(_super) {
    __extends(IntentRecognitionResult, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param intentId - The intent id.
     * @param resultId - The result id.
     * @param reason - The reason.
     * @param text - The recognized text.
     * @param duration - The duration.
     * @param offset - The offset into the stream.
     * @param language - Primary Language detected, if provided.
     * @param languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param errorDetails - Error details, if provided.
     * @param json - Additional Json, if provided.
     * @param properties - Additional properties, if provided.
     */ function IntentRecognitionResult(intentId, resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {
        var _this = _super.call(this, resultId, reason, text, duration, offset, language, languageDetectionConfidence, undefined, errorDetails, json, properties) || this;
        _this.privIntentId = intentId;
        return _this;
    }
    Object.defineProperty(IntentRecognitionResult.prototype, "intentId", {
        /**
         * A String that represents the intent identifier being recognized.
         * @member IntentRecognitionResult.prototype.intentId
         * @function
         * @public
         * @returns {string} A String that represents the intent identifier being recognized.
         */ get: function() {
            return this.privIntentId;
        },
        enumerable: false,
        configurable: true
    });
    return IntentRecognitionResult;
}(Exports_1.SpeechRecognitionResult);
exports.IntentRecognitionResult = IntentRecognitionResult;

},{"d03255e01c9c58c7":"hxkc3"}],"6y7mJ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LanguageUnderstandingModelImpl = exports.LanguageUnderstandingModel = void 0;
// eslint-disable-next-line max-classes-per-file
var Contracts_1 = require("9008580e48d89ad");
/**
 * Language understanding model
 * @class LanguageUnderstandingModel
 */ var LanguageUnderstandingModel = /** @class */ function() {
    /**
     * Creates and initializes a new instance
     * @constructor
     */ function LanguageUnderstandingModel() {
        return;
    }
    /**
     * Creates an language understanding model using the specified endpoint.
     * @member LanguageUnderstandingModel.fromEndpoint
     * @function
     * @public
     * @param {URL} uri - A String that represents the endpoint of the language understanding model.
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */ LanguageUnderstandingModel.fromEndpoint = function(uri) {
        Contracts_1.Contracts.throwIfNull(uri, "uri");
        Contracts_1.Contracts.throwIfNullOrWhitespace(uri.hostname, "uri");
        var langModelImp = new LanguageUnderstandingModelImpl();
        // Need to extract the app ID from the URL.
        // URL is in the format: https://<region>.api.cognitive.microsoft.com/luis/v2.0/apps/<Guid>?subscription-key=<key>&timezoneOffset=-360
        // Start tearing the string apart.
        // region can be extracted from the host name.
        var firstDot = uri.host.indexOf(".");
        if (-1 === firstDot) throw new Error("Could not determine region from endpoint");
        langModelImp.region = uri.host.substr(0, firstDot);
        // Now the app ID.
        var lastSegment = uri.pathname.lastIndexOf("/") + 1;
        if (-1 === lastSegment) throw new Error("Could not determine appId from endpoint");
        langModelImp.appId = uri.pathname.substr(lastSegment);
        // And finally the key.
        langModelImp.subscriptionKey = uri.searchParams.get("subscription-key");
        if (undefined === langModelImp.subscriptionKey) throw new Error("Could not determine subscription key from endpoint");
        return langModelImp;
    };
    /**
     * Creates an language understanding model using the application id of Language Understanding service.
     * @member LanguageUnderstandingModel.fromAppId
     * @function
     * @public
     * @param {string} appId - A String that represents the application id of Language Understanding service.
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */ LanguageUnderstandingModel.fromAppId = function(appId) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(appId, "appId");
        var langModelImp = new LanguageUnderstandingModelImpl();
        langModelImp.appId = appId;
        return langModelImp;
    };
    /**
     * Creates a language understanding model using hostname, subscription key and application
     * id of Language Understanding service.
     * @member LanguageUnderstandingModel.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - A String that represents the subscription key of
     * Language Understanding service.
     * @param {string} appId - A String that represents the application id of Language
     * Understanding service.
     * @param {LanguageUnderstandingModel} region - A String that represents the region
     * of the Language Understanding service (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */ LanguageUnderstandingModel.fromSubscription = function(subscriptionKey, appId, region) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(subscriptionKey, "subscriptionKey");
        Contracts_1.Contracts.throwIfNullOrWhitespace(appId, "appId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(region, "region");
        var langModelImp = new LanguageUnderstandingModelImpl();
        langModelImp.appId = appId;
        langModelImp.region = region;
        langModelImp.subscriptionKey = subscriptionKey;
        return langModelImp;
    };
    return LanguageUnderstandingModel;
}();
exports.LanguageUnderstandingModel = LanguageUnderstandingModel;
/**
 * @private
 * @class LanguageUnderstandingModelImpl
 */ var LanguageUnderstandingModelImpl = /** @class */ function(_super) {
    __extends(LanguageUnderstandingModelImpl, _super);
    function LanguageUnderstandingModelImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return LanguageUnderstandingModelImpl;
}(LanguageUnderstandingModel);
exports.LanguageUnderstandingModelImpl = LanguageUnderstandingModelImpl;

},{"9008580e48d89ad":"4jwu5"}],"jG3r6":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeetingTranscriptionEventArgs = exports.ConversationTranscriptionEventArgs = exports.SpeechRecognitionEventArgs = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("a4279073df59474d");
/**
 * Defines contents of speech recognizing/recognized event.
 * @class SpeechRecognitionEventArgs
 */ var SpeechRecognitionEventArgs = /** @class */ function(_super) {
    __extends(SpeechRecognitionEventArgs, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechRecognitionResult} result - The speech recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */ function SpeechRecognitionEventArgs(result, offset, sessionId) {
        var _this = _super.call(this, offset, sessionId) || this;
        _this.privResult = result;
        return _this;
    }
    Object.defineProperty(SpeechRecognitionEventArgs.prototype, "result", {
        /**
         * Specifies the recognition result.
         * @member SpeechRecognitionEventArgs.prototype.result
         * @function
         * @public
         * @returns {SpeechRecognitionResult} the recognition result.
         */ get: function() {
            return this.privResult;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechRecognitionEventArgs;
}(Exports_1.RecognitionEventArgs);
exports.SpeechRecognitionEventArgs = SpeechRecognitionEventArgs;
/**
 * Defines contents of conversation transcribed/transcribing event.
 * @class ConversationTranscriptionEventArgs
 */ var ConversationTranscriptionEventArgs = /** @class */ function(_super) {
    __extends(ConversationTranscriptionEventArgs, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranscriptionResult} result - The conversation transcription result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */ function ConversationTranscriptionEventArgs(result, offset, sessionId) {
        var _this = _super.call(this, offset, sessionId) || this;
        _this.privResult = result;
        return _this;
    }
    Object.defineProperty(ConversationTranscriptionEventArgs.prototype, "result", {
        /**
         * Specifies the transcription result.
         * @member ConversationTranscription1EventArgs.prototype.result
         * @function
         * @public
         * @returns {ConversationTranscriptionResult} the recognition result.
         */ get: function() {
            return this.privResult;
        },
        enumerable: false,
        configurable: true
    });
    return ConversationTranscriptionEventArgs;
}(Exports_1.RecognitionEventArgs);
exports.ConversationTranscriptionEventArgs = ConversationTranscriptionEventArgs;
/**
 * Defines contents of meeting transcribed/transcribing event.
 * @class MeetingTranscriptionEventArgs
 */ var MeetingTranscriptionEventArgs = /** @class */ function(_super) {
    __extends(MeetingTranscriptionEventArgs, _super);
    function MeetingTranscriptionEventArgs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return MeetingTranscriptionEventArgs;
}(SpeechRecognitionEventArgs);
exports.MeetingTranscriptionEventArgs = MeetingTranscriptionEventArgs;

},{"a4279073df59474d":"hxkc3"}],"4R5tA":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechRecognitionCanceledEventArgs = void 0;
var CancellationEventArgsBase_1 = require("ad5c335e85faa6fb");
var SpeechRecognitionCanceledEventArgs = /** @class */ function(_super) {
    __extends(SpeechRecognitionCanceledEventArgs, _super);
    function SpeechRecognitionCanceledEventArgs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SpeechRecognitionCanceledEventArgs;
}(CancellationEventArgsBase_1.CancellationEventArgsBase);
exports.SpeechRecognitionCanceledEventArgs = SpeechRecognitionCanceledEventArgs;

},{"ad5c335e85faa6fb":"7hXId"}],"7hXId":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CancellationEventArgsBase = void 0;
var Exports_1 = require("fcf636414e0e2658");
/**
 * Defines content of a CancellationEvent.
 * @class CancellationEventArgsBase
 */ var CancellationEventArgsBase = /** @class */ function(_super) {
    __extends(CancellationEventArgsBase, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */ function CancellationEventArgsBase(reason, errorDetails, errorCode, offset, sessionId) {
        var _this = _super.call(this, offset, sessionId) || this;
        _this.privReason = reason;
        _this.privErrorDetails = errorDetails;
        _this.privErrorCode = errorCode;
        return _this;
    }
    Object.defineProperty(CancellationEventArgsBase.prototype, "reason", {
        /**
         * The reason the recognition was canceled.
         * @member CancellationEventArgsBase.prototype.reason
         * @function
         * @public
         * @returns {CancellationReason} Specifies the reason canceled.
         */ get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CancellationEventArgsBase.prototype, "errorCode", {
        /**
         * The error code in case of an unsuccessful operation.
         * @return An error code that represents the error reason.
         */ get: function() {
            return this.privErrorCode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CancellationEventArgsBase.prototype, "errorDetails", {
        /**
         * In case of an unsuccessful operation, provides details of the occurred error.
         * @member CancellationEventArgsBase.prototype.errorDetails
         * @function
         * @public
         * @returns {string} A String that represents the error details.
         */ get: function() {
            return this.privErrorDetails;
        },
        enumerable: false,
        configurable: true
    });
    return CancellationEventArgsBase;
}(Exports_1.RecognitionEventArgs);
exports.CancellationEventArgsBase = CancellationEventArgsBase;

},{"fcf636414e0e2658":"hxkc3"}],"h3kua":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationRecognitionEventArgs = void 0;
var Exports_1 = require("9065eef8023fc750");
/**
 * Translation text result event arguments.
 * @class TranslationRecognitionEventArgs
 */ var TranslationRecognitionEventArgs = /** @class */ function(_super) {
    __extends(TranslationRecognitionEventArgs, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationRecognitionResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */ function TranslationRecognitionEventArgs(result, offset, sessionId) {
        var _this = _super.call(this, offset, sessionId) || this;
        _this.privResult = result;
        return _this;
    }
    Object.defineProperty(TranslationRecognitionEventArgs.prototype, "result", {
        /**
         * Specifies the recognition result.
         * @member TranslationRecognitionEventArgs.prototype.result
         * @function
         * @public
         * @returns {TranslationRecognitionResult} the recognition result.
         */ get: function() {
            return this.privResult;
        },
        enumerable: false,
        configurable: true
    });
    return TranslationRecognitionEventArgs;
}(Exports_1.RecognitionEventArgs);
exports.TranslationRecognitionEventArgs = TranslationRecognitionEventArgs;

},{"9065eef8023fc750":"hxkc3"}],"dN2sU":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationSynthesisEventArgs = void 0;
var Exports_1 = require("a000679192d24a83");
/**
 * Translation Synthesis event arguments
 * @class TranslationSynthesisEventArgs
 */ var TranslationSynthesisEventArgs = /** @class */ function(_super) {
    __extends(TranslationSynthesisEventArgs, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationSynthesisResult} result - The translation synthesis result.
     * @param {string} sessionId - The session id.
     */ function TranslationSynthesisEventArgs(result, sessionId) {
        var _this = _super.call(this, sessionId) || this;
        _this.privResult = result;
        return _this;
    }
    Object.defineProperty(TranslationSynthesisEventArgs.prototype, "result", {
        /**
         * Specifies the translation synthesis result.
         * @member TranslationSynthesisEventArgs.prototype.result
         * @function
         * @public
         * @returns {TranslationSynthesisResult} Specifies the translation synthesis result.
         */ get: function() {
            return this.privResult;
        },
        enumerable: false,
        configurable: true
    });
    return TranslationSynthesisEventArgs;
}(Exports_1.SessionEventArgs);
exports.TranslationSynthesisEventArgs = TranslationSynthesisEventArgs;

},{"a000679192d24a83":"hxkc3"}],"bX84V":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationRecognitionResult = void 0;
var Exports_1 = require("7653faf97223bded");
/**
 * Translation text result.
 * @class TranslationRecognitionResult
 */ var TranslationRecognitionResult = /** @class */ function(_super) {
    __extends(TranslationRecognitionResult, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {Translations} translations - The translations.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */ function TranslationRecognitionResult(translations, resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {
        var _this = _super.call(this, resultId, reason, text, duration, offset, language, languageDetectionConfidence, undefined, errorDetails, json, properties) || this;
        _this.privTranslations = translations;
        return _this;
    }
    TranslationRecognitionResult.fromSpeechRecognitionResult = function(result) {
        return new TranslationRecognitionResult(undefined, result.resultId, result.reason, result.text, result.duration, result.offset, result.language, result.languageDetectionConfidence, result.errorDetails, result.json, result.properties);
    };
    Object.defineProperty(TranslationRecognitionResult.prototype, "translations", {
        /**
         * Presents the translation results. Each item in the dictionary represents
         * a translation result in one of target languages, where the key is the name
         * of the target language, in BCP-47 format, and the value is the translation
         * text in the specified language.
         * @member TranslationRecognitionResult.prototype.translations
         * @function
         * @public
         * @returns {Translations} the current translation map that holds all translations requested.
         */ get: function() {
            return this.privTranslations;
        },
        enumerable: false,
        configurable: true
    });
    return TranslationRecognitionResult;
}(Exports_1.SpeechRecognitionResult);
exports.TranslationRecognitionResult = TranslationRecognitionResult;

},{"7653faf97223bded":"hxkc3"}],"7z8gi":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationSynthesisResult = void 0;
/**
 * Defines translation synthesis result, i.e. the voice output of the translated
 * text in the target language.
 * @class TranslationSynthesisResult
 */ var TranslationSynthesisResult = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ResultReason} reason - The synthesis reason.
     * @param {ArrayBuffer} audio - The audio data.
     */ function TranslationSynthesisResult(reason, audio) {
        this.privReason = reason;
        this.privAudio = audio;
    }
    Object.defineProperty(TranslationSynthesisResult.prototype, "audio", {
        /**
         * Translated text in the target language.
         * @member TranslationSynthesisResult.prototype.audio
         * @function
         * @public
         * @returns {ArrayBuffer} Translated audio in the target language.
         */ get: function() {
            return this.privAudio;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationSynthesisResult.prototype, "reason", {
        /**
         * The synthesis status.
         * @member TranslationSynthesisResult.prototype.reason
         * @function
         * @public
         * @returns {ResultReason} The synthesis status.
         */ get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    return TranslationSynthesisResult;
}();
exports.TranslationSynthesisResult = TranslationSynthesisResult;

},{}],"d3kNo":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResultReason = void 0;
/**
 * Defines the possible reasons a recognition result might be generated.
 * @class ResultReason
 */ var ResultReason;
(function(ResultReason) {
    /**
     * Indicates speech could not be recognized. More details
     * can be found in the NoMatchDetails object.
     * @member ResultReason.NoMatch
     */ ResultReason[ResultReason["NoMatch"] = 0] = "NoMatch";
    /**
     * Indicates that the recognition was canceled. More details
     * can be found using the CancellationDetails object.
     * @member ResultReason.Canceled
     */ ResultReason[ResultReason["Canceled"] = 1] = "Canceled";
    /**
     * Indicates the speech result contains hypothesis text.
     * @member ResultReason.RecognizedSpeech
     */ ResultReason[ResultReason["RecognizingSpeech"] = 2] = "RecognizingSpeech";
    /**
     * Indicates the speech result contains final text that has been recognized.
     * Speech Recognition is now complete for this phrase.
     * @member ResultReason.RecognizedSpeech
     */ ResultReason[ResultReason["RecognizedSpeech"] = 3] = "RecognizedSpeech";
    /**
     * Indicates the speech result contains a finalized acceptance of a provided keyword.
     * Speech recognition will continue unless otherwise configured.
     * @member ResultReason.RecognizedKeyword
     */ ResultReason[ResultReason["RecognizedKeyword"] = 4] = "RecognizedKeyword";
    /**
     * Indicates the intent result contains hypothesis text and intent.
     * @member ResultReason.RecognizingIntent
     */ ResultReason[ResultReason["RecognizingIntent"] = 5] = "RecognizingIntent";
    /**
     * Indicates the intent result contains final text and intent.
     * Speech Recognition and Intent determination are now complete for this phrase.
     * @member ResultReason.RecognizedIntent
     */ ResultReason[ResultReason["RecognizedIntent"] = 6] = "RecognizedIntent";
    /**
     * Indicates the translation result contains hypothesis text and its translation(s).
     * @member ResultReason.TranslatingSpeech
     */ ResultReason[ResultReason["TranslatingSpeech"] = 7] = "TranslatingSpeech";
    /**
     * Indicates the translation result contains final text and corresponding translation(s).
     * Speech Recognition and Translation are now complete for this phrase.
     * @member ResultReason.TranslatedSpeech
     */ ResultReason[ResultReason["TranslatedSpeech"] = 8] = "TranslatedSpeech";
    /**
     * Indicates the synthesized audio result contains a non-zero amount of audio data
     * @member ResultReason.SynthesizingAudio
     */ ResultReason[ResultReason["SynthesizingAudio"] = 9] = "SynthesizingAudio";
    /**
     * Indicates the synthesized audio is now complete for this phrase.
     * @member ResultReason.SynthesizingAudioCompleted
     */ ResultReason[ResultReason["SynthesizingAudioCompleted"] = 10] = "SynthesizingAudioCompleted";
    /**
     * Indicates the speech synthesis is now started
     * @member ResultReason.SynthesizingAudioStarted
     */ ResultReason[ResultReason["SynthesizingAudioStarted"] = 11] = "SynthesizingAudioStarted";
    /**
     * Indicates the voice profile is being enrolled and customers need to send more audio to create a voice profile.
     * @member ResultReason.EnrollingVoiceProfile
     */ ResultReason[ResultReason["EnrollingVoiceProfile"] = 12] = "EnrollingVoiceProfile";
    /**
     * Indicates the voice profile has been enrolled.
     * @member ResultReason.EnrolledVoiceProfile
     */ ResultReason[ResultReason["EnrolledVoiceProfile"] = 13] = "EnrolledVoiceProfile";
    /**
     * Indicates successful identification of some speakers.
     * @member ResultReason.RecognizedSpeakers
     */ ResultReason[ResultReason["RecognizedSpeakers"] = 14] = "RecognizedSpeakers";
    /**
     * Indicates successfully verified one speaker.
     * @member ResultReason.RecognizedSpeaker
     */ ResultReason[ResultReason["RecognizedSpeaker"] = 15] = "RecognizedSpeaker";
    /**
     * Indicates a voice profile has been reset successfully.
     * @member ResultReason.ResetVoiceProfile
     */ ResultReason[ResultReason["ResetVoiceProfile"] = 16] = "ResetVoiceProfile";
    /**
     * Indicates a voice profile has been deleted successfully.
     * @member ResultReason.DeletedVoiceProfile
     */ ResultReason[ResultReason["DeletedVoiceProfile"] = 17] = "DeletedVoiceProfile";
    /**
     * Indicates synthesis voices list has been successfully retrieved.
     * @member ResultReason.VoicesListRetrieved
     */ ResultReason[ResultReason["VoicesListRetrieved"] = 18] = "VoicesListRetrieved";
    /**
     * Indicates the transcription result contains hypothesis text and its translation(s) for
     * other participants in the conversation.
     * @member ResultReason.TranslatingParticipantSpeech
     */ ResultReason[ResultReason["TranslatingParticipantSpeech"] = 19] = "TranslatingParticipantSpeech";
    /**
     * Indicates the transcription result contains final text and corresponding translation(s)
     * for other participants in the conversation. Speech Recognition and Translation are now
     * complete for this phrase.
     * @member ResultReason.TranslatedParticipantSpeech
     */ ResultReason[ResultReason["TranslatedParticipantSpeech"] = 20] = "TranslatedParticipantSpeech";
    /**
     * <summary>
     * Indicates the transcription result contains the instant message and corresponding
     * translation(s).
     * @member ResultReason.TranslatedInstantMessage
     */ ResultReason[ResultReason["TranslatedInstantMessage"] = 21] = "TranslatedInstantMessage";
    /**
     * Indicates the transcription result contains the instant message for other participants
     * in the conversation and corresponding translation(s).
     * @member ResultReason.TranslatedParticipantInstantMessage
     */ ResultReason[ResultReason["TranslatedParticipantInstantMessage"] = 22] = "TranslatedParticipantInstantMessage";
})(ResultReason = exports.ResultReason || (exports.ResultReason = {}));

},{}],"fULPg":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/* eslint-disable max-classes-per-file */ var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechConfigImpl = exports.SpeechConfig = void 0;
var Exports_1 = require("fa6b088fe609d127");
var Contracts_1 = require("825709284a11bea8");
var Exports_2 = require("eb3459546d8dbda4");
/**
 * Speech configuration.
 * @class SpeechConfig
 */ var SpeechConfig = /** @class */ function() {
    /**
     * Creates and initializes an instance.
     * @constructor
     */ function SpeechConfig() {
        return;
    }
    /**
     * Static instance of SpeechConfig returned by passing subscriptionKey and service region.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * @member SpeechConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} The speech factory
     */ SpeechConfig.fromSubscription = function(subscriptionKey, region) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(subscriptionKey, "subscriptionKey");
        Contracts_1.Contracts.throwIfNullOrWhitespace(region, "region");
        var speechImpl = new SpeechConfigImpl();
        speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Region, region);
        speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_IntentRegion, region);
        speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
        return speechImpl;
    };
    /**
     * Creates an instance of the speech config with specified endpoint and subscription key.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * For example, if language is defined in the uri as query parameter "language=de-DE", and also set by
     * SpeechConfig.speechRecognitionLanguage = "en-US", the language setting in uri takes precedence,
     * and the effective language is "de-DE". Only the parameters that are not specified in the
     * endpoint URL can be set by other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created SpeechConfig instance to
     * use the authorization token.
     * @member SpeechConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */ SpeechConfig.fromEndpoint = function(endpoint, subscriptionKey) {
        Contracts_1.Contracts.throwIfNull(endpoint, "endpoint");
        var speechImpl = new SpeechConfigImpl();
        speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint, endpoint.href);
        if (undefined !== subscriptionKey) speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
        return speechImpl;
    };
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */ SpeechConfig.fromHost = function(hostName, subscriptionKey) {
        Contracts_1.Contracts.throwIfNull(hostName, "hostName");
        var speechImpl = new SpeechConfigImpl();
        speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, hostName.protocol + "//" + hostName.hostname + (hostName.port === "" ? "" : ":" + hostName.port));
        if (undefined !== subscriptionKey) speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
        return speechImpl;
    };
    /**
     * Creates an instance of the speech factory with specified initial authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want
     * to use the Intent recognizer. As configuration values are copied when creating a new recognizer,
     * the new token value will not apply to recognizers that have already been created. For recognizers
     * that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The initial authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} A speech factory instance.
     */ SpeechConfig.fromAuthorizationToken = function(authorizationToken, region) {
        Contracts_1.Contracts.throwIfNull(authorizationToken, "authorizationToken");
        Contracts_1.Contracts.throwIfNullOrWhitespace(region, "region");
        var speechImpl = new SpeechConfigImpl();
        speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Region, region);
        speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_IntentRegion, region);
        speechImpl.authorizationToken = authorizationToken;
        return speechImpl;
    };
    /**
     * Closes the configuration.
     * @member SpeechConfig.prototype.close
     * @function
     * @public
     */ // eslint-disable-next-line @typescript-eslint/no-empty-function
    SpeechConfig.prototype.close = function() {};
    return SpeechConfig;
}();
exports.SpeechConfig = SpeechConfig;
/**
 * @public
 * @class SpeechConfigImpl
 */ var SpeechConfigImpl = /** @class */ function(_super) {
    __extends(SpeechConfigImpl, _super);
    function SpeechConfigImpl() {
        var _this = _super.call(this) || this;
        _this.privProperties = new Exports_2.PropertyCollection();
        _this.speechRecognitionLanguage = "en-US"; // Should we have a default?
        _this.outputFormat = Exports_2.OutputFormat.Simple;
        return _this;
    }
    Object.defineProperty(SpeechConfigImpl.prototype, "properties", {
        get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConfigImpl.prototype, "endPoint", {
        get: function() {
            return new URL(this.privProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConfigImpl.prototype, "subscriptionKey", {
        get: function() {
            return this.privProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Key);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConfigImpl.prototype, "region", {
        get: function() {
            return this.privProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Region);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConfigImpl.prototype, "authorizationToken", {
        get: function() {
            return this.privProperties.getProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token);
        },
        set: function(value) {
            this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConfigImpl.prototype, "speechRecognitionLanguage", {
        get: function() {
            return this.privProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage);
        },
        set: function(value) {
            this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConfigImpl.prototype, "autoDetectSourceLanguages", {
        get: function() {
            return this.privProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);
        },
        set: function(value) {
            this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConfigImpl.prototype, "outputFormat", {
        get: function() {
            return Exports_2.OutputFormat[this.privProperties.getProperty(Exports_1.OutputFormatPropertyName, undefined)];
        },
        set: function(value) {
            this.privProperties.setProperty(Exports_1.OutputFormatPropertyName, Exports_2.OutputFormat[value]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConfigImpl.prototype, "endpointId", {
        get: function() {
            return this.privProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_EndpointId);
        },
        set: function(value) {
            this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_EndpointId, value);
        },
        enumerable: false,
        configurable: true
    });
    SpeechConfigImpl.prototype.setProperty = function(name, value) {
        Contracts_1.Contracts.throwIfNull(value, "value");
        this.privProperties.setProperty(name, value);
    };
    SpeechConfigImpl.prototype.getProperty = function(name, def) {
        return this.privProperties.getProperty(name, def);
    };
    SpeechConfigImpl.prototype.setProxy = function(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
        this.setProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_ProxyHostName], proxyHostName);
        this.setProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_ProxyPort], proxyPort);
        this.setProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_ProxyUserName], proxyUserName);
        this.setProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_ProxyPassword], proxyPassword);
    };
    SpeechConfigImpl.prototype.setServiceProperty = function(name, value) {
        var currentProperties = JSON.parse(this.privProperties.getProperty(Exports_1.ServicePropertiesPropertyName, "{}"));
        currentProperties[name] = value;
        this.privProperties.setProperty(Exports_1.ServicePropertiesPropertyName, JSON.stringify(currentProperties));
    };
    SpeechConfigImpl.prototype.setProfanity = function(profanity) {
        this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceResponse_ProfanityOption, Exports_2.ProfanityOption[profanity]);
    };
    SpeechConfigImpl.prototype.enableAudioLogging = function() {
        this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    };
    SpeechConfigImpl.prototype.requestWordLevelTimestamps = function() {
        this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    };
    SpeechConfigImpl.prototype.enableDictation = function() {
        this.privProperties.setProperty(Exports_1.ForceDictationPropertyName, "true");
    };
    SpeechConfigImpl.prototype.clone = function() {
        var ret = new SpeechConfigImpl();
        ret.privProperties = this.privProperties.clone();
        return ret;
    };
    Object.defineProperty(SpeechConfigImpl.prototype, "speechSynthesisLanguage", {
        get: function() {
            return this.privProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthLanguage);
        },
        set: function(language) {
            this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthLanguage, language);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConfigImpl.prototype, "speechSynthesisVoiceName", {
        get: function() {
            return this.privProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthVoice);
        },
        set: function(voice) {
            this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthVoice, voice);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConfigImpl.prototype, "speechSynthesisOutputFormat", {
        get: function() {
            return Exports_2.SpeechSynthesisOutputFormat[this.privProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)];
        },
        set: function(format) {
            this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, Exports_2.SpeechSynthesisOutputFormat[format]);
        },
        enumerable: false,
        configurable: true
    });
    return SpeechConfigImpl;
}(SpeechConfig);
exports.SpeechConfigImpl = SpeechConfigImpl;

},{"fa6b088fe609d127":"7Qpvn","825709284a11bea8":"4jwu5","eb3459546d8dbda4":"hxkc3"}],"2hkll":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechTranslationConfigImpl = exports.SpeechTranslationConfig = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("e87ba63bd36cd242");
var Contracts_1 = require("9e793b07b579184e");
var Exports_2 = require("88e2a4a400b70459");
/**
 * Speech translation configuration.
 * @class SpeechTranslationConfig
 */ var SpeechTranslationConfig = /** @class */ function(_super) {
    __extends(SpeechTranslationConfig, _super);
    /**
     * Creates an instance of recognizer config.
     */ function SpeechTranslationConfig() {
        return _super.call(this) || this;
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing a subscription key and service region.
     * @member SpeechTranslationConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */ SpeechTranslationConfig.fromSubscription = function(subscriptionKey, region) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(subscriptionKey, "subscriptionKey");
        Contracts_1.Contracts.throwIfNullOrWhitespace(region, "region");
        var ret = new SpeechTranslationConfigImpl();
        ret.properties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
        ret.properties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Region, region);
        return ret;
    };
    /**
     * Static instance of SpeechTranslationConfig returned by passing authorization token and service region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by setting the property authorizationToken with a new
     * valid token. Otherwise, all the recognizers created by this SpeechTranslationConfig instance
     * will encounter errors during recognition.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply
     * to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechTranslationConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */ SpeechTranslationConfig.fromAuthorizationToken = function(authorizationToken, region) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(authorizationToken, "authorizationToken");
        Contracts_1.Contracts.throwIfNullOrWhitespace(region, "region");
        var ret = new SpeechTranslationConfigImpl();
        ret.properties.setProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token, authorizationToken);
        ret.properties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Region, region);
        return ret;
    };
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */ SpeechTranslationConfig.fromHost = function(hostName, subscriptionKey) {
        Contracts_1.Contracts.throwIfNull(hostName, "hostName");
        var speechImpl = new SpeechTranslationConfigImpl();
        speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, hostName.protocol + "//" + hostName.hostname + (hostName.port === "" ? "" : ":" + hostName.port));
        if (undefined !== subscriptionKey) speechImpl.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
        return speechImpl;
    };
    /**
     * Creates an instance of the speech translation config with specified endpoint and subscription key.
     * This method is intended only for users who use a non-standard service endpoint or paramters.
     * Note: The query properties specified in the endpoint URL are not changed, even if they are
     * set by any other APIs. For example, if language is defined in the uri as query parameter
     * "language=de-DE", and also set by the speechRecognitionLanguage property, the language
     * setting in uri takes precedence, and the effective language is "de-DE".
     * Only the properties that are not specified in the endpoint URL can be set by other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created SpeechConfig instance to
     * use the authorization token.
     * @member SpeechTranslationConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key.
     * @returns {SpeechTranslationConfig} A speech config instance.
     */ SpeechTranslationConfig.fromEndpoint = function(endpoint, subscriptionKey) {
        Contracts_1.Contracts.throwIfNull(endpoint, "endpoint");
        Contracts_1.Contracts.throwIfNull(subscriptionKey, "subscriptionKey");
        var ret = new SpeechTranslationConfigImpl();
        ret.properties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint, endpoint.href);
        ret.properties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
        return ret;
    };
    return SpeechTranslationConfig;
}(Exports_2.SpeechConfig);
exports.SpeechTranslationConfig = SpeechTranslationConfig;
/**
 * @private
 * @class SpeechTranslationConfigImpl
 */ var SpeechTranslationConfigImpl = /** @class */ function(_super) {
    __extends(SpeechTranslationConfigImpl, _super);
    function SpeechTranslationConfigImpl() {
        var _this = _super.call(this) || this;
        _this.privSpeechProperties = new Exports_2.PropertyCollection();
        _this.outputFormat = Exports_2.OutputFormat.Simple;
        return _this;
    }
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "authorizationToken", {
        /**
         * Gets/Sets the authorization token.
         * If this is set, subscription key is ignored.
         * User needs to make sure the provided authorization token is valid and not expired.
         * @member SpeechTranslationConfigImpl.prototype.authorizationToken
         * @function
         * @public
         * @param {string} value - The authorization token.
         */ set: function(value) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(value, "value");
            this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "speechRecognitionLanguage", {
        /**
         * Gets the speech recognition language.
         * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
         * @function
         * @public
         * @return {string} The speechRecognitionLanguage.
         */ get: function() {
            return this.privSpeechProperties.getProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage]);
        },
        /**
         * Sets the speech recognition language.
         * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
         * @function
         * @public
         * @param {string} value - The authorization token.
         */ set: function(value) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(value, "value");
            this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "subscriptionKey", {
        /**
         * @member SpeechTranslationConfigImpl.prototype.subscriptionKey
         * @function
         * @public
         */ get: function() {
            return this.privSpeechProperties.getProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_Key]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "outputFormat", {
        /**
         * Gets the output format
         * @member SpeechTranslationConfigImpl.prototype.outputFormat
         * @function
         * @public
         */ get: function() {
            // eslint-disable-next-line
            return Exports_2.OutputFormat[this.privSpeechProperties.getProperty(Exports_1.OutputFormatPropertyName, undefined)];
        },
        /**
         * Gets/Sets the output format
         * @member SpeechTranslationConfigImpl.prototype.outputFormat
         * @function
         * @public
         */ set: function(value) {
            this.privSpeechProperties.setProperty(Exports_1.OutputFormatPropertyName, Exports_2.OutputFormat[value]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "endpointId", {
        /**
         * Gets the endpoint id.
         * @member SpeechTranslationConfigImpl.prototype.endpointId
         * @function
         * @public
         */ get: function() {
            return this.privSpeechProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_EndpointId);
        },
        /**
         * Gets/Sets the endpoint id.
         * @member SpeechTranslationConfigImpl.prototype.endpointId
         * @function
         * @public
         */ set: function(value) {
            this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_EndpointId, value);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add a (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.addTargetLanguage
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */ SpeechTranslationConfigImpl.prototype.addTargetLanguage = function(value) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(value, "value");
        var languages = this.targetLanguages;
        languages.push(value);
        this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(","));
    };
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "targetLanguages", {
        /**
         * Gets the (text) target language to translate into.
         * @member SpeechTranslationConfigImpl.prototype.targetLanguages
         * @function
         * @public
         * @param {string} value - The language such as de-DE
         */ get: function() {
            if (this.privSpeechProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) return this.privSpeechProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
            else return [];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "voiceName", {
        /**
         * Gets the voice name.
         * @member SpeechTranslationConfigImpl.prototype.voiceName
         * @function
         * @public
         */ get: function() {
            return this.getProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_TranslationVoice]);
        },
        /**
         * Gets/Sets the voice of the translated language, enable voice synthesis output.
         * @member SpeechTranslationConfigImpl.prototype.voiceName
         * @function
         * @public
         * @param {string} value - The name of the voice.
         */ set: function(value) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(value, "value");
            this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_TranslationVoice, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "region", {
        /**
         * Provides the region.
         * @member SpeechTranslationConfigImpl.prototype.region
         * @function
         * @public
         * @returns {string} The region.
         */ get: function() {
            return this.privSpeechProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Region);
        },
        enumerable: false,
        configurable: true
    });
    SpeechTranslationConfigImpl.prototype.setProxy = function(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
        this.setProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_ProxyHostName], proxyHostName);
        this.setProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_ProxyPort], proxyPort);
        this.setProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_ProxyUserName], proxyUserName);
        this.setProperty(Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_ProxyPassword], proxyPassword);
    };
    /**
     * Gets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {string} name - The name of the property.
     * @param {string} def - The default value of the property in case it is not set.
     * @returns {string} The value of the property.
     */ SpeechTranslationConfigImpl.prototype.getProperty = function(name, def) {
        return this.privSpeechProperties.getProperty(name, def);
    };
    /**
     * Gets/Sets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {string | PropertyId} name - The name of the property to set.
     * @param {string} value - The value of the property.
     */ SpeechTranslationConfigImpl.prototype.setProperty = function(name, value) {
        this.privSpeechProperties.setProperty(name, value);
    };
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "properties", {
        /**
         * Provides access to custom properties.
         * @member SpeechTranslationConfigImpl.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The properties.
         */ get: function() {
            return this.privSpeechProperties;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Dispose of associated resources.
     * @member SpeechTranslationConfigImpl.prototype.close
     * @function
     * @public
     */ SpeechTranslationConfigImpl.prototype.close = function() {
        return;
    };
    SpeechTranslationConfigImpl.prototype.setServiceProperty = function(name, value) {
        var currentProperties = JSON.parse(this.privSpeechProperties.getProperty(Exports_1.ServicePropertiesPropertyName, "{}"));
        currentProperties[name] = value;
        this.privSpeechProperties.setProperty(Exports_1.ServicePropertiesPropertyName, JSON.stringify(currentProperties));
    };
    SpeechTranslationConfigImpl.prototype.setProfanity = function(profanity) {
        this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceResponse_ProfanityOption, Exports_2.ProfanityOption[profanity]);
    };
    SpeechTranslationConfigImpl.prototype.enableAudioLogging = function() {
        this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    };
    SpeechTranslationConfigImpl.prototype.requestWordLevelTimestamps = function() {
        this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    };
    SpeechTranslationConfigImpl.prototype.enableDictation = function() {
        this.privSpeechProperties.setProperty(Exports_1.ForceDictationPropertyName, "true");
    };
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "speechSynthesisLanguage", {
        get: function() {
            return this.privSpeechProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthLanguage);
        },
        set: function(language) {
            this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthLanguage, language);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "speechSynthesisVoiceName", {
        get: function() {
            return this.privSpeechProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthVoice);
        },
        set: function(voice) {
            this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthVoice, voice);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechTranslationConfigImpl.prototype, "speechSynthesisOutputFormat", {
        get: function() {
            // eslint-disable-next-line
            return Exports_2.SpeechSynthesisOutputFormat[this.privSpeechProperties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)];
        },
        set: function(format) {
            this.privSpeechProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, Exports_2.SpeechSynthesisOutputFormat[format]);
        },
        enumerable: false,
        configurable: true
    });
    return SpeechTranslationConfigImpl;
}(SpeechTranslationConfig);
exports.SpeechTranslationConfigImpl = SpeechTranslationConfigImpl;

},{"e87ba63bd36cd242":"7Qpvn","9e793b07b579184e":"4jwu5","88e2a4a400b70459":"hxkc3"}],"jfzZ9":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PropertyCollection = void 0;
var Exports_1 = require("74b764e5574186fc");
/**
 * Represents collection of properties and their values.
 * @class PropertyCollection
 */ var PropertyCollection = /** @class */ function() {
    function PropertyCollection() {
        this.privKeys = [];
        this.privValues = [];
    }
    /**
     * Returns the property value in type String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member PropertyCollection.prototype.getProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string | number | boolean} def - The default value which is returned if the parameter
     * is not available in the collection.
     * @returns {string} value of the parameter.
     */ PropertyCollection.prototype.getProperty = function(key, def) {
        var keyToUse;
        if (typeof key === "string") keyToUse = key;
        else keyToUse = Exports_1.PropertyId[key];
        for(var n = 0; n < this.privKeys.length; n++){
            if (this.privKeys[n] === keyToUse) return this.privValues[n];
        }
        if (def === undefined) return undefined;
        return String(def);
    };
    /**
     * Sets the String value of the parameter specified by name.
     * @member PropertyCollection.prototype.setProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */ PropertyCollection.prototype.setProperty = function(key, value) {
        var keyToUse;
        if (typeof key === "string") keyToUse = key;
        else keyToUse = Exports_1.PropertyId[key];
        for(var n = 0; n < this.privKeys.length; n++)if (this.privKeys[n] === keyToUse) {
            this.privValues[n] = value;
            return;
        }
        this.privKeys.push(keyToUse);
        this.privValues.push(value);
    };
    /**
     * Clones the collection.
     * @member PropertyCollection.prototype.clone
     * @function
     * @public
     * @returns {PropertyCollection} A copy of the collection.
     */ PropertyCollection.prototype.clone = function() {
        var clonedMap = new PropertyCollection();
        for(var n = 0; n < this.privKeys.length; n++){
            clonedMap.privKeys.push(this.privKeys[n]);
            clonedMap.privValues.push(this.privValues[n]);
        }
        return clonedMap;
    };
    /**
     * Merges this set of properties into another, no overwrites.
     * @member PropertyCollection.prototype.mergeTo
     * @function
     * @public
     * @param {PropertyCollection}  destinationCollection - The collection to merge into.
     */ PropertyCollection.prototype.mergeTo = function(destinationCollection) {
        var _this = this;
        this.privKeys.forEach(function(key) {
            if (destinationCollection.getProperty(key, undefined) === undefined) {
                var value = _this.getProperty(key);
                destinationCollection.setProperty(key, value);
            }
        });
    };
    Object.defineProperty(PropertyCollection.prototype, "keys", {
        /**
         * Get the keys in Property Collection.
         * @member PropertyCollection.prototype.keys
         * @function
         * @public
         * @returns {string []} Keys in the collection.
         */ get: function() {
            return this.privKeys;
        },
        enumerable: false,
        configurable: true
    });
    return PropertyCollection;
}();
exports.PropertyCollection = PropertyCollection;

},{"74b764e5574186fc":"hxkc3"}],"6Rdzq":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PropertyId = void 0;
/**
 * Defines speech property ids.
 * @class PropertyId
 */ var PropertyId;
(function(PropertyId) {
    /**
     * The Cognitive Services Speech Service subscription Key. If you are using an intent recognizer, you need to
     * specify the LUIS endpoint key for your particular LUIS app. Under normal circumstances, you shouldn't
     * have to use this property directly.
     * Instead, use [[SpeechConfig.fromSubscription]].
     * @member PropertyId.SpeechServiceConnection_Key
     */ PropertyId[PropertyId["SpeechServiceConnection_Key"] = 0] = "SpeechServiceConnection_Key";
    /**
     * The Cognitive Services Speech Service endpoint (url). Under normal circumstances, you shouldn't
     * have to use this property directly.
     * Instead, use [[SpeechConfig.fromEndpoint]].
     * NOTE: This endpoint is not the same as the endpoint used to obtain an access token.
     * @member PropertyId.SpeechServiceConnection_Endpoint
     */ PropertyId[PropertyId["SpeechServiceConnection_Endpoint"] = 1] = "SpeechServiceConnection_Endpoint";
    /**
     * The Cognitive Services Speech Service region. Under normal circumstances, you shouldn't have to
     * use this property directly.
     * Instead, use [[SpeechConfig.fromSubscription]], [[SpeechConfig.fromEndpoint]], [[SpeechConfig.fromAuthorizationToken]].
     * @member PropertyId.SpeechServiceConnection_Region
     */ PropertyId[PropertyId["SpeechServiceConnection_Region"] = 2] = "SpeechServiceConnection_Region";
    /**
     * The Cognitive Services Speech Service authorization token (aka access token). Under normal circumstances,
     * you shouldn't have to use this property directly.
     * Instead, use [[SpeechConfig.fromAuthorizationToken]], [[SpeechRecognizer.authorizationToken]],
     * [[IntentRecognizer.authorizationToken]], [[TranslationRecognizer.authorizationToken]], [[SpeakerRecognizer.authorizationToken]].
     * @member PropertyId.SpeechServiceAuthorization_Token
     */ PropertyId[PropertyId["SpeechServiceAuthorization_Token"] = 3] = "SpeechServiceAuthorization_Token";
    /**
     * The Cognitive Services Speech Service authorization type. Currently unused.
     * @member PropertyId.SpeechServiceAuthorization_Type
     */ PropertyId[PropertyId["SpeechServiceAuthorization_Type"] = 4] = "SpeechServiceAuthorization_Type";
    /**
     * The Cognitive Services Speech Service endpoint id. Under normal circumstances, you shouldn't
     * have to use this property directly.
     * Instead, use [[SpeechConfig.endpointId]].
     * NOTE: The endpoint id is available in the Speech Portal, listed under Endpoint Details.
     * @member PropertyId.SpeechServiceConnection_EndpointId
     */ PropertyId[PropertyId["SpeechServiceConnection_EndpointId"] = 5] = "SpeechServiceConnection_EndpointId";
    /**
     * The list of comma separated languages (BCP-47 format) used as target translation languages. Under normal circumstances,
     * you shouldn't have to use this property directly.
     * Instead use [[SpeechTranslationConfig.addTargetLanguage]],
     * [[SpeechTranslationConfig.targetLanguages]], [[TranslationRecognizer.targetLanguages]].
     * @member PropertyId.SpeechServiceConnection_TranslationToLanguages
     */ PropertyId[PropertyId["SpeechServiceConnection_TranslationToLanguages"] = 6] = "SpeechServiceConnection_TranslationToLanguages";
    /**
     * The name of the Cognitive Service Text to Speech Service Voice. Under normal circumstances, you shouldn't have to use this
     * property directly.
     * Instead, use [[SpeechTranslationConfig.voiceName]].
     * NOTE: Valid voice names can be found <a href="https://aka.ms/csspeech/voicenames">here</a>.
     * @member PropertyId.SpeechServiceConnection_TranslationVoice
     */ PropertyId[PropertyId["SpeechServiceConnection_TranslationVoice"] = 7] = "SpeechServiceConnection_TranslationVoice";
    /**
     * Translation features.
     * @member PropertyId.SpeechServiceConnection_TranslationFeatures
     */ PropertyId[PropertyId["SpeechServiceConnection_TranslationFeatures"] = 8] = "SpeechServiceConnection_TranslationFeatures";
    /**
     * The Language Understanding Service Region. Under normal circumstances, you shouldn't have to use this property directly.
     * Instead, use [[LanguageUnderstandingModel]].
     * @member PropertyId.SpeechServiceConnection_IntentRegion
     */ PropertyId[PropertyId["SpeechServiceConnection_IntentRegion"] = 9] = "SpeechServiceConnection_IntentRegion";
    /**
     * The host name of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.
     * You shouldn't have to use this property directly.
     * Instead use <see cref="SpeechConfig.SetProxy(string,int,string,string)"/>.
     * Added in version 1.4.0.
     */ PropertyId[PropertyId["SpeechServiceConnection_ProxyHostName"] = 10] = "SpeechServiceConnection_ProxyHostName";
    /**
     * The port of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.
     * You shouldn't have to use this property directly.
     * Instead use <see cref="SpeechConfig.SetProxy(string,int,string,string)"/>.
     * Added in version 1.4.0.
     */ PropertyId[PropertyId["SpeechServiceConnection_ProxyPort"] = 11] = "SpeechServiceConnection_ProxyPort";
    /**
     * The user name of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.
     * You shouldn't have to use this property directly.
     * Instead use <see cref="SpeechConfig.SetProxy(string,int,string,string)"/>.
     * Added in version 1.4.0.
     */ PropertyId[PropertyId["SpeechServiceConnection_ProxyUserName"] = 12] = "SpeechServiceConnection_ProxyUserName";
    /**
     * The password of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.
     * You shouldn't have to use this property directly.
     * Instead use <see cref="SpeechConfig.SetProxy(string,int,string,string)"/>.
     * Added in version 1.4.0.
     */ PropertyId[PropertyId["SpeechServiceConnection_ProxyPassword"] = 13] = "SpeechServiceConnection_ProxyPassword";
    /**
     * The Cognitive Services Speech Service recognition Mode. Can be "INTERACTIVE", "CONVERSATION", "DICTATION".
     * This property is intended to be read-only. The SDK is using it internally.
     * @member PropertyId.SpeechServiceConnection_RecoMode
     */ PropertyId[PropertyId["SpeechServiceConnection_RecoMode"] = 14] = "SpeechServiceConnection_RecoMode";
    /**
     * The spoken language to be recognized (in BCP-47 format). Under normal circumstances, you shouldn't have to use this property
     * directly.
     * Instead, use [[SpeechConfig.speechRecognitionLanguage]].
     * @member PropertyId.SpeechServiceConnection_RecoLanguage
     */ PropertyId[PropertyId["SpeechServiceConnection_RecoLanguage"] = 15] = "SpeechServiceConnection_RecoLanguage";
    /**
     * The session id. This id is a universally unique identifier (aka UUID) representing a specific binding of an audio input stream
     * and the underlying speech recognition instance to which it is bound. Under normal circumstances, you shouldn't have to use this
     * property directly.
     * Instead use [[SessionEventArgs.sessionId]].
     * @member PropertyId.Speech_SessionId
     */ PropertyId[PropertyId["Speech_SessionId"] = 16] = "Speech_SessionId";
    /**
     * The spoken language to be synthesized (e.g. en-US)
     * @member PropertyId.SpeechServiceConnection_SynthLanguage
     */ PropertyId[PropertyId["SpeechServiceConnection_SynthLanguage"] = 17] = "SpeechServiceConnection_SynthLanguage";
    /**
     * The name of the TTS voice to be used for speech synthesis
     * @member PropertyId.SpeechServiceConnection_SynthVoice
     */ PropertyId[PropertyId["SpeechServiceConnection_SynthVoice"] = 18] = "SpeechServiceConnection_SynthVoice";
    /**
     * The string to specify TTS output audio format
     * @member PropertyId.SpeechServiceConnection_SynthOutputFormat
     */ PropertyId[PropertyId["SpeechServiceConnection_SynthOutputFormat"] = 19] = "SpeechServiceConnection_SynthOutputFormat";
    /**
     * The list of comma separated languages used as possible source languages
     * Added in version 1.13.0
     * @member PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages
     */ PropertyId[PropertyId["SpeechServiceConnection_AutoDetectSourceLanguages"] = 20] = "SpeechServiceConnection_AutoDetectSourceLanguages";
    /**
     * The requested Cognitive Services Speech Service response output format (simple or detailed). Under normal circumstances, you shouldn't have
     * to use this property directly.
     * Instead use [[SpeechConfig.outputFormat]].
     * @member PropertyId.SpeechServiceResponse_RequestDetailedResultTrueFalse
     */ PropertyId[PropertyId["SpeechServiceResponse_RequestDetailedResultTrueFalse"] = 21] = "SpeechServiceResponse_RequestDetailedResultTrueFalse";
    /**
     * The requested Cognitive Services Speech Service response output profanity level. Currently unused.
     * @member PropertyId.SpeechServiceResponse_RequestProfanityFilterTrueFalse
     */ PropertyId[PropertyId["SpeechServiceResponse_RequestProfanityFilterTrueFalse"] = 22] = "SpeechServiceResponse_RequestProfanityFilterTrueFalse";
    /**
     * The Cognitive Services Speech Service response output (in JSON format). This property is available on recognition result objects only.
     * @member PropertyId.SpeechServiceResponse_JsonResult
     */ PropertyId[PropertyId["SpeechServiceResponse_JsonResult"] = 23] = "SpeechServiceResponse_JsonResult";
    /**
     * The Cognitive Services Speech Service error details (in JSON format). Under normal circumstances, you shouldn't have to
     * use this property directly. Instead use [[CancellationDetails.errorDetails]].
     * @member PropertyId.SpeechServiceResponse_JsonErrorDetails
     */ PropertyId[PropertyId["SpeechServiceResponse_JsonErrorDetails"] = 24] = "SpeechServiceResponse_JsonErrorDetails";
    /**
     * The cancellation reason. Currently unused.
     * @member PropertyId.CancellationDetails_Reason
     */ PropertyId[PropertyId["CancellationDetails_Reason"] = 25] = "CancellationDetails_Reason";
    /**
     * The cancellation text. Currently unused.
     * @member PropertyId.CancellationDetails_ReasonText
     */ PropertyId[PropertyId["CancellationDetails_ReasonText"] = 26] = "CancellationDetails_ReasonText";
    /**
     * The Cancellation detailed text. Currently unused.
     * @member PropertyId.CancellationDetails_ReasonDetailedText
     */ PropertyId[PropertyId["CancellationDetails_ReasonDetailedText"] = 27] = "CancellationDetails_ReasonDetailedText";
    /**
     * The Language Understanding Service response output (in JSON format). Available via [[IntentRecognitionResult]]
     * @member PropertyId.LanguageUnderstandingServiceResponse_JsonResult
     */ PropertyId[PropertyId["LanguageUnderstandingServiceResponse_JsonResult"] = 28] = "LanguageUnderstandingServiceResponse_JsonResult";
    /**
     * The URL string built from speech configuration.
     * This property is intended to be read-only. The SDK is using it internally.
     * NOTE: Added in version 1.7.0.
     */ PropertyId[PropertyId["SpeechServiceConnection_Url"] = 29] = "SpeechServiceConnection_Url";
    /**
     * The initial silence timeout value (in milliseconds) used by the service.
     * Added in version 1.7.0
     */ PropertyId[PropertyId["SpeechServiceConnection_InitialSilenceTimeoutMs"] = 30] = "SpeechServiceConnection_InitialSilenceTimeoutMs";
    /**
     * The end silence timeout value (in milliseconds) used by the service.
     * Added in version 1.7.0
     */ PropertyId[PropertyId["SpeechServiceConnection_EndSilenceTimeoutMs"] = 31] = "SpeechServiceConnection_EndSilenceTimeoutMs";
    /**
     * A duration of detected silence, measured in milliseconds, after which speech-to-text will determine a spoken
     * phrase has ended and generate a final Recognized result. Configuring this timeout may be helpful in situations
     * where spoken input is significantly faster or slower than usual and default segmentation behavior consistently
     * yields results that are too long or too short. Segmentation timeout values that are inappropriately high or low
     * can negatively affect speech-to-text accuracy; this property should be carefully configured and the resulting
     * behavior should be thoroughly validated as intended.
     *
     * For more information about timeout configuration that includes discussion of default behaviors, please visit
     * https://aka.ms/csspeech/timeouts.
     *
     * Added in version 1.21.0.
     */ PropertyId[PropertyId["Speech_SegmentationSilenceTimeoutMs"] = 32] = "Speech_SegmentationSilenceTimeoutMs";
    /**
     * A boolean value specifying whether audio logging is enabled in the service or not.
     * Audio and content logs are stored either in Microsoft-owned storage, or in your own storage account linked
     * to your Cognitive Services subscription (Bring Your Own Storage (BYOS) enabled Speech resource).
     * The logs will be removed after 30 days.
     * Added in version 1.7.0
     */ PropertyId[PropertyId["SpeechServiceConnection_EnableAudioLogging"] = 33] = "SpeechServiceConnection_EnableAudioLogging";
    /**
     * The speech service connection language identifier mode.
     * Can be "AtStart" (the default), or "Continuous". See Language
     * Identification document https://aka.ms/speech/lid?pivots=programming-language-javascript
     * for more details.
     * Added in 1.25.0
     **/ PropertyId[PropertyId["SpeechServiceConnection_LanguageIdMode"] = 34] = "SpeechServiceConnection_LanguageIdMode";
    /**
     * A string value representing the desired endpoint version to target for Speech Recognition.
     * Added in version 1.21.0
     */ PropertyId[PropertyId["SpeechServiceConnection_RecognitionEndpointVersion"] = 35] = "SpeechServiceConnection_RecognitionEndpointVersion";
    /**
    /**
     * A string value the current speaker recognition scenario/mode (TextIndependentIdentification, etc.).
     * Added in version 1.23.0
     */ PropertyId[PropertyId["SpeechServiceConnection_SpeakerIdMode"] = 36] = "SpeechServiceConnection_SpeakerIdMode";
    /**
     * The requested Cognitive Services Speech Service response output profanity setting.
     * Allowed values are "masked", "removed", and "raw".
     * Added in version 1.7.0.
     */ PropertyId[PropertyId["SpeechServiceResponse_ProfanityOption"] = 37] = "SpeechServiceResponse_ProfanityOption";
    /**
     * A string value specifying which post processing option should be used by service.
     * Allowed values are "TrueText".
     * Added in version 1.7.0
     */ PropertyId[PropertyId["SpeechServiceResponse_PostProcessingOption"] = 38] = "SpeechServiceResponse_PostProcessingOption";
    /**
     * A boolean value specifying whether to include word-level timestamps in the response result.
     * Added in version 1.7.0
     */ PropertyId[PropertyId["SpeechServiceResponse_RequestWordLevelTimestamps"] = 39] = "SpeechServiceResponse_RequestWordLevelTimestamps";
    /**
     * The number of times a word has to be in partial results to be returned.
     * Added in version 1.7.0
     */ PropertyId[PropertyId["SpeechServiceResponse_StablePartialResultThreshold"] = 40] = "SpeechServiceResponse_StablePartialResultThreshold";
    /**
     * A string value specifying the output format option in the response result. Internal use only.
     * Added in version 1.7.0.
     */ PropertyId[PropertyId["SpeechServiceResponse_OutputFormatOption"] = 41] = "SpeechServiceResponse_OutputFormatOption";
    /**
     * A boolean value to request for stabilizing translation partial results by omitting words in the end.
     * Added in version 1.7.0.
     */ PropertyId[PropertyId["SpeechServiceResponse_TranslationRequestStablePartialResult"] = 42] = "SpeechServiceResponse_TranslationRequestStablePartialResult";
    /**
     * A boolean value specifying whether to request WordBoundary events.
     * @member PropertyId.SpeechServiceResponse_RequestWordBoundary
     * Added in version 1.21.0.
     */ PropertyId[PropertyId["SpeechServiceResponse_RequestWordBoundary"] = 43] = "SpeechServiceResponse_RequestWordBoundary";
    /**
     * A boolean value specifying whether to request punctuation boundary in WordBoundary Events. Default is true.
     * @member PropertyId.SpeechServiceResponse_RequestPunctuationBoundary
     * Added in version 1.21.0.
     */ PropertyId[PropertyId["SpeechServiceResponse_RequestPunctuationBoundary"] = 44] = "SpeechServiceResponse_RequestPunctuationBoundary";
    /**
     * A boolean value specifying whether to request sentence boundary in WordBoundary Events. Default is false.
     * @member PropertyId.SpeechServiceResponse_RequestSentenceBoundary
     * Added in version 1.21.0.
     */ PropertyId[PropertyId["SpeechServiceResponse_RequestSentenceBoundary"] = 45] = "SpeechServiceResponse_RequestSentenceBoundary";
    /**
     * Identifier used to connect to the backend service.
     * @member PropertyId.Conversation_ApplicationId
     */ PropertyId[PropertyId["Conversation_ApplicationId"] = 46] = "Conversation_ApplicationId";
    /**
     * Type of dialog backend to connect to.
     * @member PropertyId.Conversation_DialogType
     */ PropertyId[PropertyId["Conversation_DialogType"] = 47] = "Conversation_DialogType";
    /**
     * Silence timeout for listening
     * @member PropertyId.Conversation_Initial_Silence_Timeout
     */ PropertyId[PropertyId["Conversation_Initial_Silence_Timeout"] = 48] = "Conversation_Initial_Silence_Timeout";
    /**
     * From Id to add to speech recognition activities.
     * @member PropertyId.Conversation_From_Id
     */ PropertyId[PropertyId["Conversation_From_Id"] = 49] = "Conversation_From_Id";
    /**
     * ConversationId for the session.
     * @member PropertyId.Conversation_Conversation_Id
     */ PropertyId[PropertyId["Conversation_Conversation_Id"] = 50] = "Conversation_Conversation_Id";
    /**
     * Comma separated list of custom voice deployment ids.
     * @member PropertyId.Conversation_Custom_Voice_Deployment_Ids
     */ PropertyId[PropertyId["Conversation_Custom_Voice_Deployment_Ids"] = 51] = "Conversation_Custom_Voice_Deployment_Ids";
    /**
     * Speech activity template, stamp properties from the template on the activity generated by the service for speech.
     * @member PropertyId.Conversation_Speech_Activity_Template
     * Added in version 1.10.0.
     */ PropertyId[PropertyId["Conversation_Speech_Activity_Template"] = 52] = "Conversation_Speech_Activity_Template";
    /**
     * Enables or disables the receipt of turn status messages as obtained on the turnStatusReceived event.
     * @member PropertyId.Conversation_Request_Bot_Status_Messages
     * Added in version 1.15.0.
     */ PropertyId[PropertyId["Conversation_Request_Bot_Status_Messages"] = 53] = "Conversation_Request_Bot_Status_Messages";
    /**
     * Specifies the connection ID to be provided in the Agent configuration message, e.g. a Direct Line token for
     * channel authentication.
     * Added in version 1.15.1.
     */ PropertyId[PropertyId["Conversation_Agent_Connection_Id"] = 54] = "Conversation_Agent_Connection_Id";
    /**
     * The Cognitive Services Speech Service host (url). Under normal circumstances, you shouldn't have to use this property directly.
     * Instead, use [[SpeechConfig.fromHost]].
     */ PropertyId[PropertyId["SpeechServiceConnection_Host"] = 55] = "SpeechServiceConnection_Host";
    /**
     * Set the host for service calls to the Conversation Translator REST management and websocket calls.
     */ PropertyId[PropertyId["ConversationTranslator_Host"] = 56] = "ConversationTranslator_Host";
    /**
     * Optionally set the the host's display name.
     * Used when joining a conversation.
     */ PropertyId[PropertyId["ConversationTranslator_Name"] = 57] = "ConversationTranslator_Name";
    /**
     * Optionally set a value for the X-CorrelationId request header.
     * Used for troubleshooting errors in the server logs. It should be a valid guid.
     */ PropertyId[PropertyId["ConversationTranslator_CorrelationId"] = 58] = "ConversationTranslator_CorrelationId";
    /**
     * Set the conversation token to be sent to the speech service. This enables the
     * service to service call from the speech service to the Conversation Translator service for relaying
     * recognitions. For internal use.
     */ PropertyId[PropertyId["ConversationTranslator_Token"] = 59] = "ConversationTranslator_Token";
    /**
     * The reference text of the audio for pronunciation evaluation.
     * For this and the following pronunciation assessment parameters, see
     * https://docs.microsoft.com/azure/cognitive-services/speech-service/rest-speech-to-text#pronunciation-assessment-parameters for details.
     * Under normal circumstances, you shouldn't have to use this property directly.
     * Added in version 1.15.0
     */ PropertyId[PropertyId["PronunciationAssessment_ReferenceText"] = 60] = "PronunciationAssessment_ReferenceText";
    /**
     * The point system for pronunciation score calibration (FivePoint or HundredMark).
     * Under normal circumstances, you shouldn't have to use this property directly.
     * Added in version 1.15.0
     */ PropertyId[PropertyId["PronunciationAssessment_GradingSystem"] = 61] = "PronunciationAssessment_GradingSystem";
    /**
     * The pronunciation evaluation granularity (Phoneme, Word, or FullText).
     * Under normal circumstances, you shouldn't have to use this property directly.
     * Added in version 1.15.0
     */ PropertyId[PropertyId["PronunciationAssessment_Granularity"] = 62] = "PronunciationAssessment_Granularity";
    /**
     * Defines if enable miscue calculation.
     * With this enabled, the pronounced words will be compared to the reference text,
     * and will be marked with omission/insertion based on the comparison. The default setting is False.
     * Under normal circumstances, you shouldn't have to use this property directly.
     * Added in version 1.15.0
     */ PropertyId[PropertyId["PronunciationAssessment_EnableMiscue"] = 63] = "PronunciationAssessment_EnableMiscue";
    /**
     * The json string of pronunciation assessment parameters
     * Under normal circumstances, you shouldn't have to use this property directly.
     * Added in version 1.15.0
     */ PropertyId[PropertyId["PronunciationAssessment_Json"] = 64] = "PronunciationAssessment_Json";
    /**
     * Pronunciation assessment parameters.
     * This property is intended to be read-only. The SDK is using it internally.
     * Added in version 1.15.0
     */ PropertyId[PropertyId["PronunciationAssessment_Params"] = 65] = "PronunciationAssessment_Params";
    /**
     * Version of Speaker Recognition API to use.
     * Added in version 1.18.0
     */ PropertyId[PropertyId["SpeakerRecognition_Api_Version"] = 66] = "SpeakerRecognition_Api_Version";
})(PropertyId = exports.PropertyId || (exports.PropertyId = {}));

},{}],"c5ver":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Recognizer = void 0;
var Exports_1 = require("ed627a71f6563a68");
var Exports_2 = require("12901890a1ed665d");
var Contracts_1 = require("6d30d3bb7a776e18");
var Exports_3 = require("ee030535fd6cabbf");
/**
 * Defines the base class Recognizer which mainly contains common event handlers.
 * @class Recognizer
 */ var Recognizer = /** @class */ function() {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer
     */ function Recognizer(audioConfig, properties, connectionFactory) {
        this.audioConfig = audioConfig !== undefined ? audioConfig : Exports_3.AudioConfig.fromDefaultMicrophoneInput();
        this.privDisposed = false;
        this.privProperties = properties.clone();
        this.privConnectionFactory = connectionFactory;
        this.implCommonRecognizerSetup();
    }
    /**
     * Dispose of associated resources.
     * @member Recognizer.prototype.close
     * @function
     * @public
     */ Recognizer.prototype.close = function(cb, errorCb) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposed);
        Exports_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
    };
    Object.defineProperty(Recognizer.prototype, "internalData", {
        /**
         * @Internal
         * Internal data member to support fromRecognizer* pattern methods on other classes.
         * Do not use externally, object returned will change without warning or notice.
         */ get: function() {
            return this.privReco;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Recognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */ Recognizer.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privDisposed) return [
                            2 /*return*/ 
                        ];
                        this.privDisposed = true;
                        if (!disposing) return [
                            3 /*break*/ ,
                            3
                        ];
                        if (!this.privReco) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privReco.audioSource.turnOff()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privReco.dispose()
                        ];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    Object.defineProperty(Recognizer, "telemetryEnabled", {
        /**
         * This method returns the current state of the telemetry setting.
         * @member Recognizer.prototype.telemetryEnabled
         * @function
         * @public
         * @returns true if the telemetry is enabled, false otherwise.
         */ get: function() {
            return Exports_1.ServiceRecognizerBase.telemetryDataEnabled;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * This method globally enables or disables telemetry.
     * @member Recognizer.prototype.enableTelemetry
     * @function
     * @public
     * @param enabled - Global setting for telemetry collection.
     * If set to true, telemetry information like microphone errors,
     * recognition errors are collected and sent to Microsoft.
     * If set to false, no telemetry is sent to Microsoft.
     */ Recognizer.enableTelemetry = function(enabled) {
        Exports_1.ServiceRecognizerBase.telemetryDataEnabled = enabled;
    };
    // Does the generic recognizer setup that is common across all recognizer types.
    Recognizer.prototype.implCommonRecognizerSetup = function() {
        var osPlatform = typeof window !== "undefined" ? "Browser" : "Node";
        var osName = "unknown";
        var osVersion = "unknown";
        if (typeof navigator !== "undefined") {
            osPlatform = osPlatform + "/" + navigator.platform;
            osName = navigator.userAgent;
            osVersion = navigator.appVersion;
        }
        var recognizerConfig = this.createRecognizerConfig(new Exports_1.SpeechServiceConfig(new Exports_1.Context(new Exports_1.OS(osPlatform, osName, osVersion))));
        this.privReco = this.createServiceRecognizer(Recognizer.getAuthFromProperties(this.privProperties), this.privConnectionFactory, this.audioConfig, recognizerConfig);
    };
    Recognizer.prototype.recognizeOnceAsyncImpl = function(recognitionMode) {
        return __awaiter(this, void 0, void 0, function() {
            var ret, result;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        Contracts_1.Contracts.throwIfDisposed(this.privDisposed);
                        ret = new Exports_2.Deferred();
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privReco.recognize(recognitionMode, ret.resolve, ret.reject)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            ret.promise
                        ];
                    case 3:
                        result = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 4:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            result
                        ];
                }
            });
        });
    };
    Recognizer.prototype.startContinuousRecognitionAsyncImpl = function(recognitionMode) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        Contracts_1.Contracts.throwIfDisposed(this.privDisposed);
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privReco.recognize(recognitionMode, undefined, undefined)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    Recognizer.prototype.stopContinuousRecognitionAsyncImpl = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        Contracts_1.Contracts.throwIfDisposed(this.privDisposed);
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    Recognizer.prototype.implRecognizerStop = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!this.privReco) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privReco.stopRecognizing()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    Recognizer.getAuthFromProperties = function(properties) {
        var subscriptionKey = properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Key, undefined);
        var authentication = subscriptionKey && subscriptionKey !== "" ? new Exports_1.CognitiveSubscriptionKeyAuthentication(subscriptionKey) : new Exports_1.CognitiveTokenAuthentication(function() {
            var authorizationToken = properties.getProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token, undefined);
            return Promise.resolve(authorizationToken);
        }, function() {
            var authorizationToken = properties.getProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token, undefined);
            return Promise.resolve(authorizationToken);
        });
        return authentication;
    };
    return Recognizer;
}();
exports.Recognizer = Recognizer;

},{"ed627a71f6563a68":"7Qpvn","12901890a1ed665d":"5Bedw","6d30d3bb7a776e18":"4jwu5","ee030535fd6cabbf":"hxkc3"}],"hfqQW":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechRecognizer = void 0;
var Exports_1 = require("e65d02c56a44a9bd");
var Exports_2 = require("109b3445b3cdeeb2");
var Contracts_1 = require("93b37fb63554b10f");
var Exports_3 = require("7e6fc4e5ad5d6ae5");
/**
 * Performs speech recognition from microphone, file, or other audio input streams, and gets transcribed text as result.
 * @class SpeechRecognizer
 */ var SpeechRecognizer = /** @class */ function(_super) {
    __extends(SpeechRecognizer, _super);
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */ function SpeechRecognizer(speechConfig, audioConfig) {
        var _this = this;
        var speechConfigImpl = speechConfig;
        Contracts_1.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
        Contracts_1.Contracts.throwIfNullOrWhitespace(speechConfigImpl.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
        _this = _super.call(this, audioConfig, speechConfigImpl.properties, new Exports_1.SpeechConnectionFactory()) || this;
        _this.privDisposedRecognizer = false;
        return _this;
    }
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */ SpeechRecognizer.FromConfig = function(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {
        var speechConfigImpl = speechConfig;
        autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);
        var recognizer = new SpeechRecognizer(speechConfig, audioConfig);
        return recognizer;
    };
    Object.defineProperty(SpeechRecognizer.prototype, "endpointId", {
        /**
         * Gets the endpoint id of a customized speech model that is used for speech recognition.
         * @member SpeechRecognizer.prototype.endpointId
         * @function
         * @public
         * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechRecognizer.prototype, "authorizationToken", {
        /**
         * Gets the authorization token used to communicate with the service.
         * @member SpeechRecognizer.prototype.authorizationToken
         * @function
         * @public
         * @returns {string} Authorization token.
         */ get: function() {
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token);
        },
        /**
         * Gets/Sets the authorization token used to communicate with the service.
         * @member SpeechRecognizer.prototype.authorizationToken
         * @function
         * @public
         * @param {string} token - Authorization token.
         */ set: function(token) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(token, "token");
            this.properties.setProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token, token);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechRecognizer.prototype, "speechRecognitionLanguage", {
        /**
         * Gets the spoken language of recognition.
         * @member SpeechRecognizer.prototype.speechRecognitionLanguage
         * @function
         * @public
         * @returns {string} The spoken language of recognition.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechRecognizer.prototype, "outputFormat", {
        /**
         * Gets the output format of recognition.
         * @member SpeechRecognizer.prototype.outputFormat
         * @function
         * @public
         * @returns {OutputFormat} The output format of recognition.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
            if (this.properties.getProperty(Exports_1.OutputFormatPropertyName, Exports_3.OutputFormat[Exports_3.OutputFormat.Simple]) === Exports_3.OutputFormat[Exports_3.OutputFormat.Simple]) return Exports_3.OutputFormat.Simple;
            else return Exports_3.OutputFormat.Detailed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechRecognizer.prototype, "properties", {
        /**
         * The collection of properties and their values defined for this SpeechRecognizer.
         * @member SpeechRecognizer.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Starts speech recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition
     * like command or query. For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member SpeechRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the SpeechRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */ SpeechRecognizer.prototype.recognizeOnceAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(Exports_1.RecognitionMode.Interactive), cb, err);
    };
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member SpeechRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */ SpeechRecognizer.prototype.startContinuousRecognitionAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_1.RecognitionMode.Conversation), cb, err);
    };
    /**
     * Stops continuous speech recognition.
     * @member SpeechRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */ SpeechRecognizer.prototype.stopContinuousRecognitionAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
    };
    /**
     * Starts speech recognition with keyword spotting, until
     * stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model The keyword recognition model that
     * specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */ SpeechRecognizer.prototype.startKeywordRecognitionAsync = function(model, cb, err) {
        Contracts_1.Contracts.throwIfNull(model, "model");
        if (!!err) err("Not yet implemented.");
    };
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */ SpeechRecognizer.prototype.stopKeywordRecognitionAsync = function(cb) {
        if (!!cb) cb();
    };
    /**
     * closes all external resources held by an instance of this class.
     * @member SpeechRecognizer.prototype.close
     * @function
     * @public
     */ SpeechRecognizer.prototype.close = function(cb, errorCb) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
        Exports_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
    };
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */ SpeechRecognizer.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privDisposedRecognizer) return [
                            2 /*return*/ 
                        ];
                        if (!disposing) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privDisposedRecognizer = true;
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            4 /*yield*/ ,
                            _super.prototype.dispose.call(this, disposing)
                        ];
                    case 3:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SpeechRecognizer.prototype.createRecognizerConfig = function(speechConfig) {
        return new Exports_1.RecognizerConfig(speechConfig, this.privProperties);
    };
    SpeechRecognizer.prototype.createServiceRecognizer = function(authentication, connectionFactory, audioConfig, recognizerConfig) {
        var configImpl = audioConfig;
        return new Exports_1.SpeechServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
    };
    return SpeechRecognizer;
}(Exports_3.Recognizer);
exports.SpeechRecognizer = SpeechRecognizer;

},{"e65d02c56a44a9bd":"7Qpvn","109b3445b3cdeeb2":"5Bedw","93b37fb63554b10f":"4jwu5","7e6fc4e5ad5d6ae5":"hxkc3"}],"1Ea8Z":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntentRecognizer = void 0;
var Exports_1 = require("740df6011d885498");
var Exports_2 = require("7dd808c2cdf6d954");
var Contracts_1 = require("e32ec2dc18599950");
var Exports_3 = require("3e01e3b2def0a57");
/**
 * Intent recognizer.
 * @class
 */ var IntentRecognizer = /** @class */ function(_super) {
    __extends(IntentRecognizer, _super);
    /**
     * Initializes an instance of the IntentRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */ function IntentRecognizer(speechConfig, audioConfig) {
        var _this = this;
        Contracts_1.Contracts.throwIfNullOrUndefined(speechConfig, "speechConfig");
        var configImpl = speechConfig;
        Contracts_1.Contracts.throwIfNullOrUndefined(configImpl, "speechConfig");
        _this = _super.call(this, audioConfig, configImpl.properties, new Exports_1.IntentConnectionFactory()) || this;
        _this.privAddedIntents = [];
        _this.privAddedLmIntents = {};
        _this.privDisposedIntentRecognizer = false;
        _this.privProperties = configImpl.properties;
        Contracts_1.Contracts.throwIfNullOrWhitespace(_this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
        return _this;
    }
    Object.defineProperty(IntentRecognizer.prototype, "speechRecognitionLanguage", {
        /**
         * Gets the spoken language of recognition.
         * @member IntentRecognizer.prototype.speechRecognitionLanguage
         * @function
         * @public
         * @returns {string} the spoken language of recognition.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IntentRecognizer.prototype, "authorizationToken", {
        /**
         * Gets the authorization token used to communicate with the service.
         * @member IntentRecognizer.prototype.authorizationToken
         * @function
         * @public
         * @returns {string} Authorization token.
         */ get: function() {
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token);
        },
        /**
         * Gets/Sets the authorization token used to communicate with the service.
         * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.
         * @member IntentRecognizer.prototype.authorizationToken
         * @function
         * @public
         * @param {string} value - Authorization token.
         */ set: function(value) {
            this.properties.setProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IntentRecognizer.prototype, "properties", {
        /**
         * The collection of properties and their values defined for this IntentRecognizer.
         * @member IntentRecognizer.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The collection of properties and their
         * values defined for this IntentRecognizer.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Starts intent recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text and intent as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition like command or query.
     * For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member IntentRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */ IntentRecognizer.prototype.recognizeOnceAsync = function(cb, err) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
        if (Object.keys(this.privAddedLmIntents).length !== 0 || undefined !== this.privUmbrellaIntent) {
            var context = this.buildSpeechContext();
            this.privReco.speechContext.setSection("intent", context.Intent);
            this.privReco.dynamicGrammar.addReferenceGrammar(context.ReferenceGrammars);
            var intentReco = this.privReco;
            intentReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
        }
        Exports_2.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(Exports_1.RecognitionMode.Interactive), cb, err);
    };
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member IntentRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */ IntentRecognizer.prototype.startContinuousRecognitionAsync = function(cb, err) {
        if (Object.keys(this.privAddedLmIntents).length !== 0 || undefined !== this.privUmbrellaIntent) {
            var context = this.buildSpeechContext();
            this.privReco.speechContext.setSection("intent", context.Intent);
            this.privReco.dynamicGrammar.addReferenceGrammar(context.ReferenceGrammars);
            var intentReco = this.privReco;
            intentReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
        }
        Exports_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_1.RecognitionMode.Conversation), cb, err);
    };
    /**
     * Stops continuous intent recognition.
     * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */ IntentRecognizer.prototype.stopContinuousRecognitionAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
    };
    /**
     * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */ IntentRecognizer.prototype.startKeywordRecognitionAsync = function(model, cb, err) {
        Contracts_1.Contracts.throwIfNull(model, "model");
        if (!!err) err("Not yet implemented.");
    };
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */ IntentRecognizer.prototype.stopKeywordRecognitionAsync = function(cb, err) {
        if (!!cb) try {
            cb();
        } catch (e) {
            if (!!err) err(e);
        }
    };
    /**
     * Adds a phrase that should be recognized as intent.
     * @member IntentRecognizer.prototype.addIntent
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent to be recognized.
     * @param {string} phrase - A String that specifies the phrase representing the intent.
     */ IntentRecognizer.prototype.addIntent = function(simplePhrase, intentId) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
        Contracts_1.Contracts.throwIfNullOrWhitespace(intentId, "intentId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(simplePhrase, "simplePhrase");
        this.privAddedIntents.push([
            intentId,
            simplePhrase
        ]);
    };
    /**
     * Adds an intent from Language Understanding service for recognition.
     * @member IntentRecognizer.prototype.addIntentWithLanguageModel
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent
     * to be recognized. Ignored if intentName is empty.
     * @param {string} model - The intent model from Language Understanding service.
     * @param {string} intentName - The intent name defined in the intent model. If it
     * is empty, all intent names defined in the model will be added.
     */ IntentRecognizer.prototype.addIntentWithLanguageModel = function(intentId, model, intentName) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
        Contracts_1.Contracts.throwIfNullOrWhitespace(intentId, "intentId");
        Contracts_1.Contracts.throwIfNull(model, "model");
        var modelImpl = model;
        Contracts_1.Contracts.throwIfNullOrWhitespace(modelImpl.appId, "model.appId");
        this.privAddedLmIntents[intentId] = new Exports_1.AddedLmIntent(modelImpl, intentName);
    };
    /**
     * @summary Adds all intents from the specified Language Understanding Model.
     * @member IntentRecognizer.prototype.addAllIntents
     * @function
     * @public
     * @function
     * @public
     * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.
     * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.
     */ IntentRecognizer.prototype.addAllIntents = function(model, intentId) {
        Contracts_1.Contracts.throwIfNull(model, "model");
        var modelImpl = model;
        Contracts_1.Contracts.throwIfNullOrWhitespace(modelImpl.appId, "model.appId");
        this.privUmbrellaIntent = new Exports_1.AddedLmIntent(modelImpl, intentId);
    };
    /**
     * closes all external resources held by an instance of this class.
     * @member IntentRecognizer.prototype.close
     * @function
     * @public
     */ IntentRecognizer.prototype.close = function(cb, errorCb) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
        Exports_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
    };
    IntentRecognizer.prototype.createRecognizerConfig = function(speechConfig) {
        return new Exports_1.RecognizerConfig(speechConfig, this.privProperties);
    };
    IntentRecognizer.prototype.createServiceRecognizer = function(authentication, connectionFactory, audioConfig, recognizerConfig) {
        var audioImpl = audioConfig;
        return new Exports_1.IntentServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);
    };
    IntentRecognizer.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privDisposedIntentRecognizer) return [
                            2 /*return*/ 
                        ];
                        if (!disposing) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privDisposedIntentRecognizer = true;
                        return [
                            4 /*yield*/ ,
                            _super.prototype.dispose.call(this, disposing)
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    IntentRecognizer.prototype.buildSpeechContext = function() {
        var appId;
        var region;
        var subscriptionKey;
        var refGrammers = [];
        if (undefined !== this.privUmbrellaIntent) {
            appId = this.privUmbrellaIntent.modelImpl.appId;
            region = this.privUmbrellaIntent.modelImpl.region;
            subscriptionKey = this.privUmbrellaIntent.modelImpl.subscriptionKey;
        }
        // Build the reference grammer array.
        for(var _i = 0, _a = Object.keys(this.privAddedLmIntents); _i < _a.length; _i++){
            var intentId = _a[_i];
            var addedLmIntent = this.privAddedLmIntents[intentId];
            // validate all the same model, region, and key...
            if (appId === undefined) appId = addedLmIntent.modelImpl.appId;
            else {
                if (appId !== addedLmIntent.modelImpl.appId) throw new Error("Intents must all be from the same LUIS model");
            }
            if (region === undefined) region = addedLmIntent.modelImpl.region;
            else {
                if (region !== addedLmIntent.modelImpl.region) throw new Error("Intents must all be from the same LUIS model in a single region");
            }
            if (subscriptionKey === undefined) subscriptionKey = addedLmIntent.modelImpl.subscriptionKey;
            else {
                if (subscriptionKey !== addedLmIntent.modelImpl.subscriptionKey) throw new Error("Intents must all use the same subscription key");
            }
            var grammer = "luis/" + appId + "-PRODUCTION#" + intentId;
            refGrammers.push(grammer);
        }
        return {
            Intent: {
                id: appId,
                key: subscriptionKey === undefined ? this.privProperties.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_Key]) : subscriptionKey,
                provider: "LUIS"
            },
            ReferenceGrammars: undefined === this.privUmbrellaIntent ? refGrammers : [
                "luis/" + appId + "-PRODUCTION"
            ]
        };
    };
    return IntentRecognizer;
}(Exports_3.Recognizer);
exports.IntentRecognizer = IntentRecognizer;

},{"740df6011d885498":"7Qpvn","7dd808c2cdf6d954":"5Bedw","e32ec2dc18599950":"4jwu5","3e01e3b2def0a57":"hxkc3"}],"8wwPQ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoiceProfileType = void 0;
/**
 * Output format
 * @class VoiceProfileType
 */ var VoiceProfileType;
(function(VoiceProfileType) {
    /**
     * Text independent speaker identification
     * @member VoiceProfileType.TextIndependentIdentification
     */ VoiceProfileType[VoiceProfileType["TextIndependentIdentification"] = 0] = "TextIndependentIdentification";
    /**
     * Text dependent speaker verification
     * @member VoiceProfileType.TextDependentVerification
     */ VoiceProfileType[VoiceProfileType["TextDependentVerification"] = 1] = "TextDependentVerification";
    /**
     * Text independent speaker verification
     * @member VoiceProfileType.TextIndependentVerification
     */ VoiceProfileType[VoiceProfileType["TextIndependentVerification"] = 2] = "TextIndependentVerification";
})(VoiceProfileType = exports.VoiceProfileType || (exports.VoiceProfileType = {}));

},{}],"68FZq":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationRecognizer = void 0;
var Exports_1 = require("a7e0786baccd434b");
var Exports_2 = require("f5e4e3532f1c7200");
var Connection_1 = require("9178ba774c529f5c");
var Contracts_1 = require("26e02d0e93fd07d2");
var Exports_3 = require("314b304419972657");
/**
 * Translation recognizer
 * @class TranslationRecognizer
 */ var TranslationRecognizer = /** @class */ function(_super) {
    __extends(TranslationRecognizer, _super);
    /**
     * Initializes an instance of the TranslationRecognizer.
     * @constructor
     * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     * @param {IConnectionFactory} connectionFactory - An optional connection factory to use to generate the endpoint URIs, headers to set, etc...
     */ function TranslationRecognizer(speechConfig, audioConfig, connectionFactory) {
        var _this = this;
        var configImpl = speechConfig;
        Contracts_1.Contracts.throwIfNull(configImpl, "speechConfig");
        _this = _super.call(this, audioConfig, configImpl.properties, connectionFactory || new Exports_1.TranslationConnectionFactory()) || this;
        _this.privDisposedTranslationRecognizer = false;
        if (_this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationVoice, undefined) !== undefined) Contracts_1.Contracts.throwIfNullOrWhitespace(_this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationVoice), Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_TranslationVoice]);
        Contracts_1.Contracts.throwIfNullOrWhitespace(_this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationToLanguages), Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_TranslationToLanguages]);
        Contracts_1.Contracts.throwIfNullOrWhitespace(_this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
        return _this;
    }
    /**
     * TranslationRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */ TranslationRecognizer.FromConfig = function(speechTranslationConfig, autoDetectSourceLanguageConfig, audioConfig) {
        var speechTranslationConfigImpl = speechTranslationConfig;
        autoDetectSourceLanguageConfig.properties.mergeTo(speechTranslationConfigImpl.properties);
        return new TranslationRecognizer(speechTranslationConfig, audioConfig);
    };
    Object.defineProperty(TranslationRecognizer.prototype, "speechRecognitionLanguage", {
        /**
         * Gets the language name that was set when the recognizer was created.
         * @member TranslationRecognizer.prototype.speechRecognitionLanguage
         * @function
         * @public
         * @returns {string} Gets the language name that was set when the recognizer was created.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationRecognizer.prototype, "targetLanguages", {
        /**
         * Gets target languages for translation that were set when the recognizer was created.
         * The language is specified in BCP-47 format. The translation will provide translated text for each of language.
         * @member TranslationRecognizer.prototype.targetLanguages
         * @function
         * @public
         * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationRecognizer.prototype, "voiceName", {
        /**
         * Gets the name of output voice.
         * @member TranslationRecognizer.prototype.voiceName
         * @function
         * @public
         * @returns {string} the name of output voice.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationVoice, undefined);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationRecognizer.prototype, "properties", {
        /**
         * The collection of properties and their values defined for this TranslationRecognizer.
         * @member TranslationRecognizer.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationRecognizer.prototype, "authorizationToken", {
        /**
         * Gets the authorization token used to communicate with the service.
         * @member TranslationRecognizer.prototype.authorizationToken
         * @function
         * @public
         * @returns {string} Authorization token.
         */ get: function() {
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token);
        },
        /**
         * Gets/Sets the authorization token used to communicate with the service.
         * @member TranslationRecognizer.prototype.authorizationToken
         * @function
         * @public
         * @param {string} value - Authorization token.
         */ set: function(value) {
            this.properties.setProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token, value);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Starts recognition and translation, and stops after the first utterance is recognized.
     * The task returns the translation text as result.
     * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only
     * for single shot recognition like command or query. For long-running recognition,
     * use startContinuousRecognitionAsync() instead.
     * @member TranslationRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the translation has completed.
     * @param err - Callback invoked in case of an error.
     */ TranslationRecognizer.prototype.recognizeOnceAsync = function(cb, err) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
        Exports_2.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(Exports_1.RecognitionMode.Conversation), cb, err);
    };
    /**
     * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive translation results.
     * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has started.
     * @param err - Callback invoked in case of an error.
     */ TranslationRecognizer.prototype.startContinuousRecognitionAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_1.RecognitionMode.Conversation), cb, err);
    };
    /**
     * Stops continuous recognition and translation.
     * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has stopped.
     * @param err - Callback invoked in case of an error.
     */ TranslationRecognizer.prototype.stopContinuousRecognitionAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
    };
    /**
     * dynamically remove a language from list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.removeTargetLanguage
     * @function
     * @param lang - language to be removed
     * @public
     */ TranslationRecognizer.prototype.removeTargetLanguage = function(lang) {
        Contracts_1.Contracts.throwIfNullOrUndefined(lang, "language to be removed");
        if (this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {
            var languages = this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
            var index = languages.indexOf(lang);
            if (index > -1) {
                languages.splice(index, 1);
                this.properties.setProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(","));
                this.updateLanguages(languages);
            }
        }
    };
    /**
     * dynamically add a language to list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.addTargetLanguage
     * @function
     * @param lang - language to be added
     * @public
     */ TranslationRecognizer.prototype.addTargetLanguage = function(lang) {
        Contracts_1.Contracts.throwIfNullOrUndefined(lang, "language to be added");
        var languages = [];
        if (this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {
            languages = this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
            if (!languages.includes(lang)) {
                languages.push(lang);
                this.properties.setProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(","));
            }
        } else {
            this.properties.setProperty(Exports_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, lang);
            languages = [
                lang
            ];
        }
        this.updateLanguages(languages);
    };
    /**
     * closes all external resources held by an instance of this class.
     * @member TranslationRecognizer.prototype.close
     * @function
     * @public
     */ TranslationRecognizer.prototype.close = function(cb, errorCb) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
        Exports_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
    };
    /**
     * handles ConnectionEstablishedEvent for conversation translation scenarios.
     * @member TranslationRecognizer.prototype.onConnection
     * @function
     * @public
     */ // eslint-disable-next-line @typescript-eslint/no-empty-function
    TranslationRecognizer.prototype.onConnection = function() {};
    /**
     * handles disconnection events for conversation translation scenarios.
     * @member TranslationRecognizer.prototype.onDisconnection
     * @function
     * @public
     */ // eslint-disable-next-line @typescript-eslint/no-empty-function
    TranslationRecognizer.prototype.onDisconnection = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                return [
                    2 /*return*/ 
                ];
            });
        });
    };
    TranslationRecognizer.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privDisposedTranslationRecognizer) return [
                            2 /*return*/ 
                        ];
                        this.privDisposedTranslationRecognizer = true;
                        if (!disposing) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            _super.prototype.dispose.call(this, disposing)
                        ];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    TranslationRecognizer.prototype.createRecognizerConfig = function(speechConfig) {
        return new Exports_1.RecognizerConfig(speechConfig, this.privProperties);
    };
    TranslationRecognizer.prototype.createServiceRecognizer = function(authentication, connectionFactory, audioConfig, recognizerConfig) {
        var configImpl = audioConfig;
        return new Exports_1.TranslationServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
    };
    TranslationRecognizer.prototype.updateLanguages = function(languages) {
        var conn = Connection_1.Connection.fromRecognizer(this);
        if (!!conn) {
            conn.setMessageProperty("speech.context", "translationcontext", {
                to: languages
            });
            conn.sendMessageAsync("event", JSON.stringify({
                id: "translation",
                name: "updateLanguage",
                to: languages
            }));
        }
    };
    return TranslationRecognizer;
}(Exports_3.Recognizer);
exports.TranslationRecognizer = TranslationRecognizer;

},{"a7e0786baccd434b":"7Qpvn","f5e4e3532f1c7200":"5Bedw","9178ba774c529f5c":"6O7VR","26e02d0e93fd07d2":"4jwu5","314b304419972657":"hxkc3"}],"6O7VR":[function(require,module,exports) {
"use strict";
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Connection = void 0;
var Exports_1 = require("109ae5b3e2c3d851");
var Exports_2 = require("24e7341ea16f2d9a");
var ConnectionMessage_1 = require("75fc018c09fc60a7");
var Contracts_1 = require("253bd4c2d319d200");
var Exports_3 = require("f776c0a7643e9eb9");
/**
 * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.
 * By default, a Recognizer autonomously manages connection to service when needed.
 * The Connection class provides additional methods for users to explicitly open or close a connection and
 * to subscribe to connection status changes.
 * The use of Connection is optional, and mainly for scenarios where fine tuning of application
 * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection
 * in advance before starting recognition on the Recognizer associated with this Connection.
 * If the Recognizer needs to connect or disconnect to service, it will
 * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection
 * status via Connected/Disconnected events.
 * Added in version 1.2.1.
 */ var Connection = /** @class */ function() {
    function Connection() {}
    /**
     * Gets the Connection instance from the specified recognizer.
     * @param recognizer The recognizer associated with the connection.
     * @return The Connection instance of the recognizer.
     */ Connection.fromRecognizer = function(recognizer) {
        var recoBase = recognizer.internalData;
        var ret = new Connection();
        ret.privInternalData = recoBase;
        ret.setupEvents();
        return ret;
    };
    /**
     * Gets the Connection instance from the specified synthesizer.
     * @param synthesizer The synthesizer associated with the connection.
     * @return The Connection instance of the synthesizer.
     */ Connection.fromSynthesizer = function(synthesizer) {
        var synthBase = synthesizer.internalData;
        var ret = new Connection();
        ret.privInternalData = synthBase;
        ret.setupEvents();
        return ret;
    };
    /**
     * Starts to set up connection to the service.
     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the
     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     */ Connection.prototype.openConnection = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.privInternalData.connect(), cb, err);
    };
    /**
     * Closes the connection the service.
     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.
     *
     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.
     */ Connection.prototype.closeConnection = function(cb, err) {
        if (this.privInternalData instanceof Exports_1.SynthesisAdapterBase) throw new Error("Disconnecting a synthesizer's connection is currently not supported");
        else Exports_2.marshalPromiseToCallbacks(this.privInternalData.disconnect(), cb, err);
    };
    /**
     * Appends a parameter in a message to service.
     * Added in version 1.12.1.
     * @param path The path of the network message.
     * @param propertyName Name of the property
     * @param propertyValue Value of the property. This is a json string.
     */ Connection.prototype.setMessageProperty = function(path, propertyName, propertyValue) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(propertyName, "propertyName");
        if (this.privInternalData instanceof Exports_1.ServiceRecognizerBase) {
            if (path.toLowerCase() !== "speech.context") throw new Error("Only speech.context message property sets are currently supported for recognizer");
            else this.privInternalData.speechContext.setSection(propertyName, propertyValue);
        } else if (this.privInternalData instanceof Exports_1.SynthesisAdapterBase) {
            if (path.toLowerCase() !== "synthesis.context") throw new Error("Only synthesis.context message property sets are currently supported for synthesizer");
            else this.privInternalData.synthesisContext.setSection(propertyName, propertyValue);
        }
    };
    /**
     * Sends a message to the speech service.
     * Added in version 1.13.0.
     * @param path The WebSocket path of the message
     * @param payload The payload of the message. This is a json string or a ArrayBuffer.
     * @param success A callback to indicate success.
     * @param error A callback to indicate an error.
     */ Connection.prototype.sendMessageAsync = function(path, payload, success, error) {
        Exports_2.marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(path, payload), success, error);
    };
    /**
     * Dispose of associated resources.
     */ Connection.prototype.close = function() {
    /* eslint-disable no-empty */ };
    Connection.prototype.setupEvents = function() {
        var _this = this;
        this.privEventListener = this.privInternalData.connectionEvents.attach(function(connectionEvent) {
            if (connectionEvent.name === "ConnectionEstablishedEvent") {
                if (!!_this.connected) _this.connected(new Exports_3.ConnectionEventArgs(connectionEvent.connectionId));
            } else if (connectionEvent.name === "ConnectionClosedEvent") {
                if (!!_this.disconnected) _this.disconnected(new Exports_3.ConnectionEventArgs(connectionEvent.connectionId));
            } else if (connectionEvent.name === "ConnectionMessageSentEvent") {
                if (!!_this.messageSent) _this.messageSent(new Exports_3.ConnectionMessageEventArgs(new ConnectionMessage_1.ConnectionMessageImpl(connectionEvent.message)));
            } else if (connectionEvent.name === "ConnectionMessageReceivedEvent") {
                if (!!_this.messageReceived) _this.messageReceived(new Exports_3.ConnectionMessageEventArgs(new ConnectionMessage_1.ConnectionMessageImpl(connectionEvent.message)));
            }
        });
        this.privServiceEventListener = this.privInternalData.serviceEvents.attach(function(e) {
            if (!!_this.receivedServiceMessage) _this.receivedServiceMessage(new Exports_3.ServiceEventArgs(e.jsonString, e.name));
        });
    };
    return Connection;
}();
exports.Connection = Connection;

},{"109ae5b3e2c3d851":"7Qpvn","24e7341ea16f2d9a":"5Bedw","75fc018c09fc60a7":"1bz2k","253bd4c2d319d200":"4jwu5","f776c0a7643e9eb9":"hxkc3"}],"1bz2k":[function(require,module,exports) {
"use strict";
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionMessageImpl = exports.ConnectionMessage = void 0;
// eslint-disable-next-line max-classes-per-file
var HeaderNames_1 = require("6b4be6814ea1d44b");
var Exports_1 = require("95f0b9be8795191b");
var PropertyCollection_1 = require("b303d394b6247d63");
var PropertyId_1 = require("b66ef060172aade8");
/**
 * ConnectionMessage represents implementation specific messages sent to and received from
 * the speech service. These messages are provided for debugging purposes and should not
 * be used for production use cases with the Azure Cognitive Services Speech Service.
 * Messages sent to and received from the Speech Service are subject to change without
 * notice. This includes message contents, headers, payloads, ordering, etc.
 * Added in version 1.11.0.
 */ var ConnectionMessage = /** @class */ function() {
    function ConnectionMessage() {}
    return ConnectionMessage;
}();
exports.ConnectionMessage = ConnectionMessage;
var ConnectionMessageImpl = /** @class */ function() {
    function ConnectionMessageImpl(message) {
        var _this = this;
        this.privConnectionMessage = message;
        this.privProperties = new PropertyCollection_1.PropertyCollection();
        if (!!this.privConnectionMessage.headers[HeaderNames_1.HeaderNames.ConnectionId]) this.privProperties.setProperty(PropertyId_1.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[HeaderNames_1.HeaderNames.ConnectionId]);
        Object.keys(this.privConnectionMessage.headers).forEach(function(header) {
            _this.privProperties.setProperty(header, _this.privConnectionMessage.headers[header]);
        });
    }
    Object.defineProperty(ConnectionMessageImpl.prototype, "path", {
        /**
         * The message path.
         */ get: function() {
            return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find(function(key) {
                return key.toLowerCase() === "path".toLowerCase();
            })];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessageImpl.prototype, "isTextMessage", {
        /**
         * Checks to see if the ConnectionMessage is a text message.
         * See also IsBinaryMessage().
         */ get: function() {
            return this.privConnectionMessage.messageType === Exports_1.MessageType.Text;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessageImpl.prototype, "isBinaryMessage", {
        /**
         * Checks to see if the ConnectionMessage is a binary message.
         * See also GetBinaryMessage().
         */ get: function() {
            return this.privConnectionMessage.messageType === Exports_1.MessageType.Binary;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessageImpl.prototype, "TextMessage", {
        /**
         * Gets the text message payload. Typically the text message content-type is
         * application/json. To determine other content-types use
         * Properties.GetProperty("Content-Type").
         */ get: function() {
            return this.privConnectionMessage.textBody;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessageImpl.prototype, "binaryMessage", {
        /**
         * Gets the binary message payload.
         */ get: function() {
            return this.privConnectionMessage.binaryBody;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectionMessageImpl.prototype, "properties", {
        /**
         * A collection of properties and their values defined for this <see cref="ConnectionMessage"/>.
         * Message headers can be accessed via this collection (e.g. "Content-Type").
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns a string that represents the connection message.
     */ ConnectionMessageImpl.prototype.toString = function() {
        return "";
    };
    return ConnectionMessageImpl;
}();
exports.ConnectionMessageImpl = ConnectionMessageImpl;

},{"6b4be6814ea1d44b":"bNYHA","95f0b9be8795191b":"5Bedw","b303d394b6247d63":"jfzZ9","b66ef060172aade8":"6Rdzq"}],"gon5O":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Translations = void 0;
var Exports_1 = require("9d199a89b47ee4f8");
/**
 * Represents collection of parameters and their values.
 * @class Translations
 */ var Translations = /** @class */ function() {
    function Translations() {
        // Use an PropertyCollection internally, just wrapping it to hide the | enum syntax it has.
        this.privMap = new Exports_1.PropertyCollection();
    }
    Object.defineProperty(Translations.prototype, "languages", {
        /**
         * Get the languages in the object in a String array.
         * @member Translations.prototype.languages
         * @function
         * @public
         * @returns {string[]} languages in translations object.
         */ get: function() {
            return this.privMap.keys;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns the parameter value in type String. The parameter must have the same type as String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member Translations.prototype.get
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} def - The default value which is returned if the parameter is not available in the collection.
     * @returns {string} value of the parameter.
     */ Translations.prototype.get = function(key, def) {
        return this.privMap.getProperty(key, def);
    };
    /**
     * Sets the String value of the parameter specified by name.
     * @member Translations.prototype.set
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */ Translations.prototype.set = function(key, value) {
        this.privMap.setProperty(key, value);
    };
    return Translations;
}();
exports.Translations = Translations;

},{"9d199a89b47ee4f8":"hxkc3"}],"eevn2":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoMatchReason = void 0;
/**
 * Defines the possible reasons a recognition result might not be recognized.
 * @class NoMatchReason
 */ var NoMatchReason;
(function(NoMatchReason) {
    /**
     * Indicates that speech was detected, but not recognized.
     * @member NoMatchReason.NotRecognized
     */ NoMatchReason[NoMatchReason["NotRecognized"] = 0] = "NotRecognized";
    /**
     * Indicates that the start of the audio stream contained only silence,
     * and the service timed out waiting for speech.
     * @member NoMatchReason.InitialSilenceTimeout
     */ NoMatchReason[NoMatchReason["InitialSilenceTimeout"] = 1] = "InitialSilenceTimeout";
    /**
     * Indicates that the start of the audio stream contained only noise,
     * and the service timed out waiting for speech.
     * @member NoMatchReason.InitialBabbleTimeout
     */ NoMatchReason[NoMatchReason["InitialBabbleTimeout"] = 2] = "InitialBabbleTimeout";
})(NoMatchReason = exports.NoMatchReason || (exports.NoMatchReason = {}));

},{}],"i3GJV":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoMatchDetails = void 0;
var Exports_1 = require("6972565b05a39ee0");
var Exports_2 = require("6d6385d89ca656b6");
/**
 * Contains detailed information for NoMatch recognition results.
 * @class NoMatchDetails
 */ var NoMatchDetails = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {NoMatchReason} reason - The no-match reason.
     */ function NoMatchDetails(reason) {
        this.privReason = reason;
    }
    /**
     * Creates an instance of NoMatchDetails object for the NoMatch SpeechRecognitionResults.
     * @member NoMatchDetails.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult | IntentRecognitionResult | TranslationRecognitionResult}
     * result - The recognition result that was not recognized.
     * @returns {NoMatchDetails} The no match details object being created.
     */ NoMatchDetails.fromResult = function(result) {
        var simpleSpeech = Exports_1.SimpleSpeechPhrase.fromJSON(result.json);
        var reason = Exports_2.NoMatchReason.NotRecognized;
        switch(simpleSpeech.RecognitionStatus){
            case Exports_1.RecognitionStatus.BabbleTimeout:
                reason = Exports_2.NoMatchReason.InitialBabbleTimeout;
                break;
            case Exports_1.RecognitionStatus.InitialSilenceTimeout:
                reason = Exports_2.NoMatchReason.InitialSilenceTimeout;
                break;
            default:
                reason = Exports_2.NoMatchReason.NotRecognized;
                break;
        }
        return new NoMatchDetails(reason);
    };
    Object.defineProperty(NoMatchDetails.prototype, "reason", {
        /**
         * The reason the recognition was canceled.
         * @member NoMatchDetails.prototype.reason
         * @function
         * @public
         * @returns {NoMatchReason} Specifies the reason canceled.
         */ get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    return NoMatchDetails;
}();
exports.NoMatchDetails = NoMatchDetails;

},{"6972565b05a39ee0":"7Qpvn","6d6385d89ca656b6":"hxkc3"}],"iKuA1":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationRecognitionCanceledEventArgs = void 0;
/**
 * Define payload of speech recognition canceled result events.
 * @class TranslationRecognitionCanceledEventArgs
 */ var TranslationRecognitionCanceledEventArgs = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} sessionid - The session id.
     * @param {CancellationReason} cancellationReason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {TranslationRecognitionResult} result - The result.
     */ function TranslationRecognitionCanceledEventArgs(sessionid, cancellationReason, errorDetails, errorCode, result) {
        this.privCancelReason = cancellationReason;
        this.privErrorDetails = errorDetails;
        this.privResult = result;
        this.privSessionId = sessionid;
        this.privErrorCode = errorCode;
    }
    Object.defineProperty(TranslationRecognitionCanceledEventArgs.prototype, "result", {
        /**
         * Specifies the recognition result.
         * @member TranslationRecognitionCanceledEventArgs.prototype.result
         * @function
         * @public
         * @returns {TranslationRecognitionResult} the recognition result.
         */ get: function() {
            return this.privResult;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationRecognitionCanceledEventArgs.prototype, "sessionId", {
        /**
         * Specifies the session identifier.
         * @member TranslationRecognitionCanceledEventArgs.prototype.sessionId
         * @function
         * @public
         * @returns {string} the session identifier.
         */ get: function() {
            return this.privSessionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationRecognitionCanceledEventArgs.prototype, "reason", {
        /**
         * The reason the recognition was canceled.
         * @member TranslationRecognitionCanceledEventArgs.prototype.reason
         * @function
         * @public
         * @returns {CancellationReason} Specifies the reason canceled.
         */ get: function() {
            return this.privCancelReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationRecognitionCanceledEventArgs.prototype, "errorCode", {
        /**
         * The error code in case of an unsuccessful recognition.
         * Added in version 1.1.0.
         * @return An error code that represents the error reason.
         */ get: function() {
            return this.privErrorCode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationRecognitionCanceledEventArgs.prototype, "errorDetails", {
        /**
         * In case of an unsuccessful recognition, provides details of the occurred error.
         * @member TranslationRecognitionCanceledEventArgs.prototype.errorDetails
         * @function
         * @public
         * @returns {string} A String that represents the error details.
         */ get: function() {
            return this.privErrorDetails;
        },
        enumerable: false,
        configurable: true
    });
    return TranslationRecognitionCanceledEventArgs;
}();
exports.TranslationRecognitionCanceledEventArgs = TranslationRecognitionCanceledEventArgs;

},{}],"f9DIh":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntentRecognitionCanceledEventArgs = void 0;
var Exports_1 = require("f644ed2010528938");
/**
 * Define payload of intent recognition canceled result events.
 * @class IntentRecognitionCanceledEventArgs
 */ var IntentRecognitionCanceledEventArgs = /** @class */ function(_super) {
    __extends(IntentRecognitionCanceledEventArgs, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} result - The result of the intent recognition.
     * @param {string} offset - The offset.
     * @param {IntentRecognitionResult} sessionId - The session id.
     */ function IntentRecognitionCanceledEventArgs(reason, errorDetails, errorCode, result, offset, sessionId) {
        var _this = _super.call(this, result, offset, sessionId) || this;
        _this.privReason = reason;
        _this.privErrorDetails = errorDetails;
        _this.privErrorCode = errorCode;
        return _this;
    }
    Object.defineProperty(IntentRecognitionCanceledEventArgs.prototype, "reason", {
        /**
         * The reason the recognition was canceled.
         * @member IntentRecognitionCanceledEventArgs.prototype.reason
         * @function
         * @public
         * @returns {CancellationReason} Specifies the reason canceled.
         */ get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IntentRecognitionCanceledEventArgs.prototype, "errorCode", {
        /**
         * The error code in case of an unsuccessful recognition.
         * Added in version 1.1.0.
         * @return An error code that represents the error reason.
         */ get: function() {
            return this.privErrorCode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IntentRecognitionCanceledEventArgs.prototype, "errorDetails", {
        /**
         * In case of an unsuccessful recognition, provides details of the occurred error.
         * @member IntentRecognitionCanceledEventArgs.prototype.errorDetails
         * @function
         * @public
         * @returns {string} A String that represents the error details.
         */ get: function() {
            return this.privErrorDetails;
        },
        enumerable: false,
        configurable: true
    });
    return IntentRecognitionCanceledEventArgs;
}(Exports_1.IntentRecognitionEventArgs);
exports.IntentRecognitionCanceledEventArgs = IntentRecognitionCanceledEventArgs;

},{"f644ed2010528938":"hxkc3"}],"9oXOl":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CancellationDetailsBase = void 0;
/**
 * Contains detailed information about why a result was canceled.
 * @class CancellationDetailsBase
 */ var CancellationDetailsBase = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - The error details, if provided.
     */ function CancellationDetailsBase(reason, errorDetails, errorCode) {
        this.privReason = reason;
        this.privErrorDetails = errorDetails;
        this.privErrorCode = errorCode;
    }
    Object.defineProperty(CancellationDetailsBase.prototype, "reason", {
        /**
         * The reason the recognition was canceled.
         * @member CancellationDetailsBase.prototype.reason
         * @function
         * @public
         * @returns {CancellationReason} Specifies the reason canceled.
         */ get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CancellationDetailsBase.prototype, "errorDetails", {
        /**
         * In case of an unsuccessful recognition, provides details of the occurred error.
         * @member CancellationDetailsBase.prototype.errorDetails
         * @function
         * @public
         * @returns {string} A String that represents the error details.
         */ get: function() {
            return this.privErrorDetails;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CancellationDetailsBase.prototype, "ErrorCode", {
        /**
         * The error code in case of an unsuccessful recognition.
         * Added in version 1.1.0.
         * @return An error code that represents the error reason.
         */ get: function() {
            return this.privErrorCode;
        },
        enumerable: false,
        configurable: true
    });
    return CancellationDetailsBase;
}();
exports.CancellationDetailsBase = CancellationDetailsBase;

},{}],"aLF5A":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CancellationDetails = void 0;
var Exports_1 = require("b9dda31bf2b560c5");
var CancellationDetailsBase_1 = require("2bbde155df0ac911");
var Exports_2 = require("9fea23466b426ebc");
/**
 * Contains detailed information about why a result was canceled.
 * @class CancellationDetails
 */ var CancellationDetails = /** @class */ function(_super) {
    __extends(CancellationDetails, _super);
    function CancellationDetails(reason, errorDetails, errorCode) {
        return _super.call(this, reason, errorDetails, errorCode) || this;
    }
    /**
     * Creates an instance of CancellationDetails object for the canceled RecognitionResult.
     * @member CancellationDetails.fromResult
     * @function
     * @public
     * @param {RecognitionResult | SpeechSynthesisResult} result - The result that was canceled.
     * @returns {CancellationDetails} The cancellation details object being created.
     */ CancellationDetails.fromResult = function(result) {
        var reason = Exports_2.CancellationReason.Error;
        var errorCode = Exports_2.CancellationErrorCode.NoError;
        if (result instanceof Exports_2.RecognitionResult && !!result.json) {
            var simpleSpeech = Exports_1.SimpleSpeechPhrase.fromJSON(result.json);
            reason = Exports_1.EnumTranslation.implTranslateCancelResult(simpleSpeech.RecognitionStatus);
        }
        if (!!result.properties) errorCode = Exports_2.CancellationErrorCode[result.properties.getProperty(Exports_1.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[Exports_2.CancellationErrorCode.NoError])];
        return new CancellationDetails(reason, result.errorDetails || Exports_1.EnumTranslation.implTranslateErrorDetails(errorCode), errorCode);
    };
    return CancellationDetails;
}(CancellationDetailsBase_1.CancellationDetailsBase);
exports.CancellationDetails = CancellationDetails;

},{"b9dda31bf2b560c5":"7Qpvn","2bbde155df0ac911":"9oXOl","9fea23466b426ebc":"hxkc3"}],"bs4bZ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CancellationErrorCode = void 0;
/**
 * Defines error code in case that CancellationReason is Error.
 * Added in version 1.1.0.
 */ var CancellationErrorCode;
(function(CancellationErrorCode) {
    /**
     * Indicates that no error occurred during speech recognition.
     */ CancellationErrorCode[CancellationErrorCode["NoError"] = 0] = "NoError";
    /**
     * Indicates an authentication error.
     */ CancellationErrorCode[CancellationErrorCode["AuthenticationFailure"] = 1] = "AuthenticationFailure";
    /**
     * Indicates that one or more recognition parameters are invalid.
     */ CancellationErrorCode[CancellationErrorCode["BadRequestParameters"] = 2] = "BadRequestParameters";
    /**
     * Indicates that the number of parallel requests exceeded the number of allowed
     * concurrent transcriptions for the subscription.
     */ CancellationErrorCode[CancellationErrorCode["TooManyRequests"] = 3] = "TooManyRequests";
    /**
     * Indicates a connection error.
     */ CancellationErrorCode[CancellationErrorCode["ConnectionFailure"] = 4] = "ConnectionFailure";
    /**
     * Indicates a time-out error when waiting for response from service.
     */ CancellationErrorCode[CancellationErrorCode["ServiceTimeout"] = 5] = "ServiceTimeout";
    /**
     * Indicates that an error is returned by the service.
     */ CancellationErrorCode[CancellationErrorCode["ServiceError"] = 6] = "ServiceError";
    /**
     * Indicates an unexpected runtime error.
     */ CancellationErrorCode[CancellationErrorCode["RuntimeError"] = 7] = "RuntimeError";
    /**
     * Indicates an quota overrun on existing key.
     */ CancellationErrorCode[CancellationErrorCode["Forbidden"] = 8] = "Forbidden";
})(CancellationErrorCode = exports.CancellationErrorCode || (exports.CancellationErrorCode = {}));

},{}],"fFQRG":[function(require,module,exports) {
"use strict";
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionEventArgs = void 0;
var Exports_1 = require("6aca0b3dabc8954e");
/**
 * Defines payload for connection events like Connected/Disconnected.
 * Added in version 1.2.0
 */ var ConnectionEventArgs = /** @class */ function(_super) {
    __extends(ConnectionEventArgs, _super);
    function ConnectionEventArgs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ConnectionEventArgs;
}(Exports_1.SessionEventArgs);
exports.ConnectionEventArgs = ConnectionEventArgs;

},{"6aca0b3dabc8954e":"hxkc3"}],"l2QCH":[function(require,module,exports) {
"use strict";
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServiceEventArgs = void 0;
var Exports_1 = require("8a5b1be68c1887b8");
/**
 * Defines payload for any Service message event
 * Added in version 1.9.0
 */ var ServiceEventArgs = /** @class */ function(_super) {
    __extends(ServiceEventArgs, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} json - json payload of the USP message.
     */ function ServiceEventArgs(json, name, sessionId) {
        var _this = _super.call(this, sessionId) || this;
        _this.privJsonResult = json;
        _this.privEventName = name;
        return _this;
    }
    Object.defineProperty(ServiceEventArgs.prototype, "jsonString", {
        get: function() {
            return this.privJsonResult;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServiceEventArgs.prototype, "eventName", {
        get: function() {
            return this.privEventName;
        },
        enumerable: false,
        configurable: true
    });
    return ServiceEventArgs;
}(Exports_1.SessionEventArgs);
exports.ServiceEventArgs = ServiceEventArgs;

},{"8a5b1be68c1887b8":"hxkc3"}],"bvcgC":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PhraseListGrammar = void 0;
/**
 * Allows additions of new phrases to improve speech recognition.
 *
 * Phrases added to the recognizer are effective at the start of the next recognition, or the next time the SpeechSDK must reconnect
 * to the speech service.
 */ var PhraseListGrammar = /** @class */ function() {
    function PhraseListGrammar(recogBase) {
        this.privGrammerBuilder = recogBase.dynamicGrammar;
    }
    /**
     * Creates a PhraseListGrammar from a given speech recognizer. Will accept any recognizer that derives from @class Recognizer.
     * @param recognizer The recognizer to add phrase lists to.
     */ PhraseListGrammar.fromRecognizer = function(recognizer) {
        var recoBase = recognizer.internalData;
        return new PhraseListGrammar(recoBase);
    };
    /**
     * Adds a single phrase to the current recognizer.
     * @param phrase Phrase to add.
     */ PhraseListGrammar.prototype.addPhrase = function(phrase) {
        this.privGrammerBuilder.addPhrase(phrase);
    };
    /**
     * Adds multiple phrases to the current recognizer.
     * @param phrases Array of phrases to add.
     */ PhraseListGrammar.prototype.addPhrases = function(phrases) {
        this.privGrammerBuilder.addPhrase(phrases);
    };
    /**
     * Clears all phrases added to the current recognizer.
     */ PhraseListGrammar.prototype.clear = function() {
        this.privGrammerBuilder.clearPhrases();
    };
    return PhraseListGrammar;
}();
exports.PhraseListGrammar = PhraseListGrammar;

},{}],"5hc1l":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DialogServiceConfigImpl = exports.DialogServiceConfig = void 0;
/* eslint-disable max-classes-per-file */ var Contracts_1 = require("987451538f184a07");
var Exports_1 = require("fdf79e4ad22fa14");
/**
 * Class that defines base configurations for dialog service connector
 * @class DialogServiceConfig
 */ var DialogServiceConfig = /** @class */ function() {
    /**
     * Creates an instance of DialogService config.
     * @constructor
     */ function DialogServiceConfig() {
        return;
    }
    Object.defineProperty(DialogServiceConfig.prototype, "applicationId", {
        /**
         * Sets the corresponding backend application identifier.
         * @member DialogServiceConfig.prototype.Conversation_ApplicationId
         * @function
         * @public
         * @param {string} value - The application identifier to set.
         */ // eslint-disable-next-line @typescript-eslint/no-empty-function
        set: function(value) {},
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DialogServiceConfig, "DialogTypes", {
        get: function() {
            return {
                BotFramework: "bot_framework",
                CustomCommands: "custom_commands"
            };
        },
        enumerable: false,
        configurable: true
    });
    return DialogServiceConfig;
}();
exports.DialogServiceConfig = DialogServiceConfig;
/**
 * Dialog Service configuration.
 * @class DialogServiceConfigImpl
 */ var DialogServiceConfigImpl = /** @class */ function(_super) {
    __extends(DialogServiceConfigImpl, _super);
    /**
     * Creates an instance of dialogService config.
     */ function DialogServiceConfigImpl() {
        var _this = _super.call(this) || this;
        _this.privSpeechConfig = new Exports_1.SpeechConfigImpl();
        return _this;
    }
    Object.defineProperty(DialogServiceConfigImpl.prototype, "properties", {
        /**
         * Provides access to custom properties.
         * @member DialogServiceConfigImpl.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The properties.
         */ get: function() {
            return this.privSpeechConfig.properties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DialogServiceConfigImpl.prototype, "speechRecognitionLanguage", {
        /**
         * Gets the speech recognition language.
         * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
         * @function
         * @public
         */ get: function() {
            return this.privSpeechConfig.speechRecognitionLanguage;
        },
        /**
         * Sets the speech recognition language.
         * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
         * @function
         * @public
         * @param {string} value - The language to set.
         */ set: function(value) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(value, "value");
            this.privSpeechConfig.speechRecognitionLanguage = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DialogServiceConfigImpl.prototype, "outputFormat", {
        get: function() {
            return this.privSpeechConfig.outputFormat;
        },
        set: function(value) {
            this.privSpeechConfig.outputFormat = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to set.
     * @param {string} value - The value.
     */ DialogServiceConfigImpl.prototype.setProperty = function(name, value) {
        this.privSpeechConfig.setProperty(name, value);
    };
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to get.
     * @param {string} def - The default value to return in case the property is not known.
     * @returns {string} The current value, or provided default, of the given property.
     */ DialogServiceConfigImpl.prototype.getProperty = function(name, def) {
        return this.privSpeechConfig.getProperty(name);
    };
    /**
     * Sets the proxy configuration.
     * Only relevant in Node.js environments.
     * Added in version 1.4.0.
     * @param proxyHostName The host name of the proxy server, without the protocol scheme (http://)
     * @param proxyPort The port number of the proxy server.
     * @param proxyUserName The user name of the proxy server.
     * @param proxyPassword The password of the proxy server.
     */ DialogServiceConfigImpl.prototype.setProxy = function(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
        this.setProperty(Exports_1.PropertyId.SpeechServiceConnection_ProxyHostName, proxyHostName);
        this.setProperty(Exports_1.PropertyId.SpeechServiceConnection_ProxyPort, "" + proxyPort);
        if (proxyUserName) this.setProperty(Exports_1.PropertyId.SpeechServiceConnection_ProxyUserName, proxyUserName);
        if (proxyPassword) this.setProperty(Exports_1.PropertyId.SpeechServiceConnection_ProxyPassword, proxyPassword);
    };
    DialogServiceConfigImpl.prototype.setServiceProperty = function(name, value, channel) {
        this.privSpeechConfig.setServiceProperty(name, value);
    };
    /**
     * Dispose of associated resources.
     * @member DialogServiceConfigImpl.prototype.close
     * @function
     * @public
     */ DialogServiceConfigImpl.prototype.close = function() {
        return;
    };
    return DialogServiceConfigImpl;
}(DialogServiceConfig);
exports.DialogServiceConfigImpl = DialogServiceConfigImpl;

},{"987451538f184a07":"4jwu5","fdf79e4ad22fa14":"hxkc3"}],"5hvMW":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BotFrameworkConfig = void 0;
var Contracts_1 = require("2860e124101938f1");
var DialogServiceConfig_1 = require("52c96b1a46f4b141");
var Exports_1 = require("a1f3ea2086225ed1");
/**
 * Class that defines configurations for the dialog service connector object for using a Bot Framework backend.
 * @class BotFrameworkConfig
 */ var BotFrameworkConfig = /** @class */ function(_super) {
    __extends(BotFrameworkConfig, _super);
    /**
     * Creates an instance of BotFrameworkConfig.
     */ function BotFrameworkConfig() {
        return _super.call(this) || this;
    }
    /**
     * Creates a bot framework configuration instance with the provided subscription information.
     * @member BotFrameworkConfig.fromSubscription
     * @function
     * @public
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */ BotFrameworkConfig.fromSubscription = function(subscription, region, botId) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(subscription, "subscription");
        Contracts_1.Contracts.throwIfNullOrWhitespace(region, "region");
        var botFrameworkConfig = new DialogServiceConfig_1.DialogServiceConfigImpl();
        botFrameworkConfig.setProperty(Exports_1.PropertyId.Conversation_DialogType, DialogServiceConfig_1.DialogServiceConfig.DialogTypes.BotFramework);
        botFrameworkConfig.setProperty(Exports_1.PropertyId.SpeechServiceConnection_Key, subscription);
        botFrameworkConfig.setProperty(Exports_1.PropertyId.SpeechServiceConnection_Region, region);
        if (botId) botFrameworkConfig.setProperty(Exports_1.PropertyId.Conversation_ApplicationId, botId);
        return botFrameworkConfig;
    };
    /**
     * Creates a bot framework configuration instance for the specified authorization token and region.
     * Note: The caller must ensure that an authorization token is valid. Before an authorization token expires, the
     * caller must refresh it by setting the authorizationToken property on the corresponding
     * DialogServiceConnector instance created with this config. The contents of configuration objects are copied
     * when connectors are created, so setting authorizationToken on a DialogServiceConnector will not update the
     * original configuration's authorization token. Create a new configuration instance or set the
     * SpeechServiceAuthorization_Token property to update an existing instance if it will be used to create
     * further DialogServiceConnectors.
     * @member BotFrameworkConfig.fromAuthorizationToken
     * @function
     * @public
     * @param authorizationToken The authorization token associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */ BotFrameworkConfig.fromAuthorizationToken = function(authorizationToken, region, botId) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(authorizationToken, "authorizationToken");
        Contracts_1.Contracts.throwIfNullOrWhitespace(region, "region");
        var botFrameworkConfig = new DialogServiceConfig_1.DialogServiceConfigImpl();
        botFrameworkConfig.setProperty(Exports_1.PropertyId.Conversation_DialogType, DialogServiceConfig_1.DialogServiceConfig.DialogTypes.BotFramework);
        botFrameworkConfig.setProperty(Exports_1.PropertyId.SpeechServiceAuthorization_Token, authorizationToken);
        botFrameworkConfig.setProperty(Exports_1.PropertyId.SpeechServiceConnection_Region, region);
        if (botId) botFrameworkConfig.setProperty(Exports_1.PropertyId.Conversation_ApplicationId, botId);
        return botFrameworkConfig;
    };
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-default service host. The standard resource path will be
     * assumed. For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL) and then set the AuthorizationToken
     * property on the created BotFrameworkConfig instance.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromHost
     * @function
     * @public
     * @param {URL | string} host - If a URL is provided, the fully-qualified host with protocol (e.g.
     * wss://your.host.com:1234) will be used. If a string is provided, it will be embedded in
     * wss://{host}.convai.speech.azure.us.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */ BotFrameworkConfig.fromHost = function(host, subscriptionKey, botId) {
        Contracts_1.Contracts.throwIfNullOrUndefined(host, "host");
        var resolvedHost = host instanceof URL ? host : new URL("wss://" + host + ".convai.speech.azure.us");
        Contracts_1.Contracts.throwIfNullOrUndefined(resolvedHost, "resolvedHost");
        var botFrameworkConfig = new DialogServiceConfig_1.DialogServiceConfigImpl();
        botFrameworkConfig.setProperty(Exports_1.PropertyId.Conversation_DialogType, DialogServiceConfig_1.DialogServiceConfig.DialogTypes.BotFramework);
        botFrameworkConfig.setProperty(Exports_1.PropertyId.SpeechServiceConnection_Host, resolvedHost.toString());
        if (undefined !== subscriptionKey) botFrameworkConfig.setProperty(Exports_1.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
        return botFrameworkConfig;
    };
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created BotFrameworkConfig instance to
     * use the authorization token.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @returns {BotFrameworkConfig} - A new bot framework configuration instance using the provided endpoint.
     */ BotFrameworkConfig.fromEndpoint = function(endpoint, subscriptionKey) {
        Contracts_1.Contracts.throwIfNull(endpoint, "endpoint");
        var botFrameworkConfig = new DialogServiceConfig_1.DialogServiceConfigImpl();
        botFrameworkConfig.setProperty(Exports_1.PropertyId.Conversation_DialogType, DialogServiceConfig_1.DialogServiceConfig.DialogTypes.BotFramework);
        botFrameworkConfig.setProperty(Exports_1.PropertyId.SpeechServiceConnection_Endpoint, endpoint.toString());
        if (undefined !== subscriptionKey) botFrameworkConfig.setProperty(Exports_1.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
        return botFrameworkConfig;
    };
    return BotFrameworkConfig;
}(DialogServiceConfig_1.DialogServiceConfigImpl);
exports.BotFrameworkConfig = BotFrameworkConfig;

},{"2860e124101938f1":"4jwu5","52c96b1a46f4b141":"5hc1l","a1f3ea2086225ed1":"hxkc3"}],"3KSme":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CustomCommandsConfig = void 0;
var Contracts_1 = require("a1414516c0c943aa");
var DialogServiceConfig_1 = require("49903a1f5bbd3a8d");
var Exports_1 = require("37ba7adde2920e6a");
/**
 * Class that defines configurations for the dialog service connector object for using a CustomCommands backend.
 * @class CustomCommandsConfig
 */ var CustomCommandsConfig = /** @class */ function(_super) {
    __extends(CustomCommandsConfig, _super);
    /**
     * Creates an instance of CustomCommandsConfig.
     */ function CustomCommandsConfig() {
        return _super.call(this) || this;
    }
    /**
     * Creates an instance of the bot framework config with the specified subscription and region.
     * @member CustomCommandsConfig.fromSubscription
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new bot framework config.
     */ CustomCommandsConfig.fromSubscription = function(applicationId, subscription, region) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(applicationId, "applicationId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(subscription, "subscription");
        Contracts_1.Contracts.throwIfNullOrWhitespace(region, "region");
        var customCommandsConfig = new DialogServiceConfig_1.DialogServiceConfigImpl();
        customCommandsConfig.setProperty(Exports_1.PropertyId.Conversation_DialogType, DialogServiceConfig_1.DialogServiceConfig.DialogTypes.CustomCommands);
        customCommandsConfig.setProperty(Exports_1.PropertyId.Conversation_ApplicationId, applicationId);
        customCommandsConfig.setProperty(Exports_1.PropertyId.SpeechServiceConnection_Key, subscription);
        customCommandsConfig.setProperty(Exports_1.PropertyId.SpeechServiceConnection_Region, region);
        return customCommandsConfig;
    };
    /**
     * Creates an instance of the bot framework config with the specified Speech Commands application id, authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member CustomCommandsConfig.fromAuthorizationToken
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param authorizationToken The authorization token associated with the application.
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new speech commands config.
     */ CustomCommandsConfig.fromAuthorizationToken = function(applicationId, authorizationToken, region) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(applicationId, "applicationId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(authorizationToken, "authorizationToken");
        Contracts_1.Contracts.throwIfNullOrWhitespace(region, "region");
        var customCommandsConfig = new DialogServiceConfig_1.DialogServiceConfigImpl();
        customCommandsConfig.setProperty(Exports_1.PropertyId.Conversation_DialogType, DialogServiceConfig_1.DialogServiceConfig.DialogTypes.CustomCommands);
        customCommandsConfig.setProperty(Exports_1.PropertyId.Conversation_ApplicationId, applicationId);
        customCommandsConfig.setProperty(Exports_1.PropertyId.SpeechServiceAuthorization_Token, authorizationToken);
        customCommandsConfig.setProperty(Exports_1.PropertyId.SpeechServiceConnection_Region, region);
        return customCommandsConfig;
    };
    Object.defineProperty(CustomCommandsConfig.prototype, "applicationId", {
        /**
         * Gets the corresponding backend application identifier.
         * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
         * @function
         * @public
         * @param {string} value - The application identifier to get.
         */ get: function() {
            return this.getProperty(Exports_1.PropertyId.Conversation_ApplicationId);
        },
        /**
         * Sets the corresponding backend application identifier.
         * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
         * @function
         * @public
         * @param {string} value - The application identifier to set.
         */ set: function(value) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(value, "value");
            this.setProperty(Exports_1.PropertyId.Conversation_ApplicationId, value);
        },
        enumerable: false,
        configurable: true
    });
    return CustomCommandsConfig;
}(DialogServiceConfig_1.DialogServiceConfigImpl);
exports.CustomCommandsConfig = CustomCommandsConfig;

},{"a1414516c0c943aa":"4jwu5","49903a1f5bbd3a8d":"5hc1l","37ba7adde2920e6a":"hxkc3"}],"bUp2i":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DialogServiceConnector = void 0;
var DialogConnectorFactory_1 = require("f001cf08717971df");
var Exports_1 = require("de322480cc725a6d");
var Exports_2 = require("a9938208cf724bb8");
var Contracts_1 = require("e02067535a45bb9e");
var Exports_3 = require("4efdfc580da7fc5b");
var PropertyId_1 = require("cd1f5686c06b9353");
/**
 * Dialog Service Connector
 * @class DialogServiceConnector
 */ var DialogServiceConnector = /** @class */ function(_super) {
    __extends(DialogServiceConnector, _super);
    /**
     * Initializes an instance of the DialogServiceConnector.
     * @constructor
     * @param {DialogServiceConfig} dialogConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     */ function DialogServiceConnector(dialogConfig, audioConfig) {
        var _this = this;
        var dialogServiceConfigImpl = dialogConfig;
        Contracts_1.Contracts.throwIfNull(dialogConfig, "dialogConfig");
        _this = _super.call(this, audioConfig, dialogServiceConfigImpl.properties, new DialogConnectorFactory_1.DialogConnectionFactory()) || this;
        _this.isTurnComplete = true;
        _this.privIsDisposed = false;
        _this.privProperties = dialogServiceConfigImpl.properties.clone();
        var agentConfig = _this.buildAgentConfig();
        _this.privReco.agentConfig.set(agentConfig);
        return _this;
    }
    /**
     * Starts a connection to the service.
     * Users can optionally call connect() to manually set up a connection in advance, before starting interactions.
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     * @member DialogServiceConnector.prototype.connect
     * @function
     * @public
     */ DialogServiceConnector.prototype.connect = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.privReco.connect(), cb, err);
    };
    /**
     * Closes the connection the service.
     * Users can optionally call disconnect() to manually shutdown the connection of the associated DialogServiceConnector.
     *
     * If disconnect() is called during a recognition, recognition will fail and cancel with an error.
     */ DialogServiceConnector.prototype.disconnect = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.privReco.disconnect(), cb, err);
    };
    Object.defineProperty(DialogServiceConnector.prototype, "authorizationToken", {
        /**
         * Gets the authorization token used to communicate with the service.
         * @member DialogServiceConnector.prototype.authorizationToken
         * @function
         * @public
         * @returns {string} Authorization token.
         */ get: function() {
            return this.properties.getProperty(PropertyId_1.PropertyId.SpeechServiceAuthorization_Token);
        },
        /**
         * Sets the authorization token used to communicate with the service.
         * @member DialogServiceConnector.prototype.authorizationToken
         * @function
         * @public
         * @param {string} token - Authorization token.
         */ set: function(token) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(token, "token");
            this.properties.setProperty(PropertyId_1.PropertyId.SpeechServiceAuthorization_Token, token);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DialogServiceConnector.prototype, "properties", {
        /**
         * The collection of properties and their values defined for this DialogServiceConnector.
         * @member DialogServiceConnector.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The collection of properties and their values defined for this DialogServiceConnector.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DialogServiceConnector.prototype, "speechActivityTemplate", {
        /** Gets the template for the activity generated by service from speech.
         * Properties from the template will be stamped on the generated activity.
         * It can be empty
         */ get: function() {
            return this.properties.getProperty(PropertyId_1.PropertyId.Conversation_Speech_Activity_Template);
        },
        /** Sets the template for the activity generated by service from speech.
         * Properties from the template will be stamped on the generated activity.
         * It can be null or empty.
         * Note: it has to be a valid Json object.
         */ set: function(speechActivityTemplate) {
            this.properties.setProperty(PropertyId_1.PropertyId.Conversation_Speech_Activity_Template, speechActivityTemplate);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Starts recognition and stops after the first utterance is recognized.
     * @member DialogServiceConnector.prototype.listenOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the reco has completed.
     * @param err - Callback invoked in case of an error.
     */ DialogServiceConnector.prototype.listenOnceAsync = function(cb, err) {
        var _this = this;
        if (this.isTurnComplete) {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            var callbackHolder = function() {
                return __awaiter(_this, void 0, void 0, function() {
                    var ret, e;
                    return __generator(this, function(_a) {
                        switch(_a.label){
                            case 0:
                                return [
                                    4 /*yield*/ ,
                                    this.privReco.connect()
                                ];
                            case 1:
                                _a.sent();
                                return [
                                    4 /*yield*/ ,
                                    this.implRecognizerStop()
                                ];
                            case 2:
                                _a.sent();
                                this.isTurnComplete = false;
                                ret = new Exports_2.Deferred();
                                return [
                                    4 /*yield*/ ,
                                    this.privReco.recognize(Exports_1.RecognitionMode.Conversation, ret.resolve, ret.reject)
                                ];
                            case 3:
                                _a.sent();
                                return [
                                    4 /*yield*/ ,
                                    ret.promise
                                ];
                            case 4:
                                e = _a.sent();
                                return [
                                    4 /*yield*/ ,
                                    this.implRecognizerStop()
                                ];
                            case 5:
                                _a.sent();
                                return [
                                    2 /*return*/ ,
                                    e
                                ];
                        }
                    });
                });
            };
            var retPromise = callbackHolder();
            retPromise.catch(function() {
                // Destroy the recognizer.
                // We've done all we can here.
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                _this.dispose(true).catch(function() {});
            });
            Exports_2.marshalPromiseToCallbacks(retPromise.finally(function() {
                _this.isTurnComplete = true;
            }), cb, err);
        }
    };
    DialogServiceConnector.prototype.sendActivityAsync = function(activity, cb, errCb) {
        Exports_2.marshalPromiseToCallbacks(this.privReco.sendMessage(activity), cb, errCb);
    };
    /**
     * closes all external resources held by an instance of this class.
     * @member DialogServiceConnector.prototype.close
     * @function
     * @public
     */ DialogServiceConnector.prototype.close = function(cb, err) {
        Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
        Exports_2.marshalPromiseToCallbacks(this.dispose(true), cb, err);
    };
    DialogServiceConnector.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privIsDisposed) return [
                            2 /*return*/ 
                        ];
                        if (!disposing) return [
                            3 /*break*/ ,
                            3
                        ];
                        this.privIsDisposed = true;
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            _super.prototype.dispose.call(this, disposing)
                        ];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    DialogServiceConnector.prototype.createRecognizerConfig = function(speechConfig) {
        return new Exports_1.RecognizerConfig(speechConfig, this.privProperties);
    };
    DialogServiceConnector.prototype.createServiceRecognizer = function(authentication, connectionFactory, audioConfig, recognizerConfig) {
        var audioSource = audioConfig;
        return new Exports_1.DialogServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);
    };
    DialogServiceConnector.prototype.buildAgentConfig = function() {
        var communicationType = this.properties.getProperty("Conversation_Communication_Type", "Default");
        return {
            botInfo: {
                commType: communicationType,
                commandsCulture: undefined,
                connectionId: this.properties.getProperty(PropertyId_1.PropertyId.Conversation_Agent_Connection_Id),
                conversationId: this.properties.getProperty(PropertyId_1.PropertyId.Conversation_Conversation_Id, undefined),
                fromId: this.properties.getProperty(PropertyId_1.PropertyId.Conversation_From_Id, undefined),
                ttsAudioFormat: this.properties.getProperty(PropertyId_1.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)
            },
            version: 0.2
        };
    };
    return DialogServiceConnector;
}(Exports_3.Recognizer);
exports.DialogServiceConnector = DialogServiceConnector;

},{"f001cf08717971df":"bRd2F","de322480cc725a6d":"7Qpvn","a9938208cf724bb8":"5Bedw","e02067535a45bb9e":"4jwu5","4efdfc580da7fc5b":"hxkc3","cd1f5686c06b9353":"6Rdzq"}],"bRd2F":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DialogConnectionFactory = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("b56b6b3acddf091d");
var Exports_2 = require("80e6cdbc38516e8a");
var Exports_3 = require("3ab4a8a0a734e6a0");
var ConnectionFactoryBase_1 = require("bfc644efd86d12e2");
var Exports_4 = require("fedbe73f569ae077");
var HeaderNames_1 = require("afc05fa982921c3a");
var QueryParameterNames_1 = require("8c4f9f2fd7d2d04");
var DialogConnectionFactory = /** @class */ function(_super) {
    __extends(DialogConnectionFactory, _super);
    function DialogConnectionFactory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DialogConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        var applicationId = config.parameters.getProperty(Exports_3.PropertyId.Conversation_ApplicationId, "");
        var dialogType = config.parameters.getProperty(Exports_3.PropertyId.Conversation_DialogType);
        var region = config.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Region);
        var language = config.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US");
        var requestTurnStatus = config.parameters.getProperty(Exports_3.PropertyId.Conversation_Request_Bot_Status_Messages, "true");
        var queryParams = {};
        queryParams[HeaderNames_1.HeaderNames.ConnectionId] = connectionId;
        queryParams[QueryParameterNames_1.QueryParameterNames.Format] = config.parameters.getProperty(Exports_2.OutputFormatPropertyName, Exports_3.OutputFormat[Exports_3.OutputFormat.Simple]).toLowerCase();
        queryParams[QueryParameterNames_1.QueryParameterNames.Language] = language;
        queryParams[QueryParameterNames_1.QueryParameterNames.RequestBotStatusMessages] = requestTurnStatus;
        if (applicationId) {
            queryParams[QueryParameterNames_1.QueryParameterNames.BotId] = applicationId;
            if (dialogType === Exports_3.DialogServiceConfig.DialogTypes.CustomCommands) queryParams[HeaderNames_1.HeaderNames.CustomCommandsAppId] = applicationId;
        }
        var resourceInfix = dialogType === Exports_3.DialogServiceConfig.DialogTypes.CustomCommands ? "commands/" : "";
        var version = dialogType === Exports_3.DialogServiceConfig.DialogTypes.CustomCommands ? "v1" : dialogType === Exports_3.DialogServiceConfig.DialogTypes.BotFramework ? "v3" : "v0";
        var headers = {};
        if (authInfo.token != null && authInfo.token !== "") headers[authInfo.headerName] = authInfo.token;
        // The URL used for connection is chosen in a priority order of specification:
        //  1. If a custom endpoint is provided, that URL is used verbatim.
        //  2. If a custom host is provided (e.g. "wss://my.custom.endpoint.com:1123"), a URL is constructed from it.
        //  3. If no custom connection details are provided, a URL is constructed from default values.
        var endpoint = config.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Endpoint, "");
        if (!endpoint) {
            var hostSuffix = ConnectionFactoryBase_1.ConnectionFactoryBase.getHostSuffix(region);
            var host = config.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Host, "wss://" + region + "." + DialogConnectionFactory.BaseUrl + hostSuffix);
            var standardizedHost = host.endsWith("/") ? host : host + "/";
            endpoint = "" + standardizedHost + resourceInfix + DialogConnectionFactory.ApiKey + "/" + version;
        }
        this.setCommonUrlParams(config, queryParams, endpoint);
        var enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
        return new Exports_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_4.WebsocketMessageFormatter(), Exports_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    };
    DialogConnectionFactory.ApiKey = "api";
    DialogConnectionFactory.BaseUrl = "convai.speech";
    return DialogConnectionFactory;
}(ConnectionFactoryBase_1.ConnectionFactoryBase);
exports.DialogConnectionFactory = DialogConnectionFactory;

},{"b56b6b3acddf091d":"9oZeQ","80e6cdbc38516e8a":"7Qpvn","3ab4a8a0a734e6a0":"hxkc3","bfc644efd86d12e2":"hvoIt","fedbe73f569ae077":"7Qpvn","afc05fa982921c3a":"bNYHA","8c4f9f2fd7d2d04":"fLrjT"}],"hvoIt":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionFactoryBase = void 0;
var Exports_1 = require("ed9298986c2b35f1");
var Exports_2 = require("8c2dfa81510fab9d");
var QueryParameterNames_1 = require("30a31abfdb963c59");
var ConnectionFactoryBase = /** @class */ function() {
    function ConnectionFactoryBase() {}
    ConnectionFactoryBase.getHostSuffix = function(region) {
        if (!!region) {
            if (region.toLowerCase().startsWith("china")) return ".azure.cn";
            if (region.toLowerCase().startsWith("usgov")) return ".azure.us";
        }
        return ".microsoft.com";
    };
    ConnectionFactoryBase.prototype.setCommonUrlParams = function(config, queryParams, endpoint) {
        var _this = this;
        var propertyIdToParameterMap = new Map([
            [
                Exports_2.PropertyId.Speech_SegmentationSilenceTimeoutMs,
                QueryParameterNames_1.QueryParameterNames.SegmentationSilenceTimeoutMs
            ],
            [
                Exports_2.PropertyId.SpeechServiceConnection_EnableAudioLogging,
                QueryParameterNames_1.QueryParameterNames.EnableAudioLogging
            ],
            [
                Exports_2.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs,
                QueryParameterNames_1.QueryParameterNames.EndSilenceTimeoutMs
            ],
            [
                Exports_2.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs,
                QueryParameterNames_1.QueryParameterNames.InitialSilenceTimeoutMs
            ],
            [
                Exports_2.PropertyId.SpeechServiceResponse_PostProcessingOption,
                QueryParameterNames_1.QueryParameterNames.Postprocessing
            ],
            [
                Exports_2.PropertyId.SpeechServiceResponse_ProfanityOption,
                QueryParameterNames_1.QueryParameterNames.Profanity
            ],
            [
                Exports_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps,
                QueryParameterNames_1.QueryParameterNames.EnableWordLevelTimestamps
            ],
            [
                Exports_2.PropertyId.SpeechServiceResponse_StablePartialResultThreshold,
                QueryParameterNames_1.QueryParameterNames.StableIntermediateThreshold
            ]
        ]);
        propertyIdToParameterMap.forEach(function(parameterName, propertyId) {
            _this.setUrlParameter(propertyId, parameterName, config, queryParams, endpoint);
        });
        var serviceProperties = JSON.parse(config.parameters.getProperty(Exports_1.ServicePropertiesPropertyName, "{}"));
        Object.keys(serviceProperties).forEach(function(value) {
            queryParams[value] = serviceProperties[value];
        });
    };
    ConnectionFactoryBase.prototype.setUrlParameter = function(propId, parameterName, config, queryParams, endpoint) {
        var value = config.parameters.getProperty(propId, undefined);
        // FIXME: The .search() check will incorrectly match parameter name anywhere in the string
        //        including e.g. the path portion, or even as a substring of other query parameters
        if (value && (!endpoint || endpoint.search(parameterName) === -1)) queryParams[parameterName] = value.toLocaleLowerCase();
    };
    return ConnectionFactoryBase;
}();
exports.ConnectionFactoryBase = ConnectionFactoryBase;

},{"ed9298986c2b35f1":"7Qpvn","8c2dfa81510fab9d":"hxkc3","30a31abfdb963c59":"fLrjT"}],"fLrjT":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryParameterNames = void 0;
var QueryParameterNames = /** @class */ function() {
    function QueryParameterNames() {}
    QueryParameterNames.BotId = "botid";
    QueryParameterNames.CustomSpeechDeploymentId = "cid";
    QueryParameterNames.CustomVoiceDeploymentId = "deploymentId";
    QueryParameterNames.EnableAudioLogging = "storeAudio";
    QueryParameterNames.EnableLanguageId = "lidEnabled";
    QueryParameterNames.EnableWordLevelTimestamps = "wordLevelTimestamps";
    QueryParameterNames.EndSilenceTimeoutMs = "endSilenceTimeoutMs";
    QueryParameterNames.SegmentationSilenceTimeoutMs = "segmentationSilenceTimeoutMs";
    QueryParameterNames.Format = "format";
    QueryParameterNames.InitialSilenceTimeoutMs = "initialSilenceTimeoutMs";
    QueryParameterNames.Language = "language";
    QueryParameterNames.Profanity = "profanity";
    QueryParameterNames.RequestBotStatusMessages = "enableBotMessageStatus";
    QueryParameterNames.StableIntermediateThreshold = "stableIntermediateThreshold";
    QueryParameterNames.StableTranslation = "stableTranslation";
    QueryParameterNames.TestHooks = "testhooks";
    QueryParameterNames.Postprocessing = "postprocessing";
    QueryParameterNames.CtsMeetingId = "meetingId";
    QueryParameterNames.CtsDeviceId = "deviceId";
    QueryParameterNames.CtsIsParticipant = "isParticipant";
    return QueryParameterNames;
}();
exports.QueryParameterNames = QueryParameterNames;

},{}],"5H9ue":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ActivityReceivedEventArgs = void 0;
/**
 * Defines contents of received message/events.
 * @class ActivityReceivedEventArgs
 */ var ActivityReceivedEventArgs = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {any} activity - The activity..
     */ function ActivityReceivedEventArgs(activity, audioStream) {
        this.privActivity = activity;
        this.privAudioStream = audioStream;
    }
    Object.defineProperty(ActivityReceivedEventArgs.prototype, "activity", {
        /**
         * Gets the received activity
         * @member ActivityReceivedEventArgs.prototype.activity
         * @function
         * @public
         * @returns {any} the received activity.
         */ get: function() {
            return this.privActivity;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ActivityReceivedEventArgs.prototype, "audioStream", {
        get: function() {
            return this.privAudioStream;
        },
        enumerable: false,
        configurable: true
    });
    return ActivityReceivedEventArgs;
}();
exports.ActivityReceivedEventArgs = ActivityReceivedEventArgs;

},{}],"2T7cQ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TurnStatusReceivedEventArgs = void 0;
var TurnStatusPayload_1 = require("1c44b397bcd3689");
/**
 * Defines contents of received message/events.
 * @class TurnStatusReceivedEventArgs
 */ var TurnStatusReceivedEventArgs = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} turnStatus - The JSON-encoded turn status message.
     */ function TurnStatusReceivedEventArgs(turnStatus) {
        this.privTurnStatus = TurnStatusPayload_1.TurnStatusResponsePayload.fromJSON(turnStatus);
    }
    Object.defineProperty(TurnStatusReceivedEventArgs.prototype, "interactionId", {
        /**
         * Gets the interaction identifier associated with this turn status event.
         * @member TurnStatusReceivedEventArgs.prototype.interactionId
         * @function
         * @public
         * @returns {any} the received interaction id.
         */ get: function() {
            return this.privTurnStatus.interactionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TurnStatusReceivedEventArgs.prototype, "conversationId", {
        /**
         * Gets the conversation identifier associated with this turn status event.
         * @member TurnStatusReceivedEventArgs.prototype.conversationId
         * @function
         * @public
         * @returns {any} the received conversation id.
         */ get: function() {
            return this.privTurnStatus.conversationId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TurnStatusReceivedEventArgs.prototype, "statusCode", {
        /**
         * Gets the received turn status code.
         * @member TurnStatusReceivedEventArgs.prototype.statusCode
         * @function
         * @public
         * @returns {number} the received turn status.
         */ get: function() {
            return this.privTurnStatus.statusCode; // eslint-disable-line @typescript-eslint/no-unsafe-return
        },
        enumerable: false,
        configurable: true
    });
    return TurnStatusReceivedEventArgs;
}();
exports.TurnStatusReceivedEventArgs = TurnStatusReceivedEventArgs;

},{"1c44b397bcd3689":"6jEO3"}],"6jEO3":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TurnStatusResponsePayload = void 0;
var TurnStatusResponsePayload = /** @class */ function() {
    function TurnStatusResponsePayload(json) {
        this.privMessageStatusResponse = JSON.parse(json);
    }
    TurnStatusResponsePayload.fromJSON = function(json) {
        return new TurnStatusResponsePayload(json);
    };
    Object.defineProperty(TurnStatusResponsePayload.prototype, "interactionId", {
        get: function() {
            return this.privMessageStatusResponse.interactionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TurnStatusResponsePayload.prototype, "conversationId", {
        get: function() {
            return this.privMessageStatusResponse.conversationId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TurnStatusResponsePayload.prototype, "statusCode", {
        get: function() {
            // Payloads may contain a limited set of textual representations or a numeric status
            // code. The textual values are here converted into numeric ones.
            switch(this.privMessageStatusResponse.statusCode){
                case "Success":
                    return 200;
                case "Failed":
                    return 400;
                case "TimedOut":
                    return 429;
                default:
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return this.privMessageStatusResponse.statusCode;
            }
        },
        enumerable: false,
        configurable: true
    });
    return TurnStatusResponsePayload;
}();
exports.TurnStatusResponsePayload = TurnStatusResponsePayload;

},{}],"aWjLW":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServicePropertyChannel = void 0;
/**
 * Defines channels used to pass property settings to service.
 * Added in version 1.7.0.
 */ var ServicePropertyChannel;
(function(ServicePropertyChannel) {
    /**
     * Uses URI query parameter to pass property settings to service.
     */ ServicePropertyChannel[ServicePropertyChannel["UriQueryParameter"] = 0] = "UriQueryParameter";
})(ServicePropertyChannel = exports.ServicePropertyChannel || (exports.ServicePropertyChannel = {}));

},{}],"4bTun":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProfanityOption = void 0;
/**
 * Profanity option.
 * Added in version 1.7.0.
 */ var ProfanityOption;
(function(ProfanityOption) {
    ProfanityOption[ProfanityOption["Masked"] = 0] = "Masked";
    ProfanityOption[ProfanityOption["Removed"] = 1] = "Removed";
    ProfanityOption[ProfanityOption["Raw"] = 2] = "Raw";
})(ProfanityOption = exports.ProfanityOption || (exports.ProfanityOption = {}));

},{}],"ijOdN":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseAudioPlayer = void 0;
var Error_1 = require("1cf79aea9b3b6a4e");
var Exports_1 = require("dacede810cfb37f3");
var AudioStreamFormat_1 = require("a853f3b385739414");
/**
 * Base audio player class
 * TODO: Plays only PCM for now.
 * @class
 */ var BaseAudioPlayer = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.
     */ function BaseAudioPlayer(audioFormat) {
        this.audioContext = null;
        this.gainNode = null;
        this.autoUpdateBufferTimer = 0;
        if (audioFormat === undefined) audioFormat = Exports_1.AudioStreamFormat.getDefaultInputFormat();
        this.init(audioFormat);
    }
    /**
     * play Audio sample
     * @param newAudioData audio data to be played.
     */ BaseAudioPlayer.prototype.playAudioSample = function(newAudioData, cb, err) {
        try {
            this.ensureInitializedContext();
            var audioData = this.formatAudioData(newAudioData);
            var newSamplesData = new Float32Array(this.samples.length + audioData.length);
            newSamplesData.set(this.samples, 0);
            newSamplesData.set(audioData, this.samples.length);
            this.samples = newSamplesData;
            if (!!cb) cb();
        } catch (e) {
            if (!!err) err(e);
        }
    };
    /**
     * stops audio and clears the buffers
     */ BaseAudioPlayer.prototype.stopAudio = function(cb, err) {
        if (this.audioContext !== null) {
            this.samples = new Float32Array();
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            clearInterval(this.autoUpdateBufferTimer);
            this.audioContext.close().then(function() {
                if (!!cb) cb();
            }, function(error) {
                if (!!err) err(error);
            });
            this.audioContext = null;
        }
    };
    BaseAudioPlayer.prototype.init = function(audioFormat) {
        this.audioFormat = audioFormat;
        this.samples = new Float32Array();
    };
    BaseAudioPlayer.prototype.ensureInitializedContext = function() {
        var _this = this;
        if (this.audioContext === null) {
            this.createAudioContext();
            var timerPeriod = 200;
            this.autoUpdateBufferTimer = setInterval(function() {
                _this.updateAudioBuffer();
            }, timerPeriod);
        }
    };
    BaseAudioPlayer.prototype.createAudioContext = function() {
        // new ((window as any).AudioContext || (window as any).webkitAudioContext)();
        this.audioContext = AudioStreamFormat_1.AudioStreamFormatImpl.getAudioContext();
        // TODO: Various examples shows this gain node, it does not seem to be needed unless we plan
        // to control the volume, not likely
        this.gainNode = this.audioContext.createGain();
        this.gainNode.gain.value = 1;
        this.gainNode.connect(this.audioContext.destination);
        this.startTime = this.audioContext.currentTime;
    };
    BaseAudioPlayer.prototype.formatAudioData = function(audioData) {
        switch(this.audioFormat.bitsPerSample){
            case 8:
                return this.formatArrayBuffer(new Int8Array(audioData), 128);
            case 16:
                return this.formatArrayBuffer(new Int16Array(audioData), 32768);
            case 32:
                return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);
            default:
                throw new Error_1.InvalidOperationError("Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time");
        }
    };
    BaseAudioPlayer.prototype.formatArrayBuffer = function(audioData, maxValue) {
        var float32Data = new Float32Array(audioData.length);
        for(var i = 0; i < audioData.length; i++)float32Data[i] = audioData[i] / maxValue;
        return float32Data;
    };
    BaseAudioPlayer.prototype.updateAudioBuffer = function() {
        if (this.samples.length === 0) return;
        var channelCount = this.audioFormat.channels;
        var bufferSource = this.audioContext.createBufferSource();
        var frameCount = this.samples.length / channelCount;
        var audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec);
        // TODO: Should we do the conversion in the pushAudioSample instead?
        for(var channel = 0; channel < channelCount; channel++){
            // Fill in individual channel data
            var channelOffset = channel;
            var audioData = audioBuffer.getChannelData(channel);
            for(var i = 0; i < this.samples.length; i++, channelOffset += channelCount)audioData[i] = this.samples[channelOffset];
        }
        if (this.startTime < this.audioContext.currentTime) this.startTime = this.audioContext.currentTime;
        bufferSource.buffer = audioBuffer;
        bufferSource.connect(this.gainNode);
        bufferSource.start(this.startTime);
        // Make sure we play the next sample after the current one.
        this.startTime += audioBuffer.duration;
        // Clear the samples for the next pushed data.
        this.samples = new Float32Array();
    };
    BaseAudioPlayer.prototype.playAudio = function(audioData) {
        return __awaiter(this, void 0, void 0, function() {
            var source, destination;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.audioContext === null) this.createAudioContext();
                        source = this.audioContext.createBufferSource();
                        destination = this.audioContext.destination;
                        return [
                            4 /*yield*/ ,
                            this.audioContext.decodeAudioData(audioData, function(newBuffer) {
                                source.buffer = newBuffer;
                                source.connect(destination);
                                source.start(0);
                            })
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    return BaseAudioPlayer;
}();
exports.BaseAudioPlayer = BaseAudioPlayer;

},{"1cf79aea9b3b6a4e":"fyy92","dacede810cfb37f3":"hxkc3","a853f3b385739414":"8hTlD"}],"7I85W":[function(require,module,exports) {
"use strict";
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionMessageEventArgs = void 0;
var ConnectionMessageEventArgs = /** @class */ function() {
    function ConnectionMessageEventArgs(message) {
        this.privConnectionMessage = message;
    }
    Object.defineProperty(ConnectionMessageEventArgs.prototype, "message", {
        /**
         * Gets the <see cref="ConnectionMessage"/> associated with this <see cref="ConnectionMessageEventArgs"/>.
         */ get: function() {
            return this.privConnectionMessage;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns a string that represents the connection message event.
     */ ConnectionMessageEventArgs.prototype.toString = function() {
        return "Message: " + this.privConnectionMessage.toString();
    };
    return ConnectionMessageEventArgs;
}();
exports.ConnectionMessageEventArgs = ConnectionMessageEventArgs;

},{}],"4IE1Y":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoiceProfile = void 0;
/**
 * Defines Voice Profile class for Speaker Recognition
 * @class VoiceProfile
 */ var VoiceProfile = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} profileId - profileId of this Voice Profile.
     * @param {VoiceProfileType} profileType - profileType of this Voice Profile.
     */ function VoiceProfile(profileId, profileType) {
        this.privId = profileId;
        this.privProfileType = profileType;
    }
    Object.defineProperty(VoiceProfile.prototype, "profileId", {
        /**
         * profileId of this Voice Profile instance
         * @member VoiceProfile.prototype.profileId
         * @function
         * @public
         * @returns {string} profileId of this Voice Profile instance.
         */ get: function() {
            return this.privId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceProfile.prototype, "profileType", {
        /**
         * profileType of this Voice Profile instance
         * @member VoiceProfile.prototype.profileType
         * @function
         * @public
         * @returns {VoiceProfileType} profile type of this Voice Profile instance.
         */ get: function() {
            return this.privProfileType;
        },
        enumerable: false,
        configurable: true
    });
    return VoiceProfile;
}();
exports.VoiceProfile = VoiceProfile;

},{}],"gwi39":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoiceProfileEnrollmentCancellationDetails = exports.VoiceProfileEnrollmentResult = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("ff08a3129a1eaca");
var Exports_2 = require("928d56924e8c69af");
/**
 * Output format
 * @class VoiceProfileEnrollmentResult
 */ var VoiceProfileEnrollmentResult = /** @class */ function() {
    function VoiceProfileEnrollmentResult(reason, json, statusText) {
        this.privReason = reason;
        this.privProperties = new Exports_2.PropertyCollection();
        if (this.privReason !== Exports_2.ResultReason.Canceled) {
            if (!!json) {
                this.privDetails = JSON.parse(json);
                if (this.privDetails.enrollmentStatus.toLowerCase() === "enrolling") this.privReason = Exports_2.ResultReason.EnrollingVoiceProfile;
            }
        } else {
            this.privErrorDetails = statusText;
            this.privProperties.setProperty(Exports_1.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[Exports_2.CancellationErrorCode.ServiceError]);
        }
    }
    Object.defineProperty(VoiceProfileEnrollmentResult.prototype, "reason", {
        get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceProfileEnrollmentResult.prototype, "enrollmentsCount", {
        get: function() {
            return this.privDetails.enrollmentsCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceProfileEnrollmentResult.prototype, "enrollmentsLength", {
        get: function() {
            return this.privDetails.enrollmentsLength;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceProfileEnrollmentResult.prototype, "properties", {
        get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceProfileEnrollmentResult.prototype, "enrollmentResultDetails", {
        get: function() {
            return this.privDetails;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceProfileEnrollmentResult.prototype, "errorDetails", {
        get: function() {
            return this.privErrorDetails;
        },
        enumerable: false,
        configurable: true
    });
    VoiceProfileEnrollmentResult.FromIdentificationProfileList = function(json) {
        var results = [];
        for(var _i = 0, _a = json.value; _i < _a.length; _i++){
            var item = _a[_i];
            var reason = item.enrollmentStatus.toLowerCase() === "enrolling" ? Exports_2.ResultReason.EnrollingVoiceProfile : item.enrollmentStatus.toLowerCase() === "enrolled" ? Exports_2.ResultReason.EnrolledVoiceProfile : Exports_2.ResultReason.Canceled;
            var result = new VoiceProfileEnrollmentResult(reason, null, null);
            result.privDetails = this.getIdentificationDetails(item);
            results.push(result);
        }
        return results;
    };
    VoiceProfileEnrollmentResult.FromVerificationProfileList = function(json) {
        var results = [];
        for(var _i = 0, _a = json.value; _i < _a.length; _i++){
            var item = _a[_i];
            var reason = item.enrollmentStatus.toLowerCase() === "enrolling" ? Exports_2.ResultReason.EnrollingVoiceProfile : item.enrollmentStatus.toLowerCase() === "enrolled" ? Exports_2.ResultReason.EnrolledVoiceProfile : Exports_2.ResultReason.Canceled;
            var result = new VoiceProfileEnrollmentResult(reason, null, null);
            result.privDetails = this.getVerificationDetails(item);
            results.push(result);
        }
        return results;
    };
    VoiceProfileEnrollmentResult.getIdentificationDetails = function(json) {
        return {
            audioLength: json.audioLength ? parseFloat(json.audioLength) : 0,
            audioSpeechLength: json.audioSpeechLength ? parseFloat(json.audioSpeechLength) : 0,
            enrollmentStatus: json.enrollmentStatus,
            enrollmentsCount: json.enrollmentsCount || 0,
            enrollmentsLength: json.enrollmentsLength ? parseFloat(json.enrollmentsLength) : 0,
            enrollmentsSpeechLength: json.enrollmentsSpeechLength ? parseFloat(json.enrollmentsSpeechLength) : 0,
            profileId: json.profileId || json.identificationProfileId,
            remainingEnrollmentsSpeechLength: json.remainingEnrollmentsSpeechLength ? parseFloat(json.remainingEnrollmentsSpeechLength) : 0
        };
    };
    VoiceProfileEnrollmentResult.getVerificationDetails = function(json) {
        return {
            audioLength: json.audioLength ? parseFloat(json.audioLength) : 0,
            audioSpeechLength: json.audioSpeechLength ? parseFloat(json.audioSpeechLength) : 0,
            enrollmentStatus: json.enrollmentStatus,
            enrollmentsCount: json.enrollmentsCount,
            enrollmentsLength: json.enrollmentsLength ? parseFloat(json.enrollmentsLength) : 0,
            enrollmentsSpeechLength: json.enrollmentsSpeechLength ? parseFloat(json.enrollmentsSpeechLength) : 0,
            profileId: json.profileId || json.verificationProfileId,
            remainingEnrollmentsCount: json.remainingEnrollments || json.remainingEnrollmentsCount,
            remainingEnrollmentsSpeechLength: json.remainingEnrollmentsSpeechLength ? parseFloat(json.remainingEnrollmentsSpeechLength) : 0
        };
    };
    return VoiceProfileEnrollmentResult;
}();
exports.VoiceProfileEnrollmentResult = VoiceProfileEnrollmentResult;
/**
 * @class VoiceProfileEnrollmentCancellationDetails
 */ var VoiceProfileEnrollmentCancellationDetails = /** @class */ function(_super) {
    __extends(VoiceProfileEnrollmentCancellationDetails, _super);
    function VoiceProfileEnrollmentCancellationDetails(reason, errorDetails, errorCode) {
        return _super.call(this, reason, errorDetails, errorCode) || this;
    }
    /**
     * Creates an instance of VoiceProfileEnrollmentCancellationDetails object for the canceled VoiceProfileEnrollmentResult.
     * @member VoiceProfileEnrollmentCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileEnrollmentResult} result - The result that was canceled.
     * @returns {VoiceProfileEnrollmentCancellationDetails} The cancellation details object being created.
     */ VoiceProfileEnrollmentCancellationDetails.fromResult = function(result) {
        var reason = Exports_2.CancellationReason.Error;
        var errorCode = Exports_2.CancellationErrorCode.NoError;
        if (!!result.properties) errorCode = Exports_2.CancellationErrorCode[result.properties.getProperty(Exports_1.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[Exports_2.CancellationErrorCode.NoError])]; //eslint-disable-line
        return new VoiceProfileEnrollmentCancellationDetails(reason, result.errorDetails, errorCode);
    };
    return VoiceProfileEnrollmentCancellationDetails;
}(Exports_2.CancellationDetailsBase);
exports.VoiceProfileEnrollmentCancellationDetails = VoiceProfileEnrollmentCancellationDetails;

},{"ff08a3129a1eaca":"7Qpvn","928d56924e8c69af":"hxkc3"}],"64Gqz":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoiceProfileCancellationDetails = exports.VoiceProfileResult = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("4ddbe217061ce0f");
var Contracts_1 = require("d55838ab07633e08");
var Exports_2 = require("45fb3a979cc85bae");
/**
 * Output format
 * @class VoiceProfileResult
 */ var VoiceProfileResult = /** @class */ function() {
    function VoiceProfileResult(reason, statusText) {
        this.privReason = reason;
        this.privProperties = new Exports_2.PropertyCollection();
        if (reason === Exports_2.ResultReason.Canceled) {
            Contracts_1.Contracts.throwIfNullOrUndefined(statusText, "statusText");
            this.privErrorDetails = statusText;
            this.privProperties.setProperty(Exports_1.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[Exports_2.CancellationErrorCode.ServiceError]);
        }
    }
    Object.defineProperty(VoiceProfileResult.prototype, "reason", {
        get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceProfileResult.prototype, "properties", {
        get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceProfileResult.prototype, "errorDetails", {
        get: function() {
            return this.privErrorDetails;
        },
        enumerable: false,
        configurable: true
    });
    return VoiceProfileResult;
}();
exports.VoiceProfileResult = VoiceProfileResult;
/**
 * @class VoiceProfileCancellationDetails
 */ var VoiceProfileCancellationDetails = /** @class */ function(_super) {
    __extends(VoiceProfileCancellationDetails, _super);
    function VoiceProfileCancellationDetails(reason, errorDetails, errorCode) {
        return _super.call(this, reason, errorDetails, errorCode) || this;
    }
    /**
     * Creates an instance of VoiceProfileCancellationDetails object for the canceled VoiceProfileResult.
     * @member VoiceProfileCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileResult} result - The result that was canceled.
     * @returns {VoiceProfileCancellationDetails} The cancellation details object being created.
     */ VoiceProfileCancellationDetails.fromResult = function(result) {
        var reason = Exports_2.CancellationReason.Error;
        var errorCode = Exports_2.CancellationErrorCode.NoError;
        if (!!result.properties) errorCode = Exports_2.CancellationErrorCode[result.properties.getProperty(Exports_1.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[Exports_2.CancellationErrorCode.NoError])]; //eslint-disable-line
        return new VoiceProfileCancellationDetails(reason, result.errorDetails, errorCode);
    };
    return VoiceProfileCancellationDetails;
}(Exports_2.CancellationDetailsBase);
exports.VoiceProfileCancellationDetails = VoiceProfileCancellationDetails;

},{"4ddbe217061ce0f":"7Qpvn","d55838ab07633e08":"4jwu5","45fb3a979cc85bae":"hxkc3"}],"d4ZYO":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoiceProfilePhraseResult = void 0;
var Contracts_1 = require("6c19612cfa515009");
var Exports_1 = require("fd73952a26fa0a74");
/**
 * Output format
 * @class VoiceProfilePhraseResult
 */ var VoiceProfilePhraseResult = /** @class */ function(_super) {
    __extends(VoiceProfilePhraseResult, _super);
    function VoiceProfilePhraseResult(reason, statusText, type, phraseArray) {
        var _this = _super.call(this, reason, statusText) || this;
        _this.privPhrases = [];
        Contracts_1.Contracts.throwIfNullOrUndefined(phraseArray, "phrase array");
        _this.privType = type;
        if (!!phraseArray && !!phraseArray[0]) _this.privPhrases = phraseArray;
        return _this;
    }
    Object.defineProperty(VoiceProfilePhraseResult.prototype, "phrases", {
        get: function() {
            return this.privPhrases;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceProfilePhraseResult.prototype, "type", {
        get: function() {
            return this.privType;
        },
        enumerable: false,
        configurable: true
    });
    return VoiceProfilePhraseResult;
}(Exports_1.VoiceProfileResult);
exports.VoiceProfilePhraseResult = VoiceProfilePhraseResult;

},{"6c19612cfa515009":"4jwu5","fd73952a26fa0a74":"hxkc3"}],"fwssW":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoiceProfileClient = void 0;
var Exports_1 = require("c48fee1d4084630d");
var AudioConfig_1 = require("ed0c8638f69a5053");
var Contracts_1 = require("4b5d6a0e1d15724d");
var Exports_2 = require("2735b45bf3603e3e");
/**
 * Defines VoiceProfileClient class for Speaker Recognition
 * Handles operations from user for Voice Profile operations (e.g. createProfile, deleteProfile)
 * @class VoiceProfileClient
 */ var VoiceProfileClient = /** @class */ function(_super) {
    __extends(VoiceProfileClient, _super);
    /**
     * VoiceProfileClient constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer (authentication key, region, &c)
     */ function VoiceProfileClient(speechConfig) {
        var _this = this;
        Contracts_1.Contracts.throwIfNullOrUndefined(speechConfig, "speechConfig");
        var speechConfigImpl = speechConfig;
        Contracts_1.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
        _this = _super.call(this, AudioConfig_1.AudioConfig.fromStreamInput(Exports_2.AudioInputStream.createPushStream()), speechConfigImpl.properties, new Exports_1.VoiceProfileConnectionFactory()) || this;
        _this.privProperties = speechConfigImpl.properties.clone();
        _this.privVoiceAdapter = _this.privReco;
        _this.privDisposedVoiceAdapter = false;
        return _this;
    }
    Object.defineProperty(VoiceProfileClient.prototype, "properties", {
        /**
         * The collection of properties and their values defined for this VoiceProfileClient.
         * @member VoiceProfileClient.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The collection of properties and their values defined for this VoiceProfileClient.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceProfileClient.prototype, "authorizationToken", {
        /**
         * Gets the authorization token used to communicate with the service.
         * @member VoiceProfileClient.prototype.authorizationToken
         * @function
         * @public
         * @returns {string} Authorization token.
         */ get: function() {
            return this.properties.getProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token);
        },
        /**
         * Gets/Sets the authorization token used to communicate with the service.
         * @member VoiceProfileClient.prototype.authorizationToken
         * @function
         * @public
         * @param {string} token - Authorization token.
         */ set: function(token) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(token, "token");
            this.properties.setProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token, token);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.createProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Type of Voice Profile to be created
     * @param {string} lang Language string (locale) for Voice Profile
     * @return {Promise<VoiceProfile>} - Promise of a VoiceProfile.
     */ VoiceProfileClient.prototype.createProfileAsync = function(profileType, lang) {
        return __awaiter(this, void 0, void 0, function() {
            var profileIds;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.privVoiceAdapter.createProfile(profileType, lang)
                        ];
                    case 1:
                        profileIds = _a.sent();
                        return [
                            2 /*return*/ ,
                            new Exports_2.VoiceProfile(profileIds[0], profileType)
                        ];
                }
            });
        });
    };
    /**
     * Get current information of a voice profile
     * @member VoiceProfileClient.prototype.retrieveEnrollmentResultAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to retrieve info for
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */ VoiceProfileClient.prototype.retrieveEnrollmentResultAsync = function(profile) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                return [
                    2 /*return*/ ,
                    this.privVoiceAdapter.retrieveEnrollmentResult(profile)
                ];
            });
        });
    };
    /**
     * Get all voice profiles on account with given voice profile type
     * @member VoiceProfileClient.prototype.getAllProfilesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType profile type (identification/verification) for which to list profiles
     * @return {Promise<VoiceProfileEnrollmentResult[]>} - Promise of an array of VoiceProfileEnrollmentResults.
     */ VoiceProfileClient.prototype.getAllProfilesAsync = function(profileType) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                return [
                    2 /*return*/ ,
                    this.privVoiceAdapter.getAllProfiles(profileType)
                ];
            });
        });
    };
    /**
     * Get valid authorization phrases for voice profile enrollment
     * @member VoiceProfileClient.prototype.getActivationPhrasesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Profile Type to get activation phrases for
     * @param {string} lang Language string (locale) for Voice Profile
     */ VoiceProfileClient.prototype.getActivationPhrasesAsync = function(profileType, lang) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                return [
                    2 /*return*/ ,
                    this.privVoiceAdapter.getActivationPhrases(profileType, lang)
                ];
            });
        });
    };
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.enrollProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to create enrollment for
     * @param {AudioConfig} audioConfig source info from which to create enrollment
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */ VoiceProfileClient.prototype.enrollProfileAsync = function(profile, audioConfig) {
        return __awaiter(this, void 0, void 0, function() {
            var configImpl;
            return __generator(this, function(_a) {
                configImpl = audioConfig;
                Contracts_1.Contracts.throwIfNullOrUndefined(configImpl, "audioConfig");
                this.audioConfig = audioConfig;
                this.privVoiceAdapter.SpeakerAudioSource = configImpl;
                return [
                    2 /*return*/ ,
                    this.privVoiceAdapter.enrollProfile(profile)
                ];
            });
        });
    };
    /**
     * Delete a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.deleteProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be deleted
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */ VoiceProfileClient.prototype.deleteProfileAsync = function(profile) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                return [
                    2 /*return*/ ,
                    this.privVoiceAdapter.deleteProfile(profile)
                ];
            });
        });
    };
    /**
     * Remove all enrollments for a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.resetProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be reset
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */ VoiceProfileClient.prototype.resetProfileAsync = function(profile) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                return [
                    2 /*return*/ ,
                    this.privVoiceAdapter.resetProfile(profile)
                ];
            });
        });
    };
    /**
     * Clean up object and close underlying connection
     * @member VoiceProfileClient.prototype.close
     * @function
     * @async
     * @public
     */ VoiceProfileClient.prototype.close = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.dispose(true)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    VoiceProfileClient.prototype.createServiceRecognizer = function(authentication, connectionFactory, audioConfig, recognizerConfig) {
        var audioImpl = audioConfig;
        return new Exports_1.VoiceServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);
    };
    VoiceProfileClient.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privDisposedVoiceAdapter) return [
                            2 /*return*/ 
                        ];
                        this.privDisposedVoiceAdapter = true;
                        if (!disposing) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            _super.prototype.dispose.call(this, disposing)
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    VoiceProfileClient.prototype.createRecognizerConfig = function(speechConfig) {
        return new Exports_1.RecognizerConfig(speechConfig, this.properties);
    };
    VoiceProfileClient.prototype.getResult = function(result, successReason) {
        var response = new Exports_2.VoiceProfileResult(result.ok ? successReason : Exports_2.ResultReason.Canceled, result.statusText);
        return response;
    };
    return VoiceProfileClient;
}(Exports_2.Recognizer);
exports.VoiceProfileClient = VoiceProfileClient;

},{"c48fee1d4084630d":"7Qpvn","ed0c8638f69a5053":"eM6bc","4b5d6a0e1d15724d":"4jwu5","2735b45bf3603e3e":"hxkc3"}],"4Swpn":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeakerRecognizer = void 0;
var Exports_1 = require("c5c4fbf221202492");
var Contracts_1 = require("3d5a43bf6c46d0d3");
var Exports_2 = require("fd3bc537cffad2c6");
/**
 * Defines SpeakerRecognizer class for Speaker Recognition
 * Handles operations from user for Voice Profile operations (e.g. createProfile, deleteProfile)
 * @class SpeakerRecognizer
 */ var SpeakerRecognizer = /** @class */ function(_super) {
    __extends(SpeakerRecognizer, _super);
    /**
     * Initializes an instance of the SpeakerRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */ function SpeakerRecognizer(speechConfig, audioConfig) {
        var _this = this;
        Contracts_1.Contracts.throwIfNullOrUndefined(speechConfig, "speechConfig");
        var configImpl = speechConfig;
        Contracts_1.Contracts.throwIfNullOrUndefined(configImpl, "speechConfig");
        _this = _super.call(this, audioConfig, configImpl.properties, new Exports_1.SpeakerRecognitionConnectionFactory()) || this;
        _this.privAudioConfigImpl = audioConfig;
        Contracts_1.Contracts.throwIfNull(_this.privAudioConfigImpl, "audioConfig");
        _this.privDisposedSpeakerRecognizer = false;
        _this.privProperties = configImpl.properties;
        return _this;
    }
    Object.defineProperty(SpeakerRecognizer.prototype, "authorizationToken", {
        /**
         * Gets the authorization token used to communicate with the service.
         * @member SpeakerRecognizer.prototype.authorizationToken
         * @function
         * @public
         * @returns {string} Authorization token.
         */ get: function() {
            return this.properties.getProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token);
        },
        /**
         * Gets/Sets the authorization token used to communicate with the service.
         * @member SpeakerRecognizer.prototype.authorizationToken
         * @function
         * @public
         * @param {string} token - Authorization token.
         */ set: function(token) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(token, "token");
            this.properties.setProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token, token);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerRecognizer.prototype, "properties", {
        /**
         * The collection of properties and their values defined for this SpeakerRecognizer.
         * @member SpeakerRecognizer.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The collection of properties and their values defined for this SpeakerRecognizer.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get recognition result for model using given audio
     * @member SpeakerRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @async
     * @param {SpeakerIdentificationModel | SpeakerVerificationModel} model Model containing Voice Profiles to be identified
     * @param cb - Callback invoked once result is returned.
     * @param err - Callback invoked in case of an error.
     */ SpeakerRecognizer.prototype.recognizeOnceAsync = function(model) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                Contracts_1.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer);
                return [
                    2 /*return*/ ,
                    this.recognizeSpeakerOnceAsyncImpl(model)
                ];
            });
        });
    };
    /**
     * Included for compatibility
     * @member SpeakerRecognizer.prototype.close
     * @function
     * @public
     * @async
     */ SpeakerRecognizer.prototype.close = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        Contracts_1.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer);
                        return [
                            4 /*yield*/ ,
                            this.dispose(true)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SpeakerRecognizer.prototype.recognizeSpeakerOnceAsyncImpl = function(model) {
        return __awaiter(this, void 0, void 0, function() {
            var result;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        Contracts_1.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer);
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privReco.recognizeSpeaker(model)
                        ];
                    case 2:
                        result = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 3:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            result
                        ];
                }
            });
        });
    };
    SpeakerRecognizer.prototype.implRecognizerStop = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!this.privReco) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privReco.stopRecognizing()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SpeakerRecognizer.prototype.createRecognizerConfig = function(speechConfig) {
        return new Exports_1.RecognizerConfig(speechConfig, this.privProperties);
    };
    SpeakerRecognizer.prototype.createServiceRecognizer = function(authentication, connectionFactory, audioConfig, recognizerConfig) {
        var audioImpl = audioConfig;
        return new Exports_1.SpeakerServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);
    };
    SpeakerRecognizer.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privDisposedSpeakerRecognizer) return [
                            2 /*return*/ 
                        ];
                        if (!disposing) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privDisposedSpeakerRecognizer = true;
                        return [
                            4 /*yield*/ ,
                            _super.prototype.dispose.call(this, disposing)
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    return SpeakerRecognizer;
}(Exports_2.Recognizer);
exports.SpeakerRecognizer = SpeakerRecognizer;

},{"c5c4fbf221202492":"7Qpvn","3d5a43bf6c46d0d3":"4jwu5","fd3bc537cffad2c6":"hxkc3"}],"1Gp2N":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeakerIdentificationModel = void 0;
var Contracts_1 = require("4d636a84db2b6781");
var Exports_1 = require("be99664819d2b5ed");
/**
 * Defines SpeakerIdentificationModel class for Speaker Recognition
 * Model contains a set of profiles against which to identify speaker(s)
 * @class SpeakerIdentificationModel
 */ var SpeakerIdentificationModel = /** @class */ function() {
    function SpeakerIdentificationModel(profiles) {
        this.privVoiceProfiles = [];
        this.privProfileIds = [];
        Contracts_1.Contracts.throwIfNullOrUndefined(profiles, "VoiceProfiles");
        if (profiles.length === 0) throw new Error("Empty Voice Profiles array");
        for(var _i = 0, profiles_1 = profiles; _i < profiles_1.length; _i++){
            var profile = profiles_1[_i];
            if (profile.profileType !== Exports_1.VoiceProfileType.TextIndependentIdentification) throw new Error("Identification model can only be created from Identification profile: " + profile.profileId);
            this.privVoiceProfiles.push(profile);
            this.privProfileIds.push(profile.profileId);
        }
    }
    SpeakerIdentificationModel.fromProfiles = function(profiles) {
        return new SpeakerIdentificationModel(profiles);
    };
    Object.defineProperty(SpeakerIdentificationModel.prototype, "voiceProfileIds", {
        get: function() {
            return this.privProfileIds.join(",");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerIdentificationModel.prototype, "profileIds", {
        get: function() {
            return this.privProfileIds;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerIdentificationModel.prototype, "scenario", {
        get: function() {
            return "TextIndependentIdentification";
        },
        enumerable: false,
        configurable: true
    });
    return SpeakerIdentificationModel;
}();
exports.SpeakerIdentificationModel = SpeakerIdentificationModel;

},{"4d636a84db2b6781":"4jwu5","be99664819d2b5ed":"hxkc3"}],"6zwRo":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeakerVerificationModel = void 0;
var Contracts_1 = require("b3e261391da6eda8");
var Exports_1 = require("abfc7fa557e29cb9");
/**
 * Defines SpeakerVerificationModel class for Speaker Recognition
 * Model contains a profile against which to verify a speaker
 * @class SpeakerVerificationModel
 */ var SpeakerVerificationModel = /** @class */ function() {
    function SpeakerVerificationModel(profile) {
        Contracts_1.Contracts.throwIfNullOrUndefined(profile, "VoiceProfile");
        if (profile.profileType === Exports_1.VoiceProfileType.TextIndependentIdentification) throw new Error("Verification model cannot be created from Identification profile");
        this.privVoiceProfile = profile;
    }
    SpeakerVerificationModel.fromProfile = function(profile) {
        return new SpeakerVerificationModel(profile);
    };
    Object.defineProperty(SpeakerVerificationModel.prototype, "voiceProfile", {
        get: function() {
            return this.privVoiceProfile;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerVerificationModel.prototype, "profileIds", {
        get: function() {
            return [
                this.voiceProfile.profileId
            ];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerVerificationModel.prototype, "scenario", {
        get: function() {
            if (this.voiceProfile.profileType === Exports_1.VoiceProfileType.TextDependentVerification) return "TextDependentVerification";
            else return "TextIndependentVerification";
        },
        enumerable: false,
        configurable: true
    });
    return SpeakerVerificationModel;
}();
exports.SpeakerVerificationModel = SpeakerVerificationModel;

},{"b3e261391da6eda8":"4jwu5","abfc7fa557e29cb9":"hxkc3"}],"lQ8xM":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AutoDetectSourceLanguageConfig = void 0;
var Exports_1 = require("b13d85cd00f3f0d6");
var Contracts_1 = require("5266a2687594c163");
var Exports_2 = require("892eba15b181a083");
var LanguageIdMode_1 = require("9239bc5e31fa81f3");
/**
 * Language auto detect configuration.
 * @class AutoDetectSourceLanguageConfig
 * Added in version 1.13.0.
 */ var AutoDetectSourceLanguageConfig = /** @class */ function() {
    function AutoDetectSourceLanguageConfig() {
        this.privProperties = new Exports_2.PropertyCollection();
        this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart");
        this.privLanguageIdMode = LanguageIdMode_1.LanguageIdMode.AtStart;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromOpenRange
     * @function
     * @public
     * Only [[SpeechSynthesizer]] supports source language auto detection from open range,
     * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.
     */ AutoDetectSourceLanguageConfig.fromOpenRange = function() {
        var config = new AutoDetectSourceLanguageConfig();
        config.properties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, Exports_1.AutoDetectSourceLanguagesOpenRangeOptionName);
        return config;
    };
    /**
     * @member AutoDetectSourceLanguageConfig.fromLanguages
     * @function
     * @public
     * @param {string[]} languages Comma-separated string of languages (eg. "en-US,fr-FR") to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.
     */ AutoDetectSourceLanguageConfig.fromLanguages = function(languages) {
        Contracts_1.Contracts.throwIfArrayEmptyOrWhitespace(languages, "languages");
        var config = new AutoDetectSourceLanguageConfig();
        config.properties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, languages.join());
        return config;
    };
    /**
     * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs
     * @function
     * @public
     * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.
     */ AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs = function(configs) {
        if (configs.length < 1) throw new Error("Expected non-empty SourceLanguageConfig array.");
        var autoConfig = new AutoDetectSourceLanguageConfig();
        var langs = [];
        configs.forEach(function(config) {
            langs.push(config.language);
            if (config.endpointId !== undefined && config.endpointId !== "") {
                var customProperty = config.language + Exports_2.PropertyId.SpeechServiceConnection_EndpointId.toString();
                autoConfig.properties.setProperty(customProperty, config.endpointId);
            }
        });
        autoConfig.properties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, langs.join());
        return autoConfig;
    };
    Object.defineProperty(AutoDetectSourceLanguageConfig.prototype, "properties", {
        /**
         * @member AutoDetectSourceLanguageConfig.prototype.properties
         * @function
         * @public
         * @return {PropertyCollection} Properties of the config.
         * @summary Gets an auto detected language config properties
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AutoDetectSourceLanguageConfig.prototype, "mode", {
        /**
         * @member AutoDetectSourceLanguageConfig.prototype.mode
         * @function
         * @public
         * @param {LanguageIdMode} mode LID mode desired.
         * @summary Sets LID operation to desired mode
         */ set: function(mode) {
            if (mode === LanguageIdMode_1.LanguageIdMode.Continuous) {
                this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2");
                this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_LanguageIdMode, "Continuous");
            } else {
                this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1");
                this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart");
            }
            this.privLanguageIdMode = mode;
        },
        enumerable: false,
        configurable: true
    });
    return AutoDetectSourceLanguageConfig;
}();
exports.AutoDetectSourceLanguageConfig = AutoDetectSourceLanguageConfig;

},{"b13d85cd00f3f0d6":"7Qpvn","5266a2687594c163":"4jwu5","892eba15b181a083":"hxkc3","9239bc5e31fa81f3":"k14Gx"}],"k14Gx":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LanguageIdMode = void 0;
/**
 * Language Identification mode
 * @class LanguageIdMode
 */ var LanguageIdMode;
(function(LanguageIdMode) {
    /**
     * Detect language at audio start
     * @member LanguageIdMode.AtStart
     */ LanguageIdMode[LanguageIdMode["AtStart"] = 0] = "AtStart";
    /**
     * Continuously detect language
     * @member LanguageIdMode.Continuous
     */ LanguageIdMode[LanguageIdMode["Continuous"] = 1] = "Continuous";
})(LanguageIdMode = exports.LanguageIdMode || (exports.LanguageIdMode = {}));

},{}],"grZnn":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AutoDetectSourceLanguageResult = void 0;
var Contracts_1 = require("fa7526645956b8d9");
/**
 * Output format
 * @class AutoDetectSourceLanguageResult
 */ var AutoDetectSourceLanguageResult = /** @class */ function() {
    function AutoDetectSourceLanguageResult(language, languageDetectionConfidence) {
        Contracts_1.Contracts.throwIfNullOrUndefined(language, "language");
        Contracts_1.Contracts.throwIfNullOrUndefined(languageDetectionConfidence, "languageDetectionConfidence");
        this.privLanguage = language;
        this.privLanguageDetectionConfidence = languageDetectionConfidence;
    }
    /**
     * Creates an instance of AutoDetectSourceLanguageResult object from a SpeechRecognitionResult instance.
     * @member AutoDetectSourceLanguageResult.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult} result - The recognition result.
     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
     */ AutoDetectSourceLanguageResult.fromResult = function(result) {
        return new AutoDetectSourceLanguageResult(result.language, result.languageDetectionConfidence);
    };
    /**
     * Creates an instance of AutoDetectSourceLanguageResult object from a ConversationTranscriptionResult instance.
     * @member AutoDetectSourceLanguageResult.fromConversationTranscriptionResult
     * @function
     * @public
     * @param {ConversationTranscriptionResult} result - The transcription result.
     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
     */ AutoDetectSourceLanguageResult.fromConversationTranscriptionResult = function(result) {
        return new AutoDetectSourceLanguageResult(result.language, result.languageDetectionConfidence);
    };
    Object.defineProperty(AutoDetectSourceLanguageResult.prototype, "language", {
        get: function() {
            return this.privLanguage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AutoDetectSourceLanguageResult.prototype, "languageDetectionConfidence", {
        get: function() {
            return this.privLanguageDetectionConfidence;
        },
        enumerable: false,
        configurable: true
    });
    return AutoDetectSourceLanguageResult;
}();
exports.AutoDetectSourceLanguageResult = AutoDetectSourceLanguageResult;

},{"fa7526645956b8d9":"4jwu5"}],"exfsc":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SourceLanguageConfig = void 0;
var Contracts_1 = require("7abd1395169f695a");
/**
 * Source Language configuration.
 * @class SourceLanguageConfig
 */ var SourceLanguageConfig = /** @class */ function() {
    function SourceLanguageConfig(language, endpointId) {
        Contracts_1.Contracts.throwIfNullOrUndefined(language, "language");
        this.privLanguage = language;
        this.privEndpointId = endpointId;
    }
    /**
     * @member SourceLanguageConfig.fromLanguage
     * @function
     * @public
     * @param {string} language language (eg. "en-US") value of config.
     * @param {string?} endpointId endpointId of model bound to given language of config.
     * @return {SourceLanguageConfig} Instance of SourceLanguageConfig
     * @summary Creates an instance of the SourceLanguageConfig with the given language and optional endpointId.
     * Added in version 1.13.0.
     */ SourceLanguageConfig.fromLanguage = function(language, endpointId) {
        return new SourceLanguageConfig(language, endpointId);
    };
    Object.defineProperty(SourceLanguageConfig.prototype, "language", {
        get: function() {
            return this.privLanguage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourceLanguageConfig.prototype, "endpointId", {
        get: function() {
            return this.privEndpointId;
        },
        enumerable: false,
        configurable: true
    });
    return SourceLanguageConfig;
}();
exports.SourceLanguageConfig = SourceLanguageConfig;

},{"7abd1395169f695a":"4jwu5"}],"aUAOO":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeakerRecognitionCancellationDetails = exports.SpeakerRecognitionResult = exports.SpeakerRecognitionResultType = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("949e39b9cdfda333");
var Exports_2 = require("7d8dd450dfa8708b");
var SpeakerRecognitionResultType;
(function(SpeakerRecognitionResultType) {
    SpeakerRecognitionResultType[SpeakerRecognitionResultType["Verify"] = 0] = "Verify";
    SpeakerRecognitionResultType[SpeakerRecognitionResultType["Identify"] = 1] = "Identify";
})(SpeakerRecognitionResultType = exports.SpeakerRecognitionResultType || (exports.SpeakerRecognitionResultType = {}));
/**
 * Output format
 * @class SpeakerRecognitionResult
 */ var SpeakerRecognitionResult = /** @class */ function() {
    function SpeakerRecognitionResult(response, resultReason, cancellationErrorCode, errorDetails) {
        if (resultReason === void 0) resultReason = Exports_2.ResultReason.RecognizedSpeaker;
        if (cancellationErrorCode === void 0) cancellationErrorCode = Exports_2.CancellationErrorCode.NoError;
        if (errorDetails === void 0) errorDetails = "";
        this.privProperties = new Exports_2.PropertyCollection();
        var resultType = response.scenario === "TextIndependentIdentification" ? SpeakerRecognitionResultType.Identify : SpeakerRecognitionResultType.Verify;
        this.privReason = resultReason;
        if (this.privReason !== Exports_2.ResultReason.Canceled) {
            if (resultType === SpeakerRecognitionResultType.Identify) {
                this.privProfileId = response.identificationResult.identifiedProfile.profileId;
                this.privScore = response.identificationResult.identifiedProfile.score;
                this.privReason = Exports_2.ResultReason.RecognizedSpeakers;
            } else {
                this.privScore = response.verificationResult.score;
                if (response.verificationResult.recognitionResult.toLowerCase() !== "accept") this.privReason = Exports_2.ResultReason.NoMatch;
                if (response.verificationResult.profileId !== undefined && response.verificationResult.profileId !== "") this.privProfileId = response.verificationResult.profileId;
            }
        } else {
            this.privErrorDetails = errorDetails;
            this.privProperties.setProperty(Exports_1.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[cancellationErrorCode]);
        }
        this.privProperties.setProperty(Exports_2.PropertyId.SpeechServiceResponse_JsonResult, JSON.stringify(response));
    }
    Object.defineProperty(SpeakerRecognitionResult.prototype, "properties", {
        get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerRecognitionResult.prototype, "reason", {
        get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerRecognitionResult.prototype, "profileId", {
        get: function() {
            return this.privProfileId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerRecognitionResult.prototype, "errorDetails", {
        get: function() {
            return this.privErrorDetails;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerRecognitionResult.prototype, "score", {
        get: function() {
            return this.privScore;
        },
        enumerable: false,
        configurable: true
    });
    return SpeakerRecognitionResult;
}();
exports.SpeakerRecognitionResult = SpeakerRecognitionResult;
/**
 * @class SpeakerRecognitionCancellationDetails
 */ var SpeakerRecognitionCancellationDetails = /** @class */ function(_super) {
    __extends(SpeakerRecognitionCancellationDetails, _super);
    function SpeakerRecognitionCancellationDetails(reason, errorDetails, errorCode) {
        return _super.call(this, reason, errorDetails, errorCode) || this;
    }
    /**
     * Creates an instance of SpeakerRecognitionCancellationDetails object for the canceled SpeakerRecognitionResult
     * @member SpeakerRecognitionCancellationDetails.fromResult
     * @function
     * @public
     * @param {SpeakerRecognitionResult} result - The result that was canceled.
     * @returns {SpeakerRecognitionCancellationDetails} The cancellation details object being created.
     */ SpeakerRecognitionCancellationDetails.fromResult = function(result) {
        var reason = Exports_2.CancellationReason.Error;
        var errorCode = Exports_2.CancellationErrorCode.NoError;
        if (!!result.properties) errorCode = Exports_2.CancellationErrorCode[result.properties.getProperty(Exports_1.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[Exports_2.CancellationErrorCode.NoError])];
        return new SpeakerRecognitionCancellationDetails(reason, result.errorDetails, errorCode);
    };
    return SpeakerRecognitionCancellationDetails;
}(Exports_2.CancellationDetailsBase);
exports.SpeakerRecognitionCancellationDetails = SpeakerRecognitionCancellationDetails;

},{"949e39b9cdfda333":"7Qpvn","7d8dd450dfa8708b":"hxkc3"}],"6pz5J":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", {
    value: true
});
var Conversation_1 = require("f0e2d26c9c15481e");
Object.defineProperty(exports, "Conversation", {
    enumerable: true,
    get: function() {
        return Conversation_1.Conversation;
    }
});
Object.defineProperty(exports, "ConversationImpl", {
    enumerable: true,
    get: function() {
        return Conversation_1.ConversationImpl;
    }
});
var ConversationCommon_1 = require("94d1277e90cee4b6");
Object.defineProperty(exports, "ConversationCommon", {
    enumerable: true,
    get: function() {
        return ConversationCommon_1.ConversationCommon;
    }
});
var ConversationExpirationEventArgs_1 = require("807b990677b1c89e");
Object.defineProperty(exports, "ConversationExpirationEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationExpirationEventArgs_1.ConversationExpirationEventArgs;
    }
});
var ConversationParticipantsChangedEventArgs_1 = require("43b1f32a6ac24fee");
Object.defineProperty(exports, "ConversationParticipantsChangedEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationParticipantsChangedEventArgs_1.ConversationParticipantsChangedEventArgs;
    }
});
var ConversationTranslationCanceledEventArgs_1 = require("ac62a708dfc00f07");
Object.defineProperty(exports, "ConversationTranslationCanceledEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationTranslationCanceledEventArgs_1.ConversationTranslationCanceledEventArgs;
    }
});
var ConversationTranslationEventArgs_1 = require("6e5167a2b36e8ac4");
Object.defineProperty(exports, "ConversationTranslationEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationTranslationEventArgs_1.ConversationTranslationEventArgs;
    }
});
var ConversationTranslationResult_1 = require("c052687e5201445");
Object.defineProperty(exports, "ConversationTranslationResult", {
    enumerable: true,
    get: function() {
        return ConversationTranslationResult_1.ConversationTranslationResult;
    }
});
var ConversationTranslator_1 = require("13346072d2dea960");
Object.defineProperty(exports, "ConversationTranslator", {
    enumerable: true,
    get: function() {
        return ConversationTranslator_1.ConversationTranslator;
    }
});
var ConversationTranscriber_1 = require("cef3e19a13aff77e");
Object.defineProperty(exports, "ConversationTranscriber", {
    enumerable: true,
    get: function() {
        return ConversationTranscriber_1.ConversationTranscriber;
    }
});
var IParticipant_1 = require("3a7c30739698e6e4");
Object.defineProperty(exports, "Participant", {
    enumerable: true,
    get: function() {
        return IParticipant_1.Participant;
    }
});
Object.defineProperty(exports, "User", {
    enumerable: true,
    get: function() {
        return IParticipant_1.User;
    }
});
var ParticipantChangedReason_1 = require("46bf31e124016e1e");
Object.defineProperty(exports, "ParticipantChangedReason", {
    enumerable: true,
    get: function() {
        return ParticipantChangedReason_1.ParticipantChangedReason;
    }
});
var Meeting_1 = require("9ab340e539645ace");
Object.defineProperty(exports, "Meeting", {
    enumerable: true,
    get: function() {
        return Meeting_1.Meeting;
    }
});
Object.defineProperty(exports, "MeetingImpl", {
    enumerable: true,
    get: function() {
        return Meeting_1.MeetingImpl;
    }
});
var MeetingTranscriptionCanceledEventArgs_1 = require("151c622dc617e11c");
Object.defineProperty(exports, "MeetingTranscriptionCanceledEventArgs", {
    enumerable: true,
    get: function() {
        return MeetingTranscriptionCanceledEventArgs_1.MeetingTranscriptionCanceledEventArgs;
    }
});
var MeetingTranscriber_1 = require("2b9b8bd903312428");
Object.defineProperty(exports, "MeetingTranscriber", {
    enumerable: true,
    get: function() {
        return MeetingTranscriber_1.MeetingTranscriber;
    }
});
var ConversationTranscriptionResult_1 = require("a1bd5a03c599b977");
Object.defineProperty(exports, "ConversationTranscriptionResult", {
    enumerable: true,
    get: function() {
        return ConversationTranscriptionResult_1.ConversationTranscriptionResult;
    }
});

},{"f0e2d26c9c15481e":"lzhw1","94d1277e90cee4b6":"bYM1v","807b990677b1c89e":"c7PpM","43b1f32a6ac24fee":"9bciV","ac62a708dfc00f07":"167tN","6e5167a2b36e8ac4":"5yKyr","c052687e5201445":"4GNcW","13346072d2dea960":"bcvMJ","cef3e19a13aff77e":"8YKg9","3a7c30739698e6e4":"1qkJX","46bf31e124016e1e":"3OlRF","9ab340e539645ace":"AAHPF","151c622dc617e11c":"fJsXt","2b9b8bd903312428":"5bZbG","a1bd5a03c599b977":"gaPT2"}],"lzhw1":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __spreadArrays = this && this.__spreadArrays || function() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationImpl = exports.Conversation = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("8815d754c0907b68");
var Exports_2 = require("fee043353a4db609");
var Contracts_1 = require("a614fe4fc95d7e1e");
var Exports_3 = require("75481c1382e6f55a");
var Conversation = /** @class */ function() {
    function Conversation() {
        return;
    }
    /**
     * Create a conversation
     * @param speechConfig
     * @param cb
     * @param err
     */ Conversation.createConversationAsync = function(speechConfig, arg2, arg3, arg4) {
        var _this = this;
        Contracts_1.Contracts.throwIfNullOrUndefined(speechConfig, Exports_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config"));
        Contracts_1.Contracts.throwIfNullOrUndefined(speechConfig.region, Exports_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region"));
        if (!speechConfig.subscriptionKey && !speechConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceAuthorization_Token])) Contracts_1.Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, Exports_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
        var conversationImpl;
        var cb;
        var err;
        if (typeof arg2 === "string") {
            conversationImpl = new ConversationImpl(speechConfig, arg2);
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            Exports_2.marshalPromiseToCallbacks(function() {
                return __awaiter(_this, void 0, void 0, function() {
                    return __generator(this, function(_a) {
                        return [
                            2 /*return*/ 
                        ];
                    });
                });
            }(), arg3, arg4);
        } else {
            conversationImpl = new ConversationImpl(speechConfig);
            cb = arg2;
            err = arg3;
            conversationImpl.createConversationAsync(function() {
                if (!!cb) cb();
            }, function(error) {
                if (!!err) err(error);
            });
        }
        return conversationImpl;
    };
    return Conversation;
}();
exports.Conversation = Conversation;
var ConversationImpl = /** @class */ function(_super) {
    __extends(ConversationImpl, _super);
    /**
     * Create a conversation impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */ function ConversationImpl(speechConfig, id) {
        var _this = _super.call(this) || this;
        _this.privErrors = Exports_1.ConversationConnectionConfig.restErrors;
        /** websocket callbacks */ /* eslint-disable @typescript-eslint/typedef */ _this.onConnected = function(e) {
            var _a;
            _this.privIsConnected = true;
            try {
                if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.sessionStarted)) _this.privConversationTranslator.sessionStarted(_this.privConversationTranslator, e);
            } catch (e) {
            //
            }
        };
        _this.onDisconnected = function(e) {
            var _a;
            try {
                if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.sessionStopped)) _this.privConversationTranslator.sessionStopped(_this.privConversationTranslator, e);
            } catch (e) {
            //
            } finally{
                _this.close(false);
            }
        };
        _this.onCanceled = function(r, e) {
            var _a;
            try {
                if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.canceled)) _this.privConversationTranslator.canceled(_this.privConversationTranslator, e);
            } catch (e) {
            //
            }
        };
        _this.onParticipantUpdateCommandReceived = function(r, e) {
            try {
                var updatedParticipant = _this.privParticipants.getParticipant(e.id);
                if (updatedParticipant !== undefined) {
                    switch(e.key){
                        case Exports_1.ConversationTranslatorCommandTypes.changeNickname:
                            updatedParticipant.displayName = e.value;
                            break;
                        case Exports_1.ConversationTranslatorCommandTypes.setUseTTS:
                            updatedParticipant.isUsingTts = e.value;
                            break;
                        case Exports_1.ConversationTranslatorCommandTypes.setProfanityFiltering:
                            updatedParticipant.profanity = e.value;
                            break;
                        case Exports_1.ConversationTranslatorCommandTypes.setMute:
                            updatedParticipant.isMuted = e.value;
                            break;
                        case Exports_1.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                            updatedParticipant.translateToLanguages = e.value;
                            break;
                    }
                    _this.privParticipants.addOrUpdateParticipant(updatedParticipant);
                    if (!!_this.privConversationTranslator) _this.privConversationTranslator.participantsChanged(_this.privConversationTranslator, new Exports_3.ConversationParticipantsChangedEventArgs(Exports_3.ParticipantChangedReason.Updated, [
                        _this.toParticipant(updatedParticipant)
                    ], e.sessionId));
                }
            } catch (e) {
            //
            }
        };
        _this.onLockRoomCommandReceived = function() {
        // TODO
        };
        _this.onMuteAllCommandReceived = function(r, e) {
            try {
                _this.privParticipants.participants.forEach(function(p) {
                    return p.isMuted = p.isHost ? false : e.isMuted;
                });
                if (!!_this.privConversationTranslator) _this.privConversationTranslator.participantsChanged(_this.privConversationTranslator, new Exports_3.ConversationParticipantsChangedEventArgs(Exports_3.ParticipantChangedReason.Updated, _this.toParticipants(false), e.sessionId));
            } catch (e) {
            //
            }
        };
        _this.onParticipantJoinCommandReceived = function(r, e) {
            try {
                var newParticipant = _this.privParticipants.addOrUpdateParticipant(e.participant);
                if (newParticipant !== undefined) {
                    if (!!_this.privConversationTranslator) _this.privConversationTranslator.participantsChanged(_this.privConversationTranslator, new Exports_3.ConversationParticipantsChangedEventArgs(Exports_3.ParticipantChangedReason.JoinedConversation, [
                        _this.toParticipant(newParticipant)
                    ], e.sessionId));
                }
            } catch (e) {
            //
            }
        };
        _this.onParticipantLeaveCommandReceived = function(r, e) {
            try {
                var ejectedParticipant = _this.privParticipants.getParticipant(e.participant.id);
                if (ejectedParticipant !== undefined) {
                    // remove the participant from the internal participants list
                    _this.privParticipants.deleteParticipant(e.participant.id);
                    if (!!_this.privConversationTranslator) // notify subscribers that the participant has left the conversation
                    _this.privConversationTranslator.participantsChanged(_this.privConversationTranslator, new Exports_3.ConversationParticipantsChangedEventArgs(Exports_3.ParticipantChangedReason.LeftConversation, [
                        _this.toParticipant(ejectedParticipant)
                    ], e.sessionId));
                }
            } catch (e) {
            //
            }
        };
        _this.onTranslationReceived = function(r, e) {
            try {
                switch(e.command){
                    case Exports_1.ConversationTranslatorMessageTypes.final:
                        if (!!_this.privConversationTranslator) _this.privConversationTranslator.transcribed(_this.privConversationTranslator, new Exports_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
                        break;
                    case Exports_1.ConversationTranslatorMessageTypes.partial:
                        if (!!_this.privConversationTranslator) _this.privConversationTranslator.transcribing(_this.privConversationTranslator, new Exports_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
                        break;
                    case Exports_1.ConversationTranslatorMessageTypes.instantMessage:
                        if (!!_this.privConversationTranslator) _this.privConversationTranslator.textMessageReceived(_this.privConversationTranslator, new Exports_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
                        break;
                }
            } catch (e) {
            //
            }
        };
        _this.onParticipantsListReceived = function(r, e) {
            var _a;
            try {
                // check if the session token needs to be updated
                if (e.sessionToken !== undefined && e.sessionToken !== null) _this.privRoom.token = e.sessionToken;
                // save the participants
                _this.privParticipants.participants = __spreadArrays(e.participants);
                // enable the conversation
                if (_this.privParticipants.me !== undefined) _this.privIsReady = true;
                if (!!_this.privConversationTranslator) _this.privConversationTranslator.participantsChanged(_this.privConversationTranslator, new Exports_3.ConversationParticipantsChangedEventArgs(Exports_3.ParticipantChangedReason.JoinedConversation, _this.toParticipants(true), e.sessionId));
                // if this is the host, update the nickname if needed
                if (_this.me.isHost) {
                    var nickname = (_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.properties.getProperty(Exports_3.PropertyId.ConversationTranslator_Name);
                    if (nickname !== undefined && nickname.length > 0 && nickname !== _this.me.displayName) // issue a change nickname request
                    _this.changeNicknameAsync(nickname);
                }
            } catch (e) {
            //
            }
        };
        _this.onConversationExpiration = function(r, e) {
            try {
                if (!!_this.privConversationTranslator) _this.privConversationTranslator.conversationExpiration(_this.privConversationTranslator, e);
            } catch (e) {
            //
            }
        };
        _this.privIsConnected = false;
        _this.privIsDisposed = false;
        _this.privConversationId = "";
        _this.privProperties = new Exports_3.PropertyCollection();
        _this.privManager = new Exports_1.ConversationManager();
        // check the speech language
        var language = speechConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
        if (!language) speechConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage], Exports_1.ConversationConnectionConfig.defaultLanguageCode);
        _this.privLanguage = speechConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
        if (!id) {
            // check the target language(s)
            if (speechConfig.targetLanguages.length === 0) speechConfig.addTargetLanguage(_this.privLanguage);
            // check the profanity setting: speech and conversationTranslator should be in sync
            var profanity = speechConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceResponse_ProfanityOption]);
            if (!profanity) speechConfig.setProfanity(Exports_3.ProfanityOption.Masked);
            // check the nickname: it should pass this regex: ^\w+([\s-][\w\(\)]+)*$"
            // TODO: specify the regex required. Nicknames must be unique or get the duplicate nickname error
            // TODO: check what the max length is and if a truncation is required or if the service handles it without an error
            var hostNickname = speechConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.ConversationTranslator_Name]);
            if (hostNickname === undefined || hostNickname === null) hostNickname = "Host";
            Contracts_1.Contracts.throwIfNullOrTooLong(hostNickname, "nickname", 50);
            Contracts_1.Contracts.throwIfNullOrTooShort(hostNickname, "nickname", 2);
            speechConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.ConversationTranslator_Name], hostNickname);
        } else _this.privConversationId = id;
        // save the speech config for future usage
        _this.privConfig = speechConfig;
        // save the config properties
        var configImpl = speechConfig;
        Contracts_1.Contracts.throwIfNull(configImpl, "speechConfig");
        _this.privProperties = configImpl.properties.clone();
        _this.privIsConnected = false;
        _this.privParticipants = new Exports_1.InternalParticipants();
        _this.privIsReady = false;
        _this.privTextMessageMaxLength = 1000;
        return _this;
    }
    Object.defineProperty(ConversationImpl.prototype, "room", {
        // get the internal data about a conversation
        get: function() {
            return this.privRoom;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "connection", {
        // get the wrapper for connecting to the websockets
        get: function() {
            return this.privConversationRecognizer; // this.privConnection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "config", {
        // get the config
        get: function() {
            return this.privConfig;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "conversationId", {
        // get the conversation Id
        get: function() {
            return this.privRoom ? this.privRoom.roomId : this.privConversationId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "properties", {
        // get the properties
        get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "speechRecognitionLanguage", {
        // get the speech language
        get: function() {
            return this.privLanguage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "isMutedByHost", {
        get: function() {
            var _a, _b;
            return ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost) ? false : (_b = this.privParticipants.me) === null || _b === void 0 ? void 0 : _b.isMuted;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "isConnected", {
        get: function() {
            return this.privIsConnected && this.privIsReady;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "participants", {
        get: function() {
            return this.toParticipants(true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "me", {
        get: function() {
            return this.toParticipant(this.privParticipants.me);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "host", {
        get: function() {
            return this.toParticipant(this.privParticipants.host);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "transcriberRecognizer", {
        get: function() {
            return this.privTranscriberRecognizer;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "conversationInfo", {
        get: function() {
            var convId = this.conversationId;
            var p = this.participants.map(function(part) {
                return {
                    id: part.id,
                    preferredLanguage: part.preferredLanguage,
                    voice: part.voice
                };
            });
            var props = {};
            for(var _i = 0, _a = Exports_1.ConversationConnectionConfig.transcriptionEventKeys; _i < _a.length; _i++){
                var key = _a[_i];
                var val = this.properties.getProperty(key, "");
                if (val !== "") props[key] = val;
            }
            var info = {
                id: convId,
                participants: p,
                conversationProperties: props
            };
            return info;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "canSend", {
        get: function() {
            var _a;
            return this.privIsConnected && !((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isMuted);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "canSendAsHost", {
        get: function() {
            var _a;
            return this.privIsConnected && ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "authorizationToken", {
        // get / set the speech auth token
        // eslint-disable-next-line @typescript-eslint/member-ordering
        get: function() {
            return this.privToken;
        },
        set: function(value) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(value, "authorizationToken");
            this.privToken = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationImpl.prototype, "conversationTranslator", {
        set: function(conversationTranslator) {
            this.privConversationTranslator = conversationTranslator;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Create a new conversation as Host
     * @param cb
     * @param err
     */ ConversationImpl.prototype.createConversationAsync = function(cb, err) {
        var _this = this;
        try {
            if (!!this.privConversationRecognizer) this.handleError(new Error(this.privErrors.permissionDeniedStart), err);
            this.privManager.createOrJoin(this.privProperties, undefined, function(room) {
                if (!room) _this.handleError(new Error(_this.privErrors.permissionDeniedConnect), err);
                _this.privRoom = room;
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Starts a new conversation as host.
     * @param cb
     * @param err
     */ ConversationImpl.prototype.startConversationAsync = function(cb, err) {
        var _this = this;
        try {
            // check if there is already a recognizer
            if (!!this.privConversationRecognizer) this.handleError(new Error(this.privErrors.permissionDeniedStart), err);
            // check if there is conversation data available
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);
            // connect to the conversation websocket
            this.privParticipants.meId = this.privRoom.participantId;
            this.privConversationRecognizer = Exports_1.ConversationRecognizerFactory.fromConfig(this, this.privConfig);
            // Because ConversationTranslator manually sets up and manages the connection, Conversation
            // has to forward serviceRecognizer connection events that usually get passed automatically
            this.privConversationRecognizer.connected = this.onConnected;
            this.privConversationRecognizer.disconnected = this.onDisconnected;
            this.privConversationRecognizer.canceled = this.onCanceled;
            this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;
            this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;
            this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;
            this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;
            this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;
            this.privConversationRecognizer.translationReceived = this.onTranslationReceived;
            this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;
            this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;
            this.privConversationRecognizer.connect(this.privRoom.token, function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Join a conversation as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */ ConversationImpl.prototype.addParticipantAsync = function(participant, cb, err) {
        Contracts_1.Contracts.throwIfNullOrUndefined(participant, "Participant");
        Exports_2.marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb, err);
    };
    /**
     * Join a conversation as a participant.
     * @param conversation
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */ ConversationImpl.prototype.joinConversationAsync = function(conversationId, nickname, lang, cb, err) {
        var _this = this;
        try {
            // TODO
            // if (!!this.privConversationRecognizer) {
            //     throw new Error(this.privErrors.permissionDeniedStart);
            // }
            Contracts_1.Contracts.throwIfNullOrWhitespace(conversationId, this.privErrors.invalidArgs.replace("{arg}", "conversationId"));
            Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
            Contracts_1.Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace("{arg}", "language"));
            // join the conversation
            this.privManager.createOrJoin(this.privProperties, conversationId, function(room) {
                Contracts_1.Contracts.throwIfNullOrUndefined(room, _this.privErrors.permissionDeniedConnect);
                _this.privRoom = room;
                _this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;
                // join callback
                if (!!cb) cb(room.cognitiveSpeechAuthToken);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Deletes a conversation
     * @param cb
     * @param err
     */ ConversationImpl.prototype.deleteConversationAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.deleteConversationImplAsync(), cb, err);
    };
    ConversationImpl.prototype.deleteConversationImplAsync = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        Contracts_1.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);
                        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);
                        return [
                            4 /*yield*/ ,
                            this.privManager.leave(this.privProperties, this.privRoom.token)
                        ];
                    case 1:
                        _a.sent();
                        this.dispose();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */ ConversationImpl.prototype.endConversationAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.endConversationImplAsync(), cb, err);
    };
    ConversationImpl.prototype.endConversationImplAsync = function() {
        return this.close(true);
    };
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */ ConversationImpl.prototype.lockConversationAsync = function(cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSendAsHost) this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getLockCommand(true), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to mute the conversation
     * @param cb
     * @param err
     */ ConversationImpl.prototype.muteAllParticipantsAsync = function(cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            // check the user's permissions
            if (!this.canSendAsHost) this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(true), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to mute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */ ConversationImpl.prototype.muteParticipantAsync = function(userId, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            // check the connection is open (host + participant can perform the mute command)
            if (!this.canSend) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
            // if not host, check the participant is not muting another participant
            if (!this.me.isHost && this.me.id !== userId) this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err);
            // check the user exists
            var exists = this.privParticipants.getParticipantIndex(userId);
            if (exists === -1) this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, true), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */ ConversationImpl.prototype.removeParticipantAsync = function(userId, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            if (!!this.privTranscriberRecognizer && userId.hasOwnProperty("id")) // Assume this is a transcription participant
            Exports_2.marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId), cb, err);
            else {
                Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
                Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
                if (!this.canSendAsHost) this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), err);
                var participantId_1 = "";
                if (typeof userId === "string") participantId_1 = userId;
                else if (userId.hasOwnProperty("id")) {
                    var participant = userId;
                    participantId_1 = participant.id;
                } else if (userId.hasOwnProperty("userId")) {
                    var user = userId;
                    participantId_1 = user.userId;
                }
                Contracts_1.Contracts.throwIfNullOrWhitespace(participantId_1, this.privErrors.invalidArgs.replace("{arg}", "userId"));
                // check the participant exists
                var index = this.participants.findIndex(function(p) {
                    return p.id === participantId_1;
                });
                if (index === -1) this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
                if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getEjectCommand(participantId_1), function() {
                    _this.handleCallback(cb, err);
                }, function(error) {
                    _this.handleError(error, err);
                });
            }
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to unlock the conversation
     * @param cb
     * @param err
     */ ConversationImpl.prototype.unlockConversationAsync = function(cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSendAsHost) this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getLockCommand(false), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to unmute all participants in the conversation
     * @param cb
     * @param err
     */ ConversationImpl.prototype.unmuteAllParticipantsAsync = function(cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSendAsHost) this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(false), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to unmute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */ ConversationImpl.prototype.unmuteParticipantAsync = function(userId, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            // check the connection is open (host + participant can perform the mute command)
            if (!this.canSend) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
            // if not host, check the participant is not muting another participant
            if (!this.me.isHost && this.me.id !== userId) this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err);
            // check the user exists
            var exists = this.privParticipants.getParticipantIndex(userId);
            if (exists === -1) this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, false), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */ ConversationImpl.prototype.sendTextMessageAsync = function(message, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace("{arg}", "message"));
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSend) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
            // TODO: is a max length check required?
            if (message.length > this.privTextMessageMaxLength) this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getMessageCommand(message), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */ ConversationImpl.prototype.setTranslatedLanguagesAsync = function(languages, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfArrayEmptyOrWhitespace(languages, this.privErrors.invalidArgs.replace("{arg}", "languages"));
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSend) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(languages), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */ ConversationImpl.prototype.changeNicknameAsync = function(nickname, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSend) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(nickname), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    ConversationImpl.prototype.isDisposed = function() {
        return this.privIsDisposed;
    };
    ConversationImpl.prototype.dispose = function() {
        if (this.isDisposed) return;
        this.privIsDisposed = true;
        if (!!this.config) this.config.close();
        this.privConfig = undefined;
        this.privLanguage = undefined;
        this.privProperties = undefined;
        this.privRoom = undefined;
        this.privToken = undefined;
        this.privManager = undefined;
        this.privIsConnected = false;
        this.privIsReady = false;
        this.privParticipants = undefined;
    };
    ConversationImpl.prototype.connectTranscriberRecognizer = function(recognizer) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!!this.privTranscriberRecognizer) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privTranscriberRecognizer.close()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            4 /*yield*/ ,
                            recognizer.enforceAudioGating()
                        ];
                    case 3:
                        _a.sent();
                        this.privTranscriberRecognizer = recognizer;
                        this.privTranscriberRecognizer.conversation = this;
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ConversationImpl.prototype.getKeepAlive = function() {
        var nickname = !!this.me ? this.me.displayName : "default_nickname";
        return JSON.stringify({
            id: "0",
            nickname: nickname,
            participantId: this.privRoom.participantId,
            roomId: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.keepAlive
        });
    };
    /* eslint-enable @typescript-eslint/typedef */ ConversationImpl.prototype.addParticipantImplAsync = function(participant) {
        var newParticipant = this.privParticipants.addOrUpdateParticipant(participant);
        if (newParticipant !== undefined) {
            if (!!this.privTranscriberRecognizer) {
                var conversationInfo = this.conversationInfo;
                conversationInfo.participants = [
                    participant
                ];
                return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, "join");
            }
        }
    };
    ConversationImpl.prototype.removeParticipantImplAsync = function(participant) {
        this.privParticipants.deleteParticipant(participant.id);
        var conversationInfo = this.conversationInfo;
        conversationInfo.participants = [
            participant
        ];
        return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, "leave");
    };
    ConversationImpl.prototype.close = function(dispose) {
        var _a;
        return __awaiter(this, void 0, void 0, function() {
            var e_1;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _b.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]);
                        this.privIsConnected = false;
                        return [
                            4 /*yield*/ ,
                            (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.close()
                        ];
                    case 1:
                        _b.sent();
                        this.privConversationRecognizer = undefined;
                        if (!!this.privConversationTranslator) this.privConversationTranslator.dispose();
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 2:
                        e_1 = _b.sent();
                        // ignore error
                        throw e_1;
                    case 3:
                        if (dispose) this.dispose();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /** Helpers */ ConversationImpl.prototype.handleCallback = function(cb, err) {
        if (!!cb) {
            try {
                cb();
            } catch (e) {
                if (!!err) err(e);
            }
            cb = undefined;
        }
    };
    ConversationImpl.prototype.handleError = function(error, err) {
        if (!!err) {
            if (error instanceof Error) {
                var typedError = error;
                err(typedError.name + ": " + typedError.message);
            } else err(error);
        }
    };
    /** Participant Helpers */ ConversationImpl.prototype.toParticipants = function(includeHost) {
        var _this = this;
        var participants = this.privParticipants.participants.map(function(p) {
            return _this.toParticipant(p);
        });
        if (!includeHost) return participants.filter(function(p) {
            return p.isHost === false;
        });
        else return participants;
    };
    ConversationImpl.prototype.toParticipant = function(p) {
        return new Exports_3.Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage, p.voice);
    };
    ConversationImpl.prototype.getMuteAllCommand = function(isMuted) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.setMuteAll,
            participantId: this.privRoom.participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand,
            value: isMuted
        });
    };
    ConversationImpl.prototype.getMuteCommand = function(participantId, isMuted) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.setMute,
            // eslint-disable-next-line object-shorthand
            participantId: participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand,
            value: isMuted
        });
    };
    ConversationImpl.prototype.getLockCommand = function(isLocked) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.setLockState,
            participantId: this.privRoom.participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand,
            value: isLocked
        });
    };
    ConversationImpl.prototype.getEjectCommand = function(participantId) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.ejectParticipant,
            // eslint-disable-next-line object-shorthand
            participantId: participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand
        });
    };
    ConversationImpl.prototype.getSetTranslateToLanguagesCommand = function(languages) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.setTranslateToLanguages,
            participantId: this.privRoom.participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand,
            value: languages
        });
    };
    ConversationImpl.prototype.getChangeNicknameCommand = function(nickname) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.changeNickname,
            nickname: nickname,
            participantId: this.privRoom.participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand,
            value: nickname
        });
    };
    ConversationImpl.prototype.getMessageCommand = function(message) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(message, "message");
        return JSON.stringify({
            participantId: this.privRoom.participantId,
            roomId: this.privRoom.roomId,
            text: message,
            type: Exports_1.ConversationTranslatorMessageTypes.instantMessage
        });
    };
    return ConversationImpl;
}(Conversation);
exports.ConversationImpl = ConversationImpl;

},{"8815d754c0907b68":"7Qpvn","fee043353a4db609":"5Bedw","a614fe4fc95d7e1e":"4jwu5","75481c1382e6f55a":"hxkc3"}],"bYM1v":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationCommon = void 0;
var ConversationCommon = /** @class */ function() {
    function ConversationCommon(audioConfig) {
        this.privAudioConfig = audioConfig;
    }
    ConversationCommon.prototype.handleCallback = function(cb, err) {
        if (!!cb) {
            try {
                cb();
            } catch (e) {
                if (!!err) err(e);
            }
            cb = undefined;
        }
    };
    ConversationCommon.prototype.handleError = function(error, err) {
        if (!!err) {
            if (error instanceof Error) {
                var typedError = error;
                err(typedError.name + ": " + typedError.message);
            } else err(error);
        }
    };
    return ConversationCommon;
}();
exports.ConversationCommon = ConversationCommon;

},{}],"c7PpM":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationExpirationEventArgs = void 0;
var Exports_1 = require("cbc7377b8821aed");
var ConversationExpirationEventArgs = /** @class */ function(_super) {
    __extends(ConversationExpirationEventArgs, _super);
    function ConversationExpirationEventArgs(expirationTime, sessionId) {
        var _this = _super.call(this, sessionId) || this;
        _this.privExpirationTime = expirationTime;
        return _this;
    }
    Object.defineProperty(ConversationExpirationEventArgs.prototype, "expirationTime", {
        /** How much longer until the conversation expires (in minutes). */ get: function() {
            return this.privExpirationTime;
        },
        enumerable: false,
        configurable: true
    });
    return ConversationExpirationEventArgs;
}(Exports_1.SessionEventArgs);
exports.ConversationExpirationEventArgs = ConversationExpirationEventArgs;

},{"cbc7377b8821aed":"hxkc3"}],"9bciV":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationParticipantsChangedEventArgs = void 0;
var Exports_1 = require("d318ec90b2f07e3f");
var ConversationParticipantsChangedEventArgs = /** @class */ function(_super) {
    __extends(ConversationParticipantsChangedEventArgs, _super);
    function ConversationParticipantsChangedEventArgs(reason, participants, sessionId) {
        var _this = _super.call(this, sessionId) || this;
        _this.privReason = reason;
        _this.privParticipant = participants;
        return _this;
    }
    Object.defineProperty(ConversationParticipantsChangedEventArgs.prototype, "reason", {
        get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationParticipantsChangedEventArgs.prototype, "participants", {
        get: function() {
            return this.privParticipant;
        },
        enumerable: false,
        configurable: true
    });
    return ConversationParticipantsChangedEventArgs;
}(Exports_1.SessionEventArgs);
exports.ConversationParticipantsChangedEventArgs = ConversationParticipantsChangedEventArgs;

},{"d318ec90b2f07e3f":"hxkc3"}],"167tN":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranslationCanceledEventArgs = void 0;
var CancellationEventArgsBase_1 = require("5af999e423f002ff");
var ConversationTranslationCanceledEventArgs = /** @class */ function(_super) {
    __extends(ConversationTranslationCanceledEventArgs, _super);
    function ConversationTranslationCanceledEventArgs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ConversationTranslationCanceledEventArgs;
}(CancellationEventArgsBase_1.CancellationEventArgsBase);
exports.ConversationTranslationCanceledEventArgs = ConversationTranslationCanceledEventArgs;

},{"5af999e423f002ff":"7hXId"}],"5yKyr":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranslationEventArgs = void 0;
var Exports_1 = require("5ae5a6bf0f000ae2");
var ConversationTranslationEventArgs = /** @class */ function(_super) {
    __extends(ConversationTranslationEventArgs, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranslationResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */ function ConversationTranslationEventArgs(result, offset, sessionId) {
        var _this = _super.call(this, offset, sessionId) || this;
        _this.privResult = result;
        return _this;
    }
    Object.defineProperty(ConversationTranslationEventArgs.prototype, "result", {
        /**
         * Specifies the recognition result.
         * @returns {ConversationTranslationResult} the recognition result.
         */ get: function() {
            return this.privResult;
        },
        enumerable: false,
        configurable: true
    });
    return ConversationTranslationEventArgs;
}(Exports_1.RecognitionEventArgs);
exports.ConversationTranslationEventArgs = ConversationTranslationEventArgs;

},{"5ae5a6bf0f000ae2":"hxkc3"}],"4GNcW":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranslationResult = void 0;
var TranslationRecognitionResult_1 = require("74eed75746b8de5c");
var ConversationTranslationResult = /** @class */ function(_super) {
    __extends(ConversationTranslationResult, _super);
    function ConversationTranslationResult(participantId, translations, originalLanguage, resultId, reason, text, duration, offset, errorDetails, json, properties) {
        var _this = _super.call(this, translations, resultId, reason, text, duration, offset, undefined, undefined, errorDetails, json, properties) || this;
        _this.privId = participantId;
        _this.privOrigLang = originalLanguage;
        return _this;
    }
    Object.defineProperty(ConversationTranslationResult.prototype, "participantId", {
        /**
         * The unique identifier for the participant this result is for.
         */ get: function() {
            return this.privId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranslationResult.prototype, "originalLang", {
        /**
         * The original language this result was in.
         */ get: function() {
            return this.privOrigLang;
        },
        enumerable: false,
        configurable: true
    });
    return ConversationTranslationResult;
}(TranslationRecognitionResult_1.TranslationRecognitionResult);
exports.ConversationTranslationResult = ConversationTranslationResult;

},{"74eed75746b8de5c":"bX84V"}],"bcvMJ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranslator = exports.SpeechState = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("fff8e98b2aebb47b");
var ConversationTranslatorConnectionFactory_1 = require("1a4eabe47022fe69");
var Exports_2 = require("315abd0c1504da30");
var Contracts_1 = require("207681c764341fbb");
var Exports_3 = require("589c063c804ce189");
var Conversation_1 = require("6130ffc1c29778e0");
var Exports_4 = require("593a77c8076b987b");
var SpeechState;
(function(SpeechState) {
    SpeechState[SpeechState["Inactive"] = 0] = "Inactive";
    SpeechState[SpeechState["Connecting"] = 1] = "Connecting";
    SpeechState[SpeechState["Connected"] = 2] = "Connected";
})(SpeechState = exports.SpeechState || (exports.SpeechState = {}));
// child class of TranslationRecognizer meant only for use with ConversationTranslator
var ConversationTranslationRecognizer = /** @class */ function(_super) {
    __extends(ConversationTranslationRecognizer, _super);
    function ConversationTranslationRecognizer(speechConfig, audioConfig, translator, convGetter) {
        var _this = _super.call(this, speechConfig, audioConfig, new ConversationTranslatorConnectionFactory_1.ConversationTranslatorConnectionFactory(convGetter)) || this;
        _this.privSpeechState = SpeechState.Inactive;
        if (!!translator) {
            _this.privTranslator = translator;
            _this.sessionStarted = function() {
                _this.privSpeechState = SpeechState.Connected;
            };
            _this.sessionStopped = function() {
                _this.privSpeechState = SpeechState.Inactive;
            };
            _this.recognizing = function(tr, e) {
                if (!!_this.privTranslator.recognizing) _this.privTranslator.recognizing(_this.privTranslator, e);
            };
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            _this.recognized = function(tr, e) {
                return __awaiter(_this, void 0, void 0, function() {
                    var _a;
                    return __generator(this, function(_b) {
                        switch(_b.label){
                            case 0:
                                if (!((_a = e.result) === null || _a === void 0 ? void 0 : _a.errorDetails)) return [
                                    3 /*break*/ ,
                                    2
                                ];
                                return [
                                    4 /*yield*/ ,
                                    this.cancelSpeech()
                                ];
                            case 1:
                                _b.sent();
                                // TODO: format the error message contained in 'errorDetails'
                                this.fireCancelEvent(e.result.errorDetails);
                                return [
                                    3 /*break*/ ,
                                    3
                                ];
                            case 2:
                                if (!!this.privTranslator.recognized) this.privTranslator.recognized(this.privTranslator, e);
                                _b.label = 3;
                            case 3:
                                return [
                                    2 /*return*/ 
                                ];
                        }
                    });
                });
            };
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            _this.canceled = function() {
                return __awaiter(_this, void 0, void 0, function() {
                    var error_1;
                    return __generator(this, function(_a) {
                        switch(_a.label){
                            case 0:
                                if (!(this.privSpeechState !== SpeechState.Inactive)) return [
                                    3 /*break*/ ,
                                    4
                                ];
                                _a.label = 1;
                            case 1:
                                _a.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                return [
                                    4 /*yield*/ ,
                                    this.cancelSpeech()
                                ];
                            case 2:
                                _a.sent();
                                return [
                                    3 /*break*/ ,
                                    4
                                ];
                            case 3:
                                error_1 = _a.sent();
                                this.privSpeechState = SpeechState.Inactive;
                                return [
                                    3 /*break*/ ,
                                    4
                                ];
                            case 4:
                                return [
                                    2 /*return*/ 
                                ];
                        }
                    });
                });
            };
        }
        return _this;
    }
    Object.defineProperty(ConversationTranslationRecognizer.prototype, "state", {
        get: function() {
            return this.privSpeechState;
        },
        set: function(newState) {
            this.privSpeechState = newState;
        },
        enumerable: false,
        configurable: true
    });
    ConversationTranslationRecognizer.prototype.onConnection = function() {
        this.privSpeechState = SpeechState.Connected;
    };
    ConversationTranslationRecognizer.prototype.onDisconnection = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.privSpeechState = SpeechState.Inactive;
                        return [
                            4 /*yield*/ ,
                            this.cancelSpeech()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Fire a cancel event
     * @param error
     */ ConversationTranslationRecognizer.prototype.fireCancelEvent = function(error) {
        try {
            if (!!this.privTranslator.canceled) {
                var cancelEvent = new Exports_4.ConversationTranslationCanceledEventArgs(Exports_3.CancellationReason.Error, error, Exports_3.CancellationErrorCode.RuntimeError);
                this.privTranslator.canceled(this.privTranslator, cancelEvent);
            }
        } catch (e) {
        //
        }
    };
    ConversationTranslationRecognizer.prototype.cancelSpeech = function() {
        var _a;
        return __awaiter(this, void 0, void 0, function() {
            var e_1;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _b.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]);
                        this.stopContinuousRecognitionAsync();
                        return [
                            4 /*yield*/ ,
                            (_a = this.privReco) === null || _a === void 0 ? void 0 : _a.disconnect()
                        ];
                    case 1:
                        _b.sent();
                        this.privSpeechState = SpeechState.Inactive;
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 2:
                        e_1 = _b.sent();
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    return ConversationTranslationRecognizer;
}(Exports_3.TranslationRecognizer);
/**
 * Join, leave or connect to a conversation.
 */ var ConversationTranslator = /** @class */ function(_super) {
    __extends(ConversationTranslator, _super);
    function ConversationTranslator(audioConfig) {
        var _this = _super.call(this, audioConfig) || this;
        _this.privErrors = Exports_1.ConversationConnectionConfig.restErrors;
        _this.privIsDisposed = false;
        _this.privIsSpeaking = false;
        _this.privPlaceholderKey = "abcdefghijklmnopqrstuvwxyz012345";
        _this.privPlaceholderRegion = "westus";
        _this.privProperties = new Exports_3.PropertyCollection();
        return _this;
    }
    Object.defineProperty(ConversationTranslator.prototype, "properties", {
        get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranslator.prototype, "speechRecognitionLanguage", {
        get: function() {
            return this.privSpeechRecognitionLanguage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranslator.prototype, "participants", {
        get: function() {
            var _a;
            return (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.participants;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranslator.prototype, "canSpeak", {
        get: function() {
            // is there a Conversation websocket available and has the Recognizer been set up
            if (!this.privConversation.isConnected || !this.privCTRecognizer) return false;
            // is the user already speaking
            if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) return false;
            // is the user muted
            if (this.privConversation.isMutedByHost) return false;
            return true;
        },
        enumerable: false,
        configurable: true
    });
    ConversationTranslator.prototype.setServiceProperty = function(name, value) {
        var currentProperties = JSON.parse(this.privProperties.getProperty(Exports_1.ServicePropertiesPropertyName, "{}"));
        currentProperties[name] = value;
        this.privProperties.setProperty(Exports_1.ServicePropertiesPropertyName, JSON.stringify(currentProperties));
    };
    ConversationTranslator.prototype.joinConversationAsync = function(conversation, nickname, param1, param2, param3) {
        var _this = this;
        try {
            if (typeof conversation === "string") {
                Contracts_1.Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace("{arg}", "conversation id"));
                Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
                if (!!this.privConversation) this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);
                var lang = param1;
                if (lang === undefined || lang === null || lang === "") lang = Exports_1.ConversationConnectionConfig.defaultLanguageCode;
                // create a placeholder config
                this.privSpeechTranslationConfig = Exports_3.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion);
                this.privSpeechTranslationConfig.setProfanity(Exports_3.ProfanityOption.Masked);
                this.privSpeechTranslationConfig.addTargetLanguage(lang);
                this.privSpeechTranslationConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage], lang);
                this.privSpeechTranslationConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.ConversationTranslator_Name], nickname);
                var propertyIdsToCopy = [
                    Exports_3.PropertyId.SpeechServiceConnection_Host,
                    Exports_3.PropertyId.ConversationTranslator_Host,
                    Exports_3.PropertyId.SpeechServiceConnection_Endpoint,
                    Exports_3.PropertyId.SpeechServiceConnection_ProxyHostName,
                    Exports_3.PropertyId.SpeechServiceConnection_ProxyPassword,
                    Exports_3.PropertyId.SpeechServiceConnection_ProxyPort,
                    Exports_3.PropertyId.SpeechServiceConnection_ProxyUserName,
                    "ConversationTranslator_MultiChannelAudio",
                    "ConversationTranslator_Region"
                ];
                for(var _i = 0, propertyIdsToCopy_1 = propertyIdsToCopy; _i < propertyIdsToCopy_1.length; _i++){
                    var prop = propertyIdsToCopy_1[_i];
                    var value = this.privProperties.getProperty(prop);
                    if (value) {
                        var key = typeof prop === "string" ? prop : Exports_3.PropertyId[prop];
                        this.privSpeechTranslationConfig.setProperty(key, value);
                    }
                }
                var currentProperties = JSON.parse(this.privProperties.getProperty(Exports_1.ServicePropertiesPropertyName, "{}"));
                for(var _a = 0, _b = Object.keys(currentProperties); _a < _b.length; _a++){
                    var prop = _b[_a];
                    this.privSpeechTranslationConfig.setServiceProperty(prop, currentProperties[prop], Exports_3.ServicePropertyChannel.UriQueryParameter);
                }
                // join the conversation
                this.privConversation = new Conversation_1.ConversationImpl(this.privSpeechTranslationConfig);
                this.privConversation.conversationTranslator = this;
                this.privConversation.joinConversationAsync(conversation, nickname, lang, function(result) {
                    if (!result) _this.handleError(new Error(_this.privErrors.permissionDeniedConnect), param3);
                    _this.privSpeechTranslationConfig.authorizationToken = result;
                    _this.privConversation.room.isHost = false;
                    // connect to the ws
                    _this.privConversation.startConversationAsync(function() {
                        _this.handleCallback(param2, param3);
                    }, function(error) {
                        _this.handleError(error, param3);
                    });
                }, function(error) {
                    _this.handleError(error, param3);
                });
            } else if (typeof conversation === "object") {
                Contracts_1.Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace("{arg}", "conversation id"));
                Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
                // save the nickname
                this.privProperties.setProperty(Exports_3.PropertyId.ConversationTranslator_Name, nickname);
                // ref the conversation object
                this.privConversation = conversation;
                // ref the conversation translator object
                this.privConversation.conversationTranslator = this;
                this.privConversation.room.isHost = true;
                Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);
                Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);
                this.privSpeechTranslationConfig = conversation.config;
                this.handleCallback(param1, param2);
            } else this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "invalid conversation type")), param2);
        } catch (error) {
            this.handleError(error, typeof param1 === "string" ? param3 : param2);
        }
    };
    /**
     * Leave the conversation
     * @param cb
     * @param err
     */ ConversationTranslator.prototype.leaveConversationAsync = function(cb, err) {
        var _this = this;
        Exports_2.marshalPromiseToCallbacks(function() {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            // stop the speech websocket
                            return [
                                4 /*yield*/ ,
                                this.cancelSpeech()
                            ];
                        case 1:
                            // stop the speech websocket
                            _a.sent();
                            // stop the websocket
                            return [
                                4 /*yield*/ ,
                                this.privConversation.endConversationImplAsync()
                            ];
                        case 2:
                            // stop the websocket
                            _a.sent();
                            // https delete request
                            return [
                                4 /*yield*/ ,
                                this.privConversation.deleteConversationImplAsync()
                            ];
                        case 3:
                            // https delete request
                            _a.sent();
                            this.dispose();
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        }(), cb, err);
    };
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */ ConversationTranslator.prototype.sendTextMessageAsync = function(message, cb, err) {
        try {
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);
            Contracts_1.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace("{arg}", message));
            this.privConversation.sendTextMessageAsync(message, cb, err);
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Start speaking
     * @param cb
     * @param err
     */ ConversationTranslator.prototype.startTranscribingAsync = function(cb, err) {
        var _this = this;
        Exports_2.marshalPromiseToCallbacks(function() {
            return __awaiter(_this, void 0, void 0, function() {
                var error_2;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            _a.trys.push([
                                0,
                                4,
                                ,
                                6
                            ]);
                            Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);
                            Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);
                            if (!(this.privCTRecognizer === undefined)) return [
                                3 /*break*/ ,
                                2
                            ];
                            return [
                                4 /*yield*/ ,
                                this.connectTranslatorRecognizer()
                            ];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            Contracts_1.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);
                            if (!this.canSpeak) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
                            return [
                                4 /*yield*/ ,
                                this.startContinuousRecognition()
                            ];
                        case 3:
                            _a.sent();
                            this.privIsSpeaking = true;
                            return [
                                3 /*break*/ ,
                                6
                            ];
                        case 4:
                            error_2 = _a.sent();
                            this.privIsSpeaking = false;
                            return [
                                4 /*yield*/ ,
                                this.cancelSpeech()
                            ];
                        case 5:
                            _a.sent();
                            throw error_2;
                        case 6:
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        }(), cb, err);
    };
    /**
     * Stop speaking
     * @param cb
     * @param err
     */ ConversationTranslator.prototype.stopTranscribingAsync = function(cb, err) {
        var _this = this;
        Exports_2.marshalPromiseToCallbacks(function() {
            return __awaiter(_this, void 0, void 0, function() {
                var error_3;
                var _this = this;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            _a.trys.push([
                                0,
                                4,
                                ,
                                6
                            ]);
                            if (!!this.privIsSpeaking) return [
                                3 /*break*/ ,
                                2
                            ];
                            // stop speech
                            return [
                                4 /*yield*/ ,
                                this.cancelSpeech()
                            ];
                        case 1:
                            // stop speech
                            _a.sent();
                            return [
                                2 /*return*/ 
                            ];
                        case 2:
                            // stop the recognition but leave the websocket open
                            this.privIsSpeaking = false;
                            return [
                                4 /*yield*/ ,
                                new Promise(function(resolve, reject) {
                                    _this.privCTRecognizer.stopContinuousRecognitionAsync(resolve, reject);
                                })
                            ];
                        case 3:
                            _a.sent();
                            return [
                                3 /*break*/ ,
                                6
                            ];
                        case 4:
                            error_3 = _a.sent();
                            return [
                                4 /*yield*/ ,
                                this.cancelSpeech()
                            ];
                        case 5:
                            _a.sent();
                            return [
                                3 /*break*/ ,
                                6
                            ];
                        case 6:
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        }(), cb, err);
    };
    ConversationTranslator.prototype.isDisposed = function() {
        return this.privIsDisposed;
    };
    ConversationTranslator.prototype.dispose = function(reason, success, err) {
        var _this = this;
        Exports_2.marshalPromiseToCallbacks(function() {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            if (this.isDisposed && !this.privIsSpeaking) return [
                                2 /*return*/ 
                            ];
                            return [
                                4 /*yield*/ ,
                                this.cancelSpeech()
                            ];
                        case 1:
                            _a.sent();
                            this.privIsDisposed = true;
                            this.privSpeechTranslationConfig.close();
                            this.privSpeechRecognitionLanguage = undefined;
                            this.privProperties = undefined;
                            this.privAudioConfig = undefined;
                            this.privSpeechTranslationConfig = undefined;
                            this.privConversation.dispose();
                            this.privConversation = undefined;
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        }(), success, err);
    };
    /**
     * Cancel the speech websocket
     */ ConversationTranslator.prototype.cancelSpeech = function() {
        var _a;
        return __awaiter(this, void 0, void 0, function() {
            var e_2;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _b.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]);
                        this.privIsSpeaking = false;
                        return [
                            4 /*yield*/ ,
                            (_a = this.privCTRecognizer) === null || _a === void 0 ? void 0 : _a.onDisconnection()
                        ];
                    case 1:
                        _b.sent();
                        this.privCTRecognizer = undefined;
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 2:
                        e_2 = _b.sent();
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Connect to the speech translation recognizer.
     * Currently there is no language validation performed before sending the SpeechLanguage code to the service.
     * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'
     * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'
     */ ConversationTranslator.prototype.connectTranslatorRecognizer = function() {
        return __awaiter(this, void 0, void 0, function() {
            var convGetter, error_4;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        _a.trys.push([
                            0,
                            1,
                            ,
                            3
                        ]);
                        if (this.privAudioConfig === undefined) this.privAudioConfig = Exports_3.AudioConfig.fromDefaultMicrophoneInput();
                        // clear the temp subscription key if it's a participant joining
                        if (this.privSpeechTranslationConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey) this.privSpeechTranslationConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_Key], "");
                        convGetter = function() {
                            return _this.privConversation;
                        };
                        this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this, convGetter);
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 1:
                        error_4 = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.cancelSpeech()
                        ];
                    case 2:
                        _a.sent();
                        throw error_4;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Handle the start speaking request
     */ ConversationTranslator.prototype.startContinuousRecognition = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
            _this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);
        });
    };
    return ConversationTranslator;
}(Exports_4.ConversationCommon);
exports.ConversationTranslator = ConversationTranslator;

},{"fff8e98b2aebb47b":"7Qpvn","1a4eabe47022fe69":"645I6","315abd0c1504da30":"5Bedw","207681c764341fbb":"4jwu5","589c063c804ce189":"hxkc3","6130ffc1c29778e0":"lzhw1","593a77c8076b987b":"6pz5J"}],"645I6":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranslatorConnectionFactory = void 0;
var Exports_1 = require("c523ca33921dc7f4");
var StringUtils_1 = require("c572964b1e564677");
var Contracts_1 = require("828a19872823b0a3");
var Exports_2 = require("f3c4f1a189c3e3f3");
var HeaderNames_1 = require("d07d400d08a59088");
var QueryParameterNames_1 = require("3bb5886b698a1bf3");
var ConnectionFactoryBase_1 = require("5caacbb2ba55c88d");
var Exports_3 = require("908c92e5ec539924");
/**
 * Connection factory for the conversation translator. Handles connecting to the regular translator endpoint,
 * as well as the virtual microphone array transcription endpoint
 */ var ConversationTranslatorConnectionFactory = /** @class */ function(_super) {
    __extends(ConversationTranslatorConnectionFactory, _super);
    function ConversationTranslatorConnectionFactory(convGetter) {
        var _this = _super.call(this) || this;
        Contracts_1.Contracts.throwIfNullOrUndefined(convGetter, "convGetter");
        _this.privConvGetter = convGetter;
        return _this;
    }
    ConversationTranslatorConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        var isVirtMicArrayEndpoint = config.parameters.getProperty("ConversationTranslator_MultiChannelAudio", "").toUpperCase() === "TRUE";
        var convInfo = this.privConvGetter().room;
        var region = convInfo.cognitiveSpeechRegion || config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Region, "");
        var replacementValues = {
            hostSuffix: ConnectionFactoryBase_1.ConnectionFactoryBase.getHostSuffix(region),
            path: ConversationTranslatorConnectionFactory.CTS_VIRT_MIC_PATH,
            region: encodeURIComponent(region)
        };
        replacementValues[QueryParameterNames_1.QueryParameterNames.Language] = encodeURIComponent(config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage, ""));
        replacementValues[QueryParameterNames_1.QueryParameterNames.CtsMeetingId] = encodeURIComponent(convInfo.roomId);
        replacementValues[QueryParameterNames_1.QueryParameterNames.CtsDeviceId] = encodeURIComponent(convInfo.participantId);
        replacementValues[QueryParameterNames_1.QueryParameterNames.CtsIsParticipant] = convInfo.isHost ? "" : "&" + QueryParameterNames_1.QueryParameterNames.CtsIsParticipant;
        var endpointUrl = "";
        var queryParams = {};
        var headers = {};
        if (isVirtMicArrayEndpoint) {
            // connecting to the conversation transcription virtual microphone array endpoint
            endpointUrl = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint);
            if (!endpointUrl) {
                var hostName = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, "transcribe.{region}.cts.speech{hostSuffix}");
                endpointUrl = "wss://" + hostName + "{path}";
            }
            // because the region can change during a session, we support being passed a format string which we can then
            // replace with the correct information.
            endpointUrl = StringUtils_1.StringUtils.formatString(endpointUrl, replacementValues);
            var parsedUrl_1 = new URL(endpointUrl);
            parsedUrl_1.searchParams.forEach(function(val, key) {
                queryParams[key] = val;
            });
            var connFactory = new Exports_3.TranscriberConnectionFactory();
            connFactory.setQueryParams(queryParams, config, endpointUrl);
            // Some query parameters are required for the CTS endpoint, let's explicity set them here
            queryParams[QueryParameterNames_1.QueryParameterNames.CtsMeetingId] = replacementValues[QueryParameterNames_1.QueryParameterNames.CtsMeetingId];
            queryParams[QueryParameterNames_1.QueryParameterNames.CtsDeviceId] = replacementValues[QueryParameterNames_1.QueryParameterNames.CtsDeviceId];
            if (!convInfo.isHost) queryParams[QueryParameterNames_1.QueryParameterNames.CtsIsParticipant] = ""; // this doesn't have a value so set to an empty string
            if (!(QueryParameterNames_1.QueryParameterNames.Format in queryParams)) queryParams[QueryParameterNames_1.QueryParameterNames.Format] = "simple";
            parsedUrl_1.searchParams.forEach(function(val, key) {
                parsedUrl_1.searchParams.set(key, queryParams[key]);
                delete queryParams[key];
            });
            endpointUrl = parsedUrl_1.toString();
        } else {
            // connecting to regular translation endpoint
            var connFactory = new Exports_3.TranslationConnectionFactory();
            endpointUrl = connFactory.getEndpointUrl(config, true);
            endpointUrl = StringUtils_1.StringUtils.formatString(endpointUrl, replacementValues);
            connFactory.setQueryParams(queryParams, config, endpointUrl);
        }
        headers[HeaderNames_1.HeaderNames.ConnectionId] = connectionId;
        headers[Exports_1.RestConfigBase.configParams.token] = convInfo.token;
        if (authInfo.token) headers[authInfo.headerName] = authInfo.token;
        var enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "").toUpperCase() === "TRUE";
        return new Exports_1.WebsocketConnection(endpointUrl, queryParams, headers, new Exports_3.WebsocketMessageFormatter(), Exports_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    };
    ConversationTranslatorConnectionFactory.CTS_VIRT_MIC_PATH = "/speech/recognition/dynamicaudio";
    return ConversationTranslatorConnectionFactory;
}(ConnectionFactoryBase_1.ConnectionFactoryBase);
exports.ConversationTranslatorConnectionFactory = ConversationTranslatorConnectionFactory;

},{"c523ca33921dc7f4":"9oZeQ","c572964b1e564677":"2xnkU","828a19872823b0a3":"4jwu5","f3c4f1a189c3e3f3":"hxkc3","d07d400d08a59088":"bNYHA","3bb5886b698a1bf3":"fLrjT","5caacbb2ba55c88d":"hvoIt","908c92e5ec539924":"7Qpvn"}],"2xnkU":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StringUtils = void 0;
/**
 * String helper functions
 */ var StringUtils = /** @class */ function() {
    function StringUtils() {}
    /**
     * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.
     * @param format The format string that contains the parts to replace surrounded by {}. For example: "wss://{region}.cts.speech.microsoft.com".
     * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.
     * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string
     * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned
     */ StringUtils.formatString = function(format, replacements) {
        if (!format) return "";
        if (!replacements) return format;
        var formatted = "";
        var key = "";
        var appendToFormatted = function(str) {
            formatted += str;
        };
        var appendToKey = function(str) {
            key += str;
        };
        var appendFunc = appendToFormatted;
        for(var i = 0; i < format.length; i++){
            var c = format[i];
            var next = i + 1 < format.length ? format[i + 1] : "";
            switch(c){
                case "{":
                    if (next === "{") {
                        appendFunc("{");
                        i++;
                    } else appendFunc = appendToKey;
                    break;
                case "}":
                    if (next === "}") {
                        appendFunc("}");
                        i++;
                    } else {
                        if (replacements.hasOwnProperty(key)) formatted += replacements[key];
                        appendFunc = appendToFormatted;
                        key = "";
                    }
                    break;
                default:
                    appendFunc(c);
                    break;
            }
        }
        return formatted;
    };
    return StringUtils;
}();
exports.StringUtils = StringUtils;

},{}],"8YKg9":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranscriber = void 0;
var Exports_1 = require("667a6c498ce29c35");
var Exports_2 = require("b5c434eb685e840e");
var Contracts_1 = require("f9e8a71880025285");
var Exports_3 = require("2a9bb3e02b22faac");
/**
 * Performs speech recognition with speaker separation from microphone, file, or other audio input streams, and gets transcribed text as result.
 * @class ConversationTranscriber
 */ var ConversationTranscriber = /** @class */ function(_super) {
    __extends(ConversationTranscriber, _super);
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */ function ConversationTranscriber(speechConfig, audioConfig) {
        var _this = this;
        var speechConfigImpl = speechConfig;
        Contracts_1.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
        Contracts_1.Contracts.throwIfNullOrWhitespace(speechConfigImpl.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
        _this = _super.call(this, audioConfig, speechConfigImpl.properties, new Exports_1.ConversationTranscriberConnectionFactory()) || this;
        _this.privProperties.setProperty(Exports_3.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2");
        _this.privDisposedRecognizer = false;
        return _this;
    }
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */ ConversationTranscriber.FromConfig = function(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {
        var speechConfigImpl = speechConfig;
        autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);
        var recognizer = new ConversationTranscriber(speechConfig, audioConfig);
        return recognizer;
    };
    Object.defineProperty(ConversationTranscriber.prototype, "endpointId", {
        /**
         * Gets the endpoint id of a customized speech model that is used for transcription.
         * @member ConversationTranscriber.prototype.endpointId
         * @function
         * @public
         * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranscriber.prototype, "authorizationToken", {
        /**
         * Gets the authorization token used to communicate with the service.
         * @member ConversationTranscriber.prototype.authorizationToken
         * @function
         * @public
         * @returns {string} Authorization token.
         */ get: function() {
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token);
        },
        /**
         * Gets/Sets the authorization token used to communicate with the service.
         * @member ConversationTranscriber.prototype.authorizationToken
         * @function
         * @public
         * @param {string} token - Authorization token.
         */ set: function(token) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(token, "token");
            this.properties.setProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token, token);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranscriber.prototype, "speechRecognitionLanguage", {
        /**
         * Gets the spoken language of transcription.
         * @member ConversationTranscriber.prototype.speechRecognitionLanguage
         * @function
         * @public
         * @returns {string} The spoken language of transcription.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranscriber.prototype, "outputFormat", {
        /**
         * Gets the output format of transcription.
         * @member ConversationTranscriber.prototype.outputFormat
         * @function
         * @public
         * @returns {OutputFormat} The output format of transcription.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
            if (this.properties.getProperty(Exports_1.OutputFormatPropertyName, Exports_3.OutputFormat[Exports_3.OutputFormat.Simple]) === Exports_3.OutputFormat[Exports_3.OutputFormat.Simple]) return Exports_3.OutputFormat.Simple;
            else return Exports_3.OutputFormat.Detailed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranscriber.prototype, "properties", {
        /**
         * The collection of properties and their values defined for this conversation transcriber.
         * @member ConversationTranscriber.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Starts conversation transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member ConversationTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */ ConversationTranscriber.prototype.startTranscribingAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_1.RecognitionMode.Conversation), cb, err);
    };
    /**
     * Stops conversation transcription.
     * @member ConversationTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has stopped.
     * @param err - Callback invoked in case of an error.
     */ ConversationTranscriber.prototype.stopTranscribingAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
    };
    /**
     * closes all external resources held by an instance of this class.
     * @member ConversationTranscriber.prototype.close
     * @function
     * @public
     */ ConversationTranscriber.prototype.close = function(cb, errorCb) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
        Exports_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
    };
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */ ConversationTranscriber.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privDisposedRecognizer) return [
                            2 /*return*/ 
                        ];
                        if (!disposing) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privDisposedRecognizer = true;
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            4 /*yield*/ ,
                            _super.prototype.dispose.call(this, disposing)
                        ];
                    case 3:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ConversationTranscriber.prototype.createRecognizerConfig = function(speechConfig) {
        return new Exports_1.RecognizerConfig(speechConfig, this.privProperties);
    };
    ConversationTranscriber.prototype.createServiceRecognizer = function(authentication, connectionFactory, audioConfig, recognizerConfig) {
        var configImpl = audioConfig;
        recognizerConfig.isSpeakerDiarizationEnabled = true;
        return new Exports_1.ConversationTranscriptionServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
    };
    return ConversationTranscriber;
}(Exports_3.Recognizer);
exports.ConversationTranscriber = ConversationTranscriber;

},{"667a6c498ce29c35":"7Qpvn","b5c434eb685e840e":"5Bedw","f9e8a71880025285":"4jwu5","2a9bb3e02b22faac":"hxkc3"}],"1qkJX":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Participant = exports.User = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("96456725a56b7c50");
var User = /** @class */ function() {
    function User(userId) {
        this.privUserId = userId;
    }
    Object.defineProperty(User.prototype, "userId", {
        get: function() {
            return this.privUserId;
        },
        enumerable: false,
        configurable: true
    });
    return User;
}();
exports.User = User;
var Participant = /** @class */ function() {
    function Participant(id, avatar, displayName, isHost, isMuted, isUsingTts, preferredLanguage, voice) {
        this.privId = id;
        this.privAvatar = avatar;
        this.privDisplayName = displayName;
        this.privIsHost = isHost;
        this.privIsMuted = isMuted;
        this.privIsUsingTts = isUsingTts;
        this.privPreferredLanguage = preferredLanguage;
        this.privVoice = voice;
        this.privProperties = new Exports_1.PropertyCollection();
    }
    Object.defineProperty(Participant.prototype, "avatar", {
        get: function() {
            return this.privAvatar;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Participant.prototype, "displayName", {
        get: function() {
            return this.privDisplayName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Participant.prototype, "id", {
        get: function() {
            return this.privId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Participant.prototype, "preferredLanguage", {
        get: function() {
            return this.privPreferredLanguage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Participant.prototype, "isHost", {
        get: function() {
            return this.privIsHost;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Participant.prototype, "isMuted", {
        get: function() {
            return this.privIsMuted;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Participant.prototype, "isUsingTts", {
        get: function() {
            return this.privIsUsingTts;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Participant.prototype, "voice", {
        get: function() {
            return this.privVoice;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Participant.prototype, "properties", {
        get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Participant.From = function(id, language, voice) {
        return new Participant(id, "", id, false, false, false, language, voice);
    };
    return Participant;
}();
exports.Participant = Participant;

},{"96456725a56b7c50":"hxkc3"}],"3OlRF":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParticipantChangedReason = void 0;
var ParticipantChangedReason;
(function(ParticipantChangedReason) {
    /** Participant has joined the conversation. */ ParticipantChangedReason[ParticipantChangedReason["JoinedConversation"] = 0] = "JoinedConversation";
    /** Participant has left the conversation. This could be voluntary, or involuntary
     * (e.g. they are experiencing networking issues).
     */ ParticipantChangedReason[ParticipantChangedReason["LeftConversation"] = 1] = "LeftConversation";
    /** The participants' state has changed (e.g. they became muted, changed their nickname). */ ParticipantChangedReason[ParticipantChangedReason["Updated"] = 2] = "Updated";
})(ParticipantChangedReason = exports.ParticipantChangedReason || (exports.ParticipantChangedReason = {}));

},{}],"AAHPF":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __spreadArrays = this && this.__spreadArrays || function() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeetingImpl = exports.Meeting = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("2ceeb19a1093a203");
var Exports_2 = require("2044a00e4365f39c");
var Contracts_1 = require("ed82684c126fc396");
var Exports_3 = require("3bcba904dd2fe3ff");
var Meeting = /** @class */ function() {
    function Meeting() {
        return;
    }
    /**
     * Create a meeting
     * @param speechConfig
     * @param cb
     * @param err
     */ Meeting.createMeetingAsync = function(speechConfig, arg2, arg3, arg4) {
        var _this = this;
        Contracts_1.Contracts.throwIfNullOrUndefined(speechConfig, Exports_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config"));
        Contracts_1.Contracts.throwIfNullOrUndefined(speechConfig.region, Exports_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region"));
        if (!speechConfig.subscriptionKey && !speechConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceAuthorization_Token])) Contracts_1.Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, Exports_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
        var meetingImpl;
        if (typeof arg2 === "string") {
            meetingImpl = new MeetingImpl(speechConfig, arg2);
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            Exports_2.marshalPromiseToCallbacks(function() {
                return __awaiter(_this, void 0, void 0, function() {
                    return __generator(this, function(_a) {
                        return [
                            2 /*return*/ 
                        ];
                    });
                });
            }(), arg3, arg4);
        } else {
            meetingImpl = new MeetingImpl(speechConfig, "");
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            Exports_2.marshalPromiseToCallbacks(function() {
                return __awaiter(_this, void 0, void 0, function() {
                    return __generator(this, function(_a) {
                        return [
                            2 /*return*/ 
                        ];
                    });
                });
            }(), arg2, arg3);
        }
        return meetingImpl;
    };
    return Meeting;
}();
exports.Meeting = Meeting;
var MeetingImpl = /** @class */ function(_super) {
    __extends(MeetingImpl, _super);
    /**
     * Create a Meeting impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */ function MeetingImpl(speechConfig, id) {
        var _this = _super.call(this) || this;
        _this.privErrors = Exports_1.ConversationConnectionConfig.restErrors;
        /** websocket callbacks */ /* eslint-disable @typescript-eslint/typedef */ _this.onConnected = function(e) {
            var _a;
            _this.privIsConnected = true;
            try {
                if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.sessionStarted)) _this.privConversationTranslator.sessionStarted(_this.privConversationTranslator, e);
            } catch (e) {
            //
            }
        };
        _this.onDisconnected = function(e) {
            var _a;
            try {
                if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.sessionStopped)) _this.privConversationTranslator.sessionStopped(_this.privConversationTranslator, e);
            } catch (e) {
            //
            } finally{
                _this.close(false);
            }
        };
        _this.onCanceled = function(r, e) {
            var _a;
            try {
                if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.canceled)) _this.privConversationTranslator.canceled(_this.privConversationTranslator, e);
            } catch (e) {
            //
            }
        };
        _this.onParticipantUpdateCommandReceived = function(r, e) {
            try {
                var updatedParticipant = _this.privParticipants.getParticipant(e.id);
                if (updatedParticipant !== undefined) {
                    switch(e.key){
                        case Exports_1.ConversationTranslatorCommandTypes.changeNickname:
                            updatedParticipant.displayName = e.value;
                            break;
                        case Exports_1.ConversationTranslatorCommandTypes.setUseTTS:
                            updatedParticipant.isUsingTts = e.value;
                            break;
                        case Exports_1.ConversationTranslatorCommandTypes.setProfanityFiltering:
                            updatedParticipant.profanity = e.value;
                            break;
                        case Exports_1.ConversationTranslatorCommandTypes.setMute:
                            updatedParticipant.isMuted = e.value;
                            break;
                        case Exports_1.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                            updatedParticipant.translateToLanguages = e.value;
                            break;
                    }
                    _this.privParticipants.addOrUpdateParticipant(updatedParticipant);
                    if (!!_this.privConversationTranslator) _this.privConversationTranslator.participantsChanged(_this.privConversationTranslator, new Exports_3.ConversationParticipantsChangedEventArgs(Exports_3.ParticipantChangedReason.Updated, [
                        _this.toParticipant(updatedParticipant)
                    ], e.sessionId));
                }
            } catch (e) {
            //
            }
        };
        _this.onLockRoomCommandReceived = function() {
        // TODO
        };
        _this.onMuteAllCommandReceived = function(r, e) {
            try {
                _this.privParticipants.participants.forEach(function(p) {
                    return p.isMuted = p.isHost ? false : e.isMuted;
                });
                if (!!_this.privConversationTranslator) _this.privConversationTranslator.participantsChanged(_this.privConversationTranslator, new Exports_3.ConversationParticipantsChangedEventArgs(Exports_3.ParticipantChangedReason.Updated, _this.toParticipants(false), e.sessionId));
            } catch (e) {
            //
            }
        };
        _this.onParticipantJoinCommandReceived = function(r, e) {
            try {
                var newParticipant = _this.privParticipants.addOrUpdateParticipant(e.participant);
                if (newParticipant !== undefined) {
                    if (!!_this.privConversationTranslator) _this.privConversationTranslator.participantsChanged(_this.privConversationTranslator, new Exports_3.ConversationParticipantsChangedEventArgs(Exports_3.ParticipantChangedReason.JoinedConversation, [
                        _this.toParticipant(newParticipant)
                    ], e.sessionId));
                }
            } catch (e) {
            //
            }
        };
        _this.onParticipantLeaveCommandReceived = function(r, e) {
            try {
                var ejectedParticipant = _this.privParticipants.getParticipant(e.participant.id);
                if (ejectedParticipant !== undefined) {
                    // remove the participant from the internal participants list
                    _this.privParticipants.deleteParticipant(e.participant.id);
                    if (!!_this.privConversationTranslator) // notify subscribers that the participant has left the conversation
                    _this.privConversationTranslator.participantsChanged(_this.privConversationTranslator, new Exports_3.ConversationParticipantsChangedEventArgs(Exports_3.ParticipantChangedReason.LeftConversation, [
                        _this.toParticipant(ejectedParticipant)
                    ], e.sessionId));
                }
            } catch (e) {
            //
            }
        };
        _this.onTranslationReceived = function(r, e) {
            try {
                switch(e.command){
                    case Exports_1.ConversationTranslatorMessageTypes.final:
                        if (!!_this.privConversationTranslator) _this.privConversationTranslator.transcribed(_this.privConversationTranslator, new Exports_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
                        break;
                    case Exports_1.ConversationTranslatorMessageTypes.partial:
                        if (!!_this.privConversationTranslator) _this.privConversationTranslator.transcribing(_this.privConversationTranslator, new Exports_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
                        break;
                    case Exports_1.ConversationTranslatorMessageTypes.instantMessage:
                        if (!!_this.privConversationTranslator) _this.privConversationTranslator.textMessageReceived(_this.privConversationTranslator, new Exports_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
                        break;
                }
            } catch (e) {
            //
            }
        };
        _this.onParticipantsListReceived = function(r, e) {
            var _a;
            try {
                // check if the session token needs to be updated
                if (e.sessionToken !== undefined && e.sessionToken !== null) _this.privRoom.token = e.sessionToken;
                // save the participants
                _this.privParticipants.participants = __spreadArrays(e.participants);
                // enable the conversation
                if (_this.privParticipants.me !== undefined) _this.privIsReady = true;
                if (!!_this.privConversationTranslator) _this.privConversationTranslator.participantsChanged(_this.privConversationTranslator, new Exports_3.ConversationParticipantsChangedEventArgs(Exports_3.ParticipantChangedReason.JoinedConversation, _this.toParticipants(true), e.sessionId));
                // if this is the host, update the nickname if needed
                if (_this.me.isHost) {
                    var nickname = (_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.properties.getProperty(Exports_3.PropertyId.ConversationTranslator_Name);
                    if (nickname !== undefined && nickname.length > 0 && nickname !== _this.me.displayName) // issue a change nickname request
                    _this.changeNicknameAsync(nickname);
                }
            } catch (e) {
            //
            }
        };
        _this.onConversationExpiration = function(r, e) {
            try {
                if (!!_this.privConversationTranslator) _this.privConversationTranslator.conversationExpiration(_this.privConversationTranslator, e);
            } catch (e) {
            //
            }
        };
        _this.privIsConnected = false;
        _this.privIsDisposed = false;
        _this.privConversationId = "";
        _this.privProperties = new Exports_3.PropertyCollection();
        _this.privManager = new Exports_1.ConversationManager();
        // check the speech language
        var language = speechConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
        if (!language) speechConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage], Exports_1.ConversationConnectionConfig.defaultLanguageCode);
        _this.privLanguage = speechConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
        _this.privConversationId = id;
        // save the speech config for future usage
        _this.privConfig = speechConfig;
        // save the config properties
        var configImpl = speechConfig;
        Contracts_1.Contracts.throwIfNull(configImpl, "speechConfig");
        _this.privProperties = configImpl.properties.clone();
        _this.privIsConnected = false;
        _this.privParticipants = new Exports_1.InternalParticipants();
        _this.privIsReady = false;
        _this.privTextMessageMaxLength = 1000;
        return _this;
    }
    Object.defineProperty(MeetingImpl.prototype, "room", {
        // get the internal data about a conversation
        get: function() {
            return this.privRoom;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "connection", {
        // get the wrapper for connecting to the websockets
        get: function() {
            return this.privConversationRecognizer; // this.privConnection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "config", {
        // get the config
        get: function() {
            return this.privConfig;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "meetingId", {
        // get the meeting Id
        get: function() {
            return this.privRoom ? this.privRoom.roomId : this.privConversationId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "properties", {
        // get the properties
        get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "speechRecognitionLanguage", {
        // get the speech language
        get: function() {
            return this.privLanguage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "isMutedByHost", {
        get: function() {
            var _a, _b;
            return ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost) ? false : (_b = this.privParticipants.me) === null || _b === void 0 ? void 0 : _b.isMuted;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "isConnected", {
        get: function() {
            return this.privIsConnected && this.privIsReady;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "participants", {
        get: function() {
            return this.toParticipants(true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "me", {
        get: function() {
            return this.toParticipant(this.privParticipants.me);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "host", {
        get: function() {
            return this.toParticipant(this.privParticipants.host);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "transcriberRecognizer", {
        get: function() {
            return this.privTranscriberRecognizer;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "meetingInfo", {
        get: function() {
            var convId = this.meetingId;
            var p = this.participants.map(function(part) {
                return {
                    id: part.id,
                    preferredLanguage: part.preferredLanguage,
                    voice: part.voice
                };
            });
            var props = {};
            for(var _i = 0, _a = Exports_1.ConversationConnectionConfig.transcriptionEventKeys; _i < _a.length; _i++){
                var key = _a[_i];
                var val = this.properties.getProperty(key, "");
                if (val !== "") props[key] = val;
            }
            var info = {
                id: convId,
                participants: p,
                meetingProperties: props
            };
            return info;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "canSend", {
        get: function() {
            var _a;
            return this.privIsConnected && !((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isMuted);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "canSendAsHost", {
        get: function() {
            var _a;
            return this.privIsConnected && ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingImpl.prototype, "authorizationToken", {
        // get / set the speech auth token
        // eslint-disable-next-line @typescript-eslint/member-ordering
        get: function() {
            return this.privToken;
        },
        set: function(value) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(value, "authorizationToken");
            this.privToken = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Create a new meeting as Host
     * @param cb
     * @param err
     */ MeetingImpl.prototype.createMeetingAsync = function(cb, err) {
        var _this = this;
        try {
            if (!!this.privConversationRecognizer) this.handleError(new Error(this.privErrors.permissionDeniedStart), err);
            this.privManager.createOrJoin(this.privProperties, undefined, function(room) {
                if (!room) _this.handleError(new Error(_this.privErrors.permissionDeniedConnect), err);
                _this.privRoom = room;
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Starts a new meeting as host.
     * @param cb
     * @param err
     */ MeetingImpl.prototype.startMeetingAsync = function(cb, err) {
        var _this = this;
        try {
            // check if there is already a recognizer
            if (!!this.privConversationRecognizer) this.handleError(new Error(this.privErrors.permissionDeniedStart), err);
            // check if there is conversation data available
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);
            // connect to the conversation websocket
            this.privParticipants.meId = this.privRoom.participantId;
            // Because ConversationTranslator manually sets up and manages the connection, Conversation
            // has to forward serviceRecognizer connection events that usually get passed automatically
            this.privConversationRecognizer.connected = this.onConnected;
            this.privConversationRecognizer.disconnected = this.onDisconnected;
            this.privConversationRecognizer.canceled = this.onCanceled;
            this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;
            this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;
            this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;
            this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;
            this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;
            this.privConversationRecognizer.translationReceived = this.onTranslationReceived;
            this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;
            this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;
            this.privConversationRecognizer.connect(this.privRoom.token, function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Join a meeting as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */ MeetingImpl.prototype.addParticipantAsync = function(participant, cb, err) {
        Contracts_1.Contracts.throwIfNullOrUndefined(participant, "Participant");
        Exports_2.marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb, err);
    };
    /**
     * Join a meeting as a participant.
     * @param meeting
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */ MeetingImpl.prototype.joinMeetingAsync = function(meetingId, nickname, lang, cb, err) {
        var _this = this;
        try {
            // TODO
            // if (!!this.privConversationRecognizer) {
            //     throw new Error(this.privErrors.permissionDeniedStart);
            // }
            Contracts_1.Contracts.throwIfNullOrWhitespace(meetingId, this.privErrors.invalidArgs.replace("{arg}", "conversationId"));
            Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
            Contracts_1.Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace("{arg}", "language"));
            // join the conversation
            this.privManager.createOrJoin(this.privProperties, meetingId, function(room) {
                Contracts_1.Contracts.throwIfNullOrUndefined(room, _this.privErrors.permissionDeniedConnect);
                _this.privRoom = room;
                _this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;
                // join callback
                if (!!cb) cb(room.cognitiveSpeechAuthToken);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Deletes a meeting
     * @param cb
     * @param err
     */ MeetingImpl.prototype.deleteMeetingAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.deleteMeetingImplAsync(), cb, err);
    };
    MeetingImpl.prototype.deleteMeetingImplAsync = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        Contracts_1.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);
                        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);
                        return [
                            4 /*yield*/ ,
                            this.privManager.leave(this.privProperties, this.privRoom.token)
                        ];
                    case 1:
                        _a.sent();
                        this.dispose();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */ MeetingImpl.prototype.endMeetingAsync = function(cb, err) {
        Exports_2.marshalPromiseToCallbacks(this.endMeetingImplAsync(), cb, err);
    };
    MeetingImpl.prototype.endMeetingImplAsync = function() {
        return this.close(true);
    };
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */ MeetingImpl.prototype.lockMeetingAsync = function(cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSendAsHost) this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getLockCommand(true), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to mute the meeting
     * @param cb
     * @param err
     */ MeetingImpl.prototype.muteAllParticipantsAsync = function(cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            // check the user's permissions
            if (!this.canSendAsHost) this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(true), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to mute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */ MeetingImpl.prototype.muteParticipantAsync = function(userId, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            // check the connection is open (host + participant can perform the mute command)
            if (!this.canSend) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
            // if not host, check the participant is not muting another participant
            if (!this.me.isHost && this.me.id !== userId) this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err);
            // check the user exists
            var exists = this.privParticipants.getParticipantIndex(userId);
            if (exists === -1) this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, true), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */ MeetingImpl.prototype.removeParticipantAsync = function(userId, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            if (!!this.privTranscriberRecognizer && userId.hasOwnProperty("id")) // Assume this is a transcription participant
            Exports_2.marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId), cb, err);
            else {
                Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
                Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
                if (!this.canSendAsHost) this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), err);
                var participantId_1 = "";
                if (typeof userId === "string") participantId_1 = userId;
                else if (userId.hasOwnProperty("id")) {
                    var participant = userId;
                    participantId_1 = participant.id;
                } else if (userId.hasOwnProperty("userId")) {
                    var user = userId;
                    participantId_1 = user.userId;
                }
                Contracts_1.Contracts.throwIfNullOrWhitespace(participantId_1, this.privErrors.invalidArgs.replace("{arg}", "userId"));
                // check the participant exists
                var index = this.participants.findIndex(function(p) {
                    return p.id === participantId_1;
                });
                if (index === -1) this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
                if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getEjectCommand(participantId_1), function() {
                    _this.handleCallback(cb, err);
                }, function(error) {
                    _this.handleError(error, err);
                });
            }
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to unlock the meeting
     * @param cb
     * @param err
     */ MeetingImpl.prototype.unlockMeetingAsync = function(cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSendAsHost) this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getLockCommand(false), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to unmute all participants in the meeting
     * @param cb
     * @param err
     */ MeetingImpl.prototype.unmuteAllParticipantsAsync = function(cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSendAsHost) this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(false), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Issues a request to unmute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */ MeetingImpl.prototype.unmuteParticipantAsync = function(userId, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            // check the connection is open (host + participant can perform the mute command)
            if (!this.canSend) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
            // if not host, check the participant is not muting another participant
            if (!this.me.isHost && this.me.id !== userId) this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err);
            // check the user exists
            var exists = this.privParticipants.getParticipantIndex(userId);
            if (exists === -1) this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, false), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */ MeetingImpl.prototype.sendTextMessageAsync = function(message, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace("{arg}", "message"));
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSend) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
            // TODO: is a max length check required?
            if (message.length > this.privTextMessageMaxLength) this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getMessageCommand(message), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */ MeetingImpl.prototype.setTranslatedLanguagesAsync = function(languages, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfArrayEmptyOrWhitespace(languages, this.privErrors.invalidArgs.replace("{arg}", "languages"));
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSend) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(languages), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */ MeetingImpl.prototype.changeNicknameAsync = function(nickname, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
            Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
            Contracts_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
            if (!this.canSend) this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
            if (!!this.privConversationRecognizer) this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(nickname), function() {
                _this.handleCallback(cb, err);
            }, function(error) {
                _this.handleError(error, err);
            });
        } catch (error) {
            this.handleError(error, err);
        }
    };
    MeetingImpl.prototype.isDisposed = function() {
        return this.privIsDisposed;
    };
    MeetingImpl.prototype.dispose = function() {
        if (this.isDisposed) return;
        this.privIsDisposed = true;
        if (!!this.config) this.config.close();
        this.privConfig = undefined;
        this.privLanguage = undefined;
        this.privProperties = undefined;
        this.privRoom = undefined;
        this.privToken = undefined;
        this.privManager = undefined;
        this.privIsConnected = false;
        this.privIsReady = false;
        this.privParticipants = undefined;
    };
    MeetingImpl.prototype.connectTranscriberRecognizer = function(recognizer) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!!this.privTranscriberRecognizer) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privTranscriberRecognizer.close()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            4 /*yield*/ ,
                            recognizer.enforceAudioGating()
                        ];
                    case 3:
                        _a.sent();
                        this.privTranscriberRecognizer = recognizer;
                        this.privTranscriberRecognizer.meeting = this;
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    MeetingImpl.prototype.getKeepAlive = function() {
        var nickname = !!this.me ? this.me.displayName : "default_nickname";
        return JSON.stringify({
            id: "0",
            nickname: nickname,
            participantId: this.privRoom.participantId,
            roomId: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.keepAlive
        });
    };
    /* eslint-enable @typescript-eslint/typedef */ MeetingImpl.prototype.addParticipantImplAsync = function(participant) {
        var newParticipant = this.privParticipants.addOrUpdateParticipant(participant);
        if (newParticipant !== undefined) {
            if (!!this.privTranscriberRecognizer) {
                var meetingInfo = this.meetingInfo;
                meetingInfo.participants = [
                    participant
                ];
                return this.privTranscriberRecognizer.pushMeetingEvent(meetingInfo, "join");
            }
        }
    };
    MeetingImpl.prototype.removeParticipantImplAsync = function(participant) {
        this.privParticipants.deleteParticipant(participant.id);
        var meetingInfo = this.meetingInfo;
        meetingInfo.participants = [
            participant
        ];
        return this.privTranscriberRecognizer.pushMeetingEvent(meetingInfo, "leave");
    };
    MeetingImpl.prototype.close = function(dispose) {
        var _a;
        return __awaiter(this, void 0, void 0, function() {
            var e_1;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _b.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]);
                        this.privIsConnected = false;
                        return [
                            4 /*yield*/ ,
                            (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.close()
                        ];
                    case 1:
                        _b.sent();
                        this.privConversationRecognizer = undefined;
                        if (!!this.privConversationTranslator) this.privConversationTranslator.dispose();
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 2:
                        e_1 = _b.sent();
                        // ignore error
                        throw e_1;
                    case 3:
                        if (dispose) this.dispose();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /** Helpers */ MeetingImpl.prototype.handleCallback = function(cb, err) {
        if (!!cb) {
            try {
                cb();
            } catch (e) {
                if (!!err) err(e);
            }
            cb = undefined;
        }
    };
    MeetingImpl.prototype.handleError = function(error, err) {
        if (!!err) {
            if (error instanceof Error) {
                var typedError = error;
                err(typedError.name + ": " + typedError.message);
            } else err(error);
        }
    };
    /** Participant Helpers */ MeetingImpl.prototype.toParticipants = function(includeHost) {
        var _this = this;
        var participants = this.privParticipants.participants.map(function(p) {
            return _this.toParticipant(p);
        });
        if (!includeHost) return participants.filter(function(p) {
            return p.isHost === false;
        });
        else return participants;
    };
    MeetingImpl.prototype.toParticipant = function(p) {
        return new Exports_3.Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage, p.voice);
    };
    MeetingImpl.prototype.getMuteAllCommand = function(isMuted) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingd");
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.setMuteAll,
            participantId: this.privRoom.participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand,
            value: isMuted
        });
    };
    MeetingImpl.prototype.getMuteCommand = function(participantId, isMuted) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.setMute,
            // eslint-disable-next-line object-shorthand
            participantId: participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand,
            value: isMuted
        });
    };
    MeetingImpl.prototype.getLockCommand = function(isLocked) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.setLockState,
            participantId: this.privRoom.participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand,
            value: isLocked
        });
    };
    MeetingImpl.prototype.getEjectCommand = function(participantId) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.ejectParticipant,
            // eslint-disable-next-line object-shorthand
            participantId: participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand
        });
    };
    MeetingImpl.prototype.getSetTranslateToLanguagesCommand = function(languages) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.setTranslateToLanguages,
            participantId: this.privRoom.participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand,
            value: languages
        });
    };
    MeetingImpl.prototype.getChangeNicknameCommand = function(nickname) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
        return JSON.stringify({
            command: Exports_1.ConversationTranslatorCommandTypes.changeNickname,
            nickname: nickname,
            participantId: this.privRoom.participantId,
            roomid: this.privRoom.roomId,
            type: Exports_1.ConversationTranslatorMessageTypes.participantCommand,
            value: nickname
        });
    };
    MeetingImpl.prototype.getMessageCommand = function(message) {
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
        Contracts_1.Contracts.throwIfNullOrWhitespace(message, "message");
        return JSON.stringify({
            participantId: this.privRoom.participantId,
            roomId: this.privRoom.roomId,
            text: message,
            type: Exports_1.ConversationTranslatorMessageTypes.instantMessage
        });
    };
    return MeetingImpl;
}(Meeting);
exports.MeetingImpl = MeetingImpl;

},{"2ceeb19a1093a203":"7Qpvn","2044a00e4365f39c":"5Bedw","ed82684c126fc396":"4jwu5","3bcba904dd2fe3ff":"hxkc3"}],"fJsXt":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeetingTranscriptionCanceledEventArgs = void 0;
var CancellationEventArgsBase_1 = require("9289daed324850d1");
var MeetingTranscriptionCanceledEventArgs = /** @class */ function(_super) {
    __extends(MeetingTranscriptionCanceledEventArgs, _super);
    function MeetingTranscriptionCanceledEventArgs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return MeetingTranscriptionCanceledEventArgs;
}(CancellationEventArgsBase_1.CancellationEventArgsBase);
exports.MeetingTranscriptionCanceledEventArgs = MeetingTranscriptionCanceledEventArgs;

},{"9289daed324850d1":"7hXId"}],"5bZbG":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeetingTranscriber = void 0;
var Exports_1 = require("bbf5600dac75169");
var Exports_2 = require("85b815a53841605e");
var Contracts_1 = require("31aa0e06c981c584");
var Exports_3 = require("d2247494c9f0d504");
var Exports_4 = require("345076a13367fa13");
var MeetingTranscriber = /** @class */ function() {
    /**
     * MeetingTranscriber constructor.
     * @constructor
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */ function MeetingTranscriber(audioConfig) {
        this.privAudioConfig = audioConfig;
        this.privProperties = new Exports_3.PropertyCollection();
        this.privRecognizer = undefined;
        this.privDisposedRecognizer = false;
    }
    Object.defineProperty(MeetingTranscriber.prototype, "speechRecognitionLanguage", {
        /**
         * Gets the spoken language of recognition.
         * @member MeetingTranscriber.prototype.speechRecognitionLanguage
         * @function
         * @public
         * @returns {string} The spoken language of recognition.
         */ get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingTranscriber.prototype, "properties", {
        /**
         * The collection of properties and their values defined for this MeetingTranscriber.
         * @member MeetingTranscriber.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The collection of properties and their values defined for this MeetingTranscriber.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingTranscriber.prototype, "internalData", {
        /**
         * @Internal
         * Internal data member to support fromRecognizer* pattern methods on other classes.
         * Do not use externally, object returned will change without warning or notice.
         */ get: function() {
            return this.privRecognizer.internalData;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingTranscriber.prototype, "connection", {
        /**
         * @Deprecated
         * @Obsolete
         * Please use the Connection.fromRecognizer pattern to obtain a connection object
         */ get: function() {
            return Exports_3.Connection.fromRecognizer(this.privRecognizer);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeetingTranscriber.prototype, "authorizationToken", {
        /**
         * Gets the authorization token used to communicate with the service.
         * @member MeetingTranscriber.prototype.authorizationToken
         * @function
         * @public
         * @returns {string} Authorization token.
         */ get: function() {
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token);
        },
        /**
         * Gets/Sets the authorization token used to communicate with the service.
         * @member MeetingTranscriber.prototype.authorizationToken
         * @function
         * @public
         * @param {string} token - Authorization token.
         */ set: function(token) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(token, "token");
            this.properties.setProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token, token);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @param {Meeting} meeting - meeting to be recognized
     */ MeetingTranscriber.prototype.joinMeetingAsync = function(meeting, cb, err) {
        /* eslint-disable no-console */ // console.log(">> MeetingTranscriber::joinMeetingAsync");
        /* eslint-enable no-console */ var meetingImpl = meeting;
        Contracts_1.Contracts.throwIfNullOrUndefined(Exports_4.MeetingImpl, "Meeting");
        // ref the meeting object
        // create recognizer and subscribe to recognizer events
        this.privRecognizer = new Exports_1.TranscriberRecognizer(meeting.config, this.privAudioConfig);
        Contracts_1.Contracts.throwIfNullOrUndefined(this.privRecognizer, "Recognizer");
        this.privRecognizer.connectMeetingCallbacks(this);
        Exports_2.marshalPromiseToCallbacks(meetingImpl.connectTranscriberRecognizer(this.privRecognizer), cb, err);
    };
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */ MeetingTranscriber.prototype.startTranscribingAsync = function(cb, err) {
        this.privRecognizer.startContinuousRecognitionAsync(cb, err);
    };
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */ MeetingTranscriber.prototype.stopTranscribingAsync = function(cb, err) {
        this.privRecognizer.stopContinuousRecognitionAsync(cb, err);
    };
    /**
     * Leave the current meeting. After this is called, you will no longer receive any events.
     */ MeetingTranscriber.prototype.leaveMeetingAsync = function(cb, err) {
        var _this = this;
        this.privRecognizer.disconnectCallbacks();
        // eslint-disable-next-line
        Exports_2.marshalPromiseToCallbacks(function() {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    return [
                        2 /*return*/ 
                    ];
                });
            });
        }(), cb, err);
    };
    /**
     * closes all external resources held by an instance of this class.
     * @member MeetingTranscriber.prototype.close
     * @function
     * @public
     */ MeetingTranscriber.prototype.close = function(cb, errorCb) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
        Exports_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
    };
    /**
     * Disposes any resources held by the object.
     * @member MeetingTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */ MeetingTranscriber.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privDisposedRecognizer) return [
                            2 /*return*/ 
                        ];
                        if (!!!this.privRecognizer) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privRecognizer.close()
                        ];
                    case 1:
                        _a.sent();
                        this.privRecognizer = undefined;
                        _a.label = 2;
                    case 2:
                        if (disposing) this.privDisposedRecognizer = true;
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    return MeetingTranscriber;
}();
exports.MeetingTranscriber = MeetingTranscriber;

},{"bbf5600dac75169":"7Qpvn","85b815a53841605e":"5Bedw","31aa0e06c981c584":"4jwu5","d2247494c9f0d504":"hxkc3","345076a13367fa13":"6pz5J"}],"gaPT2":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranscriptionResult = void 0;
var Exports_1 = require("6bd5ac1405317273");
/**
 * Defines result of conversation transcription.
 * @class ConversationTranscriptionResult
 */ var ConversationTranscriptionResult = /** @class */ function(_super) {
    __extends(ConversationTranscriptionResult, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */ function ConversationTranscriptionResult(resultId, reason, text, duration, offset, language, languageDetectionConfidence, speakerId, errorDetails, json, properties) {
        var _this = _super.call(this, resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) || this;
        _this.privSpeakerId = speakerId;
        return _this;
    }
    Object.defineProperty(ConversationTranscriptionResult.prototype, "speakerId", {
        /**
         * speaker id
         * @member ConversationTranscriptionResult.prototype.speakerId
         * @function
         * @public
         * @returns {string} id of speaker in given result
         */ get: function() {
            return this.privSpeakerId;
        },
        enumerable: false,
        configurable: true
    });
    return ConversationTranscriptionResult;
}(Exports_1.RecognitionResult);
exports.ConversationTranscriptionResult = ConversationTranscriptionResult;

},{"6bd5ac1405317273":"hxkc3"}],"alKVB":[function(require,module,exports) {
"use strict";
/* eslint-disable @typescript-eslint/no-empty-function */ // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SynthesisRequest = exports.SpeechSynthesizer = void 0;
var Exports_1 = require("86423c51b0a30f83");
var Exports_2 = require("87a3fb84efdab50b");
var AudioFileWriter_1 = require("a242a38b7b2d2352");
var AudioOutputFormat_1 = require("b21ed3d9156e65b2");
var AudioOutputStream_1 = require("ddd6f347931f7bb");
var Contracts_1 = require("fec65fa1ac79b3df");
var Exports_3 = require("e95360dd8aadf5f3");
/**
 * Defines the class SpeechSynthesizer for text to speech.
 * Updated in version 1.16.0
 * @class SpeechSynthesizer
 */ var SpeechSynthesizer = /** @class */ function() {
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.
     */ function SpeechSynthesizer(speechConfig, audioConfig) {
        var speechConfigImpl = speechConfig;
        Contracts_1.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
        if (audioConfig !== null) {
            if (audioConfig === undefined) this.audioConfig = typeof window === "undefined" ? undefined : Exports_3.AudioConfig.fromDefaultSpeakerOutput();
            else this.audioConfig = audioConfig;
        }
        this.privProperties = speechConfigImpl.properties.clone();
        this.privDisposed = false;
        this.privSynthesizing = false;
        this.privConnectionFactory = new Exports_1.SpeechSynthesisConnectionFactory();
        this.synthesisRequestQueue = new Exports_2.Queue();
        this.implCommonSynthesizeSetup();
    }
    Object.defineProperty(SpeechSynthesizer.prototype, "authorizationToken", {
        /**
         * Gets the authorization token used to communicate with the service.
         * @member SpeechSynthesizer.prototype.authorizationToken
         * @function
         * @public
         * @returns {string} Authorization token.
         */ get: function() {
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token);
        },
        /**
         * Gets/Sets the authorization token used to communicate with the service.
         * @member SpeechSynthesizer.prototype.authorizationToken
         * @function
         * @public
         * @param {string} token - Authorization token.
         */ set: function(token) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(token, "token");
            this.properties.setProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token, token);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesizer.prototype, "properties", {
        /**
         * The collection of properties and their values defined for this SpeechSynthesizer.
         * @member SpeechSynthesizer.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechSynthesizer.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesizer.prototype, "autoDetectSourceLanguage", {
        /**
         * Indicates if auto detect source language is enabled
         * @member SpeechSynthesizer.prototype.properties
         * @function
         * @public
         * @returns {boolean} if auto detect source language is enabled
         */ get: function() {
            return this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages) === Exports_1.AutoDetectSourceLanguagesOpenRangeOptionName;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer
     */ SpeechSynthesizer.FromConfig = function(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {
        var speechConfigImpl = speechConfig;
        autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);
        return new SpeechSynthesizer(speechConfig, audioConfig);
    };
    SpeechSynthesizer.prototype.buildSsml = function(text) {
        var _a;
        var languageToDefaultVoice = (_a = {}, _a["af-ZA"] = "af-ZA-AdriNeural", _a["am-ET"] = "am-ET-AmehaNeural", _a["ar-AE"] = "ar-AE-FatimaNeural", _a["ar-BH"] = "ar-BH-AliNeural", _a["ar-DZ"] = "ar-DZ-AminaNeural", _a["ar-EG"] = "ar-EG-SalmaNeural", _a["ar-IQ"] = "ar-IQ-BasselNeural", _a["ar-JO"] = "ar-JO-SanaNeural", _a["ar-KW"] = "ar-KW-FahedNeural", _a["ar-LY"] = "ar-LY-ImanNeural", _a["ar-MA"] = "ar-MA-JamalNeural", _a["ar-QA"] = "ar-QA-AmalNeural", _a["ar-SA"] = "ar-SA-HamedNeural", _a["ar-SY"] = "ar-SY-AmanyNeural", _a["ar-TN"] = "ar-TN-HediNeural", _a["ar-YE"] = "ar-YE-MaryamNeural", _a["bg-BG"] = "bg-BG-BorislavNeural", _a["bn-BD"] = "bn-BD-NabanitaNeural", _a["bn-IN"] = "bn-IN-BashkarNeural", _a["ca-ES"] = "ca-ES-JoanaNeural", _a["cs-CZ"] = "cs-CZ-AntoninNeural", _a["cy-GB"] = "cy-GB-AledNeural", _a["da-DK"] = "da-DK-ChristelNeural", _a["de-AT"] = "de-AT-IngridNeural", _a["de-CH"] = "de-CH-JanNeural", _a["de-DE"] = "de-DE-KatjaNeural", _a["el-GR"] = "el-GR-AthinaNeural", _a["en-AU"] = "en-AU-NatashaNeural", _a["en-CA"] = "en-CA-ClaraNeural", _a["en-GB"] = "en-GB-LibbyNeural", _a["en-HK"] = "en-HK-SamNeural", _a["en-IE"] = "en-IE-ConnorNeural", _a["en-IN"] = "en-IN-NeerjaNeural", _a["en-KE"] = "en-KE-AsiliaNeural", _a["en-NG"] = "en-NG-AbeoNeural", _a["en-NZ"] = "en-NZ-MitchellNeural", _a["en-PH"] = "en-PH-JamesNeural", _a["en-SG"] = "en-SG-LunaNeural", _a["en-TZ"] = "en-TZ-ElimuNeural", _a["en-US"] = "en-US-JennyNeural", _a["en-ZA"] = "en-ZA-LeahNeural", _a["es-AR"] = "es-AR-ElenaNeural", _a["es-BO"] = "es-BO-MarceloNeural", _a["es-CL"] = "es-CL-CatalinaNeural", _a["es-CO"] = "es-CO-GonzaloNeural", _a["es-CR"] = "es-CR-JuanNeural", _a["es-CU"] = "es-CU-BelkysNeural", _a["es-DO"] = "es-DO-EmilioNeural", _a["es-EC"] = "es-EC-AndreaNeural", _a["es-ES"] = "es-ES-AlvaroNeural", _a["es-GQ"] = "es-GQ-JavierNeural", _a["es-GT"] = "es-GT-AndresNeural", _a["es-HN"] = "es-HN-CarlosNeural", _a["es-MX"] = "es-MX-DaliaNeural", _a["es-NI"] = "es-NI-FedericoNeural", _a["es-PA"] = "es-PA-MargaritaNeural", _a["es-PE"] = "es-PE-AlexNeural", _a["es-PR"] = "es-PR-KarinaNeural", _a["es-PY"] = "es-PY-MarioNeural", _a["es-SV"] = "es-SV-LorenaNeural", _a["es-US"] = "es-US-AlonsoNeural", _a["es-UY"] = "es-UY-MateoNeural", _a["es-VE"] = "es-VE-PaolaNeural", _a["et-EE"] = "et-EE-AnuNeural", _a["fa-IR"] = "fa-IR-DilaraNeural", _a["fi-FI"] = "fi-FI-SelmaNeural", _a["fil-PH"] = "fil-PH-AngeloNeural", _a["fr-BE"] = "fr-BE-CharlineNeural", _a["fr-CA"] = "fr-CA-SylvieNeural", _a["fr-CH"] = "fr-CH-ArianeNeural", _a["fr-FR"] = "fr-FR-DeniseNeural", _a["ga-IE"] = "ga-IE-ColmNeural", _a["gl-ES"] = "gl-ES-RoiNeural", _a["gu-IN"] = "gu-IN-DhwaniNeural", _a["he-IL"] = "he-IL-AvriNeural", _a["hi-IN"] = "hi-IN-MadhurNeural", _a["hr-HR"] = "hr-HR-GabrijelaNeural", _a["hu-HU"] = "hu-HU-NoemiNeural", _a["id-ID"] = "id-ID-ArdiNeural", _a["is-IS"] = "is-IS-GudrunNeural", _a["it-IT"] = "it-IT-IsabellaNeural", _a["ja-JP"] = "ja-JP-NanamiNeural", _a["jv-ID"] = "jv-ID-DimasNeural", _a["kk-KZ"] = "kk-KZ-AigulNeural", _a["km-KH"] = "km-KH-PisethNeural", _a["kn-IN"] = "kn-IN-GaganNeural", _a["ko-KR"] = "ko-KR-SunHiNeural", _a["lo-LA"] = "lo-LA-ChanthavongNeural", _a["lt-LT"] = "lt-LT-LeonasNeural", _a["lv-LV"] = "lv-LV-EveritaNeural", _a["mk-MK"] = "mk-MK-AleksandarNeural", _a["ml-IN"] = "ml-IN-MidhunNeural", _a["mr-IN"] = "mr-IN-AarohiNeural", _a["ms-MY"] = "ms-MY-OsmanNeural", _a["mt-MT"] = "mt-MT-GraceNeural", _a["my-MM"] = "my-MM-NilarNeural", _a["nb-NO"] = "nb-NO-PernilleNeural", _a["nl-BE"] = "nl-BE-ArnaudNeural", _a["nl-NL"] = "nl-NL-ColetteNeural", _a["pl-PL"] = "pl-PL-AgnieszkaNeural", _a["ps-AF"] = "ps-AF-GulNawazNeural", _a["pt-BR"] = "pt-BR-FranciscaNeural", _a["pt-PT"] = "pt-PT-DuarteNeural", _a["ro-RO"] = "ro-RO-AlinaNeural", _a["ru-RU"] = "ru-RU-SvetlanaNeural", _a["si-LK"] = "si-LK-SameeraNeural", _a["sk-SK"] = "sk-SK-LukasNeural", _a["sl-SI"] = "sl-SI-PetraNeural", _a["so-SO"] = "so-SO-MuuseNeural", _a["sr-RS"] = "sr-RS-NicholasNeural", _a["su-ID"] = "su-ID-JajangNeural", _a["sv-SE"] = "sv-SE-SofieNeural", _a["sw-KE"] = "sw-KE-RafikiNeural", _a["sw-TZ"] = "sw-TZ-DaudiNeural", _a["ta-IN"] = "ta-IN-PallaviNeural", _a["ta-LK"] = "ta-LK-KumarNeural", _a["ta-SG"] = "ta-SG-AnbuNeural", _a["te-IN"] = "te-IN-MohanNeural", _a["th-TH"] = "th-TH-PremwadeeNeural", _a["tr-TR"] = "tr-TR-AhmetNeural", _a["uk-UA"] = "uk-UA-OstapNeural", _a["ur-IN"] = "ur-IN-GulNeural", _a["ur-PK"] = "ur-PK-AsadNeural", _a["uz-UZ"] = "uz-UZ-MadinaNeural", _a["vi-VN"] = "vi-VN-HoaiMyNeural", _a["zh-CN"] = "zh-CN-XiaoxiaoNeural", _a["zh-HK"] = "zh-HK-HiuMaanNeural", _a["zh-TW"] = "zh-TW-HsiaoChenNeural", _a["zu-ZA"] = "zu-ZA-ThandoNeural", _a);
        var language = this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_SynthLanguage, "en-US");
        var voice = this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_SynthVoice, "");
        var ssml = SpeechSynthesizer.XMLEncode(text);
        if (this.autoDetectSourceLanguage) language = "en-US";
        else voice = voice || languageToDefaultVoice[language];
        if (voice) ssml = "<voice name='" + voice + "'>" + ssml + "</voice>";
        ssml = "<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xmlns:mstts='http://www.w3.org/2001/mstts' xmlns:emo='http://www.w3.org/2009/10/emotionml' xml:lang='" + language + "'>" + ssml + "</speak>";
        return ssml;
    };
    /**
     * Executes speech synthesis on plain text.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param text - Text to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */ SpeechSynthesizer.prototype.speakTextAsync = function(text, cb, err, stream) {
        this.speakImpl(text, false, cb, err, stream);
    };
    /**
     * Executes speech synthesis on SSML.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param ssml - SSML to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */ SpeechSynthesizer.prototype.speakSsmlAsync = function(ssml, cb, err, stream) {
        this.speakImpl(ssml, true, cb, err, stream);
    };
    /**
     * Get list of synthesis voices available.
     * The task returns the synthesis voice result.
     * @member SpeechSynthesizer.prototype.getVoicesAsync
     * @function
     * @async
     * @public
     * @param locale - Locale of voices in BCP-47 format; if left empty, get all available voices.
     * @return {Promise<SynthesisVoicesResult>} - Promise of a SynthesisVoicesResult.
     */ SpeechSynthesizer.prototype.getVoicesAsync = function(locale) {
        if (locale === void 0) locale = "";
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                return [
                    2 /*return*/ ,
                    this.getVoices(locale)
                ];
            });
        });
    };
    /**
     * Dispose of associated resources.
     * @member SpeechSynthesizer.prototype.close
     * @function
     * @public
     */ SpeechSynthesizer.prototype.close = function(cb, err) {
        Contracts_1.Contracts.throwIfDisposed(this.privDisposed);
        Exports_2.marshalPromiseToCallbacks(this.dispose(true), cb, err);
    };
    Object.defineProperty(SpeechSynthesizer.prototype, "internalData", {
        /**
         * @Internal
         * Do not use externally, object returned will change without warning or notice.
         */ get: function() {
            return this.privAdapter;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member SpeechSynthesizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */ SpeechSynthesizer.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privDisposed) return [
                            2 /*return*/ 
                        ];
                        if (!disposing) return [
                            3 /*break*/ ,
                            2
                        ];
                        if (!this.privAdapter) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privAdapter.dispose()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this.privDisposed = true;
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    //
    // ################################################################################################################
    // IMPLEMENTATION.
    // Move to independent class
    // ################################################################################################################
    //
    SpeechSynthesizer.prototype.createSynthesizerConfig = function(speechConfig) {
        return new Exports_1.SynthesizerConfig(speechConfig, this.privProperties);
    };
    // Creates the synthesis adapter
    SpeechSynthesizer.prototype.createSynthesisAdapter = function(authentication, connectionFactory, audioConfig, synthesizerConfig) {
        return new Exports_1.SynthesisAdapterBase(authentication, connectionFactory, synthesizerConfig, this, this.audioConfig);
    };
    SpeechSynthesizer.prototype.implCommonSynthesizeSetup = function() {
        var _this = this;
        var osPlatform = typeof window !== "undefined" ? "Browser" : "Node";
        var osName = "unknown";
        var osVersion = "unknown";
        if (typeof navigator !== "undefined") {
            osPlatform = osPlatform + "/" + navigator.platform;
            osName = navigator.userAgent;
            osVersion = navigator.appVersion;
        }
        var synthesizerConfig = this.createSynthesizerConfig(new Exports_1.SpeechServiceConfig(new Exports_1.Context(new Exports_1.OS(osPlatform, osName, osVersion))));
        var subscriptionKey = this.privProperties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Key, undefined);
        var authentication = subscriptionKey && subscriptionKey !== "" ? new Exports_1.CognitiveSubscriptionKeyAuthentication(subscriptionKey) : new Exports_1.CognitiveTokenAuthentication(function() {
            var authorizationToken = _this.privProperties.getProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token, undefined);
            return Promise.resolve(authorizationToken);
        }, function() {
            var authorizationToken = _this.privProperties.getProperty(Exports_3.PropertyId.SpeechServiceAuthorization_Token, undefined);
            return Promise.resolve(authorizationToken);
        });
        this.privAdapter = this.createSynthesisAdapter(authentication, this.privConnectionFactory, this.audioConfig, synthesizerConfig);
        this.privAdapter.audioOutputFormat = AudioOutputFormat_1.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(Exports_3.SpeechSynthesisOutputFormat[this.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)]);
        this.privRestAdapter = new Exports_1.SynthesisRestAdapter(synthesizerConfig, authentication);
    };
    SpeechSynthesizer.prototype.speakImpl = function(text, IsSsml, cb, err, dataStream) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposed);
            var requestId = Exports_2.createNoDashGuid();
            var audioDestination = void 0;
            if (dataStream instanceof Exports_3.PushAudioOutputStreamCallback) audioDestination = new AudioOutputStream_1.PushAudioOutputStreamImpl(dataStream);
            else if (dataStream instanceof Exports_3.PullAudioOutputStream) audioDestination = dataStream;
            else if (dataStream !== undefined) audioDestination = new AudioFileWriter_1.AudioFileWriter(dataStream);
            else audioDestination = undefined;
            this.synthesisRequestQueue.enqueue(new SynthesisRequest(requestId, text, IsSsml, function(e) {
                _this.privSynthesizing = false;
                if (!!cb) try {
                    cb(e);
                } catch (e) {
                    if (!!err) err(e);
                }
                cb = undefined;
                /* eslint-disable no-empty */ _this.adapterSpeak().catch(function() {});
            }, function(e) {
                if (!!err) err(e);
            }, audioDestination));
            /* eslint-disable no-empty-function */ this.adapterSpeak().catch(function() {});
        } catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                } else err(error);
            }
            // Destroy the synthesizer.
            /* eslint-disable no-empty */ this.dispose(true).catch(function() {});
        }
    };
    SpeechSynthesizer.prototype.getVoices = function(locale) {
        return __awaiter(this, void 0, void 0, function() {
            var requestId, response, json;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        requestId = Exports_2.createNoDashGuid();
                        return [
                            4 /*yield*/ ,
                            this.privRestAdapter.getVoicesList(requestId)
                        ];
                    case 1:
                        response = _a.sent();
                        if (response.ok && Array.isArray(response.json)) {
                            json = response.json;
                            if (!!locale && locale.length > 0) json = json.filter(function(item) {
                                return !!item.Locale && item.Locale.toLowerCase() === locale.toLowerCase();
                            });
                            return [
                                2 /*return*/ ,
                                new Exports_3.SynthesisVoicesResult(requestId, json, undefined)
                            ];
                        } else return [
                            2 /*return*/ ,
                            new Exports_3.SynthesisVoicesResult(requestId, undefined, "Error: " + response.status + ": " + response.statusText)
                        ];
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SpeechSynthesizer.prototype.adapterSpeak = function() {
        return __awaiter(this, void 0, void 0, function() {
            var request;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!(!this.privDisposed && !this.privSynthesizing)) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privSynthesizing = true;
                        return [
                            4 /*yield*/ ,
                            this.synthesisRequestQueue.dequeue()
                        ];
                    case 1:
                        request = _a.sent();
                        return [
                            2 /*return*/ ,
                            this.privAdapter.Speak(request.text, request.isSSML, request.requestId, request.cb, request.err, request.dataStream)
                        ];
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SpeechSynthesizer.XMLEncode = function(text) {
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    };
    return SpeechSynthesizer;
}();
exports.SpeechSynthesizer = SpeechSynthesizer;
var SynthesisRequest = /** @class */ function() {
    function SynthesisRequest(requestId, text, isSSML, cb, err, dataStream) {
        this.requestId = requestId;
        this.text = text;
        this.isSSML = isSSML;
        this.cb = cb;
        this.err = err;
        this.dataStream = dataStream;
    }
    return SynthesisRequest;
}();
exports.SynthesisRequest = SynthesisRequest;

},{"86423c51b0a30f83":"7Qpvn","87a3fb84efdab50b":"5Bedw","a242a38b7b2d2352":"byi0Y","b21ed3d9156e65b2":"lrOQK","ddd6f347931f7bb":"budsd","fec65fa1ac79b3df":"4jwu5","e95360dd8aadf5f3":"hxkc3"}],"iMoxM":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SynthesisResult = void 0;
/**
 * Base class for synthesis results
 * @class SynthesisResult
 * Added in version 1.20.0
 */ var SynthesisResult = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */ function SynthesisResult(resultId, reason, errorDetails, properties) {
        this.privResultId = resultId;
        this.privReason = reason;
        this.privErrorDetails = errorDetails;
        this.privProperties = properties;
    }
    Object.defineProperty(SynthesisResult.prototype, "resultId", {
        /**
         * Specifies the result identifier.
         * @member SynthesisResult.prototype.resultId
         * @function
         * @public
         * @returns {string} Specifies the result identifier.
         */ get: function() {
            return this.privResultId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisResult.prototype, "reason", {
        /**
         * Specifies status of the result.
         * @member SynthesisResult.prototype.reason
         * @function
         * @public
         * @returns {ResultReason} Specifies status of the result.
         */ get: function() {
            return this.privReason;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisResult.prototype, "errorDetails", {
        /**
         * In case of an unsuccessful synthesis, provides details of the occurred error.
         * @member SynthesisResult.prototype.errorDetails
         * @function
         * @public
         * @returns {string} a brief description of an error.
         */ get: function() {
            return this.privErrorDetails;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisResult.prototype, "properties", {
        /**
         * The set of properties exposed in the result.
         * @member SynthesisResult.prototype.properties
         * @function
         * @public
         * @returns {PropertyCollection} The set of properties exposed in the result.
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    return SynthesisResult;
}();
exports.SynthesisResult = SynthesisResult;

},{}],"7Bjmi":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechSynthesisResult = void 0;
var Exports_1 = require("c67080bccaa1acf9");
/**
 * Defines result of speech synthesis.
 * @class SpeechSynthesisResult
 * Added in version 1.11.0
 */ var SpeechSynthesisResult = /** @class */ function(_super) {
    __extends(SpeechSynthesisResult, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {ArrayBuffer} audioData - The synthesized audio binary.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     * @param {number} audioDuration - The audio duration.
     */ function SpeechSynthesisResult(resultId, reason, audioData, errorDetails, properties, audioDuration) {
        var _this = _super.call(this, resultId, reason, errorDetails, properties) || this;
        _this.privAudioData = audioData;
        _this.privAudioDuration = audioDuration;
        return _this;
    }
    Object.defineProperty(SpeechSynthesisResult.prototype, "audioData", {
        /**
         * The synthesized audio data
         * @member SpeechSynthesisResult.prototype.audioData
         * @function
         * @public
         * @returns {ArrayBuffer} The synthesized audio data.
         */ get: function() {
            return this.privAudioData;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesisResult.prototype, "audioDuration", {
        /**
         * The time duration of synthesized audio, in ticks (100 nanoseconds).
         * @member SpeechSynthesisResult.prototype.audioDuration
         * @function
         * @public
         * @returns {number} The time duration of synthesized audio.
         */ get: function() {
            return this.privAudioDuration;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechSynthesisResult;
}(Exports_1.SynthesisResult);
exports.SpeechSynthesisResult = SpeechSynthesisResult;

},{"c67080bccaa1acf9":"hxkc3"}],"g0l5f":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechSynthesisEventArgs = void 0;
/**
 * Defines contents of speech synthesis events.
 * @class SpeechSynthesisEventArgs
 * Added in version 1.11.0
 */ var SpeechSynthesisEventArgs = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechSynthesisResult} result - The speech synthesis result.
     */ function SpeechSynthesisEventArgs(result) {
        this.privResult = result;
    }
    Object.defineProperty(SpeechSynthesisEventArgs.prototype, "result", {
        /**
         * Specifies the synthesis result.
         * @member SpeechSynthesisEventArgs.prototype.result
         * @function
         * @public
         * @returns {SpeechSynthesisResult} the synthesis result.
         */ get: function() {
            return this.privResult;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechSynthesisEventArgs;
}();
exports.SpeechSynthesisEventArgs = SpeechSynthesisEventArgs;

},{}],"lkrUn":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechSynthesisWordBoundaryEventArgs = void 0;
/**
 * Defines contents of speech synthesis word boundary event.
 * @class SpeechSynthesisWordBoundaryEventArgs
 * Added in version 1.11.0
 */ var SpeechSynthesisWordBoundaryEventArgs = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {number} duration - The audio duration.
     * @param {string} text - The text.
     * @param {number} wordLength - The length of the word.
     * @param {number} textOffset - The text offset.
     * @param {SpeechSynthesisBoundaryType} boundaryType - The boundary type
     */ function SpeechSynthesisWordBoundaryEventArgs(audioOffset, duration, text, wordLength, textOffset, boundaryType) {
        this.privAudioOffset = audioOffset;
        this.privDuration = duration;
        this.privText = text;
        this.privWordLength = wordLength;
        this.privTextOffset = textOffset;
        this.privBoundaryType = boundaryType;
    }
    Object.defineProperty(SpeechSynthesisWordBoundaryEventArgs.prototype, "audioOffset", {
        /**
         * Specifies the audio offset.
         * @member SpeechSynthesisWordBoundaryEventArgs.prototype.audioOffset
         * @function
         * @public
         * @returns {number} the audio offset.
         */ get: function() {
            return this.privAudioOffset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesisWordBoundaryEventArgs.prototype, "duration", {
        /**
         * Specifies the duration, in ticks (100 nanoseconds).
         * @member SpeechSynthesisWordBoundaryEventArgs.prototype.duration
         * @function
         * @public
         * @returns {number} Duration in 100 nanosecond increments.
         */ get: function() {
            return this.privDuration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesisWordBoundaryEventArgs.prototype, "text", {
        /**
         * Specifies the text of the word boundary event.
         * @member SpeechSynthesisWordBoundaryEventArgs.prototype.text
         * @function
         * @public
         * @returns {string} the text.
         */ get: function() {
            return this.privText;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesisWordBoundaryEventArgs.prototype, "wordLength", {
        /**
         * Specifies the word length
         * @member SpeechSynthesisWordBoundaryEventArgs.prototype.wordLength
         * @function
         * @public
         * @returns {number} the word length
         */ get: function() {
            return this.privWordLength;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesisWordBoundaryEventArgs.prototype, "textOffset", {
        /**
         * Specifies the text offset.
         * @member SpeechSynthesisWordBoundaryEventArgs.prototype.textOffset
         * @function
         * @public
         * @returns {number} the text offset.
         */ get: function() {
            return this.privTextOffset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesisWordBoundaryEventArgs.prototype, "boundaryType", {
        /**
         * Specifies the boundary type.
         * @member SpeechSynthesisWordBoundaryEventArgs.prototype.boundaryType
         * @function
         * @public
         * @returns {SpeechSynthesisBoundaryType} the boundary type.
         */ get: function() {
            return this.privBoundaryType;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechSynthesisWordBoundaryEventArgs;
}();
exports.SpeechSynthesisWordBoundaryEventArgs = SpeechSynthesisWordBoundaryEventArgs;

},{}],"jVnhb":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechSynthesisBookmarkEventArgs = void 0;
/**
 * Defines contents of speech synthesis bookmark event.
 * @class SpeechSynthesisBookmarkEventArgs
 * Added in version 1.16.0
 */ var SpeechSynthesisBookmarkEventArgs = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {string} text - The bookmark text.
     */ function SpeechSynthesisBookmarkEventArgs(audioOffset, text) {
        this.privAudioOffset = audioOffset;
        this.privText = text;
    }
    Object.defineProperty(SpeechSynthesisBookmarkEventArgs.prototype, "audioOffset", {
        /**
         * Specifies the audio offset.
         * @member SpeechSynthesisBookmarkEventArgs.prototype.audioOffset
         * @function
         * @public
         * @returns {number} the audio offset.
         */ get: function() {
            return this.privAudioOffset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesisBookmarkEventArgs.prototype, "text", {
        /**
         * Specifies the bookmark.
         * @member SpeechSynthesisBookmarkEventArgs.prototype.text
         * @function
         * @public
         * @returns {string} the bookmark text.
         */ get: function() {
            return this.privText;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechSynthesisBookmarkEventArgs;
}();
exports.SpeechSynthesisBookmarkEventArgs = SpeechSynthesisBookmarkEventArgs;

},{}],"eAa7l":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechSynthesisVisemeEventArgs = void 0;
/**
 * Defines contents of speech synthesis viseme event.
 * @class SpeechSynthesisVisemeEventArgs
 * Added in version 1.16.0
 */ var SpeechSynthesisVisemeEventArgs = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {number} visemeId - The viseme ID.
     * @param {string} animation - The animation, could be in svg or other format.
     */ function SpeechSynthesisVisemeEventArgs(audioOffset, visemeId, animation) {
        this.privAudioOffset = audioOffset;
        this.privVisemeId = visemeId;
        this.privAnimation = animation;
    }
    Object.defineProperty(SpeechSynthesisVisemeEventArgs.prototype, "audioOffset", {
        /**
         * Specifies the audio offset.
         * @member SpeechSynthesisVisemeEventArgs.prototype.audioOffset
         * @function
         * @public
         * @returns {number} the audio offset.
         */ get: function() {
            return this.privAudioOffset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesisVisemeEventArgs.prototype, "visemeId", {
        /**
         * Specifies the viseme ID.
         * @member SpeechSynthesisVisemeEventArgs.prototype.visemeId
         * @function
         * @public
         * @returns {number} the viseme ID.
         */ get: function() {
            return this.privVisemeId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechSynthesisVisemeEventArgs.prototype, "animation", {
        /**
         * Specifies the animation.
         * @member SpeechSynthesisVisemeEventArgs.prototype.animation
         * @function
         * @public
         * @returns {string} the animation, could be in svg or other format.
         */ get: function() {
            return this.privAnimation;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechSynthesisVisemeEventArgs;
}();
exports.SpeechSynthesisVisemeEventArgs = SpeechSynthesisVisemeEventArgs;

},{}],"gPzKL":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechSynthesisBoundaryType = void 0;
/**
 * Defines the boundary type of speech synthesis boundary event.
 * @class SpeechSynthesisBoundaryType
 * Added in version 1.21.0
 */ var SpeechSynthesisBoundaryType;
(function(SpeechSynthesisBoundaryType) {
    /**
     * Indicates the boundary text is a word.
     * @member SpeechSynthesisBoundaryType.Word
     */ SpeechSynthesisBoundaryType["Word"] = "WordBoundary";
    /**
     * Indicates the boundary text is a punctuation.
     * @member SpeechSynthesisBoundaryType.Punctuation
     */ SpeechSynthesisBoundaryType["Punctuation"] = "PunctuationBoundary";
    /**
     * Indicates the boundary text is a sentence.
     * @member SpeechSynthesisBoundaryType.Sentence
     */ SpeechSynthesisBoundaryType["Sentence"] = "SentenceBoundary";
})(SpeechSynthesisBoundaryType = exports.SpeechSynthesisBoundaryType || (exports.SpeechSynthesisBoundaryType = {}));

},{}],"1gNhu":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SynthesisVoicesResult = void 0;
var Exports_1 = require("346a128a7a47f6c4");
/**
 * Defines result of speech synthesis.
 * @class SynthesisVoicesResult
 * Added in version 1.20.0
 */ var SynthesisVoicesResult = /** @class */ function(_super) {
    __extends(SynthesisVoicesResult, _super);
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param requestId - result id for request.
     * @param json - json payload from endpoint.
     */ function SynthesisVoicesResult(requestId, json, errorDetails) {
        var _this = this;
        if (Array.isArray(json)) {
            _this = _super.call(this, requestId, Exports_1.ResultReason.VoicesListRetrieved, undefined, new Exports_1.PropertyCollection()) || this;
            _this.privVoices = [];
            for(var _i = 0, json_1 = json; _i < json_1.length; _i++){
                var item = json_1[_i];
                _this.privVoices.push(new Exports_1.VoiceInfo(item));
            }
        } else _this = _super.call(this, requestId, Exports_1.ResultReason.Canceled, errorDetails ? errorDetails : "Error information unavailable", new Exports_1.PropertyCollection()) || this;
        return _this;
    }
    Object.defineProperty(SynthesisVoicesResult.prototype, "voices", {
        /**
         * The list of voices
         * @member SynthesisVoicesResult.prototype.voices
         * @function
         * @public
         * @returns {VoiceInfo[]} List of synthesized voices.
         */ get: function() {
            return this.privVoices;
        },
        enumerable: false,
        configurable: true
    });
    return SynthesisVoicesResult;
}(Exports_1.SynthesisResult);
exports.SynthesisVoicesResult = SynthesisVoicesResult;

},{"346a128a7a47f6c4":"hxkc3"}],"1oVyt":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoiceInfo = exports.SynthesisVoiceType = exports.SynthesisVoiceGender = void 0;
/**
 * Defines the gender of synthesis voices.
 * Added in version 1.20.0.
 */ var SynthesisVoiceGender;
(function(SynthesisVoiceGender) {
    /** Gender unknown */ SynthesisVoiceGender[SynthesisVoiceGender["Unknown"] = 0] = "Unknown";
    /** Female voice */ SynthesisVoiceGender[SynthesisVoiceGender["Female"] = 1] = "Female";
    /** Male voice */ SynthesisVoiceGender[SynthesisVoiceGender["Male"] = 2] = "Male";
})(SynthesisVoiceGender = exports.SynthesisVoiceGender || (exports.SynthesisVoiceGender = {}));
var SynthesisVoiceType;
(function(SynthesisVoiceType) {
    SynthesisVoiceType[SynthesisVoiceType["OnlineNeural"] = 1] = "OnlineNeural";
    SynthesisVoiceType[SynthesisVoiceType["OnlineStandard"] = 2] = "OnlineStandard";
    SynthesisVoiceType[SynthesisVoiceType["OfflineNeural"] = 3] = "OfflineNeural";
    SynthesisVoiceType[SynthesisVoiceType["OfflineStandard"] = 4] = "OfflineStandard";
})(SynthesisVoiceType = exports.SynthesisVoiceType || (exports.SynthesisVoiceType = {}));
/**
 * Information about Speech Synthesis voice
 * Added in version 1.20.0.
 * @class VoiceInfo
 */ var VoiceInfo = /** @class */ function() {
    function VoiceInfo(json) {
        this.privStyleList = [];
        this.privVoicePath = "";
        if (!!json) {
            this.privName = json.Name;
            this.privLocale = json.Locale;
            this.privShortName = json.ShortName;
            this.privLocaleName = json.LocaleName;
            this.privDisplayName = json.DisplayName;
            this.privLocalName = json.LocalName;
            this.privVoiceType = json.VoiceType.endsWith("Standard") ? SynthesisVoiceType.OnlineStandard : SynthesisVoiceType.OnlineNeural;
            this.privGender = json.Gender === "Male" ? SynthesisVoiceGender.Male : json.Gender === "Female" ? SynthesisVoiceGender.Female : SynthesisVoiceGender.Unknown;
            if (!!json.StyleList && Array.isArray(json.StyleList)) for(var _i = 0, _a = json.StyleList; _i < _a.length; _i++){
                var style = _a[_i];
                this.privStyleList.push(style);
            }
        }
    }
    Object.defineProperty(VoiceInfo.prototype, "name", {
        get: function() {
            return this.privName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceInfo.prototype, "locale", {
        get: function() {
            return this.privLocale;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceInfo.prototype, "shortName", {
        get: function() {
            return this.privShortName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceInfo.prototype, "displayName", {
        get: function() {
            return this.privDisplayName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceInfo.prototype, "localName", {
        get: function() {
            return this.privLocalName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceInfo.prototype, "localeName", {
        get: function() {
            return this.privLocaleName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceInfo.prototype, "gender", {
        get: function() {
            return this.privGender;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceInfo.prototype, "voiceType", {
        get: function() {
            return this.privVoiceType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceInfo.prototype, "styleList", {
        get: function() {
            return this.privStyleList;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VoiceInfo.prototype, "voicePath", {
        get: function() {
            return this.privVoicePath;
        },
        enumerable: false,
        configurable: true
    });
    return VoiceInfo;
}();
exports.VoiceInfo = VoiceInfo;

},{}],"5tT7p":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeakerAudioDestination = void 0;
var Exports_1 = require("1e70f115227e7a5f");
var Exports_2 = require("ce36732b93cb6fad");
var AudioOutputStream_1 = require("55526d8881a74d6c");
var AudioStreamFormat_1 = require("dfbaeecbee2a13");
var MediaDurationPlaceholderSeconds = 1800;
var AudioFormatToMimeType = (_a = {}, _a[AudioStreamFormat_1.AudioFormatTag.PCM] = "audio/wav", _a[AudioStreamFormat_1.AudioFormatTag.MuLaw] = "audio/x-wav", _a[AudioStreamFormat_1.AudioFormatTag.MP3] = "audio/mpeg", _a[AudioStreamFormat_1.AudioFormatTag.OGG_OPUS] = "audio/ogg", _a[AudioStreamFormat_1.AudioFormatTag.WEBM_OPUS] = "audio/webm; codecs=opus", _a[AudioStreamFormat_1.AudioFormatTag.ALaw] = "audio/x-wav", _a[AudioStreamFormat_1.AudioFormatTag.FLAC] = "audio/flac", _a);
/**
 * Represents the speaker playback audio destination, which only works in browser.
 * Note: the SDK will try to use <a href="https://www.w3.org/TR/media-source/">Media Source Extensions</a> to play audio.
 * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.
 * @class SpeakerAudioDestination
 * Updated in version 1.17.0
 */ var SpeakerAudioDestination = /** @class */ function() {
    function SpeakerAudioDestination(audioDestinationId) {
        this.privPlaybackStarted = false;
        this.privAppendingToBuffer = false;
        this.privMediaSourceOpened = false;
        this.privBytesReceived = 0;
        this.privId = audioDestinationId ? audioDestinationId : Exports_2.createNoDashGuid();
        this.privIsPaused = false;
        this.privIsClosed = false;
    }
    SpeakerAudioDestination.prototype.id = function() {
        return this.privId;
    };
    SpeakerAudioDestination.prototype.write = function(buffer, cb, err) {
        if (this.privAudioBuffer !== undefined) {
            this.privAudioBuffer.push(buffer);
            this.updateSourceBuffer().then(function() {
                if (!!cb) cb();
            }, function(error) {
                if (!!err) err(error);
            });
        } else if (this.privAudioOutputStream !== undefined) {
            this.privAudioOutputStream.write(buffer);
            this.privBytesReceived += buffer.byteLength;
        }
    };
    SpeakerAudioDestination.prototype.close = function(cb, err) {
        var _this = this;
        this.privIsClosed = true;
        if (this.privSourceBuffer !== undefined) this.handleSourceBufferUpdateEnd().then(function() {
            if (!!cb) cb();
        }, function(error) {
            if (!!err) err(error);
        });
        else if (this.privAudioOutputStream !== undefined && typeof window !== "undefined") {
            if ((this.privFormat.formatTag === AudioStreamFormat_1.AudioFormatTag.PCM || this.privFormat.formatTag === AudioStreamFormat_1.AudioFormatTag.MuLaw || this.privFormat.formatTag === AudioStreamFormat_1.AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {
                // eslint-disable-next-line no-console
                console.warn("Play back is not supported for raw PCM, mulaw or alaw format without header.");
                if (!!this.onAudioEnd) this.onAudioEnd(this);
            } else {
                var receivedAudio_1 = new ArrayBuffer(this.privBytesReceived);
                this.privAudioOutputStream.read(receivedAudio_1).then(function() {
                    receivedAudio_1 = Exports_1.SynthesisAdapterBase.addHeader(receivedAudio_1, _this.privFormat);
                    var audioBlob = new Blob([
                        receivedAudio_1
                    ], {
                        type: AudioFormatToMimeType[_this.privFormat.formatTag]
                    });
                    _this.privAudio.src = window.URL.createObjectURL(audioBlob);
                    _this.notifyPlayback().then(function() {
                        if (!!cb) cb();
                    }, function(error) {
                        if (!!err) err(error);
                    });
                }, function(error) {
                    if (!!err) err(error);
                });
            }
        } else // unsupported format, call onAudioEnd directly.
        if (!!this.onAudioEnd) this.onAudioEnd(this);
    };
    Object.defineProperty(SpeakerAudioDestination.prototype, "format", {
        set: function(format) {
            var _this = this;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (typeof AudioContext !== "undefined" || typeof window !== "undefined" && typeof window.webkitAudioContext !== "undefined") {
                this.privFormat = format;
                var mimeType_1 = AudioFormatToMimeType[this.privFormat.formatTag];
                if (mimeType_1 === undefined) // eslint-disable-next-line no-console
                console.warn("Unknown mimeType for format " + AudioStreamFormat_1.AudioFormatTag[this.privFormat.formatTag] + "; playback is not supported.");
                else if (typeof MediaSource !== "undefined" && MediaSource.isTypeSupported(mimeType_1)) {
                    this.privAudio = new Audio();
                    this.privAudioBuffer = [];
                    this.privMediaSource = new MediaSource();
                    this.privAudio.src = URL.createObjectURL(this.privMediaSource);
                    this.privAudio.load();
                    this.privMediaSource.onsourceopen = function() {
                        _this.privMediaSourceOpened = true;
                        _this.privMediaSource.duration = MediaDurationPlaceholderSeconds;
                        _this.privSourceBuffer = _this.privMediaSource.addSourceBuffer(mimeType_1);
                        _this.privSourceBuffer.onupdate = function() {
                            _this.updateSourceBuffer().catch(function(reason) {
                                Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));
                            });
                        };
                        _this.privSourceBuffer.onupdateend = function() {
                            _this.handleSourceBufferUpdateEnd().catch(function(reason) {
                                Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));
                            });
                        };
                        _this.privSourceBuffer.onupdatestart = function() {
                            _this.privAppendingToBuffer = false;
                        };
                    };
                    this.updateSourceBuffer().catch(function(reason) {
                        Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));
                    });
                } else {
                    // eslint-disable-next-line no-console
                    console.warn("Format " + AudioStreamFormat_1.AudioFormatTag[this.privFormat.formatTag] + " could not be played by MSE, streaming playback is not enabled.");
                    this.privAudioOutputStream = new AudioOutputStream_1.PullAudioOutputStreamImpl();
                    this.privAudioOutputStream.format = this.privFormat;
                    this.privAudio = new Audio();
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerAudioDestination.prototype, "volume", {
        get: function() {
            var _a, _b;
            return (_b = (_a = this.privAudio) === null || _a === void 0 ? void 0 : _a.volume) !== null && _b !== void 0 ? _b : -1;
        },
        set: function(volume) {
            if (!!this.privAudio) this.privAudio.volume = volume;
        },
        enumerable: false,
        configurable: true
    });
    SpeakerAudioDestination.prototype.mute = function() {
        if (!!this.privAudio) this.privAudio.muted = true;
    };
    SpeakerAudioDestination.prototype.unmute = function() {
        if (!!this.privAudio) this.privAudio.muted = false;
    };
    Object.defineProperty(SpeakerAudioDestination.prototype, "isClosed", {
        get: function() {
            return this.privIsClosed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerAudioDestination.prototype, "currentTime", {
        get: function() {
            if (this.privAudio !== undefined) return this.privAudio.currentTime;
            return -1;
        },
        enumerable: false,
        configurable: true
    });
    SpeakerAudioDestination.prototype.pause = function() {
        if (!this.privIsPaused && this.privAudio !== undefined) {
            this.privAudio.pause();
            this.privIsPaused = true;
        }
    };
    SpeakerAudioDestination.prototype.resume = function(cb, err) {
        if (this.privIsPaused && this.privAudio !== undefined) {
            this.privAudio.play().then(function() {
                if (!!cb) cb();
            }, function(error) {
                if (!!err) err(error);
            });
            this.privIsPaused = false;
        }
    };
    Object.defineProperty(SpeakerAudioDestination.prototype, "internalAudio", {
        get: function() {
            return this.privAudio;
        },
        enumerable: false,
        configurable: true
    });
    SpeakerAudioDestination.prototype.updateSourceBuffer = function() {
        return __awaiter(this, void 0, void 0, function() {
            var binary;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!(this.privAudioBuffer !== undefined && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable())) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privAppendingToBuffer = true;
                        binary = this.privAudioBuffer.shift();
                        try {
                            this.privSourceBuffer.appendBuffer(binary);
                        } catch (error) {
                            this.privAudioBuffer.unshift(binary);
                            // eslint-disable-next-line no-console
                            console.log("buffer filled, pausing addition of binaries until space is made");
                            return [
                                2 /*return*/ 
                            ];
                        }
                        return [
                            4 /*yield*/ ,
                            this.notifyPlayback()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            4
                        ];
                    case 2:
                        if (!this.canEndStream()) return [
                            3 /*break*/ ,
                            4
                        ];
                        return [
                            4 /*yield*/ ,
                            this.handleSourceBufferUpdateEnd()
                        ];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SpeakerAudioDestination.prototype.handleSourceBufferUpdateEnd = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!(this.canEndStream() && this.sourceBufferAvailable())) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privMediaSource.endOfStream();
                        return [
                            4 /*yield*/ ,
                            this.notifyPlayback()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SpeakerAudioDestination.prototype.notifyPlayback = function() {
        return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!(!this.privPlaybackStarted && this.privAudio !== undefined)) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privPlaybackStarted = true;
                        if (!!this.onAudioStart) this.onAudioStart(this);
                        this.privAudio.onended = function() {
                            if (!!_this.onAudioEnd) _this.onAudioEnd(_this);
                        };
                        if (!!this.privIsPaused) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privAudio.play()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SpeakerAudioDestination.prototype.canEndStream = function() {
        return this.isClosed && this.privSourceBuffer !== undefined && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === "open";
    };
    SpeakerAudioDestination.prototype.sourceBufferAvailable = function() {
        return this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating;
    };
    return SpeakerAudioDestination;
}();
exports.SpeakerAudioDestination = SpeakerAudioDestination;

},{"1e70f115227e7a5f":"7Qpvn","ce36732b93cb6fad":"5Bedw","55526d8881a74d6c":"budsd","dfbaeecbee2a13":"8hTlD"}],"33B6B":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranscriptionCanceledEventArgs = void 0;
var CancellationEventArgsBase_1 = require("ac30006db2718da6");
/**
 * Defines content of a RecognitionErrorEvent.
 * @class ConversationTranscriptionCanceledEventArgs
 */ var ConversationTranscriptionCanceledEventArgs = /** @class */ function(_super) {
    __extends(ConversationTranscriptionCanceledEventArgs, _super);
    function ConversationTranscriptionCanceledEventArgs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ConversationTranscriptionCanceledEventArgs;
}(CancellationEventArgsBase_1.CancellationEventArgsBase);
exports.ConversationTranscriptionCanceledEventArgs = ConversationTranscriptionCanceledEventArgs;

},{"ac30006db2718da6":"7hXId"}],"bhLqE":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeetingTranscriptionCanceledEventArgs = void 0;
var CancellationEventArgsBase_1 = require("ac680d1d07e53be0");
/**
 * Defines content of a MeetingTranscriptionCanceledEvent.
 * @class MeetingTranscriptionCanceledEventArgs
 */ var MeetingTranscriptionCanceledEventArgs = /** @class */ function(_super) {
    __extends(MeetingTranscriptionCanceledEventArgs, _super);
    function MeetingTranscriptionCanceledEventArgs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return MeetingTranscriptionCanceledEventArgs;
}(CancellationEventArgsBase_1.CancellationEventArgsBase);
exports.MeetingTranscriptionCanceledEventArgs = MeetingTranscriptionCanceledEventArgs;

},{"ac680d1d07e53be0":"7hXId"}],"8TV5m":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PronunciationAssessmentGradingSystem = void 0;
/**
 * Defines the point system for pronunciation score calibration; default value is FivePoint.
 * Added in version 1.15.0
 * @class PronunciationAssessmentGradingSystem
 */ var PronunciationAssessmentGradingSystem;
(function(PronunciationAssessmentGradingSystem) {
    /**
     * Five point calibration
     * @member PronunciationAssessmentGradingSystem.FivePoint
     */ PronunciationAssessmentGradingSystem[PronunciationAssessmentGradingSystem["FivePoint"] = 1] = "FivePoint";
    /**
     * Hundred mark
     * @member PronunciationAssessmentGradingSystem.HundredMark
     */ PronunciationAssessmentGradingSystem[PronunciationAssessmentGradingSystem["HundredMark"] = 2] = "HundredMark";
})(PronunciationAssessmentGradingSystem = exports.PronunciationAssessmentGradingSystem || (exports.PronunciationAssessmentGradingSystem = {}));

},{}],"bOGVv":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PronunciationAssessmentGranularity = void 0;
/**
 * Defines the pronunciation evaluation granularity; default value is Phoneme.
 * Added in version 1.15.0
 * @class PronunciationAssessmentGranularity
 */ var PronunciationAssessmentGranularity;
(function(PronunciationAssessmentGranularity) {
    /**
     * Shows the score on the full text, word and phoneme level
     * @member PronunciationAssessmentGranularity.Phoneme
     */ PronunciationAssessmentGranularity[PronunciationAssessmentGranularity["Phoneme"] = 1] = "Phoneme";
    /**
     * Shows the score on the full text and word level
     * @member PronunciationAssessmentGranularity.Word
     */ PronunciationAssessmentGranularity[PronunciationAssessmentGranularity["Word"] = 2] = "Word";
    /**
     * Shows the score on the full text level only
     * @member PronunciationAssessmentGranularity.FullText
     */ PronunciationAssessmentGranularity[PronunciationAssessmentGranularity["FullText"] = 3] = "FullText";
})(PronunciationAssessmentGranularity = exports.PronunciationAssessmentGranularity || (exports.PronunciationAssessmentGranularity = {}));

},{}],"jCQGZ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PronunciationAssessmentConfig = void 0;
var Contracts_1 = require("3e662d556f2f0c39");
var Exports_1 = require("4632b4338a06466a");
/**
 * Pronunciation assessment configuration.
 * @class PronunciationAssessmentConfig
 * Added in version 1.15.0.
 */ var PronunciationAssessmentConfig = /** @class */ function() {
    /**
     * PronunciationAssessmentConfig constructor.
     * @constructor
     * @param {string} referenceText
     * @param gradingSystem
     * @param granularity
     * @param enableMiscue
     */ function PronunciationAssessmentConfig(referenceText, gradingSystem, granularity, enableMiscue) {
        if (gradingSystem === void 0) gradingSystem = Exports_1.PronunciationAssessmentGradingSystem.FivePoint;
        if (granularity === void 0) granularity = Exports_1.PronunciationAssessmentGranularity.Phoneme;
        if (enableMiscue === void 0) enableMiscue = false;
        Contracts_1.Contracts.throwIfNullOrUndefined(referenceText, "referenceText");
        this.privProperties = new Exports_1.PropertyCollection();
        this.privProperties.setProperty(Exports_1.PropertyId.PronunciationAssessment_ReferenceText, referenceText);
        this.privProperties.setProperty(Exports_1.PropertyId.PronunciationAssessment_GradingSystem, Exports_1.PronunciationAssessmentGradingSystem[gradingSystem]);
        this.privProperties.setProperty(Exports_1.PropertyId.PronunciationAssessment_Granularity, Exports_1.PronunciationAssessmentGranularity[granularity]);
        this.privProperties.setProperty(Exports_1.PropertyId.PronunciationAssessment_EnableMiscue, String(enableMiscue));
    }
    /**
     * @member PronunciationAssessmentConfig.fromJSON
     * @function
     * @public
     * @param {string} json The json string containing the pronunciation assessment parameters.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentConfig from json.
     * This method is designed to support the pronunciation assessment parameters still in preview.
     * Under normal circumstances, use the constructor instead.
     */ PronunciationAssessmentConfig.fromJSON = function(json) {
        Contracts_1.Contracts.throwIfNullOrUndefined(json, "json");
        var config = new PronunciationAssessmentConfig("");
        config.privProperties = new Exports_1.PropertyCollection();
        config.properties.setProperty(Exports_1.PropertyId.PronunciationAssessment_Json, json);
        return config;
    };
    PronunciationAssessmentConfig.prototype.toJSON = function() {
        this.updateJson();
        return this.privProperties.getProperty(Exports_1.PropertyId.PronunciationAssessment_Params);
    };
    PronunciationAssessmentConfig.prototype.applyTo = function(recognizer) {
        this.updateJson();
        var recoBase = recognizer.internalData;
        recoBase.speechContext.setPronunciationAssessmentParams(this.properties.getProperty(Exports_1.PropertyId.PronunciationAssessment_Params), recoBase.isSpeakerDiarizationEnabled);
    };
    Object.defineProperty(PronunciationAssessmentConfig.prototype, "referenceText", {
        /**
         * Gets the reference text.
         * @member PronunciationAssessmentConfig.prototype.referenceText
         * @function
         * @public
         * @returns {string} Reference text.
         */ get: function() {
            return this.properties.getProperty(Exports_1.PropertyId.PronunciationAssessment_ReferenceText);
        },
        /**
         * Gets/Sets the reference text.
         * @member PronunciationAssessmentConfig.prototype.referenceText
         * @function
         * @public
         * @param {string} referenceText - Reference text.
         */ set: function(referenceText) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(referenceText, "referenceText");
            this.properties.setProperty(Exports_1.PropertyId.PronunciationAssessment_ReferenceText, referenceText);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PronunciationAssessmentConfig.prototype, "phonemeAlphabet", {
        /**
         * Sets the phoneme alphabet.
         * The valid values are "SAPI" (default) and "IPA".
         * Added in version 1.20.0
         * @member PronunciationAssessmentConfig.prototype.phonemeAlphabet
         * @function
         * @public
         * @param {string} phonemeAlphabet - Phoneme alphabet.
         */ set: function(phonemeAlphabet) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(phonemeAlphabet, "phonemeAlphabet");
            this.privPhonemeAlphabet = phonemeAlphabet;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PronunciationAssessmentConfig.prototype, "enableMiscue", {
        /**
         * Gets the boolean enableMiscue property.
         * Added in version 1.26.0
         * @member PronunciationAssessmentConfig.prototype.enableMiscue
         * @function
         * @public
         * @return {boolean} enableMiscue - enable miscue.
         */ get: function() {
            var enableMiscueString = this.properties.getProperty(Exports_1.PropertyId.PronunciationAssessment_EnableMiscue, "false");
            return enableMiscueString.toLowerCase() === "true";
        },
        /**
         * Sets the boolean enableMiscue property.
         * Added in version 1.26.0
         * @member PronunciationAssessmentConfig.prototype.enableMiscue
         * @function
         * @public
         * @param {boolean} enableMiscue - enable miscue.
         */ set: function(enableMiscue) {
            var enableMiscueString = enableMiscue ? "true" : "false";
            this.properties.setProperty(Exports_1.PropertyId.PronunciationAssessment_EnableMiscue, enableMiscueString);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PronunciationAssessmentConfig.prototype, "nbestPhonemeCount", {
        /**
         * Sets the nbest phoneme count
         * Added in version 1.20.0
         * @member PronunciationAssessmentConfig.prototype.nbestPhonemeCount
         * @function
         * @public
         * @param {number} nbestPhonemeCount - NBest phoneme count.
         */ set: function(nbestPhonemeCount) {
            this.privNBestPhonemeCount = nbestPhonemeCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PronunciationAssessmentConfig.prototype, "properties", {
        /**
         * @member PronunciationAssessmentConfig.prototype.properties
         * @function
         * @public
         * @return {PropertyCollection} Properties of the config.
         * @summary Gets a pronunciation assessment config properties
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    PronunciationAssessmentConfig.prototype.updateJson = function() {
        var jsonString = this.privProperties.getProperty(Exports_1.PropertyId.PronunciationAssessment_Json, "{}");
        var paramsJson = JSON.parse(jsonString);
        var referenceText = this.privProperties.getProperty(Exports_1.PropertyId.PronunciationAssessment_ReferenceText);
        if (referenceText) paramsJson.referenceText = referenceText;
        var gradingSystem = this.privProperties.getProperty(Exports_1.PropertyId.PronunciationAssessment_GradingSystem);
        if (gradingSystem) paramsJson.gradingSystem = gradingSystem;
        var granularity = this.privProperties.getProperty(Exports_1.PropertyId.PronunciationAssessment_Granularity);
        if (granularity) paramsJson.granularity = granularity;
        if (this.privPhonemeAlphabet) paramsJson.phonemeAlphabet = this.privPhonemeAlphabet;
        if (this.privNBestPhonemeCount) paramsJson.nbestPhonemeCount = this.privNBestPhonemeCount;
        // always set dimension to Comprehensive
        paramsJson.dimension = "Comprehensive";
        var enableMiscueString = this.privProperties.getProperty(Exports_1.PropertyId.PronunciationAssessment_EnableMiscue);
        if (enableMiscueString) paramsJson.enableMiscue = this.enableMiscue;
        this.privProperties.setProperty(Exports_1.PropertyId.PronunciationAssessment_Params, JSON.stringify(paramsJson));
    };
    return PronunciationAssessmentConfig;
}();
exports.PronunciationAssessmentConfig = PronunciationAssessmentConfig;

},{"3e662d556f2f0c39":"4jwu5","4632b4338a06466a":"hxkc3"}],"r0TWP":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PronunciationAssessmentResult = void 0;
var Contracts_1 = require("42d7ff2a011fab80");
var Exports_1 = require("5eb878ae8c531d02");
/**
 * Pronunciation assessment results.
 * @class PronunciationAssessmentResult
 * Added in version 1.15.0.
 */ var PronunciationAssessmentResult = /** @class */ function() {
    function PronunciationAssessmentResult(jsonString) {
        var j = JSON.parse(jsonString);
        Contracts_1.Contracts.throwIfNullOrUndefined(j.NBest[0], "NBest");
        this.privPronJson = j.NBest[0];
    }
    /**
     * @member PronunciationAssessmentResult.fromResult
     * @function
     * @public
     * @param {RecognitionResult} result The recognition result.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentResult from recognition result.
     */ PronunciationAssessmentResult.fromResult = function(result) {
        Contracts_1.Contracts.throwIfNullOrUndefined(result, "result");
        var json = result.properties.getProperty(Exports_1.PropertyId.SpeechServiceResponse_JsonResult);
        Contracts_1.Contracts.throwIfNullOrUndefined(json, "json");
        return new PronunciationAssessmentResult(json);
    };
    Object.defineProperty(PronunciationAssessmentResult.prototype, "detailResult", {
        /**
         * Gets the detail result of pronunciation assessment.
         * @member PronunciationAssessmentConfig.prototype.detailResult
         * @function
         * @public
         * @returns {DetailResult} detail result.
         */ get: function() {
            return this.privPronJson;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PronunciationAssessmentResult.prototype, "accuracyScore", {
        /**
         * The score indicating the pronunciation accuracy of the given speech, which indicates
         * how closely the phonemes match a native speaker's pronunciation.
         * @member PronunciationAssessmentResult.prototype.accuracyScore
         * @function
         * @public
         * @returns {number} Accuracy score.
         */ get: function() {
            return this.detailResult.PronunciationAssessment.AccuracyScore;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PronunciationAssessmentResult.prototype, "pronunciationScore", {
        /**
         * The overall score indicating the pronunciation quality of the given speech.
         * This is calculated from AccuracyScore, FluencyScore and CompletenessScore with weight.
         * @member PronunciationAssessmentResult.prototype.pronunciationScore
         * @function
         * @public
         * @returns {number} Pronunciation score.
         */ get: function() {
            return this.detailResult.PronunciationAssessment.PronScore;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PronunciationAssessmentResult.prototype, "completenessScore", {
        /**
         * The score indicating the completeness of the given speech by calculating the ratio of pronounced words towards entire input.
         * @member PronunciationAssessmentResult.prototype.completenessScore
         * @function
         * @public
         * @returns {number} Completeness score.
         */ get: function() {
            return this.detailResult.PronunciationAssessment.CompletenessScore;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PronunciationAssessmentResult.prototype, "fluencyScore", {
        /**
         * The score indicating the fluency of the given speech.
         * @member PronunciationAssessmentResult.prototype.fluencyScore
         * @function
         * @public
         * @returns {number} Fluency score.
         */ get: function() {
            return this.detailResult.PronunciationAssessment.FluencyScore;
        },
        enumerable: false,
        configurable: true
    });
    return PronunciationAssessmentResult;
}();
exports.PronunciationAssessmentResult = PronunciationAssessmentResult;

},{"42d7ff2a011fab80":"4jwu5","5eb878ae8c531d02":"hxkc3"}],"5DSuL":[function(require,module,exports) {
"use strict";
//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Diagnostics = void 0;
var Exports_1 = require("c813f6ba5fac22a7");
var Exports_2 = require("bdec16818e433795");
/**
 * Defines diagnostics API for managing console output
 * Added in version 1.21.0
 */ var Diagnostics = /** @class */ function() {
    function Diagnostics() {}
    Diagnostics.SetLoggingLevel = function(logLevel) {
        this.privListener = new Exports_1.ConsoleLoggingListener(logLevel);
        Exports_2.Events.instance.attachConsoleListener(this.privListener);
    };
    Diagnostics.StartConsoleOutput = function() {
        if (!!this.privListener) this.privListener.enableConsoleOutput = true;
    };
    Diagnostics.StopConsoleOutput = function() {
        if (!!this.privListener) this.privListener.enableConsoleOutput = false;
    };
    Diagnostics.SetLogOutputPath = function(path) {
        if (typeof window === "undefined") {
            if (!!this.privListener) this.privListener.logPath = path;
        } else throw new Error("File system logging not available in browser.");
    };
    Diagnostics.privListener = undefined;
    return Diagnostics;
}();
exports.Diagnostics = Diagnostics;

},{"c813f6ba5fac22a7":"9oZeQ","bdec16818e433795":"5Bedw"}],"93Yn9":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoiceProfileConnectionFactory = exports.SpeakerRecognitionConnectionFactory = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("aee7d731335029be");
var Exports_2 = require("3e95c5dbf8d04b28");
var ConnectionFactoryBase_1 = require("66fd9393afe07904");
var Exports_3 = require("94c41af6f9a86655");
var HeaderNames_1 = require("dada6da81922e51");
var SpeakerRecognitionConnectionFactoryBase = /** @class */ function(_super) {
    __extends(SpeakerRecognitionConnectionFactoryBase, _super);
    function SpeakerRecognitionConnectionFactoryBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SpeakerRecognitionConnectionFactoryBase.prototype.create = function(config, authInfo, endpointPath, connectionId) {
        var endpoint = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint);
        if (!endpoint) {
            var region = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Region);
            var hostSuffix = ConnectionFactoryBase_1.ConnectionFactoryBase.getHostSuffix(region);
            var host = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".spr-frontend.speech" + hostSuffix);
            var scenario = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_SpeakerIdMode, "TextIndependentIdentification");
            endpoint = host + "/speaker/ws/" + this.scenarioToPath(scenario) + "/" + endpointPath;
        }
        var queryParams = {
            format: "simple",
            language: config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage)
        };
        this.setCommonUrlParams(config, queryParams, endpoint);
        var headers = {};
        if (authInfo.token !== undefined && authInfo.token !== "") headers[authInfo.headerName] = authInfo.token;
        headers[HeaderNames_1.HeaderNames.ConnectionId] = connectionId;
        headers[HeaderNames_1.HeaderNames.SpIDAuthKey] = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Key);
        config.parameters.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Url, endpoint);
        var enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
        return new Exports_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_3.WebsocketMessageFormatter(), Exports_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    };
    SpeakerRecognitionConnectionFactoryBase.prototype.scenarioToPath = function(mode) {
        switch(mode){
            case "TextIndependentVerification":
            case "2":
                return "verification/text-independent";
            case "TextDependentVerification":
            case "1":
                return "verification/text-dependent";
            default:
                return "identification/text-independent";
        }
    };
    return SpeakerRecognitionConnectionFactoryBase;
}(ConnectionFactoryBase_1.ConnectionFactoryBase);
var SpeakerRecognitionConnectionFactory = /** @class */ function(_super) {
    __extends(SpeakerRecognitionConnectionFactory, _super);
    function SpeakerRecognitionConnectionFactory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SpeakerRecognitionConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        return _super.prototype.create.call(this, config, authInfo, "recognition", connectionId);
    };
    return SpeakerRecognitionConnectionFactory;
}(SpeakerRecognitionConnectionFactoryBase);
exports.SpeakerRecognitionConnectionFactory = SpeakerRecognitionConnectionFactory;
var VoiceProfileConnectionFactory = /** @class */ function(_super) {
    __extends(VoiceProfileConnectionFactory, _super);
    function VoiceProfileConnectionFactory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    VoiceProfileConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        return _super.prototype.create.call(this, config, authInfo, "profile", connectionId);
    };
    return VoiceProfileConnectionFactory;
}(SpeakerRecognitionConnectionFactoryBase);
exports.VoiceProfileConnectionFactory = VoiceProfileConnectionFactory;

},{"aee7d731335029be":"9oZeQ","3e95c5dbf8d04b28":"hxkc3","66fd9393afe07904":"hvoIt","94c41af6f9a86655":"7Qpvn","dada6da81922e51":"bNYHA"}],"josuk":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/* eslint-disable max-classes-per-file */ var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecognitionEndedEvent = exports.RecognitionCompletionStatus = exports.RecognitionStartedEvent = exports.ConnectingToServiceEvent = exports.ListeningStartedEvent = exports.RecognitionTriggeredEvent = exports.SpeechRecognitionEvent = void 0;
var Exports_1 = require("d61f23f748e419d2");
var SpeechRecognitionEvent = /** @class */ function(_super) {
    __extends(SpeechRecognitionEvent, _super);
    function SpeechRecognitionEvent(eventName, requestId, sessionId, eventType) {
        if (eventType === void 0) eventType = Exports_1.EventType.Info;
        var _this = _super.call(this, eventName, eventType) || this;
        _this.privRequestId = requestId;
        _this.privSessionId = sessionId;
        return _this;
    }
    Object.defineProperty(SpeechRecognitionEvent.prototype, "requestId", {
        get: function() {
            return this.privRequestId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechRecognitionEvent.prototype, "sessionId", {
        get: function() {
            return this.privSessionId;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechRecognitionEvent;
}(Exports_1.PlatformEvent);
exports.SpeechRecognitionEvent = SpeechRecognitionEvent;
var RecognitionTriggeredEvent = /** @class */ function(_super) {
    __extends(RecognitionTriggeredEvent, _super);
    function RecognitionTriggeredEvent(requestId, sessionId, audioSourceId, audioNodeId) {
        var _this = _super.call(this, "RecognitionTriggeredEvent", requestId, sessionId) || this;
        _this.privAudioSourceId = audioSourceId;
        _this.privAudioNodeId = audioNodeId;
        return _this;
    }
    Object.defineProperty(RecognitionTriggeredEvent.prototype, "audioSourceId", {
        get: function() {
            return this.privAudioSourceId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionTriggeredEvent.prototype, "audioNodeId", {
        get: function() {
            return this.privAudioNodeId;
        },
        enumerable: false,
        configurable: true
    });
    return RecognitionTriggeredEvent;
}(SpeechRecognitionEvent);
exports.RecognitionTriggeredEvent = RecognitionTriggeredEvent;
var ListeningStartedEvent = /** @class */ function(_super) {
    __extends(ListeningStartedEvent, _super);
    function ListeningStartedEvent(requestId, sessionId, audioSourceId, audioNodeId) {
        var _this = _super.call(this, "ListeningStartedEvent", requestId, sessionId) || this;
        _this.privAudioSourceId = audioSourceId;
        _this.privAudioNodeId = audioNodeId;
        return _this;
    }
    Object.defineProperty(ListeningStartedEvent.prototype, "audioSourceId", {
        get: function() {
            return this.privAudioSourceId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListeningStartedEvent.prototype, "audioNodeId", {
        get: function() {
            return this.privAudioNodeId;
        },
        enumerable: false,
        configurable: true
    });
    return ListeningStartedEvent;
}(SpeechRecognitionEvent);
exports.ListeningStartedEvent = ListeningStartedEvent;
var ConnectingToServiceEvent = /** @class */ function(_super) {
    __extends(ConnectingToServiceEvent, _super);
    function ConnectingToServiceEvent(requestId, authFetchEventid, sessionId) {
        var _this = _super.call(this, "ConnectingToServiceEvent", requestId, sessionId) || this;
        _this.privAuthFetchEventid = authFetchEventid;
        return _this;
    }
    Object.defineProperty(ConnectingToServiceEvent.prototype, "authFetchEventid", {
        get: function() {
            return this.privAuthFetchEventid;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectingToServiceEvent;
}(SpeechRecognitionEvent);
exports.ConnectingToServiceEvent = ConnectingToServiceEvent;
var RecognitionStartedEvent = /** @class */ function(_super) {
    __extends(RecognitionStartedEvent, _super);
    function RecognitionStartedEvent(requestId, audioSourceId, audioNodeId, authFetchEventId, sessionId) {
        var _this = _super.call(this, "RecognitionStartedEvent", requestId, sessionId) || this;
        _this.privAudioSourceId = audioSourceId;
        _this.privAudioNodeId = audioNodeId;
        _this.privAuthFetchEventId = authFetchEventId;
        return _this;
    }
    Object.defineProperty(RecognitionStartedEvent.prototype, "audioSourceId", {
        get: function() {
            return this.privAudioSourceId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionStartedEvent.prototype, "audioNodeId", {
        get: function() {
            return this.privAudioNodeId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionStartedEvent.prototype, "authFetchEventId", {
        get: function() {
            return this.privAuthFetchEventId;
        },
        enumerable: false,
        configurable: true
    });
    return RecognitionStartedEvent;
}(SpeechRecognitionEvent);
exports.RecognitionStartedEvent = RecognitionStartedEvent;
var RecognitionCompletionStatus;
(function(RecognitionCompletionStatus) {
    RecognitionCompletionStatus[RecognitionCompletionStatus["Success"] = 0] = "Success";
    RecognitionCompletionStatus[RecognitionCompletionStatus["AudioSourceError"] = 1] = "AudioSourceError";
    RecognitionCompletionStatus[RecognitionCompletionStatus["AudioSourceTimeout"] = 2] = "AudioSourceTimeout";
    RecognitionCompletionStatus[RecognitionCompletionStatus["AuthTokenFetchError"] = 3] = "AuthTokenFetchError";
    RecognitionCompletionStatus[RecognitionCompletionStatus["AuthTokenFetchTimeout"] = 4] = "AuthTokenFetchTimeout";
    RecognitionCompletionStatus[RecognitionCompletionStatus["UnAuthorized"] = 5] = "UnAuthorized";
    RecognitionCompletionStatus[RecognitionCompletionStatus["ConnectTimeout"] = 6] = "ConnectTimeout";
    RecognitionCompletionStatus[RecognitionCompletionStatus["ConnectError"] = 7] = "ConnectError";
    RecognitionCompletionStatus[RecognitionCompletionStatus["ClientRecognitionActivityTimeout"] = 8] = "ClientRecognitionActivityTimeout";
    RecognitionCompletionStatus[RecognitionCompletionStatus["UnknownError"] = 9] = "UnknownError";
})(RecognitionCompletionStatus = exports.RecognitionCompletionStatus || (exports.RecognitionCompletionStatus = {}));
var RecognitionEndedEvent = /** @class */ function(_super) {
    __extends(RecognitionEndedEvent, _super);
    function RecognitionEndedEvent(requestId, audioSourceId, audioNodeId, authFetchEventId, sessionId, serviceTag, status, error) {
        var _this = _super.call(this, "RecognitionEndedEvent", requestId, sessionId, status === RecognitionCompletionStatus.Success ? Exports_1.EventType.Info : Exports_1.EventType.Error) || this;
        _this.privAudioSourceId = audioSourceId;
        _this.privAudioNodeId = audioNodeId;
        _this.privAuthFetchEventId = authFetchEventId;
        _this.privStatus = status;
        _this.privError = error;
        _this.privServiceTag = serviceTag;
        return _this;
    }
    Object.defineProperty(RecognitionEndedEvent.prototype, "audioSourceId", {
        get: function() {
            return this.privAudioSourceId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionEndedEvent.prototype, "audioNodeId", {
        get: function() {
            return this.privAudioNodeId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionEndedEvent.prototype, "authFetchEventId", {
        get: function() {
            return this.privAuthFetchEventId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionEndedEvent.prototype, "serviceTag", {
        get: function() {
            return this.privServiceTag;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionEndedEvent.prototype, "status", {
        get: function() {
            return this.privStatus;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognitionEndedEvent.prototype, "error", {
        get: function() {
            return this.privError;
        },
        enumerable: false,
        configurable: true
    });
    return RecognitionEndedEvent;
}(SpeechRecognitionEvent);
exports.RecognitionEndedEvent = RecognitionEndedEvent;

},{"d61f23f748e419d2":"5Bedw"}],"jhVVj":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServiceRecognizerBase = void 0;
var Exports_1 = require("f2a77618249ca183");
var Exports_2 = require("a01615f5c80e912");
var Exports_3 = require("1cdfd196bfa00773");
var Exports_4 = require("12bebb1752a95a9d");
var SpeechConnectionMessage_Internal_1 = require("e81b581f6712575b");
var ServiceRecognizerBase = /** @class */ function() {
    function ServiceRecognizerBase(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
        var _this = this;
        // A promise for a configured connection.
        // Do not consume directly, call fetchConnection instead.
        this.privConnectionConfigurationPromise = undefined;
        // A promise for a connection, but one that has not had the speech context sent yet.
        // Do not consume directly, call fetchConnection instead.
        this.privConnectionPromise = undefined;
        this.privSetTimeout = setTimeout;
        this.privIsLiveAudio = false;
        this.privAverageBytesPerMs = 0;
        this.privEnableSpeakerId = false;
        this.recognizeOverride = undefined;
        this.recognizeSpeaker = undefined;
        this.disconnectOverride = undefined;
        this.receiveMessageOverride = undefined;
        this.sendPrePayloadJSONOverride = undefined;
        this.postConnectImplOverride = undefined;
        this.configConnectionOverride = undefined;
        this.handleSpeechPhraseMessage = undefined;
        this.handleSpeechHypothesisMessage = undefined;
        if (!authentication) throw new Exports_2.ArgumentNullError("authentication");
        if (!connectionFactory) throw new Exports_2.ArgumentNullError("connectionFactory");
        if (!audioSource) throw new Exports_2.ArgumentNullError("audioSource");
        if (!recognizerConfig) throw new Exports_2.ArgumentNullError("recognizerConfig");
        this.privEnableSpeakerId = recognizerConfig.isSpeakerDiarizationEnabled;
        this.privMustReportEndOfStream = false;
        this.privAuthentication = authentication;
        this.privConnectionFactory = connectionFactory;
        this.privAudioSource = audioSource;
        this.privRecognizerConfig = recognizerConfig;
        this.privIsDisposed = false;
        this.privRecognizer = recognizer;
        this.privRequestSession = new Exports_4.RequestSession(this.privAudioSource.id());
        this.privConnectionEvents = new Exports_2.EventSource();
        this.privServiceEvents = new Exports_2.EventSource();
        this.privDynamicGrammar = new Exports_4.DynamicGrammarBuilder();
        this.privSpeechContext = new Exports_4.SpeechContext(this.privDynamicGrammar);
        this.privAgentConfig = new Exports_4.AgentConfig();
        if (typeof Blob !== "undefined" && typeof Worker !== "undefined") this.privSetTimeout = Exports_2.Timeout.setTimeout;
        this.connectionEvents.attach(function(connectionEvent) {
            if (connectionEvent.name === "ConnectionClosedEvent") {
                var connectionClosedEvent = connectionEvent;
                if (connectionClosedEvent.statusCode === 1003 || connectionClosedEvent.statusCode === 1007 || connectionClosedEvent.statusCode === 1002 || connectionClosedEvent.statusCode === 4000 || _this.privRequestSession.numConnectionAttempts > _this.privRecognizerConfig.maxRetryCount) _this.cancelRecognitionLocal(Exports_3.CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? Exports_3.CancellationErrorCode.BadRequestParameters : Exports_3.CancellationErrorCode.ConnectionFailure, connectionClosedEvent.reason + " websocket error code: " + connectionClosedEvent.statusCode);
            }
        });
        if (this.privEnableSpeakerId) this.privDiarizationSessionId = Exports_2.createNoDashGuid();
        this.setLanguageIdJson();
        this.setOutputDetailLevelJson();
    }
    ServiceRecognizerBase.prototype.setSpeechSegmentationTimeoutJson = function() {
        var speechSegmentationTimeout = this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.Speech_SegmentationSilenceTimeoutMs, undefined);
        if (speechSegmentationTimeout !== undefined) {
            var mode = this.recognitionMode === Exports_4.RecognitionMode.Conversation ? "CONVERSATION" : this.recognitionMode === Exports_4.RecognitionMode.Dictation ? "DICTATION" : "INTERACTIVE";
            var segmentationSilenceTimeoutMs = parseInt(speechSegmentationTimeout, 10);
            var phraseDetection = this.privSpeechContext.getSection("phraseDetection");
            phraseDetection.mode = mode;
            phraseDetection[mode] = {
                segmentation: {
                    mode: "Custom",
                    segmentationSilenceTimeoutMs: segmentationSilenceTimeoutMs
                }
            };
            this.privSpeechContext.setSection("phraseDetection", phraseDetection);
        }
    };
    ServiceRecognizerBase.prototype.setLanguageIdJson = function() {
        if (this.privRecognizerConfig.autoDetectSourceLanguages !== undefined) {
            var phraseDetection = this.privSpeechContext.getSection("phraseDetection");
            var sourceLanguages = this.privRecognizerConfig.autoDetectSourceLanguages.split(",");
            var speechContextLidMode = void 0;
            if (this.privRecognizerConfig.languageIdMode === "Continuous") speechContextLidMode = "DetectContinuous";
            else speechContextLidMode = "DetectAtAudioStart";
            this.privSpeechContext.setSection("languageId", {
                Priority: "PrioritizeLatency",
                languages: sourceLanguages,
                mode: speechContextLidMode,
                onSuccess: {
                    action: "Recognize"
                },
                onUnknown: {
                    action: "None"
                }
            });
            this.privSpeechContext.setSection("phraseOutput", {
                interimResults: {
                    resultType: "Auto"
                },
                phraseResults: {
                    resultType: "Always"
                }
            });
            var customModels = this.privRecognizerConfig.sourceLanguageModels;
            if (customModels !== undefined) {
                phraseDetection.customModels = customModels;
                phraseDetection.onInterim = {
                    action: "None"
                };
                phraseDetection.onSuccess = {
                    action: "None"
                };
            }
            this.privSpeechContext.setSection("phraseDetection", phraseDetection);
        }
    };
    ServiceRecognizerBase.prototype.setOutputDetailLevelJson = function() {
        if (this.privEnableSpeakerId) {
            var requestWordLevelTimestamps = this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase();
            if (requestWordLevelTimestamps === "true") this.privSpeechContext.setWordLevelTimings();
            else {
                var outputFormat = this.privRecognizerConfig.parameters.getProperty(Exports_4.OutputFormatPropertyName, Exports_3.OutputFormat[Exports_3.OutputFormat.Simple]).toLowerCase();
                if (outputFormat === Exports_3.OutputFormat[Exports_3.OutputFormat.Detailed].toLocaleLowerCase()) this.privSpeechContext.setDetailedOutputFormat();
            }
        }
    };
    Object.defineProperty(ServiceRecognizerBase.prototype, "isSpeakerDiarizationEnabled", {
        get: function() {
            return this.privEnableSpeakerId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServiceRecognizerBase.prototype, "audioSource", {
        get: function() {
            return this.privAudioSource;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServiceRecognizerBase.prototype, "speechContext", {
        get: function() {
            return this.privSpeechContext;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServiceRecognizerBase.prototype, "dynamicGrammar", {
        get: function() {
            return this.privDynamicGrammar;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServiceRecognizerBase.prototype, "agentConfig", {
        get: function() {
            return this.privAgentConfig;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServiceRecognizerBase.prototype, "conversationTranslatorToken", {
        set: function(token) {
            this.privRecognizerConfig.parameters.setProperty(Exports_3.PropertyId.ConversationTranslator_Token, token);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServiceRecognizerBase.prototype, "voiceProfileType", {
        set: function(type) {
            this.privRecognizerConfig.parameters.setProperty(Exports_3.PropertyId.SpeechServiceConnection_SpeakerIdMode, type);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServiceRecognizerBase.prototype, "authentication", {
        set: function(auth) {
            this.privAuthentication = this.authentication;
        },
        enumerable: false,
        configurable: true
    });
    ServiceRecognizerBase.prototype.isDisposed = function() {
        return this.privIsDisposed;
    };
    ServiceRecognizerBase.prototype.dispose = function(reason) {
        return __awaiter(this, void 0, void 0, function() {
            var connection, error_1;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.privIsDisposed = true;
                        if (!(this.privConnectionConfigurationPromise !== undefined)) return [
                            3 /*break*/ ,
                            5
                        ];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            4,
                            ,
                            5
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.privConnectionConfigurationPromise
                        ];
                    case 2:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            connection.dispose(reason)
                        ];
                    case 3:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 4:
                        error_1 = _a.sent();
                        // The connection is in a bad state. But we're trying to kill it, so...
                        return [
                            2 /*return*/ 
                        ];
                    case 5:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    Object.defineProperty(ServiceRecognizerBase.prototype, "connectionEvents", {
        get: function() {
            return this.privConnectionEvents;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServiceRecognizerBase.prototype, "serviceEvents", {
        get: function() {
            return this.privServiceEvents;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServiceRecognizerBase.prototype, "recognitionMode", {
        get: function() {
            return this.privRecognizerConfig.recognitionMode;
        },
        enumerable: false,
        configurable: true
    });
    ServiceRecognizerBase.prototype.recognize = function(recoMode, successCallback, errorCallBack) {
        return __awaiter(this, void 0, void 0, function() {
            var conPromise, audioNode, audioStreamNode, format, deviceInfo, error_2, error_3, sessionStartEventArgs, audioSendPromise;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!(this.recognizeOverride !== undefined)) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.recognizeOverride(recoMode, successCallback, errorCallBack)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                    case 2:
                        // Clear the existing configuration promise to force a re-transmission of config and context.
                        this.privConnectionConfigurationPromise = undefined;
                        this.privRecognizerConfig.recognitionMode = recoMode;
                        this.setSpeechSegmentationTimeoutJson();
                        this.privSuccessCallback = successCallback;
                        this.privErrorCallback = errorCallBack;
                        this.privRequestSession.startNewRecognition();
                        this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);
                        conPromise = this.connectImpl();
                        _a.label = 3;
                    case 3:
                        _a.trys.push([
                            3,
                            8,
                            ,
                            10
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.audioSource.attach(this.privRequestSession.audioNodeId)
                        ];
                    case 4:
                        audioStreamNode = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.audioSource.format
                        ];
                    case 5:
                        format = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.audioSource.deviceInfo
                        ];
                    case 6:
                        deviceInfo = _a.sent();
                        this.privIsLiveAudio = deviceInfo.type && deviceInfo.type === Exports_4.type.Microphones;
                        audioNode = new Exports_1.ReplayableAudioNode(audioStreamNode, format.avgBytesPerSec);
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false)
                        ];
                    case 7:
                        _a.sent();
                        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {
                            source: deviceInfo
                        };
                        return [
                            3 /*break*/ ,
                            10
                        ];
                    case 8:
                        error_2 = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onStopRecognizing()
                        ];
                    case 9:
                        _a.sent();
                        throw error_2;
                    case 10:
                        _a.trys.push([
                            10,
                            12,
                            ,
                            14
                        ]);
                        return [
                            4 /*yield*/ ,
                            conPromise
                        ];
                    case 11:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            14
                        ];
                    case 12:
                        error_3 = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.cancelRecognitionLocal(Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.ConnectionFailure, error_3)
                        ];
                    case 13:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                    case 14:
                        sessionStartEventArgs = new Exports_3.SessionEventArgs(this.privRequestSession.sessionId);
                        if (!!this.privRecognizer.sessionStarted) this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
                        this.receiveMessage();
                        audioSendPromise = this.sendAudio(audioNode);
                        audioSendPromise.catch(function(error) {
                            return __awaiter(_this, void 0, void 0, function() {
                                return __generator(this, function(_a) {
                                    switch(_a.label){
                                        case 0:
                                            return [
                                                4 /*yield*/ ,
                                                this.cancelRecognitionLocal(Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error)
                                            ];
                                        case 1:
                                            _a.sent();
                                            return [
                                                2 /*return*/ 
                                            ];
                                    }
                                });
                            });
                        });
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ServiceRecognizerBase.prototype.stopRecognizing = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!this.privRequestSession.isRecognizing) return [
                            3 /*break*/ ,
                            8
                        ];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            ,
                            6,
                            8
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.audioSource.turnOff()
                        ];
                    case 2:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendFinalAudio()
                        ];
                    case 3:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onStopRecognizing()
                        ];
                    case 4:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.turnCompletionPromise
                        ];
                    case 5:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            8
                        ];
                    case 6:
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.dispose()
                        ];
                    case 7:
                        _a.sent();
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 8:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ServiceRecognizerBase.prototype.connect = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.connectImpl()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            Promise.resolve()
                        ];
                }
            });
        });
    };
    ServiceRecognizerBase.prototype.connectAsync = function(cb, err) {
        this.connectImpl().then(function() {
            try {
                if (!!cb) cb();
            } catch (e) {
                if (!!err) err(e);
            }
        }, function(reason) {
            try {
                if (!!err) err(reason);
            /* eslint-disable no-empty */ } catch (error) {}
        });
    };
    ServiceRecognizerBase.prototype.disconnect = function() {
        return __awaiter(this, void 0, void 0, function() {
            var error_4;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.cancelRecognitionLocal(Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.NoError, "Disconnecting")
                        ];
                    case 1:
                        _a.sent();
                        if (!(this.disconnectOverride !== undefined)) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            this.disconnectOverride()
                        ];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        if (!(this.privConnectionPromise !== undefined)) return [
                            3 /*break*/ ,
                            8
                        ];
                        _a.label = 4;
                    case 4:
                        _a.trys.push([
                            4,
                            7,
                            ,
                            8
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.privConnectionPromise
                        ];
                    case 5:
                        return [
                            4 /*yield*/ ,
                            _a.sent().dispose()
                        ];
                    case 6:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            8
                        ];
                    case 7:
                        error_4 = _a.sent();
                        return [
                            3 /*break*/ ,
                            8
                        ];
                    case 8:
                        this.privConnectionPromise = undefined;
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ServiceRecognizerBase.prototype.sendMessage = function(message) {
        return;
    };
    ServiceRecognizerBase.prototype.sendNetworkMessage = function(path, payload) {
        return __awaiter(this, void 0, void 0, function() {
            var type, contentType, connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        type = typeof payload === "string" ? Exports_2.MessageType.Text : Exports_2.MessageType.Binary;
                        contentType = typeof payload === "string" ? "application/json" : "";
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            2 /*return*/ ,
                            connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(type, path, this.privRequestSession.requestId, contentType, payload))
                        ];
                }
            });
        });
    };
    Object.defineProperty(ServiceRecognizerBase.prototype, "activityTemplate", {
        get: function() {
            return this.privActivityTemplate;
        },
        set: function(messagePayload) {
            this.privActivityTemplate = messagePayload;
        },
        enumerable: false,
        configurable: true
    });
    ServiceRecognizerBase.prototype.sendTelemetryData = function() {
        return __awaiter(this, void 0, void 0, function() {
            var telemetryData, connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        telemetryData = this.privRequestSession.getTelemetry();
                        if (ServiceRecognizerBase.telemetryDataEnabled !== true || this.privIsDisposed || null === telemetryData) return [
                            2 /*return*/ 
                        ];
                        if (!!ServiceRecognizerBase.telemetryData) try {
                            ServiceRecognizerBase.telemetryData(telemetryData);
                        /* eslint-disable no-empty */ } catch (_b) {}
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, "telemetry", this.privRequestSession.requestId, "application/json", telemetryData))
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    // Cancels recognition.
    ServiceRecognizerBase.prototype.cancelRecognitionLocal = function(cancellationReason, errorCode, error) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!!this.privRequestSession.isRecognizing) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onStopRecognizing()
                        ];
                    case 1:
                        _a.sent();
                        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, cancellationReason, errorCode, error);
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ServiceRecognizerBase.prototype.receiveMessage = function() {
        return __awaiter(this, void 0, void 0, function() {
            var connection, message, connectionMessage, _a, speechStartDetected, speechStartEventArgs, json, speechStopDetected, speechStopEventArgs, sessionStopEventArgs, error_5;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _b.trys.push([
                            0,
                            18,
                            ,
                            19
                        ]);
                        if (this.privIsDisposed) // We're done.
                        return [
                            2 /*return*/ 
                        ];
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _b.sent();
                        return [
                            4 /*yield*/ ,
                            connection.read()
                        ];
                    case 2:
                        message = _b.sent();
                        if (this.receiveMessageOverride !== undefined) return [
                            2 /*return*/ ,
                            this.receiveMessageOverride()
                        ];
                        // indicates we are draining the queue and it came with no message;
                        if (!message) {
                            if (!this.privRequestSession.isRecognizing) return [
                                2 /*return*/ 
                            ];
                            else return [
                                2 /*return*/ ,
                                this.receiveMessage()
                            ];
                        }
                        this.privServiceHasSentMessage = true;
                        connectionMessage = SpeechConnectionMessage_Internal_1.SpeechConnectionMessage.fromConnectionMessage(message);
                        if (!(connectionMessage.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase())) return [
                            3 /*break*/ ,
                            17
                        ];
                        _a = connectionMessage.path.toLowerCase();
                        switch(_a){
                            case "turn.start":
                                return [
                                    3 /*break*/ ,
                                    3
                                ];
                            case "speech.startdetected":
                                return [
                                    3 /*break*/ ,
                                    4
                                ];
                            case "speech.enddetected":
                                return [
                                    3 /*break*/ ,
                                    5
                                ];
                            case "turn.end":
                                return [
                                    3 /*break*/ ,
                                    6
                                ];
                        }
                        return [
                            3 /*break*/ ,
                            15
                        ];
                    case 3:
                        this.privMustReportEndOfStream = true;
                        this.privRequestSession.onServiceTurnStartResponse();
                        return [
                            3 /*break*/ ,
                            17
                        ];
                    case 4:
                        speechStartDetected = Exports_4.SpeechDetected.fromJSON(connectionMessage.textBody);
                        speechStartEventArgs = new Exports_3.RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);
                        if (!!this.privRecognizer.speechStartDetected) this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);
                        return [
                            3 /*break*/ ,
                            17
                        ];
                    case 5:
                        json = void 0;
                        if (connectionMessage.textBody.length > 0) json = connectionMessage.textBody;
                        else // If the request was empty, the JSON returned is empty.
                        json = "{ Offset: 0 }";
                        speechStopDetected = Exports_4.SpeechDetected.fromJSON(json);
                        speechStopEventArgs = new Exports_3.RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
                        if (!!this.privRecognizer.speechEndDetected) this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);
                        return [
                            3 /*break*/ ,
                            17
                        ];
                    case 6:
                        return [
                            4 /*yield*/ ,
                            this.sendTelemetryData()
                        ];
                    case 7:
                        _b.sent();
                        if (!(this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream)) return [
                            3 /*break*/ ,
                            9
                        ];
                        this.privMustReportEndOfStream = false;
                        return [
                            4 /*yield*/ ,
                            this.cancelRecognitionLocal(Exports_3.CancellationReason.EndOfStream, Exports_3.CancellationErrorCode.NoError, undefined)
                        ];
                    case 8:
                        _b.sent();
                        _b.label = 9;
                    case 9:
                        sessionStopEventArgs = new Exports_3.SessionEventArgs(this.privRequestSession.sessionId);
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition)
                        ];
                    case 10:
                        _b.sent();
                        if (!(!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing)) return [
                            3 /*break*/ ,
                            11
                        ];
                        if (!!this.privRecognizer.sessionStopped) this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);
                        return [
                            2 /*return*/ 
                        ];
                    case 11:
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 12:
                        connection = _b.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendPrePayloadJSON(connection)
                        ];
                    case 13:
                        _b.sent();
                        _b.label = 14;
                    case 14:
                        return [
                            3 /*break*/ ,
                            17
                        ];
                    case 15:
                        return [
                            4 /*yield*/ ,
                            this.processTypeSpecificMessages(connectionMessage)
                        ];
                    case 16:
                        if (!_b.sent()) // here are some messages that the derived class has not processed, dispatch them to connect class
                        {
                            if (!!this.privServiceEvents) this.serviceEvents.onEvent(new Exports_2.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
                        }
                        _b.label = 17;
                    case 17:
                        return [
                            2 /*return*/ ,
                            this.receiveMessage()
                        ];
                    case 18:
                        error_5 = _b.sent();
                        return [
                            2 /*return*/ ,
                            null
                        ];
                    case 19:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ServiceRecognizerBase.prototype.updateSpeakerDiarizationAudioOffset = function() {
        var bytesSent = this.privRequestSession.recognitionBytesSent;
        var audioOffsetMs = bytesSent / this.privAverageBytesPerMs;
        this.privSpeechContext.setSpeakerDiarizationAudioOffsetMs(audioOffsetMs);
    };
    ServiceRecognizerBase.prototype.sendSpeechContext = function(connection, generateNewRequestId) {
        if (this.privEnableSpeakerId) this.updateSpeakerDiarizationAudioOffset();
        var speechContextJson = this.speechContext.toJSON();
        if (generateNewRequestId) this.privRequestSession.onSpeechContext();
        if (speechContextJson) return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, "speech.context", this.privRequestSession.requestId, "application/json", speechContextJson));
        return;
    };
    ServiceRecognizerBase.prototype.noOp = function() {
        // operation not supported
        return;
    };
    // Encapsulated for derived service recognizers that need to send additional JSON
    ServiceRecognizerBase.prototype.sendPrePayloadJSON = function(connection, generateNewRequestId) {
        if (generateNewRequestId === void 0) generateNewRequestId = true;
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.sendPrePayloadJSONOverride !== undefined) return [
                            2 /*return*/ ,
                            this.sendPrePayloadJSONOverride(connection)
                        ];
                        return [
                            4 /*yield*/ ,
                            this.sendSpeechContext(connection, generateNewRequestId)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendWaveHeader(connection)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ServiceRecognizerBase.prototype.sendWaveHeader = function(connection) {
        return __awaiter(this, void 0, void 0, function() {
            var format;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.audioSource.format
                        ];
                    case 1:
                        format = _a.sent();
                        // this.writeBufferToConsole(format.header);
                        return [
                            2 /*return*/ ,
                            connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Binary, "audio", this.privRequestSession.requestId, "audio/x-wav", format.header))
                        ];
                }
            });
        });
    };
    // Establishes a websocket connection to the end point.
    ServiceRecognizerBase.prototype.connectImpl = function() {
        var _this = this;
        if (this.privConnectionPromise !== undefined) return this.privConnectionPromise.then(function(connection) {
            if (connection.state() === Exports_2.ConnectionState.Disconnected) {
                _this.privConnectionId = null;
                _this.privConnectionPromise = undefined;
                _this.privServiceHasSentMessage = false;
                return _this.connectImpl();
            }
            return _this.privConnectionPromise;
        }, function() {
            _this.privConnectionId = null;
            _this.privConnectionPromise = undefined;
            _this.privServiceHasSentMessage = false;
            return _this.connectImpl();
        });
        this.privConnectionPromise = this.retryableConnect();
        // Attach an empty handler to allow the promise to run in the background while
        // other startup events happen. It'll eventually be awaited on.
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.privConnectionPromise.catch(function() {});
        if (this.postConnectImplOverride !== undefined) return this.postConnectImplOverride(this.privConnectionPromise);
        return this.privConnectionPromise;
    };
    ServiceRecognizerBase.prototype.sendSpeechServiceConfig = function(connection, requestSession, SpeechServiceConfigJson) {
        requestSession.onSpeechContext();
        // filter out anything that is not required for the service to work.
        if (ServiceRecognizerBase.telemetryDataEnabled !== true) {
            var withTelemetry = JSON.parse(SpeechServiceConfigJson);
            var replacement = {
                context: {
                    system: withTelemetry.context.system
                }
            };
            SpeechServiceConfigJson = JSON.stringify(replacement);
        }
        if (this.privRecognizerConfig.parameters.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() === "true") {
            var json = JSON.parse(SpeechServiceConfigJson);
            json.context.DisableReferenceChannel = "True";
            json.context.MicSpec = "1_0_0";
            SpeechServiceConfigJson = JSON.stringify(json);
        }
        if (SpeechServiceConfigJson) return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, "speech.config", requestSession.requestId, "application/json", SpeechServiceConfigJson));
        return;
    };
    ServiceRecognizerBase.prototype.fetchConnection = function() {
        return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privConnectionConfigurationPromise !== undefined) return [
                            2 /*return*/ ,
                            this.privConnectionConfigurationPromise.then(function(connection) {
                                if (connection.state() === Exports_2.ConnectionState.Disconnected) {
                                    _this.privConnectionId = null;
                                    _this.privConnectionConfigurationPromise = undefined;
                                    _this.privServiceHasSentMessage = false;
                                    return _this.fetchConnection();
                                }
                                return _this.privConnectionConfigurationPromise;
                            }, function() {
                                _this.privConnectionId = null;
                                _this.privConnectionConfigurationPromise = undefined;
                                _this.privServiceHasSentMessage = false;
                                return _this.fetchConnection();
                            })
                        ];
                        this.privConnectionConfigurationPromise = this.configureConnection();
                        return [
                            4 /*yield*/ ,
                            this.privConnectionConfigurationPromise
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.sent()
                        ];
                }
            });
        });
    };
    ServiceRecognizerBase.prototype.sendAudio = function(audioStreamNode) {
        return __awaiter(this, void 0, void 0, function() {
            var audioFormat, nextSendTime, fastLaneSizeMs, maxSendUnthrottledBytes, startRecogNumber, readAndUploadCycle;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.audioSource.format
                        ];
                    case 1:
                        audioFormat = _a.sent();
                        this.privAverageBytesPerMs = audioFormat.avgBytesPerSec / 1000;
                        nextSendTime = Date.now();
                        fastLaneSizeMs = this.privRecognizerConfig.parameters.getProperty("SPEECH-TransmitLengthBeforThrottleMs", "5000");
                        maxSendUnthrottledBytes = audioFormat.avgBytesPerSec / 1000 * parseInt(fastLaneSizeMs, 10);
                        startRecogNumber = this.privRequestSession.recogNumber;
                        readAndUploadCycle = function() {
                            return __awaiter(_this, void 0, void 0, function() {
                                var connection, audioStreamChunk, payload, sendDelay;
                                var _this = this;
                                return __generator(this, function(_a) {
                                    switch(_a.label){
                                        case 0:
                                            if (!(!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber)) return [
                                                3 /*break*/ ,
                                                5
                                            ];
                                            return [
                                                4 /*yield*/ ,
                                                this.fetchConnection()
                                            ];
                                        case 1:
                                            connection = _a.sent();
                                            return [
                                                4 /*yield*/ ,
                                                audioStreamNode.read()
                                            ];
                                        case 2:
                                            audioStreamChunk = _a.sent();
                                            // we have a new audio chunk to upload.
                                            if (this.privRequestSession.isSpeechEnded) // If service already recognized audio end then don't send any more audio
                                            return [
                                                2 /*return*/ 
                                            ];
                                            payload = void 0;
                                            sendDelay = void 0;
                                            if (!audioStreamChunk || audioStreamChunk.isEnd) {
                                                payload = null;
                                                sendDelay = 0;
                                            } else {
                                                payload = audioStreamChunk.buffer;
                                                this.privRequestSession.onAudioSent(payload.byteLength);
                                                if (maxSendUnthrottledBytes >= this.privRequestSession.bytesSent) sendDelay = 0;
                                                else sendDelay = Math.max(0, nextSendTime - Date.now());
                                            }
                                            if (!(0 !== sendDelay)) return [
                                                3 /*break*/ ,
                                                4
                                            ];
                                            return [
                                                4 /*yield*/ ,
                                                this.delay(sendDelay)
                                            ];
                                        case 3:
                                            _a.sent();
                                            _a.label = 4;
                                        case 4:
                                            if (payload !== null) nextSendTime = Date.now() + payload.byteLength * 1000 / (audioFormat.avgBytesPerSec * 2);
                                            // Are we still alive?
                                            if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {
                                                connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Binary, "audio", this.privRequestSession.requestId, null, payload)).catch(function() {
                                                    // eslint-disable-next-line @typescript-eslint/no-empty-function
                                                    _this.privRequestSession.onServiceTurnEndResponse(_this.privRecognizerConfig.isContinuousRecognition).catch(function() {});
                                                });
                                                if (!(audioStreamChunk === null || audioStreamChunk === void 0 ? void 0 : audioStreamChunk.isEnd)) // this.writeBufferToConsole(payload);
                                                // Regardless of success or failure, schedule the next upload.
                                                // If the underlying connection was broken, the next cycle will
                                                // get a new connection and re-transmit missing audio automatically.
                                                return [
                                                    2 /*return*/ ,
                                                    readAndUploadCycle()
                                                ];
                                                else // the audio stream has been closed, no need to schedule next
                                                // read-upload cycle.
                                                if (!this.privIsLiveAudio) this.privRequestSession.onSpeechEnded();
                                            }
                                            _a.label = 5;
                                        case 5:
                                            return [
                                                2 /*return*/ 
                                            ];
                                    }
                                });
                            });
                        };
                        return [
                            2 /*return*/ ,
                            readAndUploadCycle()
                        ];
                }
            });
        });
    };
    ServiceRecognizerBase.prototype.retryableConnect = function() {
        return __awaiter(this, void 0, void 0, function() {
            var isUnAuthorized, sessionId, lastStatusCode, lastReason, authPromise, auth, connection, response;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        isUnAuthorized = false;
                        this.privAuthFetchEventId = Exports_2.createNoDashGuid();
                        sessionId = this.privRequestSession.sessionId;
                        this.privConnectionId = sessionId !== undefined ? sessionId : Exports_2.createNoDashGuid();
                        this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);
                        lastStatusCode = 0;
                        lastReason = "";
                        _a.label = 1;
                    case 1:
                        if (!(this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount)) return [
                            3 /*break*/ ,
                            8
                        ];
                        authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
                        return [
                            4 /*yield*/ ,
                            authPromise
                        ];
                    case 2:
                        auth = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onAuthCompleted(false)
                        ];
                    case 3:
                        _a.sent();
                        connection = this.privConnectionFactory.create(this.privRecognizerConfig, auth, this.privConnectionId);
                        // Attach the telemetry handlers.
                        this.privRequestSession.listenForServiceTelemetry(connection.events);
                        // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,
                        // it'll stop sending events.
                        connection.events.attach(function(event) {
                            _this.connectionEvents.onEvent(event);
                        });
                        return [
                            4 /*yield*/ ,
                            connection.open()
                        ];
                    case 4:
                        response = _a.sent();
                        if (!(response.statusCode === 200)) return [
                            3 /*break*/ ,
                            6
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onConnectionEstablishCompleted(response.statusCode)
                        ];
                    case 5:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            Promise.resolve(connection)
                        ];
                    case 6:
                        if (response.statusCode === 1006) isUnAuthorized = true;
                        _a.label = 7;
                    case 7:
                        lastStatusCode = response.statusCode;
                        lastReason = response.reason;
                        this.privRequestSession.onRetryConnection();
                        return [
                            3 /*break*/ ,
                            1
                        ];
                    case 8:
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onConnectionEstablishCompleted(lastStatusCode, lastReason)
                        ];
                    case 9:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            Promise.reject("Unable to contact server. StatusCode: " + lastStatusCode + ", " + this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Endpoint) + " Reason: " + lastReason)
                        ];
                }
            });
        });
    };
    ServiceRecognizerBase.prototype.delay = function(delayMs) {
        var _this = this;
        return new Promise(function(resolve) {
            return _this.privSetTimeout(resolve, delayMs);
        });
    };
    ServiceRecognizerBase.prototype.writeBufferToConsole = function(buffer) {
        var out = "Buffer Size: ";
        if (null === buffer) out += "null";
        else {
            var readView = new Uint8Array(buffer);
            out += buffer.byteLength + "\r\n";
            for(var i = 0; i < buffer.byteLength; i++){
                out += readView[i].toString(16).padStart(2, "0") + " ";
                if ((i + 1) % 16 === 0) {
                    // eslint-disable-next-line no-console
                    console.info(out);
                    out = "";
                }
            }
        }
        // eslint-disable-next-line no-console
        console.info(out);
    };
    ServiceRecognizerBase.prototype.sendFinalAudio = function() {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Binary, "audio", this.privRequestSession.requestId, null, null))
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    ServiceRecognizerBase.prototype.configureConnection = function() {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.connectImpl()
                        ];
                    case 1:
                        connection = _a.sent();
                        if (this.configConnectionOverride !== undefined) return [
                            2 /*return*/ ,
                            this.configConnectionOverride(connection)
                        ];
                        return [
                            4 /*yield*/ ,
                            this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize())
                        ];
                    case 2:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendPrePayloadJSON(connection, false)
                        ];
                    case 3:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            connection
                        ];
                }
            });
        });
    };
    ServiceRecognizerBase.telemetryDataEnabled = true;
    return ServiceRecognizerBase;
}();
exports.ServiceRecognizerBase = ServiceRecognizerBase;

},{"f2a77618249ca183":"9oZeQ","a01615f5c80e912":"5Bedw","1cdfd196bfa00773":"hxkc3","12bebb1752a95a9d":"7Qpvn","e81b581f6712575b":"euGGf"}],"euGGf":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechConnectionMessage = void 0;
var Exports_1 = require("910b59ae1fa9a200");
var HeaderNames_1 = require("5811216d3ffce3cd");
var SpeechConnectionMessage = /** @class */ function(_super) {
    __extends(SpeechConnectionMessage, _super);
    function SpeechConnectionMessage(messageType, path, requestId, contentType, body, streamId, additionalHeaders, id) {
        var _this = this;
        if (!path) throw new Exports_1.ArgumentNullError("path");
        if (!requestId) throw new Exports_1.ArgumentNullError("requestId");
        var headers = {};
        headers[HeaderNames_1.HeaderNames.Path] = path;
        headers[HeaderNames_1.HeaderNames.RequestId] = requestId;
        headers[HeaderNames_1.HeaderNames.RequestTimestamp] = new Date().toISOString();
        if (contentType) headers[HeaderNames_1.HeaderNames.ContentType] = contentType;
        if (streamId) headers[HeaderNames_1.HeaderNames.RequestStreamId] = streamId;
        if (additionalHeaders) {
            for(var headerName in additionalHeaders)if (headerName) headers[headerName] = additionalHeaders[headerName];
        }
        if (id) _this = _super.call(this, messageType, body, headers, id) || this;
        else _this = _super.call(this, messageType, body, headers) || this;
        _this.privPath = path;
        _this.privRequestId = requestId;
        _this.privContentType = contentType;
        _this.privStreamId = streamId;
        _this.privAdditionalHeaders = additionalHeaders;
        return _this;
    }
    Object.defineProperty(SpeechConnectionMessage.prototype, "path", {
        get: function() {
            return this.privPath;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConnectionMessage.prototype, "requestId", {
        get: function() {
            return this.privRequestId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConnectionMessage.prototype, "contentType", {
        get: function() {
            return this.privContentType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConnectionMessage.prototype, "streamId", {
        get: function() {
            return this.privStreamId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechConnectionMessage.prototype, "additionalHeaders", {
        get: function() {
            return this.privAdditionalHeaders;
        },
        enumerable: false,
        configurable: true
    });
    SpeechConnectionMessage.fromConnectionMessage = function(message) {
        var path = null;
        var requestId = null;
        var contentType = null;
        // let requestTimestamp = null;
        var streamId = null;
        var additionalHeaders = {};
        if (message.headers) {
            for(var headerName in message.headers)if (headerName) {
                if (headerName.toLowerCase() === HeaderNames_1.HeaderNames.Path.toLowerCase()) path = message.headers[headerName];
                else if (headerName.toLowerCase() === HeaderNames_1.HeaderNames.RequestId.toLowerCase()) requestId = message.headers[headerName];
                else if (headerName.toLowerCase() === HeaderNames_1.HeaderNames.ContentType.toLowerCase()) contentType = message.headers[headerName];
                else if (headerName.toLowerCase() === HeaderNames_1.HeaderNames.RequestStreamId.toLowerCase()) streamId = message.headers[headerName];
                else additionalHeaders[headerName] = message.headers[headerName];
            }
        }
        return new SpeechConnectionMessage(message.messageType, path, requestId, contentType, message.body, streamId, additionalHeaders, message.id);
    };
    return SpeechConnectionMessage;
}(Exports_1.ConnectionMessage);
exports.SpeechConnectionMessage = SpeechConnectionMessage;

},{"910b59ae1fa9a200":"5Bedw","5811216d3ffce3cd":"bNYHA"}],"bBuji":[function(require,module,exports) {
"use strict";
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationServiceRecognizer = void 0;
var Exports_1 = require("8ebc04abd160a762");
var Exports_2 = require("d75be7ca9b612c19");
var ConversationServiceRecognizer = /** @class */ function(_super) {
    __extends(ConversationServiceRecognizer, _super);
    function ConversationServiceRecognizer(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, recognizer) || this;
        _this.handleSpeechPhraseMessage = function(textBody) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    return [
                        2 /*return*/ ,
                        this.handleSpeechPhrase(textBody)
                    ];
                });
            });
        };
        _this.handleSpeechHypothesisMessage = function(textBody) {
            return _this.handleSpeechHypothesis(textBody);
        };
        return _this;
    }
    ConversationServiceRecognizer.prototype.processTypeSpecificMessages = function(connectionMessage) {
        return;
    };
    ConversationServiceRecognizer.prototype.handleRecognizedCallback = function(result, offset, sessionId) {
        return;
    };
    ConversationServiceRecognizer.prototype.handleRecognizingCallback = function(result, duration, sessionId) {
        return;
    };
    ConversationServiceRecognizer.prototype.processSpeechMessages = function(connectionMessage) {
        return __awaiter(this, void 0, void 0, function() {
            var processed, _a;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        processed = false;
                        _a = connectionMessage.path.toLowerCase();
                        switch(_a){
                            case "speech.hypothesis":
                                return [
                                    3 /*break*/ ,
                                    1
                                ];
                            case "speech.fragment":
                                return [
                                    3 /*break*/ ,
                                    1
                                ];
                            case "speech.phrase":
                                return [
                                    3 /*break*/ ,
                                    2
                                ];
                        }
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 1:
                        if (!!this.handleSpeechHypothesisMessage) this.handleSpeechHypothesisMessage(connectionMessage.textBody);
                        processed = true;
                        return [
                            3 /*break*/ ,
                            6
                        ];
                    case 2:
                        if (!!!this.handleSpeechPhraseMessage) return [
                            3 /*break*/ ,
                            4
                        ];
                        return [
                            4 /*yield*/ ,
                            this.handleSpeechPhraseMessage(connectionMessage.textBody)
                        ];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        processed = true;
                        return [
                            3 /*break*/ ,
                            6
                        ];
                    case 5:
                        return [
                            3 /*break*/ ,
                            6
                        ];
                    case 6:
                        return [
                            2 /*return*/ ,
                            processed
                        ];
                }
            });
        });
    };
    ConversationServiceRecognizer.prototype.cancelRecognition = function(sessionId, requestId, cancellationReason, errorCode, error) {};
    ConversationServiceRecognizer.prototype.handleSpeechPhrase = function(textBody) {
        return __awaiter(this, void 0, void 0, function() {
            var simple, resultReason, result, resultProps, simpleOffset, offset, cancelReason, cancellationErrorCode, detailed, totalOffset, offsetCorrectedJson;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        simple = Exports_2.SimpleSpeechPhrase.fromJSON(textBody);
                        resultReason = Exports_2.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);
                        resultProps = new Exports_1.PropertyCollection();
                        resultProps.setProperty(Exports_1.PropertyId.SpeechServiceResponse_JsonResult, textBody);
                        simpleOffset = simple.Offset + this.privRequestSession.currentTurnAudioOffset;
                        offset = simpleOffset;
                        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);
                        if (!(Exports_1.ResultReason.Canceled === resultReason)) return [
                            3 /*break*/ ,
                            2
                        ];
                        cancelReason = Exports_2.EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);
                        cancellationErrorCode = Exports_2.EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);
                        return [
                            4 /*yield*/ ,
                            this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_2.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode))
                        ];
                    case 1:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 2:
                        if (!(this.privRequestSession.isSpeechEnded && resultReason === Exports_1.ResultReason.NoMatch && simple.RecognitionStatus !== Exports_2.RecognitionStatus.InitialSilenceTimeout)) {
                            if (this.privRecognizerConfig.parameters.getProperty(Exports_2.OutputFormatPropertyName) === Exports_1.OutputFormat[Exports_1.OutputFormat.Simple]) result = new Exports_1.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simpleOffset, simple.Language, simple.LanguageDetectionConfidence, simple.SpeakerId, undefined, textBody, resultProps);
                            else {
                                detailed = Exports_2.DetailedSpeechPhrase.fromJSON(textBody);
                                totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;
                                offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);
                                result = new Exports_1.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, detailed.Text, detailed.Duration, totalOffset, detailed.Language, detailed.LanguageDetectionConfidence, detailed.SpeakerId, undefined, offsetCorrectedJson, resultProps);
                                offset = result.offset;
                            }
                            this.handleRecognizedCallback(result, offset, this.privRequestSession.sessionId);
                        }
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ConversationServiceRecognizer.prototype.handleSpeechHypothesis = function(textBody) {
        var hypothesis = Exports_2.SpeechHypothesis.fromJSON(textBody);
        var offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;
        var resultProps = new Exports_1.PropertyCollection();
        resultProps.setProperty(Exports_1.PropertyId.SpeechServiceResponse_JsonResult, textBody);
        var result = new Exports_1.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_1.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, hypothesis.SpeakerId, undefined, textBody, resultProps);
        this.privRequestSession.onHypothesis(offset);
        this.handleRecognizingCallback(result, hypothesis.Duration, this.privRequestSession.sessionId);
    };
    return ConversationServiceRecognizer;
}(Exports_2.ServiceRecognizerBase);
exports.ConversationServiceRecognizer = ConversationServiceRecognizer;

},{"8ebc04abd160a762":"hxkc3","d75be7ca9b612c19":"7Qpvn"}],"6oUM0":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.type = exports.connectivity = exports.Device = exports.OS = exports.System = exports.Context = exports.SpeechServiceConfig = exports.RecognizerConfig = exports.SpeechResultFormat = exports.RecognitionMode = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("a40bf06c4dff201");
var RecognitionMode;
(function(RecognitionMode) {
    RecognitionMode[RecognitionMode["Interactive"] = 0] = "Interactive";
    RecognitionMode[RecognitionMode["Conversation"] = 1] = "Conversation";
    RecognitionMode[RecognitionMode["Dictation"] = 2] = "Dictation";
})(RecognitionMode = exports.RecognitionMode || (exports.RecognitionMode = {}));
var SpeechResultFormat;
(function(SpeechResultFormat) {
    SpeechResultFormat[SpeechResultFormat["Simple"] = 0] = "Simple";
    SpeechResultFormat[SpeechResultFormat["Detailed"] = 1] = "Detailed";
})(SpeechResultFormat = exports.SpeechResultFormat || (exports.SpeechResultFormat = {}));
var RecognizerConfig = /** @class */ function() {
    function RecognizerConfig(speechServiceConfig, parameters) {
        this.privSpeechServiceConfig = speechServiceConfig ? speechServiceConfig : new SpeechServiceConfig(new Context(null));
        this.privParameters = parameters;
        this.privMaxRetryCount = parseInt(parameters.getProperty("SPEECH-Error-MaxRetryCount", "4"), 10);
        this.privLanguageIdMode = parameters.getProperty(Exports_1.PropertyId.SpeechServiceConnection_LanguageIdMode, undefined);
        this.privEnableSpeakerId = false;
    }
    Object.defineProperty(RecognizerConfig.prototype, "parameters", {
        get: function() {
            return this.privParameters;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognizerConfig.prototype, "recognitionMode", {
        get: function() {
            return this.privRecognitionMode;
        },
        set: function(value) {
            this.privRecognitionMode = value;
            this.privRecognitionActivityTimeout = value === RecognitionMode.Interactive ? 8000 : 25000;
            this.privSpeechServiceConfig.Recognition = RecognitionMode[value];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognizerConfig.prototype, "SpeechServiceConfig", {
        get: function() {
            return this.privSpeechServiceConfig;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognizerConfig.prototype, "recognitionActivityTimeout", {
        get: function() {
            return this.privRecognitionActivityTimeout;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognizerConfig.prototype, "isContinuousRecognition", {
        get: function() {
            return this.privRecognitionMode !== RecognitionMode.Interactive;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognizerConfig.prototype, "languageIdMode", {
        get: function() {
            return this.privLanguageIdMode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognizerConfig.prototype, "autoDetectSourceLanguages", {
        get: function() {
            return this.parameters.getProperty(Exports_1.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, undefined);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognizerConfig.prototype, "recognitionEndpointVersion", {
        get: function() {
            return this.parameters.getProperty(Exports_1.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, undefined);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognizerConfig.prototype, "sourceLanguageModels", {
        get: function() {
            var models = [];
            var modelsExist = false;
            if (this.autoDetectSourceLanguages !== undefined) for(var _i = 0, _a = this.autoDetectSourceLanguages.split(","); _i < _a.length; _i++){
                var language = _a[_i];
                var customProperty = language + Exports_1.PropertyId.SpeechServiceConnection_EndpointId.toString();
                var modelId = this.parameters.getProperty(customProperty, undefined);
                if (modelId !== undefined) {
                    models.push({
                        language: language,
                        endpoint: modelId
                    });
                    modelsExist = true;
                } else models.push({
                    language: language,
                    endpoint: ""
                });
            }
            return modelsExist ? models : undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognizerConfig.prototype, "maxRetryCount", {
        get: function() {
            return this.privMaxRetryCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RecognizerConfig.prototype, "isSpeakerDiarizationEnabled", {
        get: function() {
            return this.privEnableSpeakerId;
        },
        set: function(value) {
            this.privEnableSpeakerId = value;
        },
        enumerable: false,
        configurable: true
    });
    return RecognizerConfig;
}();
exports.RecognizerConfig = RecognizerConfig;
// The config is serialized and sent as the Speech.Config
var SpeechServiceConfig = /** @class */ function() {
    function SpeechServiceConfig(context) {
        this.context = context;
    }
    SpeechServiceConfig.prototype.serialize = function() {
        return JSON.stringify(this, function(key, value) {
            if (value && typeof value === "object") {
                var replacement = {};
                for(var k in value)if (Object.hasOwnProperty.call(value, k)) // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                replacement[k && k.charAt(0).toLowerCase() + k.substring(1)] = value[k];
                return replacement;
            }
            return value;
        });
    };
    Object.defineProperty(SpeechServiceConfig.prototype, "Context", {
        get: function() {
            return this.context;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechServiceConfig.prototype, "Recognition", {
        get: function() {
            return this.recognition;
        },
        set: function(value) {
            this.recognition = value.toLowerCase();
        },
        enumerable: false,
        configurable: true
    });
    return SpeechServiceConfig;
}();
exports.SpeechServiceConfig = SpeechServiceConfig;
var Context = /** @class */ function() {
    function Context(os) {
        this.system = new System();
        this.os = os;
    }
    return Context;
}();
exports.Context = Context;
var System = /** @class */ function() {
    function System() {
        // Note: below will be patched for official builds.
        var SPEECHSDK_CLIENTSDK_VERSION = "1.31.0";
        this.name = "SpeechSDK";
        this.version = SPEECHSDK_CLIENTSDK_VERSION;
        this.build = "JavaScript";
        this.lang = "JavaScript";
    }
    return System;
}();
exports.System = System;
var OS = /** @class */ function() {
    function OS(platform, name, version) {
        this.platform = platform;
        this.name = name;
        this.version = version;
    }
    return OS;
}();
exports.OS = OS;
var Device = /** @class */ function() {
    function Device(manufacturer, model, version) {
        this.manufacturer = manufacturer;
        this.model = model;
        this.version = version;
    }
    return Device;
}();
exports.Device = Device;
var connectivity;
(function(connectivity) {
    connectivity["Bluetooth"] = "Bluetooth";
    connectivity["Wired"] = "Wired";
    connectivity["WiFi"] = "WiFi";
    connectivity["Cellular"] = "Cellular";
    connectivity["InBuilt"] = "InBuilt";
    connectivity["Unknown"] = "Unknown";
})(connectivity = exports.connectivity || (exports.connectivity = {}));
var type;
(function(type) {
    type["Phone"] = "Phone";
    type["Speaker"] = "Speaker";
    type["Car"] = "Car";
    type["Headset"] = "Headset";
    type["Thermostat"] = "Thermostat";
    type["Microphones"] = "Microphones";
    type["Deskphone"] = "Deskphone";
    type["RemoteControl"] = "RemoteControl";
    type["Unknown"] = "Unknown";
    type["File"] = "File";
    type["Stream"] = "Stream";
})(type = exports.type || (exports.type = {}));

},{"a40bf06c4dff201":"hxkc3"}],"i2u5g":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"d1suG":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebsocketMessageFormatter = void 0;
var Exports_1 = require("900e8a2f5ab2588e");
var CRLF = "\r\n";
var WebsocketMessageFormatter = /** @class */ function() {
    function WebsocketMessageFormatter() {}
    WebsocketMessageFormatter.prototype.toConnectionMessage = function(message) {
        var deferral = new Exports_1.Deferred();
        try {
            if (message.messageType === Exports_1.MessageType.Text) {
                var textMessage = message.textContent;
                var headers = {};
                var body = null;
                if (textMessage) {
                    var headerBodySplit = textMessage.split("\r\n\r\n");
                    if (headerBodySplit && headerBodySplit.length > 0) {
                        headers = this.parseHeaders(headerBodySplit[0]);
                        if (headerBodySplit.length > 1) body = headerBodySplit[1];
                    }
                }
                deferral.resolve(new Exports_1.ConnectionMessage(message.messageType, body, headers, message.id));
            } else if (message.messageType === Exports_1.MessageType.Binary) {
                var binaryMessage = message.binaryContent;
                var headers = {};
                var body = null;
                if (!binaryMessage || binaryMessage.byteLength < 2) throw new Error("Invalid binary message format. Header length missing.");
                var dataView = new DataView(binaryMessage);
                var headerLength = dataView.getInt16(0);
                if (binaryMessage.byteLength < headerLength + 2) throw new Error("Invalid binary message format. Header content missing.");
                var headersString = "";
                for(var i = 0; i < headerLength; i++)headersString += String.fromCharCode(dataView.getInt8(i + 2));
                headers = this.parseHeaders(headersString);
                if (binaryMessage.byteLength > headerLength + 2) body = binaryMessage.slice(2 + headerLength);
                deferral.resolve(new Exports_1.ConnectionMessage(message.messageType, body, headers, message.id));
            }
        } catch (e) {
            deferral.reject("Error formatting the message. Error: " + e);
        }
        return deferral.promise;
    };
    WebsocketMessageFormatter.prototype.fromConnectionMessage = function(message) {
        var deferral = new Exports_1.Deferred();
        try {
            if (message.messageType === Exports_1.MessageType.Text) {
                var payload = "" + this.makeHeaders(message) + CRLF + (message.textBody ? message.textBody : "");
                deferral.resolve(new Exports_1.RawWebsocketMessage(Exports_1.MessageType.Text, payload, message.id));
            } else if (message.messageType === Exports_1.MessageType.Binary) {
                var headersString = this.makeHeaders(message);
                var content = message.binaryBody;
                var headerBuffer = this.stringToArrayBuffer(headersString);
                var headerInt8Array = new Int8Array(headerBuffer);
                var headerLength = headerInt8Array.byteLength;
                var payloadInt8Array = new Int8Array(2 + headerLength + (content ? content.byteLength : 0));
                payloadInt8Array[0] = headerLength >> 8 & 0xff;
                payloadInt8Array[1] = headerLength & 0xff;
                payloadInt8Array.set(headerInt8Array, 2);
                if (content) {
                    var bodyInt8Array = new Int8Array(content);
                    payloadInt8Array.set(bodyInt8Array, 2 + headerLength);
                }
                var payload = payloadInt8Array.buffer;
                deferral.resolve(new Exports_1.RawWebsocketMessage(Exports_1.MessageType.Binary, payload, message.id));
            }
        } catch (e) {
            deferral.reject("Error formatting the message. " + e);
        }
        return deferral.promise;
    };
    WebsocketMessageFormatter.prototype.makeHeaders = function(message) {
        var headersString = "";
        if (message.headers) {
            for(var header in message.headers)if (header) headersString += header + ": " + message.headers[header] + CRLF;
        }
        return headersString;
    };
    WebsocketMessageFormatter.prototype.parseHeaders = function(headersString) {
        var headers = {};
        if (headersString) {
            var headerMatches = headersString.match(/[^\r\n]+/g);
            if (headers) for(var _i = 0, headerMatches_1 = headerMatches; _i < headerMatches_1.length; _i++){
                var header = headerMatches_1[_i];
                if (header) {
                    var separatorIndex = header.indexOf(":");
                    var headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;
                    var headerValue = separatorIndex > 0 && header.length > separatorIndex + 1 ? header.substr(separatorIndex + 1).trim() : "";
                    headers[headerName] = headerValue;
                }
            }
        }
        return headers;
    };
    WebsocketMessageFormatter.prototype.stringToArrayBuffer = function(str) {
        var buffer = new ArrayBuffer(str.length);
        var view = new DataView(buffer);
        for(var i = 0; i < str.length; i++)view.setUint8(i, str.charCodeAt(i));
        return buffer;
    };
    return WebsocketMessageFormatter;
}();
exports.WebsocketMessageFormatter = WebsocketMessageFormatter;

},{"900e8a2f5ab2588e":"5Bedw"}],"879mH":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechConnectionFactory = void 0;
var Exports_1 = require("fc3457902e3927ec");
var Exports_2 = require("6159fb5e23c61464");
var Exports_3 = require("6cf66a99d5547bb5");
var ConnectionFactoryBase_1 = require("8e306f6660cd0920");
var Exports_4 = require("fea78a070ddb771d");
var HeaderNames_1 = require("283a4b628327a406");
var QueryParameterNames_1 = require("1adf20432b5c3a0d");
var SpeechConnectionFactory = /** @class */ function(_super) {
    __extends(SpeechConnectionFactory, _super);
    function SpeechConnectionFactory() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.interactiveRelativeUri = "/speech/recognition/interactive/cognitiveservices/v1";
        _this.conversationRelativeUri = "/speech/recognition/conversation/cognitiveservices/v1";
        _this.dictationRelativeUri = "/speech/recognition/dictation/cognitiveservices/v1";
        _this.universalUri = "/speech/universal/v";
        return _this;
    }
    SpeechConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        var endpoint = config.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Endpoint, undefined);
        var region = config.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Region, undefined);
        var hostSuffix = ConnectionFactoryBase_1.ConnectionFactoryBase.getHostSuffix(region);
        var host = config.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".stt.speech" + hostSuffix);
        var queryParams = {};
        var endpointId = config.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_EndpointId, undefined);
        var language = config.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage, undefined);
        if (endpointId) {
            if (!endpoint || endpoint.search(QueryParameterNames_1.QueryParameterNames.CustomSpeechDeploymentId) === -1) queryParams[QueryParameterNames_1.QueryParameterNames.CustomSpeechDeploymentId] = endpointId;
        } else if (language) {
            if (!endpoint || endpoint.search(QueryParameterNames_1.QueryParameterNames.Language) === -1) queryParams[QueryParameterNames_1.QueryParameterNames.Language] = language;
        }
        if (!endpoint || endpoint.search(QueryParameterNames_1.QueryParameterNames.Format) === -1) queryParams[QueryParameterNames_1.QueryParameterNames.Format] = config.parameters.getProperty(Exports_2.OutputFormatPropertyName, Exports_3.OutputFormat[Exports_3.OutputFormat.Simple]).toLowerCase();
        if (config.autoDetectSourceLanguages !== undefined) queryParams[QueryParameterNames_1.QueryParameterNames.EnableLanguageId] = "true";
        this.setCommonUrlParams(config, queryParams, endpoint);
        if (!endpoint) switch(config.recognitionMode){
            case Exports_4.RecognitionMode.Conversation:
                if (config.parameters.getProperty(Exports_2.ForceDictationPropertyName, "false") === "true") endpoint = host + this.dictationRelativeUri;
                else if (config.recognitionEndpointVersion !== undefined && parseInt(config.recognitionEndpointVersion, 10) > 1) endpoint = "" + host + this.universalUri + config.recognitionEndpointVersion;
                else endpoint = host + this.conversationRelativeUri;
                break;
            case Exports_4.RecognitionMode.Dictation:
                endpoint = host + this.dictationRelativeUri;
                break;
            default:
                if (config.recognitionEndpointVersion !== undefined && parseInt(config.recognitionEndpointVersion, 10) > 1) endpoint = "" + host + this.universalUri + config.recognitionEndpointVersion;
                else endpoint = host + this.interactiveRelativeUri; // default is interactive
                break;
        }
        var headers = {};
        if (authInfo.token !== undefined && authInfo.token !== "") headers[authInfo.headerName] = authInfo.token;
        headers[HeaderNames_1.HeaderNames.ConnectionId] = connectionId;
        var enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
        var webSocketConnection = new Exports_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_4.WebsocketMessageFormatter(), Exports_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
        // Set the value of SpeechServiceConnection_Url to webSocketConnection.uri (and not to `endpoint`), since this value is the final
        // URI that was used to make the connection (including query parameters).
        var uri = webSocketConnection.uri;
        config.parameters.setProperty(Exports_3.PropertyId.SpeechServiceConnection_Url, uri);
        return webSocketConnection;
    };
    return SpeechConnectionFactory;
}(ConnectionFactoryBase_1.ConnectionFactoryBase);
exports.SpeechConnectionFactory = SpeechConnectionFactory;

},{"fc3457902e3927ec":"9oZeQ","6159fb5e23c61464":"7Qpvn","6cf66a99d5547bb5":"hxkc3","8e306f6660cd0920":"hvoIt","fea78a070ddb771d":"7Qpvn","283a4b628327a406":"bNYHA","1adf20432b5c3a0d":"fLrjT"}],"iBtpn":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranscriberConnectionFactory = void 0;
var Exports_1 = require("a6bb668e1fb622d1");
var Exports_2 = require("3816440cecd05b0c");
var Exports_3 = require("b2949562ab84b420");
var ConnectionFactoryBase_1 = require("fb73c5064a049408");
var Exports_4 = require("47130f867f354bd0");
var HeaderNames_1 = require("d1baa7f0cfeb463f");
var QueryParameterNames_1 = require("dc481ad05e470fe5");
var ConversationTranscriberConnectionFactory = /** @class */ function(_super) {
    __extends(ConversationTranscriberConnectionFactory, _super);
    function ConversationTranscriberConnectionFactory() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.universalUri = "/speech/universal/v2";
        return _this;
    }
    ConversationTranscriberConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        var endpoint = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint, undefined);
        var region = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Region, undefined);
        var hostSuffix = ConnectionFactoryBase_1.ConnectionFactoryBase.getHostSuffix(region);
        var host = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".stt.speech" + hostSuffix);
        var queryParams = {};
        var endpointId = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_EndpointId, undefined);
        var language = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage, undefined);
        if (endpointId) {
            if (!endpoint || endpoint.search(QueryParameterNames_1.QueryParameterNames.CustomSpeechDeploymentId) === -1) queryParams[QueryParameterNames_1.QueryParameterNames.CustomSpeechDeploymentId] = endpointId;
        } else if (language) {
            if (!endpoint || endpoint.search(QueryParameterNames_1.QueryParameterNames.Language) === -1) queryParams[QueryParameterNames_1.QueryParameterNames.Language] = language;
        }
        if (config.autoDetectSourceLanguages !== undefined) queryParams[QueryParameterNames_1.QueryParameterNames.EnableLanguageId] = "true";
        this.setV2UrlParams(config, queryParams, endpoint);
        if (!endpoint) endpoint = "" + host + this.universalUri;
        var headers = {};
        if (authInfo.token !== undefined && authInfo.token !== "") headers[authInfo.headerName] = authInfo.token;
        headers[HeaderNames_1.HeaderNames.ConnectionId] = connectionId;
        var enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
        var webSocketConnection = new Exports_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_4.WebsocketMessageFormatter(), Exports_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
        // Set the value of SpeechServiceConnection_Url to webSocketConnection.uri (and not to `endpoint`), since this value is the final
        // URI that was used to make the connection (including query parameters).
        var uri = webSocketConnection.uri;
        config.parameters.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Url, uri);
        return webSocketConnection;
    };
    ConversationTranscriberConnectionFactory.prototype.setV2UrlParams = function(config, queryParams, endpoint) {
        var _this = this;
        var propertyIdToParameterMap = new Map([
            [
                Exports_2.PropertyId.Speech_SegmentationSilenceTimeoutMs,
                QueryParameterNames_1.QueryParameterNames.SegmentationSilenceTimeoutMs
            ],
            [
                Exports_2.PropertyId.SpeechServiceConnection_EnableAudioLogging,
                QueryParameterNames_1.QueryParameterNames.EnableAudioLogging
            ],
            [
                Exports_2.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs,
                QueryParameterNames_1.QueryParameterNames.EndSilenceTimeoutMs
            ],
            [
                Exports_2.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs,
                QueryParameterNames_1.QueryParameterNames.InitialSilenceTimeoutMs
            ],
            [
                Exports_2.PropertyId.SpeechServiceResponse_PostProcessingOption,
                QueryParameterNames_1.QueryParameterNames.Postprocessing
            ],
            [
                Exports_2.PropertyId.SpeechServiceResponse_ProfanityOption,
                QueryParameterNames_1.QueryParameterNames.Profanity
            ],
            [
                Exports_2.PropertyId.SpeechServiceResponse_StablePartialResultThreshold,
                QueryParameterNames_1.QueryParameterNames.StableIntermediateThreshold
            ]
        ]);
        propertyIdToParameterMap.forEach(function(parameterName, propertyId) {
            _this.setUrlParameter(propertyId, parameterName, config, queryParams, endpoint);
        });
        var serviceProperties = JSON.parse(config.parameters.getProperty(Exports_3.ServicePropertiesPropertyName, "{}"));
        Object.keys(serviceProperties).forEach(function(value) {
            queryParams[value] = serviceProperties[value];
        });
    };
    return ConversationTranscriberConnectionFactory;
}(ConnectionFactoryBase_1.ConnectionFactoryBase);
exports.ConversationTranscriberConnectionFactory = ConversationTranscriberConnectionFactory;

},{"a6bb668e1fb622d1":"9oZeQ","3816440cecd05b0c":"hxkc3","b2949562ab84b420":"7Qpvn","fb73c5064a049408":"hvoIt","47130f867f354bd0":"7Qpvn","d1baa7f0cfeb463f":"bNYHA","dc481ad05e470fe5":"fLrjT"}],"4oKER":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranscriberConnectionFactory = void 0;
var Exports_1 = require("b36edf9d7b6ea70");
var Exports_2 = require("ee829d6607ca1005");
var ConnectionFactoryBase_1 = require("42a9a23b109a1ddd");
var Exports_3 = require("46ab6f42587a7c10");
var HeaderNames_1 = require("fe95dc74cbb05552");
var QueryParameterNames_1 = require("46963f7687dc34d7");
var TranscriberConnectionFactory = /** @class */ function(_super) {
    __extends(TranscriberConnectionFactory, _super);
    function TranscriberConnectionFactory() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.multiaudioRelativeUri = "/speech/recognition/multiaudio";
        return _this;
    }
    TranscriberConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        var endpoint = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint, undefined);
        var region = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Region, "centralus");
        var hostSuffix = ConnectionFactoryBase_1.ConnectionFactoryBase.getHostSuffix(region);
        var hostDefault = "wss://transcribe." + region + ".cts.speech" + hostSuffix + this.multiaudioRelativeUri;
        var host = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, hostDefault);
        var queryParams = {};
        this.setQueryParams(queryParams, config, endpoint);
        if (!endpoint) endpoint = host;
        var headers = {};
        if (authInfo.token !== undefined && authInfo.token !== "") headers[authInfo.headerName] = authInfo.token;
        headers[HeaderNames_1.HeaderNames.ConnectionId] = connectionId;
        config.parameters.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Url, endpoint);
        var enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
        return new Exports_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_3.WebsocketMessageFormatter(), Exports_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    };
    TranscriberConnectionFactory.prototype.setQueryParams = function(queryParams, config, endpointUrl) {
        var endpointId = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_EndpointId, undefined);
        var language = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage, undefined);
        if (endpointId && !(QueryParameterNames_1.QueryParameterNames.CustomSpeechDeploymentId in queryParams)) queryParams[QueryParameterNames_1.QueryParameterNames.CustomSpeechDeploymentId] = endpointId;
        if (language && !(QueryParameterNames_1.QueryParameterNames.Language in queryParams)) queryParams[QueryParameterNames_1.QueryParameterNames.Language] = language;
        var wordLevelTimings = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true";
        var detailed = config.parameters.getProperty(Exports_3.OutputFormatPropertyName, Exports_2.OutputFormat[Exports_2.OutputFormat.Simple]) !== Exports_2.OutputFormat[Exports_2.OutputFormat.Simple];
        if (wordLevelTimings || detailed) queryParams[QueryParameterNames_1.QueryParameterNames.Format] = Exports_2.OutputFormat[Exports_2.OutputFormat.Detailed].toLowerCase();
        this.setCommonUrlParams(config, queryParams, endpointUrl);
    };
    return TranscriberConnectionFactory;
}(ConnectionFactoryBase_1.ConnectionFactoryBase);
exports.TranscriberConnectionFactory = TranscriberConnectionFactory;

},{"b36edf9d7b6ea70":"9oZeQ","ee829d6607ca1005":"hxkc3","42a9a23b109a1ddd":"hvoIt","46ab6f42587a7c10":"7Qpvn","fe95dc74cbb05552":"bNYHA","46963f7687dc34d7":"fLrjT"}],"kFQr4":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationConnectionFactory = void 0;
var Exports_1 = require("cddd700fadcb89d2");
var StringUtils_1 = require("519659f9ab329d0e");
var Exports_2 = require("2af6e305ff5474e8");
var ConnectionFactoryBase_1 = require("e0ed8c74e0b4ded");
var Exports_3 = require("70080a08101ec1b6");
var HeaderNames_1 = require("38699904b06e43dc");
var QueryParameterNames_1 = require("898989a35f7f6f39");
var TranslationConnectionFactory = /** @class */ function(_super) {
    __extends(TranslationConnectionFactory, _super);
    function TranslationConnectionFactory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TranslationConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        var endpoint = this.getEndpointUrl(config);
        var queryParams = {};
        if (config.autoDetectSourceLanguages !== undefined) queryParams[QueryParameterNames_1.QueryParameterNames.EnableLanguageId] = "true";
        this.setQueryParams(queryParams, config, endpoint);
        var headers = {};
        if (authInfo.token !== undefined && authInfo.token !== "") headers[authInfo.headerName] = authInfo.token;
        headers[HeaderNames_1.HeaderNames.ConnectionId] = connectionId;
        config.parameters.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Url, endpoint);
        var enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
        return new Exports_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_3.WebsocketMessageFormatter(), Exports_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    };
    TranslationConnectionFactory.prototype.getEndpointUrl = function(config, returnRegionPlaceholder) {
        var region = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Region);
        var hostSuffix = ConnectionFactoryBase_1.ConnectionFactoryBase.getHostSuffix(region);
        var endpointUrl = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint, undefined);
        if (!endpointUrl) {
            if (config.autoDetectSourceLanguages !== undefined) {
                var host = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, "wss://{region}.stt.speech" + hostSuffix);
                endpointUrl = host + "/speech/universal/v2";
            } else {
                var host = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, "wss://{region}.s2s.speech" + hostSuffix);
                endpointUrl = host + "/speech/translation/cognitiveservices/v1";
            }
        }
        if (returnRegionPlaceholder === true) return endpointUrl;
        return StringUtils_1.StringUtils.formatString(endpointUrl, {
            region: region
        });
    };
    TranslationConnectionFactory.prototype.setQueryParams = function(queryParams, config, endpointUrl) {
        queryParams.from = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage);
        queryParams.to = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_TranslationToLanguages);
        this.setCommonUrlParams(config, queryParams, endpointUrl);
        this.setUrlParameter(Exports_2.PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult, QueryParameterNames_1.QueryParameterNames.StableTranslation, config, queryParams, endpointUrl);
        var translationVoice = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_TranslationVoice, undefined);
        if (translationVoice !== undefined) {
            queryParams.voice = translationVoice;
            queryParams.features = "texttospeech";
        }
    };
    return TranslationConnectionFactory;
}(ConnectionFactoryBase_1.ConnectionFactoryBase);
exports.TranslationConnectionFactory = TranslationConnectionFactory;

},{"cddd700fadcb89d2":"9oZeQ","519659f9ab329d0e":"2xnkU","2af6e305ff5474e8":"hxkc3","e0ed8c74e0b4ded":"hvoIt","70080a08101ec1b6":"7Qpvn","38699904b06e43dc":"bNYHA","898989a35f7f6f39":"fLrjT"}],"7TCCI":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechSynthesisConnectionFactory = void 0;
var Exports_1 = require("6e4312da94950ef2");
var Exports_2 = require("af8e638928549391");
var ConnectionFactoryBase_1 = require("b9f016e5c8cdc492");
var Exports_3 = require("4ba1e4190a86c3ee");
var HeaderNames_1 = require("abba58e5910665d5");
var QueryParameterNames_1 = require("a0211d3a9c5e03a7");
var SpeechSynthesisConnectionFactory = /** @class */ function() {
    function SpeechSynthesisConnectionFactory() {
        this.synthesisUri = "/cognitiveservices/websocket/v1";
    }
    SpeechSynthesisConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        var endpoint = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint, undefined);
        var region = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Region, undefined);
        var hostSuffix = ConnectionFactoryBase_1.ConnectionFactoryBase.getHostSuffix(region);
        var endpointId = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_EndpointId, undefined);
        var hostPrefix = endpointId === undefined ? "tts" : "voice";
        var host = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, "wss://" + region + "." + hostPrefix + ".speech" + hostSuffix);
        var queryParams = {};
        if (!endpoint) endpoint = host + this.synthesisUri;
        var headers = {};
        if (authInfo.token !== undefined && authInfo.token !== "") headers[authInfo.headerName] = authInfo.token;
        headers[HeaderNames_1.HeaderNames.ConnectionId] = connectionId;
        if (endpointId !== undefined) headers[QueryParameterNames_1.QueryParameterNames.CustomVoiceDeploymentId] = endpointId;
        config.parameters.setProperty(Exports_2.PropertyId.SpeechServiceConnection_Url, endpoint);
        var enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
        return new Exports_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_3.WebsocketMessageFormatter(), Exports_1.ProxyInfo.fromParameters(config.parameters), enableCompression, connectionId);
    };
    return SpeechSynthesisConnectionFactory;
}();
exports.SpeechSynthesisConnectionFactory = SpeechSynthesisConnectionFactory;

},{"6e4312da94950ef2":"9oZeQ","af8e638928549391":"hxkc3","b9f016e5c8cdc492":"hvoIt","4ba1e4190a86c3ee":"7Qpvn","abba58e5910665d5":"bNYHA","a0211d3a9c5e03a7":"fLrjT"}],"2Rx5K":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EnumTranslation = void 0;
var Exports_1 = require("4ca24c2d37a08178");
var Exports_2 = require("5315e4fad64164f3");
var EnumTranslation = /** @class */ function() {
    function EnumTranslation() {}
    EnumTranslation.implTranslateRecognitionResult = function(recognitionStatus) {
        var reason = Exports_1.ResultReason.Canceled;
        switch(recognitionStatus){
            case Exports_2.RecognitionStatus.Success:
                reason = Exports_1.ResultReason.RecognizedSpeech;
                break;
            case Exports_2.RecognitionStatus.NoMatch:
            case Exports_2.RecognitionStatus.InitialSilenceTimeout:
            case Exports_2.RecognitionStatus.BabbleTimeout:
            case Exports_2.RecognitionStatus.EndOfDictation:
                reason = Exports_1.ResultReason.NoMatch;
                break;
            case Exports_2.RecognitionStatus.Error:
            case Exports_2.RecognitionStatus.BadRequest:
            case Exports_2.RecognitionStatus.Forbidden:
            default:
                reason = Exports_1.ResultReason.Canceled;
                break;
        }
        return reason;
    };
    EnumTranslation.implTranslateCancelResult = function(recognitionStatus) {
        var reason = Exports_1.CancellationReason.EndOfStream;
        switch(recognitionStatus){
            case Exports_2.RecognitionStatus.Success:
            case Exports_2.RecognitionStatus.EndOfDictation:
            case Exports_2.RecognitionStatus.NoMatch:
                reason = Exports_1.CancellationReason.EndOfStream;
                break;
            case Exports_2.RecognitionStatus.InitialSilenceTimeout:
            case Exports_2.RecognitionStatus.BabbleTimeout:
            case Exports_2.RecognitionStatus.Error:
            case Exports_2.RecognitionStatus.BadRequest:
            case Exports_2.RecognitionStatus.Forbidden:
            default:
                reason = Exports_1.CancellationReason.Error;
                break;
        }
        return reason;
    };
    EnumTranslation.implTranslateCancelErrorCode = function(recognitionStatus) {
        var reason = Exports_1.CancellationErrorCode.NoError;
        switch(recognitionStatus){
            case Exports_2.RecognitionStatus.Error:
                reason = Exports_1.CancellationErrorCode.ServiceError;
                break;
            case Exports_2.RecognitionStatus.TooManyRequests:
                reason = Exports_1.CancellationErrorCode.TooManyRequests;
                break;
            case Exports_2.RecognitionStatus.BadRequest:
                reason = Exports_1.CancellationErrorCode.BadRequestParameters;
                break;
            case Exports_2.RecognitionStatus.Forbidden:
                reason = Exports_1.CancellationErrorCode.Forbidden;
                break;
            default:
                reason = Exports_1.CancellationErrorCode.NoError;
                break;
        }
        return reason;
    };
    EnumTranslation.implTranslateErrorDetails = function(cancellationErrorCode) {
        var errorDetails = "The speech service encountered an internal error and could not continue.";
        switch(cancellationErrorCode){
            case Exports_1.CancellationErrorCode.Forbidden:
                errorDetails = "The recognizer is using a free subscription that ran out of quota.";
                break;
            case Exports_1.CancellationErrorCode.BadRequestParameters:
                errorDetails = "Invalid parameter or unsupported audio format in the request.";
                break;
            case Exports_1.CancellationErrorCode.TooManyRequests:
                errorDetails = "The number of parallel requests exceeded the number of allowed concurrent transcriptions.";
                break;
            default:
                break;
        }
        return errorDetails;
    };
    return EnumTranslation;
}();
exports.EnumTranslation = EnumTranslation;

},{"4ca24c2d37a08178":"hxkc3","5315e4fad64164f3":"7Qpvn"}],"4ei81":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecognitionStatus = exports.SynthesisStatus = void 0;
/**
 * @class SynthesisStatus
 * @private
 */ var SynthesisStatus;
(function(SynthesisStatus) {
    /**
     * The response contains valid audio data.
     * @member SynthesisStatus.Success
     */ SynthesisStatus[SynthesisStatus["Success"] = 0] = "Success";
    /**
     * Indicates the end of audio data. No valid audio data is included in the message.
     * @member SynthesisStatus.SynthesisEnd
     */ SynthesisStatus[SynthesisStatus["SynthesisEnd"] = 1] = "SynthesisEnd";
    /**
     * Indicates an error occurred during synthesis data processing.
     * @member SynthesisStatus.Error
     */ SynthesisStatus[SynthesisStatus["Error"] = 2] = "Error";
})(SynthesisStatus = exports.SynthesisStatus || (exports.SynthesisStatus = {}));
var RecognitionStatus;
(function(RecognitionStatus) {
    RecognitionStatus[RecognitionStatus["Success"] = 0] = "Success";
    RecognitionStatus[RecognitionStatus["NoMatch"] = 1] = "NoMatch";
    RecognitionStatus[RecognitionStatus["InitialSilenceTimeout"] = 2] = "InitialSilenceTimeout";
    RecognitionStatus[RecognitionStatus["BabbleTimeout"] = 3] = "BabbleTimeout";
    RecognitionStatus[RecognitionStatus["Error"] = 4] = "Error";
    RecognitionStatus[RecognitionStatus["EndOfDictation"] = 5] = "EndOfDictation";
    RecognitionStatus[RecognitionStatus["TooManyRequests"] = 6] = "TooManyRequests";
    RecognitionStatus[RecognitionStatus["BadRequest"] = 7] = "BadRequest";
    RecognitionStatus[RecognitionStatus["Forbidden"] = 8] = "Forbidden";
})(RecognitionStatus = exports.RecognitionStatus || (exports.RecognitionStatus = {}));

},{}],"2lckn":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationSynthesisEnd = void 0;
var Exports_1 = require("6cdd5773bbb12428");
var TranslationSynthesisEnd = /** @class */ function() {
    function TranslationSynthesisEnd(json) {
        this.privSynthesisEnd = JSON.parse(json);
        if (!!this.privSynthesisEnd.SynthesisStatus) this.privSynthesisEnd.SynthesisStatus = Exports_1.SynthesisStatus[this.privSynthesisEnd.SynthesisStatus];
        if (!!this.privSynthesisEnd.Status) this.privSynthesisEnd.SynthesisStatus = Exports_1.SynthesisStatus[this.privSynthesisEnd.Status];
    }
    TranslationSynthesisEnd.fromJSON = function(json) {
        return new TranslationSynthesisEnd(json);
    };
    Object.defineProperty(TranslationSynthesisEnd.prototype, "SynthesisStatus", {
        get: function() {
            return this.privSynthesisEnd.SynthesisStatus;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationSynthesisEnd.prototype, "FailureReason", {
        get: function() {
            return this.privSynthesisEnd.FailureReason;
        },
        enumerable: false,
        configurable: true
    });
    return TranslationSynthesisEnd;
}();
exports.TranslationSynthesisEnd = TranslationSynthesisEnd;

},{"6cdd5773bbb12428":"7Qpvn"}],"4FONh":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationHypothesis = void 0;
var TranslationStatus_1 = require("59cbaf6f5a7f2679");
var TranslationHypothesis = /** @class */ function() {
    function TranslationHypothesis(json) {
        this.privTranslationHypothesis = JSON.parse(json);
        this.privTranslationHypothesis.Translation.TranslationStatus = TranslationStatus_1.TranslationStatus[this.privTranslationHypothesis.Translation.TranslationStatus];
    }
    TranslationHypothesis.fromJSON = function(json) {
        return new TranslationHypothesis(json);
    };
    Object.defineProperty(TranslationHypothesis.prototype, "Duration", {
        get: function() {
            return this.privTranslationHypothesis.Duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationHypothesis.prototype, "Offset", {
        get: function() {
            return this.privTranslationHypothesis.Offset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationHypothesis.prototype, "Text", {
        get: function() {
            return this.privTranslationHypothesis.Text;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationHypothesis.prototype, "Translation", {
        get: function() {
            return this.privTranslationHypothesis.Translation;
        },
        enumerable: false,
        configurable: true
    });
    return TranslationHypothesis;
}();
exports.TranslationHypothesis = TranslationHypothesis;

},{"59cbaf6f5a7f2679":"kKQWF"}],"fJFN0":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationPhrase = void 0;
var Contracts_1 = require("7a3c465cf3eec2ef");
var Exports_1 = require("a3cf4b309f2407ae");
var TranslationStatus_1 = require("330dbc2c47ab7ff8");
var TranslationPhrase = /** @class */ function() {
    function TranslationPhrase(phrase) {
        this.privTranslationPhrase = phrase;
        this.privTranslationPhrase.RecognitionStatus = Exports_1.RecognitionStatus[this.privTranslationPhrase.RecognitionStatus];
        if (this.privTranslationPhrase.Translation !== undefined) this.privTranslationPhrase.Translation.TranslationStatus = TranslationStatus_1.TranslationStatus[this.privTranslationPhrase.Translation.TranslationStatus];
    }
    TranslationPhrase.fromJSON = function(json) {
        return new TranslationPhrase(JSON.parse(json));
    };
    TranslationPhrase.fromTranslationResponse = function(translationResponse) {
        Contracts_1.Contracts.throwIfNullOrUndefined(translationResponse, "translationResponse");
        var phrase = translationResponse.SpeechPhrase;
        translationResponse.SpeechPhrase = undefined;
        phrase.Translation = translationResponse;
        phrase.Text = phrase.DisplayText;
        return new TranslationPhrase(phrase);
    };
    Object.defineProperty(TranslationPhrase.prototype, "RecognitionStatus", {
        get: function() {
            return this.privTranslationPhrase.RecognitionStatus;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationPhrase.prototype, "Offset", {
        get: function() {
            return this.privTranslationPhrase.Offset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationPhrase.prototype, "Duration", {
        get: function() {
            return this.privTranslationPhrase.Duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationPhrase.prototype, "Text", {
        get: function() {
            return this.privTranslationPhrase.Text;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationPhrase.prototype, "Language", {
        get: function() {
            var _a;
            return (_a = this.privTranslationPhrase.PrimaryLanguage) === null || _a === void 0 ? void 0 : _a.Language;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationPhrase.prototype, "Confidence", {
        get: function() {
            var _a;
            return (_a = this.privTranslationPhrase.PrimaryLanguage) === null || _a === void 0 ? void 0 : _a.Confidence;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranslationPhrase.prototype, "Translation", {
        get: function() {
            return this.privTranslationPhrase.Translation;
        },
        enumerable: false,
        configurable: true
    });
    return TranslationPhrase;
}();
exports.TranslationPhrase = TranslationPhrase;

},{"7a3c465cf3eec2ef":"4jwu5","a3cf4b309f2407ae":"7Qpvn","330dbc2c47ab7ff8":"kKQWF"}],"hRB6D":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranslationServiceRecognizer = void 0;
var Exports_1 = require("d237539cc082a750");
var Exports_2 = require("320fcb0f5f76fbbd");
var Exports_3 = require("f84df7ef48eccf46");
// eslint-disable-next-line max-classes-per-file
var TranslationServiceRecognizer = /** @class */ function(_super) {
    __extends(TranslationServiceRecognizer, _super);
    function TranslationServiceRecognizer(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer) {
        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer) || this;
        _this.privTranslationRecognizer = translationRecognizer;
        _this.connectionEvents.attach(function(connectionEvent) {
            if (connectionEvent.name === "ConnectionEstablishedEvent") _this.privTranslationRecognizer.onConnection();
            else if (connectionEvent.name === "ConnectionClosedEvent") _this.privTranslationRecognizer.onDisconnection();
        });
        return _this;
    }
    TranslationServiceRecognizer.prototype.processTypeSpecificMessages = function(connectionMessage) {
        return __awaiter(this, void 0, void 0, function() {
            var resultProps, processed, handleTranslationPhrase, _a, result, phrase, synthEnd, result_1, retEvent, canceledResult;
            var _this = this;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        resultProps = new Exports_2.PropertyCollection();
                        return [
                            4 /*yield*/ ,
                            this.processSpeechMessages(connectionMessage)
                        ];
                    case 1:
                        processed = _b.sent();
                        if (processed) return [
                            2 /*return*/ ,
                            true
                        ];
                        handleTranslationPhrase = function(translatedPhrase) {
                            return __awaiter(_this, void 0, void 0, function() {
                                var result, reason, result, cancelReason, cancellationErrorCode, ev;
                                return __generator(this, function(_a) {
                                    switch(_a.label){
                                        case 0:
                                            this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset + translatedPhrase.Duration);
                                            if (!(translatedPhrase.RecognitionStatus === Exports_3.RecognitionStatus.Success)) return [
                                                3 /*break*/ ,
                                                1
                                            ];
                                            result = this.fireEventForResult(translatedPhrase, resultProps);
                                            if (!!this.privTranslationRecognizer.recognized) try {
                                                this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, result);
                                            /* eslint-disable no-empty */ } catch (error) {
                                            // Not going to let errors in the event handler
                                            // trip things up.
                                            }
                                            // report result to promise.
                                            if (!!this.privSuccessCallback) {
                                                try {
                                                    this.privSuccessCallback(result.result);
                                                } catch (e) {
                                                    if (!!this.privErrorCallback) this.privErrorCallback(e);
                                                }
                                                // Only invoke the call back once.
                                                // and if it's successful don't invoke the
                                                // error after that.
                                                this.privSuccessCallback = undefined;
                                                this.privErrorCallback = undefined;
                                            }
                                            return [
                                                3 /*break*/ ,
                                                5
                                            ];
                                        case 1:
                                            reason = Exports_3.EnumTranslation.implTranslateRecognitionResult(translatedPhrase.RecognitionStatus);
                                            result = new Exports_2.TranslationRecognitionResult(undefined, this.privRequestSession.requestId, reason, translatedPhrase.Text, translatedPhrase.Duration, this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset, translatedPhrase.Language, translatedPhrase.Confidence, undefined, connectionMessage.textBody, resultProps);
                                            if (!(reason === Exports_2.ResultReason.Canceled)) return [
                                                3 /*break*/ ,
                                                3
                                            ];
                                            cancelReason = Exports_3.EnumTranslation.implTranslateCancelResult(translatedPhrase.RecognitionStatus);
                                            cancellationErrorCode = Exports_3.EnumTranslation.implTranslateCancelErrorCode(translatedPhrase.RecognitionStatus);
                                            return [
                                                4 /*yield*/ ,
                                                this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_3.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode))
                                            ];
                                        case 2:
                                            _a.sent();
                                            return [
                                                3 /*break*/ ,
                                                4
                                            ];
                                        case 3:
                                            if (!(this.privRequestSession.isSpeechEnded && reason === Exports_2.ResultReason.NoMatch && translatedPhrase.RecognitionStatus !== Exports_3.RecognitionStatus.InitialSilenceTimeout)) {
                                                ev = new Exports_2.TranslationRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);
                                                if (!!this.privTranslationRecognizer.recognized) try {
                                                    this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);
                                                /* eslint-disable no-empty */ } catch (error) {
                                                // Not going to let errors in the event handler
                                                // trip things up.
                                                }
                                            }
                                            // report result to promise.
                                            if (!!this.privSuccessCallback) {
                                                try {
                                                    this.privSuccessCallback(result);
                                                } catch (e) {
                                                    if (!!this.privErrorCallback) this.privErrorCallback(e);
                                                }
                                                // Only invoke the call back once.
                                                // and if it's successful don't invoke the
                                                // error after that.
                                                this.privSuccessCallback = undefined;
                                                this.privErrorCallback = undefined;
                                            }
                                            _a.label = 4;
                                        case 4:
                                            processed = true;
                                            _a.label = 5;
                                        case 5:
                                            return [
                                                2 /*return*/ 
                                            ];
                                    }
                                });
                            });
                        };
                        if (connectionMessage.messageType === Exports_1.MessageType.Text) resultProps.setProperty(Exports_2.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
                        _a = connectionMessage.path.toLowerCase();
                        switch(_a){
                            case "translation.hypothesis":
                                return [
                                    3 /*break*/ ,
                                    2
                                ];
                            case "translation.response":
                                return [
                                    3 /*break*/ ,
                                    3
                                ];
                            case "translation.phrase":
                                return [
                                    3 /*break*/ ,
                                    6
                                ];
                            case "translation.synthesis":
                                return [
                                    3 /*break*/ ,
                                    8
                                ];
                            case "audio.end":
                                return [
                                    3 /*break*/ ,
                                    9
                                ];
                            case "translation.synthesis.end":
                                return [
                                    3 /*break*/ ,
                                    9
                                ];
                        }
                        return [
                            3 /*break*/ ,
                            10
                        ];
                    case 2:
                        result = this.fireEventForResult(Exports_3.TranslationHypothesis.fromJSON(connectionMessage.textBody), resultProps);
                        this.privRequestSession.onHypothesis(this.privRequestSession.currentTurnAudioOffset + result.offset);
                        if (!!this.privTranslationRecognizer.recognizing) try {
                            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, result);
                        /* eslint-disable no-empty */ } catch (error) {
                        // Not going to let errors in the event handler
                        // trip things up.
                        }
                        processed = true;
                        return [
                            3 /*break*/ ,
                            11
                        ];
                    case 3:
                        phrase = JSON.parse(connectionMessage.textBody);
                        if (!!!phrase.SpeechPhrase) return [
                            3 /*break*/ ,
                            5
                        ];
                        return [
                            4 /*yield*/ ,
                            handleTranslationPhrase(Exports_3.TranslationPhrase.fromTranslationResponse(phrase))
                        ];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5:
                        return [
                            3 /*break*/ ,
                            11
                        ];
                    case 6:
                        return [
                            4 /*yield*/ ,
                            handleTranslationPhrase(Exports_3.TranslationPhrase.fromJSON(connectionMessage.textBody))
                        ];
                    case 7:
                        _b.sent();
                        return [
                            3 /*break*/ ,
                            11
                        ];
                    case 8:
                        this.sendSynthesisAudio(connectionMessage.binaryBody, this.privRequestSession.sessionId);
                        processed = true;
                        return [
                            3 /*break*/ ,
                            11
                        ];
                    case 9:
                        synthEnd = Exports_3.TranslationSynthesisEnd.fromJSON(connectionMessage.textBody);
                        switch(synthEnd.SynthesisStatus){
                            case Exports_3.SynthesisStatus.Error:
                                if (!!this.privTranslationRecognizer.synthesizing) {
                                    result_1 = new Exports_2.TranslationSynthesisResult(Exports_2.ResultReason.Canceled, undefined);
                                    retEvent = new Exports_2.TranslationSynthesisEventArgs(result_1, this.privRequestSession.sessionId);
                                    try {
                                        this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);
                                    /* eslint-disable no-empty */ } catch (error) {
                                    // Not going to let errors in the event handler
                                    // trip things up.
                                    }
                                }
                                if (!!this.privTranslationRecognizer.canceled) {
                                    canceledResult = new Exports_2.TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, Exports_2.CancellationReason.Error, synthEnd.FailureReason, Exports_2.CancellationErrorCode.ServiceError, null);
                                    try {
                                        this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, canceledResult);
                                    /* eslint-disable no-empty */ } catch (error) {
                                    // Not going to let errors in the event handler
                                    // trip things up.
                                    }
                                }
                                break;
                            case Exports_3.SynthesisStatus.Success:
                                this.sendSynthesisAudio(undefined, this.privRequestSession.sessionId);
                                break;
                            default:
                                break;
                        }
                        processed = true;
                        return [
                            3 /*break*/ ,
                            11
                        ];
                    case 10:
                        return [
                            3 /*break*/ ,
                            11
                        ];
                    case 11:
                        return [
                            2 /*return*/ ,
                            processed
                        ];
                }
            });
        });
    };
    // Cancels recognition.
    TranslationServiceRecognizer.prototype.cancelRecognition = function(sessionId, requestId, cancellationReason, errorCode, error) {
        var properties = new Exports_2.PropertyCollection();
        properties.setProperty(Exports_3.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[errorCode]);
        if (!!this.privTranslationRecognizer.canceled) {
            var cancelEvent = new Exports_2.TranslationRecognitionCanceledEventArgs(sessionId, cancellationReason, error, errorCode, undefined);
            try {
                this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, cancelEvent);
            /* eslint-disable no-empty */ } catch (_a) {}
        }
        if (!!this.privSuccessCallback) {
            var result = new Exports_2.TranslationRecognitionResult(undefined, requestId, Exports_2.ResultReason.Canceled, undefined, undefined, undefined, undefined, undefined, error, undefined, properties);
            try {
                this.privSuccessCallback(result);
                /* eslint-disable no-empty */ this.privSuccessCallback = undefined;
            } catch (_b) {}
        }
    };
    TranslationServiceRecognizer.prototype.handleRecognizingCallback = function(result, duration, sessionId) {
        try {
            var ev = new Exports_2.TranslationRecognitionEventArgs(Exports_2.TranslationRecognitionResult.fromSpeechRecognitionResult(result), duration, sessionId);
            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, ev);
        /* eslint-disable no-empty */ } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
        }
    };
    TranslationServiceRecognizer.prototype.handleRecognizedCallback = function(result, offset, sessionId) {
        try {
            var ev = new Exports_2.TranslationRecognitionEventArgs(Exports_2.TranslationRecognitionResult.fromSpeechRecognitionResult(result), offset, sessionId);
            this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);
        } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
        }
    };
    TranslationServiceRecognizer.prototype.fireEventForResult = function(serviceResult, properties) {
        var translations;
        if (undefined !== serviceResult.Translation.Translations) {
            translations = new Exports_2.Translations();
            for(var _i = 0, _a = serviceResult.Translation.Translations; _i < _a.length; _i++){
                var translation = _a[_i];
                translations.set(translation.Language, translation.Text || translation.DisplayText);
            }
        }
        var resultReason;
        var language;
        var confidence;
        if (serviceResult instanceof Exports_3.TranslationPhrase) {
            if (!!serviceResult.Translation && serviceResult.Translation.TranslationStatus === Exports_1.TranslationStatus.Success) resultReason = Exports_2.ResultReason.TranslatedSpeech;
            else resultReason = Exports_2.ResultReason.RecognizedSpeech;
            language = serviceResult.Language;
            confidence = serviceResult.Confidence;
        } else resultReason = Exports_2.ResultReason.TranslatingSpeech;
        var offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;
        var result = new Exports_2.TranslationRecognitionResult(translations, this.privRequestSession.requestId, resultReason, serviceResult.Text, serviceResult.Duration, offset, language, confidence, serviceResult.Translation.FailureReason, JSON.stringify(serviceResult), properties);
        var ev = new Exports_2.TranslationRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);
        return ev;
    };
    TranslationServiceRecognizer.prototype.sendSynthesisAudio = function(audio, sessionId) {
        var reason = undefined === audio ? Exports_2.ResultReason.SynthesizingAudioCompleted : Exports_2.ResultReason.SynthesizingAudio;
        var result = new Exports_2.TranslationSynthesisResult(reason, audio);
        var retEvent = new Exports_2.TranslationSynthesisEventArgs(result, sessionId);
        if (!!this.privTranslationRecognizer.synthesizing) try {
            this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);
        /* eslint-disable no-empty */ } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
        }
    };
    return TranslationServiceRecognizer;
}(Exports_3.ConversationServiceRecognizer);
exports.TranslationServiceRecognizer = TranslationServiceRecognizer;

},{"d237539cc082a750":"5Bedw","320fcb0f5f76fbbd":"hxkc3","f84df7ef48eccf46":"7Qpvn"}],"4C8Vr":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechDetected = void 0;
var SpeechDetected = /** @class */ function() {
    function SpeechDetected(json) {
        this.privSpeechStartDetected = JSON.parse(json);
    }
    SpeechDetected.fromJSON = function(json) {
        return new SpeechDetected(json);
    };
    Object.defineProperty(SpeechDetected.prototype, "Offset", {
        get: function() {
            return this.privSpeechStartDetected.Offset;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechDetected;
}();
exports.SpeechDetected = SpeechDetected;

},{}],"4w193":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechHypothesis = void 0;
var SpeechHypothesis = /** @class */ function() {
    function SpeechHypothesis(json) {
        this.privSpeechHypothesis = JSON.parse(json);
    }
    SpeechHypothesis.fromJSON = function(json) {
        return new SpeechHypothesis(json);
    };
    Object.defineProperty(SpeechHypothesis.prototype, "Text", {
        get: function() {
            return this.privSpeechHypothesis.Text;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechHypothesis.prototype, "Offset", {
        get: function() {
            return this.privSpeechHypothesis.Offset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechHypothesis.prototype, "Duration", {
        get: function() {
            return this.privSpeechHypothesis.Duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechHypothesis.prototype, "Language", {
        get: function() {
            return this.privSpeechHypothesis.PrimaryLanguage === undefined ? undefined : this.privSpeechHypothesis.PrimaryLanguage.Language;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechHypothesis.prototype, "LanguageDetectionConfidence", {
        get: function() {
            return this.privSpeechHypothesis.PrimaryLanguage === undefined ? undefined : this.privSpeechHypothesis.PrimaryLanguage.Confidence;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechHypothesis.prototype, "SpeakerId", {
        get: function() {
            return this.privSpeechHypothesis.SpeakerId;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechHypothesis;
}();
exports.SpeechHypothesis = SpeechHypothesis;

},{}],"jrCMe":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechKeyword = void 0;
var SpeechKeyword = /** @class */ function() {
    function SpeechKeyword(json) {
        this.privSpeechKeyword = JSON.parse(json);
    }
    SpeechKeyword.fromJSON = function(json) {
        return new SpeechKeyword(json);
    };
    Object.defineProperty(SpeechKeyword.prototype, "Status", {
        get: function() {
            return this.privSpeechKeyword.Status;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechKeyword.prototype, "Text", {
        get: function() {
            return this.privSpeechKeyword.Text;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechKeyword.prototype, "Offset", {
        get: function() {
            return this.privSpeechKeyword.Offset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechKeyword.prototype, "Duration", {
        get: function() {
            return this.privSpeechKeyword.Duration;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechKeyword;
}();
exports.SpeechKeyword = SpeechKeyword;

},{}],"exHmu":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechServiceRecognizer = void 0;
var Exports_1 = require("7f9427c2e347650f");
var Exports_2 = require("c4a440f192e986af");
// eslint-disable-next-line max-classes-per-file
var SpeechServiceRecognizer = /** @class */ function(_super) {
    __extends(SpeechServiceRecognizer, _super);
    function SpeechServiceRecognizer(authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer) {
        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer) || this;
        _this.privSpeechRecognizer = speechRecognizer;
        return _this;
    }
    SpeechServiceRecognizer.prototype.processTypeSpecificMessages = function(connectionMessage) {
        return __awaiter(this, void 0, void 0, function() {
            var result, resultProps, processed, _a, hypothesis, offset, ev, simple, resultReason, cancelReason, cancellationErrorCode, detailed, totalOffset, offsetCorrectedJson, event_1;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        resultProps = new Exports_1.PropertyCollection();
                        resultProps.setProperty(Exports_1.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
                        processed = false;
                        _a = connectionMessage.path.toLowerCase();
                        switch(_a){
                            case "speech.hypothesis":
                                return [
                                    3 /*break*/ ,
                                    1
                                ];
                            case "speech.fragment":
                                return [
                                    3 /*break*/ ,
                                    1
                                ];
                            case "speech.phrase":
                                return [
                                    3 /*break*/ ,
                                    2
                                ];
                        }
                        return [
                            3 /*break*/ ,
                            6
                        ];
                    case 1:
                        hypothesis = Exports_2.SpeechHypothesis.fromJSON(connectionMessage.textBody);
                        offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;
                        result = new Exports_1.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_1.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);
                        this.privRequestSession.onHypothesis(offset);
                        ev = new Exports_1.SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);
                        if (!!this.privSpeechRecognizer.recognizing) try {
                            this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, ev);
                        /* eslint-disable no-empty */ } catch (error) {
                        // Not going to let errors in the event handler
                        // trip things up.
                        }
                        processed = true;
                        return [
                            3 /*break*/ ,
                            7
                        ];
                    case 2:
                        simple = Exports_2.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);
                        resultReason = Exports_2.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);
                        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);
                        if (!(Exports_1.ResultReason.Canceled === resultReason)) return [
                            3 /*break*/ ,
                            4
                        ];
                        cancelReason = Exports_2.EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);
                        cancellationErrorCode = Exports_2.EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);
                        return [
                            4 /*yield*/ ,
                            this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_2.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode))
                        ];
                    case 3:
                        _b.sent();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 4:
                        if (!(this.privRequestSession.isSpeechEnded && resultReason === Exports_1.ResultReason.NoMatch && simple.RecognitionStatus !== Exports_2.RecognitionStatus.InitialSilenceTimeout)) {
                            if (this.privRecognizerConfig.parameters.getProperty(Exports_2.OutputFormatPropertyName) === Exports_1.OutputFormat[Exports_1.OutputFormat.Simple]) result = new Exports_1.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);
                            else {
                                detailed = Exports_2.DetailedSpeechPhrase.fromJSON(connectionMessage.textBody);
                                totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;
                                offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);
                                result = new Exports_1.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, detailed.RecognitionStatus === Exports_2.RecognitionStatus.Success ? detailed.NBest[0].Display : undefined, detailed.Duration, totalOffset, detailed.Language, detailed.LanguageDetectionConfidence, undefined, undefined, offsetCorrectedJson, resultProps);
                            }
                            event_1 = new Exports_1.SpeechRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);
                            if (!!this.privSpeechRecognizer.recognized) try {
                                this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, event_1);
                            /* eslint-disable no-empty */ } catch (error) {
                            // Not going to let errors in the event handler
                            // trip things up.
                            }
                        }
                        if (!!this.privSuccessCallback) {
                            try {
                                this.privSuccessCallback(result);
                            } catch (e) {
                                if (!!this.privErrorCallback) this.privErrorCallback(e);
                            }
                            // Only invoke the call back once.
                            // and if it's successful don't invoke the
                            // error after that.
                            this.privSuccessCallback = undefined;
                            this.privErrorCallback = undefined;
                        }
                        _b.label = 5;
                    case 5:
                        processed = true;
                        return [
                            3 /*break*/ ,
                            7
                        ];
                    case 6:
                        return [
                            3 /*break*/ ,
                            7
                        ];
                    case 7:
                        return [
                            2 /*return*/ ,
                            processed
                        ];
                }
            });
        });
    };
    // Cancels recognition.
    SpeechServiceRecognizer.prototype.cancelRecognition = function(sessionId, requestId, cancellationReason, errorCode, error) {
        var properties = new Exports_1.PropertyCollection();
        properties.setProperty(Exports_2.CancellationErrorCodePropertyName, Exports_1.CancellationErrorCode[errorCode]);
        if (!!this.privSpeechRecognizer.canceled) {
            var cancelEvent = new Exports_1.SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
            try {
                this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, cancelEvent);
            /* eslint-disable no-empty */ } catch (_a) {}
        }
        if (!!this.privSuccessCallback) {
            var result = new Exports_1.SpeechRecognitionResult(requestId, Exports_1.ResultReason.Canceled, undefined, undefined, undefined, undefined, undefined, undefined, error, undefined, properties);
            try {
                this.privSuccessCallback(result);
                this.privSuccessCallback = undefined;
            /* eslint-disable no-empty */ } catch (_b) {}
        }
    };
    return SpeechServiceRecognizer;
}(Exports_2.ServiceRecognizerBase);
exports.SpeechServiceRecognizer = SpeechServiceRecognizer;

},{"7f9427c2e347650f":"hxkc3","c4a440f192e986af":"7Qpvn"}],"lcJkz":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranscriptionServiceRecognizer = void 0;
var Exports_1 = require("ffe4da43b9b631f2");
var Exports_2 = require("8360b5c69c830d02");
// eslint-disable-next-line max-classes-per-file
var ConversationTranscriptionServiceRecognizer = /** @class */ function(_super) {
    __extends(ConversationTranscriptionServiceRecognizer, _super);
    function ConversationTranscriptionServiceRecognizer(authentication, connectionFactory, audioSource, recognizerConfig, conversationTranscriber) {
        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, conversationTranscriber) || this;
        _this.privConversationTranscriber = conversationTranscriber;
        _this.setSpeakerDiarizationJson();
        return _this;
    }
    ConversationTranscriptionServiceRecognizer.prototype.setSpeakerDiarizationJson = function() {
        if (this.privEnableSpeakerId) {
            var phraseDetection = this.privSpeechContext.getSection("phraseDetection");
            var speakerDiarization = {};
            speakerDiarization.mode = "Anonymous";
            speakerDiarization.audioSessionId = this.privDiarizationSessionId;
            speakerDiarization.audioOffsetMs = 0;
            phraseDetection.speakerDiarization = speakerDiarization;
            this.privSpeechContext.setSection("phraseDetection", phraseDetection);
        }
    };
    ConversationTranscriptionServiceRecognizer.prototype.processTypeSpecificMessages = function(connectionMessage) {
        return __awaiter(this, void 0, void 0, function() {
            var result, resultProps, processed, _a, hypothesis, offset, ev, simple, resultReason, cancelReason, cancellationErrorCode, detailed, totalOffset, offsetCorrectedJson, event_1;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        resultProps = new Exports_1.PropertyCollection();
                        resultProps.setProperty(Exports_1.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
                        processed = false;
                        _a = connectionMessage.path.toLowerCase();
                        switch(_a){
                            case "speech.hypothesis":
                                return [
                                    3 /*break*/ ,
                                    1
                                ];
                            case "speech.fragment":
                                return [
                                    3 /*break*/ ,
                                    1
                                ];
                            case "speech.phrase":
                                return [
                                    3 /*break*/ ,
                                    2
                                ];
                        }
                        return [
                            3 /*break*/ ,
                            6
                        ];
                    case 1:
                        hypothesis = Exports_2.SpeechHypothesis.fromJSON(connectionMessage.textBody);
                        offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;
                        result = new Exports_1.ConversationTranscriptionResult(this.privRequestSession.requestId, Exports_1.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);
                        this.privRequestSession.onHypothesis(offset);
                        ev = new Exports_1.ConversationTranscriptionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);
                        if (!!this.privConversationTranscriber.transcribing) try {
                            this.privConversationTranscriber.transcribing(this.privConversationTranscriber, ev);
                        /* eslint-disable no-empty */ } catch (error) {
                        // Not going to let errors in the event handler
                        // trip things up.
                        }
                        processed = true;
                        return [
                            3 /*break*/ ,
                            7
                        ];
                    case 2:
                        simple = Exports_2.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);
                        resultReason = Exports_2.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);
                        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);
                        if (!(Exports_1.ResultReason.Canceled === resultReason)) return [
                            3 /*break*/ ,
                            4
                        ];
                        cancelReason = Exports_2.EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);
                        cancellationErrorCode = Exports_2.EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);
                        return [
                            4 /*yield*/ ,
                            this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_2.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode))
                        ];
                    case 3:
                        _b.sent();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 4:
                        if (!(this.privRequestSession.isSpeechEnded && resultReason === Exports_1.ResultReason.NoMatch && simple.RecognitionStatus !== Exports_2.RecognitionStatus.InitialSilenceTimeout)) {
                            if (this.privRecognizerConfig.parameters.getProperty(Exports_2.OutputFormatPropertyName) === Exports_1.OutputFormat[Exports_1.OutputFormat.Simple]) result = new Exports_1.ConversationTranscriptionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, simple.SpeakerId, undefined, connectionMessage.textBody, resultProps);
                            else {
                                detailed = Exports_2.DetailedSpeechPhrase.fromJSON(connectionMessage.textBody);
                                totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;
                                offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);
                                result = new Exports_1.ConversationTranscriptionResult(this.privRequestSession.requestId, resultReason, detailed.RecognitionStatus === Exports_2.RecognitionStatus.Success ? detailed.NBest[0].Display : undefined, detailed.Duration, totalOffset, detailed.Language, detailed.LanguageDetectionConfidence, simple.SpeakerId, undefined, offsetCorrectedJson, resultProps);
                            }
                            event_1 = new Exports_1.ConversationTranscriptionEventArgs(result, result.offset, this.privRequestSession.sessionId);
                            if (!!this.privConversationTranscriber.transcribed) try {
                                this.privConversationTranscriber.transcribed(this.privConversationTranscriber, event_1);
                            /* eslint-disable no-empty */ } catch (error) {
                            // Not going to let errors in the event handler
                            // trip things up.
                            }
                        }
                        _b.label = 5;
                    case 5:
                        processed = true;
                        return [
                            3 /*break*/ ,
                            7
                        ];
                    case 6:
                        return [
                            3 /*break*/ ,
                            7
                        ];
                    case 7:
                        return [
                            2 /*return*/ ,
                            processed
                        ];
                }
            });
        });
    };
    // Cancels recognition.
    ConversationTranscriptionServiceRecognizer.prototype.cancelRecognition = function(sessionId, requestId, cancellationReason, errorCode, error) {
        var properties = new Exports_1.PropertyCollection();
        properties.setProperty(Exports_2.CancellationErrorCodePropertyName, Exports_1.CancellationErrorCode[errorCode]);
        if (!!this.privConversationTranscriber.canceled) {
            var cancelEvent = new Exports_1.ConversationTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
            try {
                this.privConversationTranscriber.canceled(this.privConversationTranscriber, cancelEvent);
            /* eslint-disable no-empty */ } catch (_a) {}
        }
    };
    return ConversationTranscriptionServiceRecognizer;
}(Exports_2.ServiceRecognizerBase);
exports.ConversationTranscriptionServiceRecognizer = ConversationTranscriptionServiceRecognizer;

},{"ffe4da43b9b631f2":"hxkc3","8360b5c69c830d02":"7Qpvn"}],"7rbYP":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranscriptionServiceRecognizer = void 0;
var Exports_1 = require("6be712e5bc9d2ac7");
var Exports_2 = require("3e5093d36d48fe33");
var Exports_3 = require("99172eaffb93cd28");
var SpeechConnectionMessage_Internal_1 = require("3c8ed92539eeec01");
// eslint-disable-next-line max-classes-per-file
var TranscriptionServiceRecognizer = /** @class */ function(_super) {
    __extends(TranscriptionServiceRecognizer, _super);
    function TranscriptionServiceRecognizer(authentication, connectionFactory, audioSource, recognizerConfig, transcriber) {
        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, transcriber) || this;
        _this.privTranscriberRecognizer = transcriber;
        _this.sendPrePayloadJSONOverride = function(connection) {
            return _this.sendTranscriptionStartJSON(connection);
        };
        if (_this.privRecognizerConfig.parameters.getProperty(Exports_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps) === "true") _this.privSpeechContext.setWordLevelTimings();
        return _this;
    }
    TranscriptionServiceRecognizer.prototype.sendSpeechEventAsync = function(info, command) {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!!this.privRequestSession.isRecognizing) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendSpeechEvent(connection, this.createSpeechEventPayload(info, command))
                        ];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    TranscriptionServiceRecognizer.prototype.sendMeetingSpeechEventAsync = function(info, command) {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!!this.privRequestSession.isRecognizing) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendSpeechEvent(connection, this.createMeetingSpeechEventPayload(info, command))
                        ];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    TranscriptionServiceRecognizer.prototype.processTypeSpecificMessages = function(connectionMessage) {
        return this.processSpeechMessages(connectionMessage);
    };
    TranscriptionServiceRecognizer.prototype.handleRecognizedCallback = function(result, offset, sessionId) {
        try {
            var event_1 = new Exports_2.SpeechRecognitionEventArgs(result, offset, sessionId);
            this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, event_1);
            if (!!this.privSuccessCallback) {
                try {
                    this.privSuccessCallback(result);
                } catch (e) {
                    if (!!this.privErrorCallback) this.privErrorCallback(e);
                }
                // Only invoke the call back once.
                // and if it's successful don't invoke the
                // error after that.
                this.privSuccessCallback = undefined;
                this.privErrorCallback = undefined;
            }
        /* eslint-disable no-empty */ } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
        }
    };
    TranscriptionServiceRecognizer.prototype.handleRecognizingCallback = function(result, duration, sessionId) {
        try {
            var ev = new Exports_2.SpeechRecognitionEventArgs(result, duration, sessionId);
            this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, ev);
        /* eslint-disable no-empty */ } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
        }
    };
    // Cancels recognition.
    TranscriptionServiceRecognizer.prototype.cancelRecognition = function(sessionId, requestId, cancellationReason, errorCode, error) {
        var properties = new Exports_2.PropertyCollection();
        properties.setProperty(Exports_3.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[errorCode]);
        if (this.privTranscriberRecognizer.IsMeetingRecognizer()) {
            if (!!this.privTranscriberRecognizer.canceled) {
                var cancelEvent = new Exports_2.MeetingTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
                try {
                    this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, cancelEvent);
                /* eslint-disable no-empty */ } catch (_a) {}
            }
        } else if (!!this.privTranscriberRecognizer.canceled) {
            var cancelEvent = new Exports_2.ConversationTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
            try {
                this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, cancelEvent);
            /* eslint-disable no-empty */ } catch (_b) {}
        }
        if (!!this.privSuccessCallback) {
            var result = new Exports_2.SpeechRecognitionResult(requestId, Exports_2.ResultReason.Canceled, undefined, undefined, undefined, undefined, undefined, undefined, error, undefined, properties);
            try {
                this.privSuccessCallback(result);
                this.privSuccessCallback = undefined;
            /* eslint-disable no-empty */ } catch (_c) {}
        }
    };
    // Encapsulated for derived service recognizers that need to send additional JSON
    TranscriptionServiceRecognizer.prototype.sendTranscriptionStartJSON = function(connection) {
        return __awaiter(this, void 0, void 0, function() {
            var info, payload, info, payload;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.sendSpeechContext(connection, true)
                        ];
                    case 1:
                        _a.sent();
                        if (!this.privTranscriberRecognizer.IsMeetingRecognizer()) return [
                            3 /*break*/ ,
                            3
                        ];
                        info = this.privTranscriberRecognizer.getMeetingInfo();
                        payload = this.createMeetingSpeechEventPayload(info, "start");
                        return [
                            4 /*yield*/ ,
                            this.sendSpeechEvent(connection, payload)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 3:
                        info = this.privTranscriberRecognizer.getConversationInfo();
                        payload = this.createSpeechEventPayload(info, "start");
                        return [
                            4 /*yield*/ ,
                            this.sendSpeechEvent(connection, payload)
                        ];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        return [
                            4 /*yield*/ ,
                            this.sendWaveHeader(connection)
                        ];
                    case 6:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    TranscriptionServiceRecognizer.prototype.sendSpeechEvent = function(connection, payload) {
        var speechEventJson = JSON.stringify(payload);
        if (speechEventJson) return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_1.MessageType.Text, "speech.event", this.privRequestSession.requestId, "application/json", speechEventJson));
        return;
    };
    TranscriptionServiceRecognizer.prototype.createSpeechEventPayload = function(info, command) {
        var eventDict = {
            id: "meeting",
            name: command,
            meeting: info.conversationProperties
        };
        eventDict.meeting.id = info.id;
        eventDict.meeting.attendees = info.participants;
        return eventDict;
    };
    TranscriptionServiceRecognizer.prototype.createMeetingSpeechEventPayload = function(info, command) {
        var eventDict = {
            id: "meeting",
            name: command,
            meeting: info.meetingProperties
        };
        eventDict.meeting.id = info.id;
        eventDict.meeting.attendees = info.participants;
        return eventDict;
    };
    return TranscriptionServiceRecognizer;
}(Exports_3.ConversationServiceRecognizer);
exports.TranscriptionServiceRecognizer = TranscriptionServiceRecognizer;

},{"6be712e5bc9d2ac7":"5Bedw","3e5093d36d48fe33":"hxkc3","99172eaffb93cd28":"7Qpvn","3c8ed92539eeec01":"euGGf"}],"1jQIe":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DetailedSpeechPhrase = void 0;
var Exports_1 = require("ffae9dd443fa399f");
var DetailedSpeechPhrase = /** @class */ function() {
    function DetailedSpeechPhrase(json) {
        this.privDetailedSpeechPhrase = JSON.parse(json);
        this.privDetailedSpeechPhrase.RecognitionStatus = Exports_1.RecognitionStatus[this.privDetailedSpeechPhrase.RecognitionStatus];
    }
    DetailedSpeechPhrase.fromJSON = function(json) {
        return new DetailedSpeechPhrase(json);
    };
    DetailedSpeechPhrase.prototype.getJsonWithCorrectedOffsets = function(baseOffset) {
        if (!!this.privDetailedSpeechPhrase.NBest) {
            var firstWordOffset = void 0;
            for(var _i = 0, _a = this.privDetailedSpeechPhrase.NBest; _i < _a.length; _i++){
                var phrase = _a[_i];
                if (!!phrase.Words && !!phrase.Words[0]) {
                    firstWordOffset = phrase.Words[0].Offset;
                    break;
                }
            }
            if (!!firstWordOffset && firstWordOffset < baseOffset) {
                var offset = baseOffset - firstWordOffset;
                for(var _b = 0, _c = this.privDetailedSpeechPhrase.NBest; _b < _c.length; _b++){
                    var details = _c[_b];
                    if (!!details.Words) for(var _d = 0, _e = details.Words; _d < _e.length; _d++){
                        var word = _e[_d];
                        word.Offset += offset;
                    }
                    if (!!details.DisplayWords) for(var _f = 0, _g = details.DisplayWords; _f < _g.length; _f++){
                        var word = _g[_f];
                        word.Offset += offset;
                    }
                }
            }
        }
        return JSON.stringify(this.privDetailedSpeechPhrase);
    };
    Object.defineProperty(DetailedSpeechPhrase.prototype, "RecognitionStatus", {
        get: function() {
            return this.privDetailedSpeechPhrase.RecognitionStatus;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DetailedSpeechPhrase.prototype, "NBest", {
        get: function() {
            return this.privDetailedSpeechPhrase.NBest;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DetailedSpeechPhrase.prototype, "Duration", {
        get: function() {
            return this.privDetailedSpeechPhrase.Duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DetailedSpeechPhrase.prototype, "Offset", {
        get: function() {
            return this.privDetailedSpeechPhrase.Offset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DetailedSpeechPhrase.prototype, "Language", {
        get: function() {
            return this.privDetailedSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DetailedSpeechPhrase.prototype, "LanguageDetectionConfidence", {
        get: function() {
            return this.privDetailedSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DetailedSpeechPhrase.prototype, "Text", {
        get: function() {
            if (!!this.privDetailedSpeechPhrase.NBest && this.privDetailedSpeechPhrase.NBest[0]) return this.privDetailedSpeechPhrase.NBest[0].Display || this.privDetailedSpeechPhrase.NBest[0].DisplayText;
            return this.privDetailedSpeechPhrase.DisplayText;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DetailedSpeechPhrase.prototype, "SpeakerId", {
        get: function() {
            return this.privDetailedSpeechPhrase.SpeakerId;
        },
        enumerable: false,
        configurable: true
    });
    return DetailedSpeechPhrase;
}();
exports.DetailedSpeechPhrase = DetailedSpeechPhrase;

},{"ffae9dd443fa399f":"7Qpvn"}],"dURiZ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SimpleSpeechPhrase = void 0;
var Exports_1 = require("90459473fec91593");
var SimpleSpeechPhrase = /** @class */ function() {
    function SimpleSpeechPhrase(json) {
        this.privSimpleSpeechPhrase = JSON.parse(json);
        this.privSimpleSpeechPhrase.RecognitionStatus = Exports_1.RecognitionStatus[this.privSimpleSpeechPhrase.RecognitionStatus];
    }
    SimpleSpeechPhrase.fromJSON = function(json) {
        return new SimpleSpeechPhrase(json);
    };
    Object.defineProperty(SimpleSpeechPhrase.prototype, "RecognitionStatus", {
        get: function() {
            return this.privSimpleSpeechPhrase.RecognitionStatus;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SimpleSpeechPhrase.prototype, "DisplayText", {
        get: function() {
            return this.privSimpleSpeechPhrase.DisplayText;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SimpleSpeechPhrase.prototype, "Offset", {
        get: function() {
            return this.privSimpleSpeechPhrase.Offset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SimpleSpeechPhrase.prototype, "Duration", {
        get: function() {
            return this.privSimpleSpeechPhrase.Duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SimpleSpeechPhrase.prototype, "Language", {
        get: function() {
            return this.privSimpleSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SimpleSpeechPhrase.prototype, "LanguageDetectionConfidence", {
        get: function() {
            return this.privSimpleSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SimpleSpeechPhrase.prototype, "SpeakerId", {
        get: function() {
            return this.privSimpleSpeechPhrase.SpeakerId;
        },
        enumerable: false,
        configurable: true
    });
    return SimpleSpeechPhrase;
}();
exports.SimpleSpeechPhrase = SimpleSpeechPhrase;

},{"90459473fec91593":"7Qpvn"}],"8IhMg":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AddedLmIntent = void 0;
/**
 * @class AddedLmIntent
 */ // eslint-disable-next-line max-classes-per-file
var AddedLmIntent = /** @class */ function() {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param modelImpl - The model.
     * @param intentName - The intent name.
     */ function AddedLmIntent(modelImpl, intentName) {
        this.modelImpl = modelImpl;
        this.intentName = intentName;
    }
    return AddedLmIntent;
}();
exports.AddedLmIntent = AddedLmIntent;

},{}],"inGQx":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntentServiceRecognizer = void 0;
var Exports_1 = require("3fd1b9339b35b451");
var Exports_2 = require("b41b2f984011243");
var Exports_3 = require("1ccc7f2f3f2485cb");
// eslint-disable-next-line max-classes-per-file
var IntentServiceRecognizer = /** @class */ function(_super) {
    __extends(IntentServiceRecognizer, _super);
    function IntentServiceRecognizer(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, recognizer) || this;
        _this.privIntentRecognizer = recognizer;
        _this.privIntentDataSent = false;
        return _this;
    }
    IntentServiceRecognizer.prototype.setIntents = function(addedIntents, umbrellaIntent) {
        this.privAddedLmIntents = addedIntents;
        this.privUmbrellaIntent = umbrellaIntent;
        this.privIntentDataSent = true;
    };
    IntentServiceRecognizer.prototype.processTypeSpecificMessages = function(connectionMessage) {
        var _this = this;
        var result;
        var ev;
        var processed = false;
        var resultProps = new Exports_2.PropertyCollection();
        if (connectionMessage.messageType === Exports_1.MessageType.Text) resultProps.setProperty(Exports_2.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
        switch(connectionMessage.path.toLowerCase()){
            case "speech.hypothesis":
                var speechHypothesis = Exports_3.SpeechHypothesis.fromJSON(connectionMessage.textBody);
                result = new Exports_2.IntentRecognitionResult(undefined, this.privRequestSession.requestId, Exports_2.ResultReason.RecognizingIntent, speechHypothesis.Text, speechHypothesis.Duration, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, speechHypothesis.Language, speechHypothesis.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);
                this.privRequestSession.onHypothesis(result.offset);
                ev = new Exports_2.IntentRecognitionEventArgs(result, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
                if (!!this.privIntentRecognizer.recognizing) try {
                    this.privIntentRecognizer.recognizing(this.privIntentRecognizer, ev);
                /* eslint-disable no-empty */ } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
                }
                processed = true;
                break;
            case "speech.phrase":
                var simple = Exports_3.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);
                result = new Exports_2.IntentRecognitionResult(undefined, this.privRequestSession.requestId, Exports_3.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus), simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);
                ev = new Exports_2.IntentRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);
                var sendEvent = function() {
                    if (!!_this.privIntentRecognizer.recognized) try {
                        _this.privIntentRecognizer.recognized(_this.privIntentRecognizer, ev);
                    /* eslint-disable no-empty */ } catch (error) {
                    // Not going to let errors in the event handler
                    // trip things up.
                    }
                    // report result to promise.
                    if (!!_this.privSuccessCallback) {
                        try {
                            _this.privSuccessCallback(result);
                        } catch (e) {
                            if (!!_this.privErrorCallback) _this.privErrorCallback(e);
                        }
                        // Only invoke the call back once.
                        // and if it's successful don't invoke the
                        // error after that.
                        _this.privSuccessCallback = undefined;
                        _this.privErrorCallback = undefined;
                    }
                };
                // If intent data was sent, the terminal result for this recognizer is an intent being found.
                // If no intent data was sent, the terminal event is speech recognition being successful.
                if (false === this.privIntentDataSent || Exports_2.ResultReason.NoMatch === ev.result.reason) {
                    // Advance the buffers.
                    this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);
                    sendEvent();
                } else // Squirrel away the args, when the response event arrives it will build upon them
                // and then return
                this.privPendingIntentArgs = ev;
                processed = true;
                break;
            case "response":
                // Response from LUIS
                ev = this.privPendingIntentArgs;
                this.privPendingIntentArgs = undefined;
                if (undefined === ev) {
                    if ("" === connectionMessage.textBody) // This condition happens if there is nothing but silence in the
                    // audio sent to the service.
                    return;
                    // Odd... Not sure this can happen
                    ev = new Exports_2.IntentRecognitionEventArgs(new Exports_2.IntentRecognitionResult(), 0, this.privRequestSession.sessionId);
                }
                var intentResponse = Exports_3.IntentResponse.fromJSON(connectionMessage.textBody);
                // If LUIS didn't return anything, send the existing event, else
                // modify it to show the match.
                // See if the intent found is in the list of intents asked for.
                if (null !== intentResponse && !!intentResponse.topScoringIntent && !!intentResponse.topScoringIntent.intent) {
                    var addedIntent = this.privAddedLmIntents[intentResponse.topScoringIntent.intent];
                    if (this.privUmbrellaIntent !== undefined) addedIntent = this.privUmbrellaIntent;
                    if (!!addedIntent) {
                        var intentId = addedIntent === undefined || addedIntent.intentName === undefined ? intentResponse.topScoringIntent.intent : addedIntent.intentName;
                        var reason = ev.result.reason;
                        if (undefined !== intentId) reason = Exports_2.ResultReason.RecognizedIntent;
                        // make sure, properties is set.
                        var properties = undefined !== ev.result.properties ? ev.result.properties : new Exports_2.PropertyCollection();
                        properties.setProperty(Exports_2.PropertyId.LanguageUnderstandingServiceResponse_JsonResult, connectionMessage.textBody);
                        ev = new Exports_2.IntentRecognitionEventArgs(new Exports_2.IntentRecognitionResult(intentId, ev.result.resultId, reason, ev.result.text, ev.result.duration, ev.result.offset, undefined, undefined, ev.result.errorDetails, ev.result.json, properties), ev.offset, ev.sessionId);
                    }
                }
                this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);
                if (!!this.privIntentRecognizer.recognized) try {
                    this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);
                /* eslint-disable no-empty */ } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
                }
                // report result to promise.
                if (!!this.privSuccessCallback) {
                    try {
                        this.privSuccessCallback(ev.result);
                    } catch (e) {
                        if (!!this.privErrorCallback) this.privErrorCallback(e);
                    }
                    // Only invoke the call back once.
                    // and if it's successful don't invoke the
                    // error after that.
                    this.privSuccessCallback = undefined;
                    this.privErrorCallback = undefined;
                }
                processed = true;
                break;
            default:
                break;
        }
        var defferal = new Exports_1.Deferred();
        defferal.resolve(processed);
        return defferal.promise;
    };
    // Cancels recognition.
    IntentServiceRecognizer.prototype.cancelRecognition = function(sessionId, requestId, cancellationReason, errorCode, error) {
        var properties = new Exports_2.PropertyCollection();
        properties.setProperty(Exports_3.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[errorCode]);
        if (!!this.privIntentRecognizer.canceled) {
            var cancelEvent = new Exports_2.IntentRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, undefined, sessionId);
            try {
                this.privIntentRecognizer.canceled(this.privIntentRecognizer, cancelEvent);
            /* eslint-disable no-empty */ } catch (_a) {}
        }
        if (!!this.privSuccessCallback) {
            var result = new Exports_2.IntentRecognitionResult(undefined, requestId, Exports_2.ResultReason.Canceled, undefined, undefined, undefined, undefined, undefined, error, undefined, properties);
            try {
                this.privSuccessCallback(result);
                this.privSuccessCallback = undefined;
            /* eslint-disable no-empty */ } catch (_b) {}
        }
    };
    return IntentServiceRecognizer;
}(Exports_3.ServiceRecognizerBase);
exports.IntentServiceRecognizer = IntentServiceRecognizer;

},{"3fd1b9339b35b451":"5Bedw","b41b2f984011243":"hxkc3","1ccc7f2f3f2485cb":"7Qpvn"}],"gt38A":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// response
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntentResponse = void 0;
var IntentResponse = /** @class */ function() {
    function IntentResponse(json) {
        if (json === "") this.privIntentResponse = {};
        else this.privIntentResponse = JSON.parse(json);
    }
    IntentResponse.fromJSON = function(json) {
        return new IntentResponse(json);
    };
    Object.defineProperty(IntentResponse.prototype, "query", {
        get: function() {
            return this.privIntentResponse.query;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IntentResponse.prototype, "topScoringIntent", {
        get: function() {
            return this.privIntentResponse.topScoringIntent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IntentResponse.prototype, "entities", {
        get: function() {
            return this.privIntentResponse.entities;
        },
        enumerable: false,
        configurable: true
    });
    return IntentResponse;
}();
exports.IntentResponse = IntentResponse;

},{}],"jRCey":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/* eslint-disable max-classes-per-file */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"URaEO":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RequestSession = void 0;
var Exports_1 = require("ad62ae27d1bae3a1");
var RecognitionEvents_1 = require("2cf90b1c455877b3");
var ServiceTelemetryListener_Internal_1 = require("58a5b658f0924eb1");
var RequestSession = /** @class */ function() {
    function RequestSession(audioSourceId) {
        this.privIsDisposed = false;
        this.privDetachables = new Array();
        this.privIsAudioNodeDetached = false;
        this.privIsRecognizing = false;
        this.privIsSpeechEnded = false;
        this.privTurnStartAudioOffset = 0;
        this.privLastRecoOffset = 0;
        this.privHypothesisReceived = false;
        this.privBytesSent = 0;
        this.privRecognitionBytesSent = 0;
        this.privRecogNumber = 0;
        this.privInTurn = false;
        this.privConnectionAttempts = 0;
        this.privAudioSourceId = audioSourceId;
        this.privRequestId = Exports_1.createNoDashGuid();
        this.privAudioNodeId = Exports_1.createNoDashGuid();
        this.privTurnDeferral = new Exports_1.Deferred();
        // We're not in a turn, so resolve.
        this.privTurnDeferral.resolve();
    }
    Object.defineProperty(RequestSession.prototype, "sessionId", {
        get: function() {
            return this.privSessionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RequestSession.prototype, "requestId", {
        get: function() {
            return this.privRequestId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RequestSession.prototype, "audioNodeId", {
        get: function() {
            return this.privAudioNodeId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RequestSession.prototype, "turnCompletionPromise", {
        get: function() {
            return this.privTurnDeferral.promise;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RequestSession.prototype, "isSpeechEnded", {
        get: function() {
            return this.privIsSpeechEnded;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RequestSession.prototype, "isRecognizing", {
        get: function() {
            return this.privIsRecognizing;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RequestSession.prototype, "currentTurnAudioOffset", {
        get: function() {
            return this.privTurnStartAudioOffset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RequestSession.prototype, "recogNumber", {
        get: function() {
            return this.privRecogNumber;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RequestSession.prototype, "numConnectionAttempts", {
        get: function() {
            return this.privConnectionAttempts;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RequestSession.prototype, "bytesSent", {
        // The number of bytes sent for the current connection.
        // Counter is reset to 0 each time a connection is established.
        get: function() {
            return this.privBytesSent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RequestSession.prototype, "recognitionBytesSent", {
        // The number of bytes sent for the current recognition.
        // Counter is reset to 0 each time recognition is started.
        get: function() {
            return this.privRecognitionBytesSent;
        },
        enumerable: false,
        configurable: true
    });
    RequestSession.prototype.listenForServiceTelemetry = function(eventSource) {
        if (!!this.privServiceTelemetryListener) this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));
    };
    RequestSession.prototype.startNewRecognition = function() {
        this.privRecognitionBytesSent = 0;
        this.privIsSpeechEnded = false;
        this.privIsRecognizing = true;
        this.privTurnStartAudioOffset = 0;
        this.privLastRecoOffset = 0;
        this.privRecogNumber++;
        this.privServiceTelemetryListener = new ServiceTelemetryListener_Internal_1.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);
        this.onEvent(new RecognitionEvents_1.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    };
    RequestSession.prototype.onAudioSourceAttachCompleted = function(audioNode, isError) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.privAudioNode = audioNode;
                        this.privIsAudioNodeDetached = false;
                        if (!isError) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.onComplete()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 2:
                        this.onEvent(new RecognitionEvents_1.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    RequestSession.prototype.onPreConnectionStart = function(authFetchEventId, connectionId) {
        this.privAuthFetchEventId = authFetchEventId;
        this.privSessionId = connectionId;
        this.onEvent(new RecognitionEvents_1.ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));
    };
    RequestSession.prototype.onAuthCompleted = function(isError) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!isError) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.onComplete()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    RequestSession.prototype.onConnectionEstablishCompleted = function(statusCode, reason) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!(statusCode === 200)) return [
                            3 /*break*/ ,
                            1
                        ];
                        this.onEvent(new RecognitionEvents_1.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));
                        if (!!this.privAudioNode) this.privAudioNode.replay();
                        this.privTurnStartAudioOffset = this.privLastRecoOffset;
                        this.privBytesSent = 0;
                        return [
                            2 /*return*/ 
                        ];
                    case 1:
                        if (!(statusCode === 403)) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            this.onComplete()
                        ];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    RequestSession.prototype.onServiceTurnEndResponse = function(continuousRecognition) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.privTurnDeferral.resolve();
                        if (!(!continuousRecognition || this.isSpeechEnded)) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.onComplete()
                        ];
                    case 1:
                        _a.sent();
                        this.privInTurn = false;
                        return [
                            3 /*break*/ ,
                            3
                        ];
                    case 2:
                        // Start a new request set.
                        this.privTurnStartAudioOffset = this.privLastRecoOffset;
                        this.privAudioNode.replay();
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    RequestSession.prototype.onSpeechContext = function() {
        this.privRequestId = Exports_1.createNoDashGuid();
    };
    RequestSession.prototype.onServiceTurnStartResponse = function() {
        if (!!this.privTurnDeferral && !!this.privInTurn) {
            // What? How are we starting a turn with another not done?
            this.privTurnDeferral.reject("Another turn started before current completed.");
            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            this.privTurnDeferral.promise.then().catch(function() {});
        }
        this.privInTurn = true;
        this.privTurnDeferral = new Exports_1.Deferred();
    };
    RequestSession.prototype.onHypothesis = function(offset) {
        if (!this.privHypothesisReceived) {
            this.privHypothesisReceived = true;
            this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));
        }
    };
    RequestSession.prototype.onPhraseRecognized = function(offset) {
        this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));
        this.onServiceRecognized(offset);
    };
    RequestSession.prototype.onServiceRecognized = function(offset) {
        this.privLastRecoOffset = offset;
        this.privHypothesisReceived = false;
        this.privAudioNode.shrinkBuffers(offset);
        this.privConnectionAttempts = 0;
    };
    RequestSession.prototype.onAudioSent = function(bytesSent) {
        this.privBytesSent += bytesSent;
        this.privRecognitionBytesSent += bytesSent;
    };
    RequestSession.prototype.onRetryConnection = function() {
        this.privConnectionAttempts++;
    };
    RequestSession.prototype.dispose = function() {
        return __awaiter(this, void 0, void 0, function() {
            var _i, _a, detachable;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        if (!!this.privIsDisposed) return [
                            3 /*break*/ ,
                            5
                        ];
                        // we should have completed by now. If we did not its an unknown error.
                        this.privIsDisposed = true;
                        _i = 0, _a = this.privDetachables;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [
                            3 /*break*/ ,
                            4
                        ];
                        detachable = _a[_i];
                        return [
                            4 /*yield*/ ,
                            detachable.detach()
                        ];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [
                            3 /*break*/ ,
                            1
                        ];
                    case 4:
                        if (!!this.privServiceTelemetryListener) this.privServiceTelemetryListener.dispose();
                        this.privIsRecognizing = false;
                        _b.label = 5;
                    case 5:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    RequestSession.prototype.getTelemetry = function() {
        if (this.privServiceTelemetryListener.hasTelemetry) return this.privServiceTelemetryListener.getTelemetry();
        else return null;
    };
    RequestSession.prototype.onStopRecognizing = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.onComplete()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    // Should be called with the audioNode for this session has indicated that it is out of speech.
    RequestSession.prototype.onSpeechEnded = function() {
        this.privIsSpeechEnded = true;
    };
    RequestSession.prototype.onEvent = function(event) {
        if (!!this.privServiceTelemetryListener) this.privServiceTelemetryListener.onEvent(event);
        Exports_1.Events.instance.onEvent(event);
    };
    RequestSession.prototype.onComplete = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!!this.privIsRecognizing) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privIsRecognizing = false;
                        return [
                            4 /*yield*/ ,
                            this.detachAudioNode()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    RequestSession.prototype.detachAudioNode = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!this.privIsAudioNodeDetached) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privIsAudioNodeDetached = true;
                        if (!this.privAudioNode) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privAudioNode.detach()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    return RequestSession;
}();
exports.RequestSession = RequestSession;

},{"ad62ae27d1bae3a1":"5Bedw","2cf90b1c455877b3":"josuk","58a5b658f0924eb1":"fRAfL"}],"fRAfL":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServiceTelemetryListener = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("828636b8ffce1248");
var RecognitionEvents_1 = require("8940c05672a64495");
var ServiceTelemetryListener = /** @class */ function() {
    function ServiceTelemetryListener(requestId, audioSourceId, audioNodeId) {
        this.privIsDisposed = false;
        this.privListeningTriggerMetric = null;
        this.privMicMetric = null;
        this.privConnectionEstablishMetric = null;
        this.privRequestId = requestId;
        this.privAudioSourceId = audioSourceId;
        this.privAudioNodeId = audioNodeId;
        this.privReceivedMessages = {};
        this.privPhraseLatencies = [];
        this.privHypothesisLatencies = [];
    }
    ServiceTelemetryListener.prototype.phraseReceived = function(audioReceivedTime) {
        if (audioReceivedTime > 0) this.privPhraseLatencies.push(Date.now() - audioReceivedTime);
    };
    ServiceTelemetryListener.prototype.hypothesisReceived = function(audioReceivedTime) {
        if (audioReceivedTime > 0) this.privHypothesisLatencies.push(Date.now() - audioReceivedTime);
    };
    ServiceTelemetryListener.prototype.onEvent = function(e) {
        if (this.privIsDisposed) return;
        if (e instanceof RecognitionEvents_1.RecognitionTriggeredEvent && e.requestId === this.privRequestId) this.privListeningTriggerMetric = {
            End: e.eventTime,
            Name: "ListeningTrigger",
            Start: e.eventTime
        };
        if (e instanceof Exports_1.AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) this.privMicStartTime = e.eventTime;
        if (e instanceof Exports_1.AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) this.privMicStartTime = e.eventTime;
        if (e instanceof Exports_1.AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId) {
            if (!this.privMicMetric) this.privMicMetric = {
                End: e.eventTime,
                Error: e.error,
                Name: "Microphone",
                Start: this.privMicStartTime
            };
        }
        if (e instanceof Exports_1.AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {
            if (!this.privMicMetric) this.privMicMetric = {
                End: e.eventTime,
                Error: e.error,
                Name: "Microphone",
                Start: this.privMicStartTime
            };
        }
        if (e instanceof Exports_1.AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {
            if (!this.privMicMetric) this.privMicMetric = {
                End: e.eventTime,
                Name: "Microphone",
                Start: this.privMicStartTime
            };
        }
        if (e instanceof RecognitionEvents_1.ConnectingToServiceEvent && e.requestId === this.privRequestId) this.privConnectionId = e.sessionId;
        if (e instanceof Exports_1.ConnectionStartEvent && e.connectionId === this.privConnectionId) this.privConnectionStartTime = e.eventTime;
        if (e instanceof Exports_1.ConnectionEstablishedEvent && e.connectionId === this.privConnectionId) {
            if (!this.privConnectionEstablishMetric) this.privConnectionEstablishMetric = {
                End: e.eventTime,
                Id: this.privConnectionId,
                Name: "Connection",
                Start: this.privConnectionStartTime
            };
        }
        if (e instanceof Exports_1.ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId) {
            if (!this.privConnectionEstablishMetric) this.privConnectionEstablishMetric = {
                End: e.eventTime,
                Error: this.getConnectionError(e.statusCode),
                Id: this.privConnectionId,
                Name: "Connection",
                Start: this.privConnectionStartTime
            };
        }
        if (e instanceof Exports_1.ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId) {
            if (e.message && e.message.headers && e.message.headers.path) {
                if (!this.privReceivedMessages[e.message.headers.path]) this.privReceivedMessages[e.message.headers.path] = new Array();
                var maxMessagesToSend = 50;
                if (this.privReceivedMessages[e.message.headers.path].length < maxMessagesToSend) this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime);
            }
        }
    };
    ServiceTelemetryListener.prototype.getTelemetry = function() {
        var metrics = new Array();
        if (this.privListeningTriggerMetric) metrics.push(this.privListeningTriggerMetric);
        if (this.privMicMetric) metrics.push(this.privMicMetric);
        if (this.privConnectionEstablishMetric) metrics.push(this.privConnectionEstablishMetric);
        if (this.privPhraseLatencies.length > 0) metrics.push({
            PhraseLatencyMs: this.privPhraseLatencies
        });
        if (this.privHypothesisLatencies.length > 0) metrics.push({
            FirstHypothesisLatencyMs: this.privHypothesisLatencies
        });
        var telemetry = {
            Metrics: metrics,
            ReceivedMessages: this.privReceivedMessages
        };
        var json = JSON.stringify(telemetry);
        // We dont want to send the same telemetry again. So clean those out.
        this.privReceivedMessages = {};
        this.privListeningTriggerMetric = null;
        this.privMicMetric = null;
        this.privConnectionEstablishMetric = null;
        this.privPhraseLatencies = [];
        this.privHypothesisLatencies = [];
        return json;
    };
    Object.defineProperty(ServiceTelemetryListener.prototype, "hasTelemetry", {
        // Determines if there are any telemetry events to send to the service.
        get: function() {
            return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;
        },
        enumerable: false,
        configurable: true
    });
    ServiceTelemetryListener.prototype.dispose = function() {
        this.privIsDisposed = true;
    };
    ServiceTelemetryListener.prototype.getConnectionError = function(statusCode) {
        /*
        -- Websocket status codes --
        NormalClosure = 1000,
        EndpointUnavailable = 1001,
        ProtocolError = 1002,
        InvalidMessageType = 1003,
        Empty = 1005,
        InvalidPayloadData = 1007,
        PolicyViolation = 1008,
        MessageTooBig = 1009,
        MandatoryExtension = 1010,
        InternalServerError = 1011
        */ switch(statusCode){
            case 400:
            case 1002:
            case 1003:
            case 1005:
            case 1007:
            case 1008:
            case 1009:
                return "BadRequest";
            case 401:
                return "Unauthorized";
            case 403:
                return "Forbidden";
            case 503:
            case 1001:
                return "ServerUnavailable";
            case 500:
            case 1011:
                return "ServerError";
            case 408:
            case 504:
                return "Timeout";
            default:
                return "statuscode:" + statusCode.toString();
        }
    };
    return ServiceTelemetryListener;
}();
exports.ServiceTelemetryListener = ServiceTelemetryListener;

},{"828636b8ffce1248":"5Bedw","8940c05672a64495":"josuk"}],"10zvM":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeechContext = void 0;
/**
 * Represents the JSON used in the speech.context message sent to the speech service.
 * The dynamic grammar is always refreshed from the encapsulated dynamic grammar object.
 */ var SpeechContext = /** @class */ function() {
    function SpeechContext(dynamicGrammar) {
        this.privContext = {};
        this.privDynamicGrammar = dynamicGrammar;
    }
    /**
     * Gets a section of the speech.context object.
     * @param sectionName Name of the section to get.
     * @return string or Context JSON serializable object that represents the value.
     */ SpeechContext.prototype.getSection = function(sectionName) {
        return this.privContext[sectionName] || {};
    };
    /**
     * Adds a section to the speech.context object.
     * @param sectionName Name of the section to add.
     * @param value JSON serializable object that represents the value.
     */ SpeechContext.prototype.setSection = function(sectionName, value) {
        this.privContext[sectionName] = value;
    };
    /**
     * @Internal
     * This is only used by pronunciation assessment config.
     * Do not use externally, object returned will change without warning or notice.
     */ SpeechContext.prototype.setPronunciationAssessmentParams = function(params, isSpeakerDiarizationEnabled) {
        if (isSpeakerDiarizationEnabled === void 0) isSpeakerDiarizationEnabled = false;
        if (this.privContext.phraseDetection === undefined) this.privContext.phraseDetection = {
            enrichment: {
                pronunciationAssessment: {}
            }
        };
        if (this.privContext.phraseDetection.enrichment === undefined) this.privContext.phraseDetection.enrichment = {
            pronunciationAssessment: {}
        };
        this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(params);
        if (isSpeakerDiarizationEnabled) this.privContext.phraseDetection.mode = "Conversation";
        this.setWordLevelTimings();
        this.privContext.phraseOutput.detailed.options.push("PronunciationAssessment");
        if (this.privContext.phraseOutput.detailed.options.indexOf("SNR") === -1) this.privContext.phraseOutput.detailed.options.push("SNR");
    };
    SpeechContext.prototype.setDetailedOutputFormat = function() {
        if (this.privContext.phraseOutput === undefined) this.privContext.phraseOutput = {
            detailed: {
                options: []
            },
            format: {}
        };
        if (this.privContext.phraseOutput.detailed === undefined) this.privContext.phraseOutput.detailed = {
            options: []
        };
        this.privContext.phraseOutput.format = "Detailed";
    };
    SpeechContext.prototype.setWordLevelTimings = function() {
        if (this.privContext.phraseOutput === undefined) this.privContext.phraseOutput = {
            detailed: {
                options: []
            },
            format: {}
        };
        if (this.privContext.phraseOutput.detailed === undefined) this.privContext.phraseOutput.detailed = {
            options: []
        };
        this.privContext.phraseOutput.format = "Detailed";
        if (this.privContext.phraseOutput.detailed.options.indexOf("WordTimings") === -1) this.privContext.phraseOutput.detailed.options.push("WordTimings");
    };
    SpeechContext.prototype.setSpeakerDiarizationAudioOffsetMs = function(audioOffsetMs) {
        this.privContext.phraseDetection.speakerDiarization.audioOffsetMs = audioOffsetMs;
    };
    SpeechContext.prototype.toJSON = function() {
        var dgi = this.privDynamicGrammar.generateGrammarObject();
        this.setSection("dgi", dgi);
        var ret = JSON.stringify(this.privContext);
        return ret;
    };
    return SpeechContext;
}();
exports.SpeechContext = SpeechContext;

},{}],"8XnIu":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DynamicGrammarBuilder = void 0;
/**
 * Responsible for building the object to be sent to the speech service to support dynamic grammars.
 * @class DynamicGrammarBuilder
 */ var DynamicGrammarBuilder = /** @class */ function() {
    function DynamicGrammarBuilder() {}
    // Adds one more reference phrases to the dynamic grammar to send.
    // All added phrases are generic phrases.
    DynamicGrammarBuilder.prototype.addPhrase = function(phrase) {
        if (!this.privPhrases) this.privPhrases = [];
        if (phrase instanceof Array) this.privPhrases = this.privPhrases.concat(phrase);
        else this.privPhrases.push(phrase);
    };
    // Clears all phrases stored in the current object.
    DynamicGrammarBuilder.prototype.clearPhrases = function() {
        this.privPhrases = undefined;
    };
    // Adds one or more reference grammars to the current grammar.
    DynamicGrammarBuilder.prototype.addReferenceGrammar = function(grammar) {
        if (!this.privGrammars) this.privGrammars = [];
        if (grammar instanceof Array) this.privGrammars = this.privGrammars.concat(grammar);
        else this.privGrammars.push(grammar);
    };
    // clears all grammars stored on the recognizer.
    DynamicGrammarBuilder.prototype.clearGrammars = function() {
        this.privGrammars = undefined;
    };
    // Generates an object that represents the dynamic grammar used by the Speech Service.
    // This is done by building an object with the correct layout based on the phrases and reference grammars added to this instance
    // of a DynamicGrammarBuilder
    DynamicGrammarBuilder.prototype.generateGrammarObject = function() {
        if (this.privGrammars === undefined && this.privPhrases === undefined) return undefined;
        var retObj = {};
        retObj.ReferenceGrammars = this.privGrammars;
        if (undefined !== this.privPhrases && 0 !== this.privPhrases.length) {
            var retPhrases_1 = [];
            this.privPhrases.forEach(function(value) {
                retPhrases_1.push({
                    Text: value
                });
            });
            retObj.Groups = [
                {
                    Type: "Generic",
                    Items: retPhrases_1
                }
            ];
        }
        return retObj;
    };
    return DynamicGrammarBuilder;
}();
exports.DynamicGrammarBuilder = DynamicGrammarBuilder;

},{}],"bM9va":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"ikpLJ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DialogServiceAdapter = void 0;
var Exports_1 = require("e553b4c21cf74213");
var DialogEvents_1 = require("2fb55381d606a93f");
var Exports_2 = require("2398b15daef7bf30");
var AudioOutputFormat_1 = require("456a1e71b78802d7");
var Exports_3 = require("bb7e194d00f7d685");
var DialogServiceTurnStateManager_1 = require("ea730eba7ce23bd5");
var Exports_4 = require("46e9305dcef85f79");
var ActivityResponsePayload_1 = require("359a35a81e474469");
var SpeechConnectionMessage_Internal_1 = require("8a8ad3c163360450");
var DialogServiceAdapter = /** @class */ function(_super) {
    __extends(DialogServiceAdapter, _super);
    function DialogServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {
        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) || this;
        _this.privEvents = new Exports_2.EventSource();
        _this.privDialogServiceConnector = dialogServiceConnector;
        _this.receiveMessageOverride = function() {
            return _this.receiveDialogMessageOverride();
        };
        _this.privTurnStateManager = new DialogServiceTurnStateManager_1.DialogServiceTurnStateManager();
        _this.recognizeOverride = function(recoMode, successCallback, errorCallback) {
            return _this.listenOnce(recoMode, successCallback, errorCallback);
        };
        _this.postConnectImplOverride = function(connection) {
            return _this.dialogConnectImpl(connection);
        };
        _this.configConnectionOverride = function(connection) {
            return _this.configConnection(connection);
        };
        _this.disconnectOverride = function() {
            return _this.privDisconnect();
        };
        _this.privDialogAudioSource = audioSource;
        _this.agentConfigSent = false;
        _this.privLastResult = null;
        _this.connectionEvents.attach(function(connectionEvent) {
            if (connectionEvent.name === "ConnectionClosedEvent") _this.terminateMessageLoop = true;
        });
        return _this;
    }
    DialogServiceAdapter.prototype.sendMessage = function(message) {
        return __awaiter(this, void 0, void 0, function() {
            var interactionGuid, requestId, agentMessage, agentMessageJson, connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        interactionGuid = Exports_2.createGuid();
                        requestId = Exports_2.createNoDashGuid();
                        agentMessage = {
                            context: {
                                interactionId: interactionGuid
                            },
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                            messagePayload: JSON.parse(message),
                            version: 0.5
                        };
                        agentMessageJson = JSON.stringify(agentMessage);
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, "agent", requestId, "application/json", agentMessageJson))
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    DialogServiceAdapter.prototype.privDisconnect = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.NoError, "Disconnecting")
                        ];
                    case 1:
                        _a.sent();
                        this.terminateMessageLoop = true;
                        this.agentConfigSent = false;
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    DialogServiceAdapter.prototype.processTypeSpecificMessages = function(connectionMessage) {
        var resultProps = new Exports_3.PropertyCollection();
        if (connectionMessage.messageType === Exports_2.MessageType.Text) resultProps.setProperty(Exports_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
        var result;
        var processed;
        switch(connectionMessage.path.toLowerCase()){
            case "speech.phrase":
                var speechPhrase = Exports_4.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);
                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);
                if (speechPhrase.RecognitionStatus !== Exports_4.RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== Exports_4.RecognitionStatus.Error) {
                    var args = this.fireEventForResult(speechPhrase, resultProps);
                    this.privLastResult = args.result;
                    if (!!this.privDialogServiceConnector.recognized) try {
                        this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);
                    /* eslint-disable no-empty */ } catch (error) {
                    // Not going to let errors in the event handler
                    // trip things up.
                    }
                }
                processed = true;
                break;
            case "speech.hypothesis":
                var hypothesis = Exports_4.SpeechHypothesis.fromJSON(connectionMessage.textBody);
                var offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;
                result = new Exports_3.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_3.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);
                this.privRequestSession.onHypothesis(offset);
                var ev = new Exports_3.SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);
                if (!!this.privDialogServiceConnector.recognizing) try {
                    this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);
                /* eslint-disable no-empty */ } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
                }
                processed = true;
                break;
            case "speech.keyword":
                var keyword = Exports_4.SpeechKeyword.fromJSON(connectionMessage.textBody);
                result = new Exports_3.SpeechRecognitionResult(this.privRequestSession.requestId, keyword.Status === "Accepted" ? Exports_3.ResultReason.RecognizedKeyword : Exports_3.ResultReason.NoMatch, keyword.Text, keyword.Duration, keyword.Offset, undefined, undefined, undefined, undefined, connectionMessage.textBody, resultProps);
                if (keyword.Status !== "Accepted") this.privLastResult = result;
                var event_1 = new Exports_3.SpeechRecognitionEventArgs(result, result.duration, result.resultId);
                if (!!this.privDialogServiceConnector.recognized) try {
                    this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event_1);
                /* eslint-disable no-empty */ } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
                }
                processed = true;
                break;
            case "audio":
                var audioRequestId = connectionMessage.requestId.toUpperCase();
                var turn = this.privTurnStateManager.GetTurn(audioRequestId);
                try {
                    // Empty binary message signals end of stream.
                    if (!connectionMessage.binaryBody) turn.endAudioStream();
                    else turn.audioStream.write(connectionMessage.binaryBody);
                } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
                }
                processed = true;
                break;
            case "response":
                this.handleResponseMessage(connectionMessage);
                processed = true;
                break;
            default:
                break;
        }
        var defferal = new Exports_2.Deferred();
        defferal.resolve(processed);
        return defferal.promise;
    };
    // Cancels recognition.
    DialogServiceAdapter.prototype.cancelRecognition = function(sessionId, requestId, cancellationReason, errorCode, error) {
        return __awaiter(this, void 0, void 0, function() {
            var properties, cancelEvent, result;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.terminateMessageLoop = true;
                        if (!!!this.privRequestSession.isRecognizing) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onStopRecognizing()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!!this.privDialogServiceConnector.canceled) {
                            properties = new Exports_3.PropertyCollection();
                            properties.setProperty(Exports_4.CancellationErrorCodePropertyName, Exports_3.CancellationErrorCode[errorCode]);
                            cancelEvent = new Exports_3.SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
                            try {
                                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);
                            /* eslint-disable no-empty */ } catch (_b) {}
                            if (!!this.privSuccessCallback) {
                                result = new Exports_3.SpeechRecognitionResult(undefined, Exports_3.ResultReason.Canceled, undefined, undefined, undefined, undefined, undefined, undefined, error, undefined, properties);
                                try {
                                    this.privSuccessCallback(result);
                                    this.privSuccessCallback = undefined;
                                /* eslint-disable no-empty */ } catch (_c) {}
                            }
                        }
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    DialogServiceAdapter.prototype.listenOnce = function(recoMode, successCallback, errorCallback) {
        return __awaiter(this, void 0, void 0, function() {
            var conPromise, preAudioPromise, node, format, deviceInfo, audioNode, error_1, sessionStartEventArgs, audioSendPromise;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.privRecognizerConfig.recognitionMode = recoMode;
                        this.privSuccessCallback = successCallback;
                        this.privErrorCallback = errorCallback;
                        this.privRequestSession.startNewRecognition();
                        this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);
                        this.privRecognizerConfig.parameters.setProperty(Exports_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
                        conPromise = this.connectImpl();
                        preAudioPromise = this.sendPreAudioMessages();
                        return [
                            4 /*yield*/ ,
                            this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId)
                        ];
                    case 1:
                        node = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privDialogAudioSource.format
                        ];
                    case 2:
                        format = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privDialogAudioSource.deviceInfo
                        ];
                    case 3:
                        deviceInfo = _a.sent();
                        audioNode = new Exports_1.ReplayableAudioNode(node, format.avgBytesPerSec);
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false)
                        ];
                    case 4:
                        _a.sent();
                        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {
                            source: deviceInfo
                        };
                        _a.label = 5;
                    case 5:
                        _a.trys.push([
                            5,
                            8,
                            ,
                            10
                        ]);
                        return [
                            4 /*yield*/ ,
                            conPromise
                        ];
                    case 6:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            preAudioPromise
                        ];
                    case 7:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            10
                        ];
                    case 8:
                        error_1 = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.ConnectionFailure, error_1)
                        ];
                    case 9:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            Promise.resolve()
                        ];
                    case 10:
                        sessionStartEventArgs = new Exports_3.SessionEventArgs(this.privRequestSession.sessionId);
                        if (!!this.privRecognizer.sessionStarted) this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
                        audioSendPromise = this.sendAudio(audioNode);
                        // /* eslint-disable no-empty */
                        audioSendPromise.then(function() {}, function(error) {
                            return __awaiter(_this, void 0, void 0, function() {
                                return __generator(this, function(_a) {
                                    switch(_a.label){
                                        case 0:
                                            return [
                                                4 /*yield*/ ,
                                                this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error)
                                            ];
                                        case 1:
                                            _a.sent();
                                            return [
                                                2 /*return*/ 
                                            ];
                                    }
                                });
                            });
                        });
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    // Establishes a websocket connection to the end point.
    DialogServiceAdapter.prototype.dialogConnectImpl = function(connection) {
        this.privConnectionLoop = this.startMessageLoop();
        return connection;
    };
    DialogServiceAdapter.prototype.receiveDialogMessageOverride = function() {
        var _this = this;
        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages
        var communicationCustodian = new Exports_2.Deferred();
        var loop = function() {
            return __awaiter(_this, void 0, void 0, function() {
                var isDisposed, terminateMessageLoop, connection, message, connectionMessage, _a, turnRequestId, audioSessionReqId, speechStartDetected, speechStartEventArgs, json, speechStopDetected, speechStopEventArgs, turnEndRequestId, audioSessionReqId, sessionStopEventArgs, processed, e_1, ret, error_2;
                return __generator(this, function(_b) {
                    switch(_b.label){
                        case 0:
                            _b.trys.push([
                                0,
                                14,
                                ,
                                15
                            ]);
                            isDisposed = this.isDisposed();
                            terminateMessageLoop = !this.isDisposed() && this.terminateMessageLoop;
                            if (isDisposed || terminateMessageLoop) {
                                // We're done.
                                communicationCustodian.resolve(undefined);
                                return [
                                    2 /*return*/ 
                                ];
                            }
                            return [
                                4 /*yield*/ ,
                                this.fetchConnection()
                            ];
                        case 1:
                            connection = _b.sent();
                            return [
                                4 /*yield*/ ,
                                connection.read()
                            ];
                        case 2:
                            message = _b.sent();
                            if (!message) return [
                                2 /*return*/ ,
                                loop()
                            ];
                            connectionMessage = SpeechConnectionMessage_Internal_1.SpeechConnectionMessage.fromConnectionMessage(message);
                            _a = connectionMessage.path.toLowerCase();
                            switch(_a){
                                case "turn.start":
                                    return [
                                        3 /*break*/ ,
                                        3
                                    ];
                                case "speech.startdetected":
                                    return [
                                        3 /*break*/ ,
                                        4
                                    ];
                                case "speech.enddetected":
                                    return [
                                        3 /*break*/ ,
                                        5
                                    ];
                                case "turn.end":
                                    return [
                                        3 /*break*/ ,
                                        6
                                    ];
                            }
                            return [
                                3 /*break*/ ,
                                10
                            ];
                        case 3:
                            turnRequestId = connectionMessage.requestId.toUpperCase();
                            audioSessionReqId = this.privRequestSession.requestId.toUpperCase();
                            // turn started by the service
                            if (turnRequestId !== audioSessionReqId) this.privTurnStateManager.StartTurn(turnRequestId);
                            else this.privRequestSession.onServiceTurnStartResponse();
                            return [
                                3 /*break*/ ,
                                13
                            ];
                        case 4:
                            speechStartDetected = Exports_4.SpeechDetected.fromJSON(connectionMessage.textBody);
                            speechStartEventArgs = new Exports_3.RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);
                            if (!!this.privRecognizer.speechStartDetected) this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);
                            return [
                                3 /*break*/ ,
                                13
                            ];
                        case 5:
                            json = void 0;
                            if (connectionMessage.textBody.length > 0) json = connectionMessage.textBody;
                            else // If the request was empty, the JSON returned is empty.
                            json = "{ Offset: 0 }";
                            speechStopDetected = Exports_4.SpeechDetected.fromJSON(json);
                            this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);
                            speechStopEventArgs = new Exports_3.RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
                            if (!!this.privRecognizer.speechEndDetected) this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);
                            return [
                                3 /*break*/ ,
                                13
                            ];
                        case 6:
                            turnEndRequestId = connectionMessage.requestId.toUpperCase();
                            audioSessionReqId = this.privRequestSession.requestId.toUpperCase();
                            if (!(turnEndRequestId !== audioSessionReqId)) return [
                                3 /*break*/ ,
                                7
                            ];
                            this.privTurnStateManager.CompleteTurn(turnEndRequestId);
                            return [
                                3 /*break*/ ,
                                9
                            ];
                        case 7:
                            sessionStopEventArgs = new Exports_3.SessionEventArgs(this.privRequestSession.sessionId);
                            return [
                                4 /*yield*/ ,
                                this.privRequestSession.onServiceTurnEndResponse(false)
                            ];
                        case 8:
                            _b.sent();
                            if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
                                if (!!this.privRecognizer.sessionStopped) this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);
                            }
                            // report result to promise.
                            if (!!this.privSuccessCallback && this.privLastResult) {
                                try {
                                    this.privSuccessCallback(this.privLastResult);
                                    this.privLastResult = null;
                                } catch (e) {
                                    if (!!this.privErrorCallback) this.privErrorCallback(e);
                                }
                                // Only invoke the call back once.
                                // and if it's successful don't invoke the
                                // error after that.
                                this.privSuccessCallback = undefined;
                                this.privErrorCallback = undefined;
                            }
                            _b.label = 9;
                        case 9:
                            return [
                                3 /*break*/ ,
                                13
                            ];
                        case 10:
                            _b.trys.push([
                                10,
                                12,
                                ,
                                13
                            ]);
                            return [
                                4 /*yield*/ ,
                                this.processTypeSpecificMessages(connectionMessage)
                            ];
                        case 11:
                            processed = _b.sent();
                            if (!processed) {
                                if (!!this.serviceEvents) this.serviceEvents.onEvent(new Exports_2.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
                            }
                            return [
                                3 /*break*/ ,
                                13
                            ];
                        case 12:
                            e_1 = _b.sent();
                            return [
                                3 /*break*/ ,
                                13
                            ];
                        case 13:
                            ret = loop();
                            return [
                                2 /*return*/ ,
                                ret
                            ];
                        case 14:
                            error_2 = _b.sent();
                            this.terminateMessageLoop = true;
                            communicationCustodian.resolve();
                            return [
                                3 /*break*/ ,
                                15
                            ];
                        case 15:
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        };
        loop().catch(function(reason) {
            Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));
        });
        return communicationCustodian.promise;
    };
    DialogServiceAdapter.prototype.startMessageLoop = function() {
        return __awaiter(this, void 0, void 0, function() {
            var error_3;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.terminateMessageLoop = false;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            3,
                            ,
                            5
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.receiveDialogMessageOverride()
                        ];
                    case 2:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 3:
                        error_3 = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error_3)
                        ];
                    case 4:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 5:
                        return [
                            2 /*return*/ ,
                            Promise.resolve()
                        ];
                }
            });
        });
    };
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    DialogServiceAdapter.prototype.configConnection = function(connection) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.terminateMessageLoop) {
                            this.terminateMessageLoop = false;
                            return [
                                2 /*return*/ ,
                                Promise.reject("Connection to service terminated.")
                            ];
                        }
                        return [
                            4 /*yield*/ ,
                            this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize())
                        ];
                    case 1:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendAgentConfig(connection)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            connection
                        ];
                }
            });
        });
    };
    DialogServiceAdapter.prototype.sendPreAudioMessages = function() {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        this.addKeywordContextData();
                        return [
                            4 /*yield*/ ,
                            this.sendSpeechContext(connection, true)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendAgentContext(connection)
                        ];
                    case 3:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendWaveHeader(connection)
                        ];
                    case 4:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    DialogServiceAdapter.prototype.sendAgentConfig = function(connection) {
        if (this.agentConfig && !this.agentConfigSent) {
            if (this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.Conversation_DialogType) === Exports_3.DialogServiceConfig.DialogTypes.CustomCommands) {
                var config = this.agentConfig.get();
                config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage, "en-us");
                this.agentConfig.set(config);
            }
            this.onEvent(new DialogEvents_1.SendingAgentContextMessageEvent(this.agentConfig));
            var agentConfigJson = this.agentConfig.toJsonString();
            // guard against sending this multiple times on one connection
            this.agentConfigSent = true;
            return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, "agent.config", this.privRequestSession.requestId, "application/json", agentConfigJson));
        }
        return;
    };
    DialogServiceAdapter.prototype.sendAgentContext = function(connection) {
        var guid = Exports_2.createGuid();
        var speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(Exports_3.PropertyId.Conversation_Speech_Activity_Template);
        var agentContext = {
            channelData: "",
            context: {
                interactionId: guid
            },
            messagePayload: speechActivityTemplate,
            version: 0.5
        };
        var agentContextJson = JSON.stringify(agentContext);
        return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, "speech.agent.context", this.privRequestSession.requestId, "application/json", agentContextJson));
    };
    DialogServiceAdapter.prototype.fireEventForResult = function(serviceResult, properties) {
        var resultReason = Exports_4.EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);
        var offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;
        var result = new Exports_3.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, undefined, undefined, JSON.stringify(serviceResult), properties);
        var ev = new Exports_3.SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);
        return ev;
    };
    DialogServiceAdapter.prototype.handleResponseMessage = function(responseMessage) {
        // "response" messages can contain either "message" (activity) or "MessageStatus" data. Fire the appropriate
        // event according to the message type that's specified.
        var responsePayload = JSON.parse(responseMessage.textBody);
        switch(responsePayload.messageType.toLowerCase()){
            case "message":
                var responseRequestId = responseMessage.requestId.toUpperCase();
                var activityPayload = ActivityResponsePayload_1.ActivityPayloadResponse.fromJSON(responseMessage.textBody);
                var turn = this.privTurnStateManager.GetTurn(responseRequestId);
                // update the conversation Id
                if (activityPayload.conversationId) {
                    var updateAgentConfig = this.agentConfig.get();
                    updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;
                    this.agentConfig.set(updateAgentConfig);
                }
                var pullAudioOutputStream = turn.processActivityPayload(activityPayload, AudioOutputFormat_1.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));
                var activity = new Exports_3.ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);
                if (!!this.privDialogServiceConnector.activityReceived) try {
                    this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);
                /* eslint-disable-next-line no-empty */ } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
                }
                break;
            case "messagestatus":
                if (!!this.privDialogServiceConnector.turnStatusReceived) try {
                    this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new Exports_3.TurnStatusReceivedEventArgs(responseMessage.textBody));
                /* eslint-disable-next-line no-empty */ } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
                }
                break;
            default:
                Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent("Unexpected response of type " + responsePayload.messageType + ". Ignoring."));
                break;
        }
    };
    DialogServiceAdapter.prototype.onEvent = function(event) {
        this.privEvents.onEvent(event);
        Exports_2.Events.instance.onEvent(event);
    };
    DialogServiceAdapter.prototype.addKeywordContextData = function() {
        var keywordPropertyValue = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect");
        if (keywordPropertyValue === undefined) return;
        var keywordOffsetPropertyValue = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Offsets");
        var keywordDurationPropertyValue = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Durations");
        var keywords = keywordPropertyValue.split(";");
        var keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(";");
        var keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(";");
        var keywordDefinitionArray = [];
        for(var i = 0; i < keywords.length; i++){
            var definition = {};
            definition.text = keywords[i];
            if (i < keywordOffsets.length) definition.offset = Number(keywordOffsets[i]);
            if (i < keywordDurations.length) definition.duration = Number(keywordDurations[i]);
            keywordDefinitionArray.push(definition);
        }
        this.speechContext.setSection("invocationSource", "VoiceActivationWithKeyword");
        this.speechContext.setSection("keywordDetection", [
            {
                clientDetectedKeywords: keywordDefinitionArray,
                onReject: {
                    action: "EndOfTurn"
                },
                type: "startTrigger"
            }
        ]);
    };
    return DialogServiceAdapter;
}(Exports_4.ServiceRecognizerBase);
exports.DialogServiceAdapter = DialogServiceAdapter;

},{"e553b4c21cf74213":"9oZeQ","2fb55381d606a93f":"cBT2n","2398b15daef7bf30":"5Bedw","456a1e71b78802d7":"lrOQK","bb7e194d00f7d685":"hxkc3","ea730eba7ce23bd5":"c2GmJ","46e9305dcef85f79":"7Qpvn","359a35a81e474469":"5Qw5j","8a8ad3c163360450":"euGGf"}],"c2GmJ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DialogServiceTurnStateManager = void 0;
var Error_1 = require("6de46fbcd69c45e9");
var DialogServiceTurnState_1 = require("f2b74a0cf3c0c145");
var DialogServiceTurnStateManager = /** @class */ function() {
    function DialogServiceTurnStateManager() {
        this.privTurnMap = new Map();
        return;
    }
    DialogServiceTurnStateManager.prototype.StartTurn = function(id) {
        if (this.privTurnMap.has(id)) throw new Error_1.InvalidOperationError("Service error: There is already a turn with id:" + id);
        var turnState = new DialogServiceTurnState_1.DialogServiceTurnState(this, id);
        this.privTurnMap.set(id, turnState);
        return this.privTurnMap.get(id);
    };
    DialogServiceTurnStateManager.prototype.GetTurn = function(id) {
        return this.privTurnMap.get(id);
    };
    DialogServiceTurnStateManager.prototype.CompleteTurn = function(id) {
        if (!this.privTurnMap.has(id)) throw new Error_1.InvalidOperationError("Service error: Received turn end for an unknown turn id:" + id);
        var turnState = this.privTurnMap.get(id);
        turnState.complete();
        this.privTurnMap.delete(id);
        return turnState;
    };
    return DialogServiceTurnStateManager;
}();
exports.DialogServiceTurnStateManager = DialogServiceTurnStateManager;

},{"6de46fbcd69c45e9":"fyy92","f2b74a0cf3c0c145":"6DFJO"}],"6DFJO":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DialogServiceTurnState = void 0;
var AudioOutputFormat_1 = require("5c2501a7e51a65cf");
var AudioOutputStream_1 = require("6fa342afa115cf18");
var ActivityResponsePayload_1 = require("3c5c46fc2f5d4da9");
var DialogServiceTurnState = /** @class */ function() {
    function DialogServiceTurnState(manager, requestId) {
        this.privRequestId = requestId;
        this.privIsCompleted = false;
        this.privAudioStream = null;
        this.privTurnManager = manager;
        this.resetTurnEndTimeout();
    }
    Object.defineProperty(DialogServiceTurnState.prototype, "audioStream", {
        get: function() {
            // Called when is needed to stream.
            this.resetTurnEndTimeout();
            return this.privAudioStream;
        },
        enumerable: false,
        configurable: true
    });
    DialogServiceTurnState.prototype.processActivityPayload = function(payload, audioFormat) {
        if (payload.messageDataStreamType === ActivityResponsePayload_1.MessageDataStreamType.TextToSpeechAudio) {
            this.privAudioStream = AudioOutputStream_1.AudioOutputStream.createPullStream();
            this.privAudioStream.format = audioFormat !== undefined ? audioFormat : AudioOutputFormat_1.AudioOutputFormatImpl.getDefaultOutputFormat();
        }
        return this.privAudioStream;
    };
    DialogServiceTurnState.prototype.endAudioStream = function() {
        if (this.privAudioStream !== null && !this.privAudioStream.isClosed) this.privAudioStream.close();
    };
    DialogServiceTurnState.prototype.complete = function() {
        if (this.privTimeoutToken !== undefined) // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        clearTimeout(this.privTimeoutToken);
        this.endAudioStream();
    };
    DialogServiceTurnState.prototype.resetTurnEndTimeout = function() {
        var _this = this;
        if (this.privTimeoutToken !== undefined) // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        clearTimeout(this.privTimeoutToken);
        this.privTimeoutToken = setTimeout(function() {
            _this.privTurnManager.CompleteTurn(_this.privRequestId);
            return;
        }, 2000);
    };
    return DialogServiceTurnState;
}();
exports.DialogServiceTurnState = DialogServiceTurnState;

},{"5c2501a7e51a65cf":"lrOQK","6fa342afa115cf18":"budsd","3c5c46fc2f5d4da9":"5Qw5j"}],"5Qw5j":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// response
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MessageDataStreamType = exports.ActivityPayloadResponse = void 0;
var ActivityPayloadResponse = /** @class */ function() {
    function ActivityPayloadResponse(json) {
        this.privActivityResponse = JSON.parse(json);
    }
    ActivityPayloadResponse.fromJSON = function(json) {
        return new ActivityPayloadResponse(json);
    };
    Object.defineProperty(ActivityPayloadResponse.prototype, "conversationId", {
        get: function() {
            return this.privActivityResponse.conversationId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ActivityPayloadResponse.prototype, "messageDataStreamType", {
        get: function() {
            return this.privActivityResponse.messageDataStreamType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ActivityPayloadResponse.prototype, "messagePayload", {
        get: function() {
            return this.privActivityResponse.messagePayload;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ActivityPayloadResponse.prototype, "version", {
        get: function() {
            return this.privActivityResponse.version;
        },
        enumerable: false,
        configurable: true
    });
    return ActivityPayloadResponse;
}();
exports.ActivityPayloadResponse = ActivityPayloadResponse;
var MessageDataStreamType;
(function(MessageDataStreamType) {
    MessageDataStreamType[MessageDataStreamType["None"] = 0] = "None";
    MessageDataStreamType[MessageDataStreamType["TextToSpeechAudio"] = 1] = "TextToSpeechAudio";
})(MessageDataStreamType = exports.MessageDataStreamType || (exports.MessageDataStreamType = {}));

},{}],"2G6zp":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AgentConfig = void 0;
/**
 * Represents the JSON used in the agent.config message sent to the speech service.
 */ var AgentConfig = /** @class */ function() {
    function AgentConfig() {}
    AgentConfig.prototype.toJsonString = function() {
        return JSON.stringify(this.iPrivConfig);
    };
    AgentConfig.prototype.get = function() {
        return this.iPrivConfig;
    };
    /**
     * Setter for the agent.config object.
     * @param value a JSON serializable object.
     */ AgentConfig.prototype.set = function(value) {
        this.iPrivConfig = value;
    };
    return AgentConfig;
}();
exports.AgentConfig = AgentConfig;

},{}],"6ZKjA":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
var ConversationManager_1 = require("6b3b61030df0128");
Object.defineProperty(exports, "ConversationManager", {
    enumerable: true,
    get: function() {
        return ConversationManager_1.ConversationManager;
    }
});
var ConversationConnectionConfig_1 = require("c1a156be1c97b549");
Object.defineProperty(exports, "ConversationConnectionConfig", {
    enumerable: true,
    get: function() {
        return ConversationConnectionConfig_1.ConversationConnectionConfig;
    }
});
var ConversationTranslatorRecognizer_1 = require("fea3bf2d4b8a4461");
Object.defineProperty(exports, "ConversationRecognizerFactory", {
    enumerable: true,
    get: function() {
        return ConversationTranslatorRecognizer_1.ConversationRecognizerFactory;
    }
});
var TranscriberRecognizer_1 = require("937ddf3740e674e2");
Object.defineProperty(exports, "TranscriberRecognizer", {
    enumerable: true,
    get: function() {
        return TranscriberRecognizer_1.TranscriberRecognizer;
    }
});
var ConversationTranslatorEventArgs_1 = require("98ba16285934f75e");
Object.defineProperty(exports, "ConversationReceivedTranslationEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs;
    }
});
Object.defineProperty(exports, "LockRoomEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationTranslatorEventArgs_1.LockRoomEventArgs;
    }
});
Object.defineProperty(exports, "MuteAllEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationTranslatorEventArgs_1.MuteAllEventArgs;
    }
});
Object.defineProperty(exports, "ParticipantAttributeEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs;
    }
});
Object.defineProperty(exports, "ParticipantEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationTranslatorEventArgs_1.ParticipantEventArgs;
    }
});
Object.defineProperty(exports, "ParticipantsListEventArgs", {
    enumerable: true,
    get: function() {
        return ConversationTranslatorEventArgs_1.ParticipantsListEventArgs;
    }
});
var ConversationTranslatorInterfaces_1 = require("a573d34fad6c7f5a");
Object.defineProperty(exports, "ConversationTranslatorCommandTypes", {
    enumerable: true,
    get: function() {
        return ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes;
    }
});
Object.defineProperty(exports, "ConversationTranslatorMessageTypes", {
    enumerable: true,
    get: function() {
        return ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes;
    }
});
Object.defineProperty(exports, "InternalParticipants", {
    enumerable: true,
    get: function() {
        return ConversationTranslatorInterfaces_1.InternalParticipants;
    }
});

},{"6b3b61030df0128":"j5VEJ","c1a156be1c97b549":"4maUi","fea3bf2d4b8a4461":"ibb3u","937ddf3740e674e2":"d1Czv","98ba16285934f75e":"canv9","a573d34fad6c7f5a":"XmN3G"}],"j5VEJ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationManager = void 0;
var Exports_1 = require("83f542c29eaa46c8");
var Contracts_1 = require("835ebcf4ddee106c");
var Exports_2 = require("b813a222da111080");
var ConversationConnectionConfig_1 = require("4fde7532c400a1a4");
var ConversationManager = /** @class */ function() {
    function ConversationManager() {
        //
        this.privRequestParams = ConversationConnectionConfig_1.ConversationConnectionConfig.configParams;
        this.privErrors = ConversationConnectionConfig_1.ConversationConnectionConfig.restErrors;
        this.privHost = ConversationConnectionConfig_1.ConversationConnectionConfig.host;
        this.privApiVersion = ConversationConnectionConfig_1.ConversationConnectionConfig.apiVersion;
        this.privRestPath = ConversationConnectionConfig_1.ConversationConnectionConfig.restPath;
        this.privRestAdapter = new Exports_1.RestMessageAdapter({});
    }
    /**
     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.
     * @param args
     * @param conversationCode
     * @param callback
     * @param errorCallback
     */ ConversationManager.prototype.createOrJoin = function(args, conversationCode, cb, err) {
        var _this = this;
        try {
            Contracts_1.Contracts.throwIfNullOrUndefined(args, "args");
            var languageCode = args.getProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage, ConversationConnectionConfig_1.ConversationConnectionConfig.defaultLanguageCode);
            var nickname = args.getProperty(Exports_2.PropertyId.ConversationTranslator_Name, "conversation_host");
            var endpointHost = args.getProperty(Exports_2.PropertyId.ConversationTranslator_Host, this.privHost);
            var correlationId = args.getProperty(Exports_2.PropertyId.ConversationTranslator_CorrelationId);
            var subscriptionKey = args.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Key);
            var subscriptionRegion = args.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Region);
            var authToken = args.getProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token);
            Contracts_1.Contracts.throwIfNullOrWhitespace(languageCode, "languageCode");
            Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
            Contracts_1.Contracts.throwIfNullOrWhitespace(endpointHost, "endpointHost");
            var queryParams = {};
            queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;
            queryParams[this.privRequestParams.languageCode] = languageCode;
            queryParams[this.privRequestParams.nickname] = nickname;
            var headers = {};
            if (correlationId) headers[this.privRequestParams.correlationId] = correlationId;
            headers[this.privRequestParams.clientAppId] = ConversationConnectionConfig_1.ConversationConnectionConfig.clientAppId;
            if (conversationCode !== undefined) queryParams[this.privRequestParams.roomId] = conversationCode;
            else {
                Contracts_1.Contracts.throwIfNullOrUndefined(subscriptionRegion, this.privErrors.authInvalidSubscriptionRegion);
                headers[this.privRequestParams.subscriptionRegion] = subscriptionRegion;
                if (subscriptionKey) headers[this.privRequestParams.subscriptionKey] = subscriptionKey;
                else if (authToken) headers[this.privRequestParams.authorization] = "Bearer " + authToken;
                else Contracts_1.Contracts.throwIfNullOrUndefined(subscriptionKey, this.privErrors.authInvalidSubscriptionKey);
            }
            var config = {};
            config.headers = headers;
            this.privRestAdapter.options = config;
            var endpoint = "https://" + endpointHost + this.privRestPath;
            // TODO: support a proxy and certificate validation
            this.privRestAdapter.request(Exports_1.RestRequestType.Post, endpoint, queryParams, null).then(function(response) {
                var requestId = Exports_1.RestMessageAdapter.extractHeaderValue(_this.privRequestParams.requestId, response.headers);
                if (!response.ok) {
                    if (!!err) {
                        // get the error
                        var errorMessage = _this.privErrors.invalidCreateJoinConversationResponse.replace("{status}", response.status.toString());
                        var errMessageRaw = void 0;
                        try {
                            errMessageRaw = JSON.parse(response.data);
                            errorMessage += " [" + errMessageRaw.error.code + ": " + errMessageRaw.error.message + "]";
                        } catch (e) {
                            errorMessage += " [" + response.data + "]";
                        }
                        if (requestId) errorMessage += " " + requestId;
                        err(errorMessage);
                    }
                    return;
                }
                var conversation = JSON.parse(response.data);
                if (conversation) conversation.requestId = requestId;
                if (!!cb) {
                    try {
                        cb(conversation);
                    } catch (e) {
                        if (!!err) err(e);
                    }
                    cb = undefined;
                }
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            }).catch(function() {});
        } catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                } else err(error);
            }
        }
    };
    /**
     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.
     * @param args
     * @param sessionToken
     * @param callback
     */ ConversationManager.prototype.leave = function(args, sessionToken) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            try {
                Contracts_1.Contracts.throwIfNullOrUndefined(args, _this.privErrors.invalidArgs.replace("{arg}", "config"));
                Contracts_1.Contracts.throwIfNullOrWhitespace(sessionToken, _this.privErrors.invalidArgs.replace("{arg}", "token"));
                var endpointHost = args.getProperty(Exports_2.PropertyId.ConversationTranslator_Host, _this.privHost);
                var correlationId = args.getProperty(Exports_2.PropertyId.ConversationTranslator_CorrelationId);
                var queryParams = {};
                queryParams[_this.privRequestParams.apiVersion] = _this.privApiVersion;
                queryParams[_this.privRequestParams.sessionToken] = sessionToken;
                var headers = {};
                if (correlationId) headers[_this.privRequestParams.correlationId] = correlationId;
                var config = {};
                config.headers = headers;
                _this.privRestAdapter.options = config;
                var endpoint = "https://" + endpointHost + _this.privRestPath;
                // TODO: support a proxy and certificate validation
                _this.privRestAdapter.request(Exports_1.RestRequestType.Delete, endpoint, queryParams, null).then(function(response) {
                    response.ok;
                    resolve();
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                }).catch(function() {});
            } catch (error) {
                if (error instanceof Error) {
                    var typedError = error;
                    reject(typedError.name + ": " + typedError.message);
                } else reject(error);
            }
        });
    };
    return ConversationManager;
}();
exports.ConversationManager = ConversationManager;

},{"83f542c29eaa46c8":"9oZeQ","835ebcf4ddee106c":"4jwu5","b813a222da111080":"hxkc3","4fde7532c400a1a4":"4maUi"}],"4maUi":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationConnectionConfig = void 0;
var RestConfigBase_1 = require("7ba933feba207509");
var ConversationConnectionConfig = /** @class */ function(_super) {
    __extends(ConversationConnectionConfig, _super);
    function ConversationConnectionConfig() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ConversationConnectionConfig, "host", {
        get: function() {
            return ConversationConnectionConfig.privHost;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationConnectionConfig, "apiVersion", {
        get: function() {
            return ConversationConnectionConfig.privApiVersion;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationConnectionConfig, "clientAppId", {
        get: function() {
            return ConversationConnectionConfig.privClientAppId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationConnectionConfig, "defaultLanguageCode", {
        get: function() {
            return ConversationConnectionConfig.privDefaultLanguageCode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationConnectionConfig, "restPath", {
        get: function() {
            return ConversationConnectionConfig.privRestPath;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationConnectionConfig, "webSocketPath", {
        get: function() {
            return ConversationConnectionConfig.privWebSocketPath;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationConnectionConfig, "transcriptionEventKeys", {
        get: function() {
            return ConversationConnectionConfig.privTranscriptionEventKeys;
        },
        enumerable: false,
        configurable: true
    });
    ConversationConnectionConfig.privHost = "dev.microsofttranslator.com";
    ConversationConnectionConfig.privRestPath = "/capito/room";
    ConversationConnectionConfig.privApiVersion = "2.0";
    ConversationConnectionConfig.privDefaultLanguageCode = "en-US";
    ConversationConnectionConfig.privClientAppId = "FC539C22-1767-4F1F-84BC-B4D811114F15";
    ConversationConnectionConfig.privWebSocketPath = "/capito/translate";
    ConversationConnectionConfig.privTranscriptionEventKeys = [
        "iCalUid",
        "callId",
        "organizer",
        "FLAC",
        "MTUri",
        "DifferentiateGuestSpeakers",
        "audiorecording",
        "Threadid",
        "OrganizerMri",
        "OrganizerTenantId",
        "UserToken"
    ];
    return ConversationConnectionConfig;
}(RestConfigBase_1.RestConfigBase);
exports.ConversationConnectionConfig = ConversationConnectionConfig;

},{"7ba933feba207509":"4qzsv"}],"4qzsv":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RestConfigBase = void 0;
var RestConfigBase = /** @class */ function() {
    function RestConfigBase() {}
    Object.defineProperty(RestConfigBase, "requestOptions", {
        get: function() {
            return RestConfigBase.privDefaultRequestOptions;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RestConfigBase, "configParams", {
        get: function() {
            return RestConfigBase.privDefaultParams;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RestConfigBase, "restErrors", {
        get: function() {
            return RestConfigBase.privRestErrors;
        },
        enumerable: false,
        configurable: true
    });
    RestConfigBase.privDefaultRequestOptions = {
        headers: {
            Accept: "application/json"
        },
        ignoreCache: false,
        timeout: 10000
    };
    RestConfigBase.privRestErrors = {
        authInvalidSubscriptionKey: "You must specify either an authentication token to use, or a Cognitive Speech subscription key.",
        authInvalidSubscriptionRegion: "You must specify the Cognitive Speech region to use.",
        invalidArgs: "Required input not found: {arg}.",
        invalidCreateJoinConversationResponse: "Creating/Joining conversation failed with HTTP {status}.",
        invalidParticipantRequest: "The requested participant was not found.",
        permissionDeniedConnect: "Required credentials not found.",
        permissionDeniedConversation: "Invalid operation: only the host can {command} the conversation.",
        permissionDeniedParticipant: "Invalid operation: only the host can {command} a participant.",
        permissionDeniedSend: "Invalid operation: the conversation is not in a connected state.",
        permissionDeniedStart: "Invalid operation: there is already an active conversation."
    };
    RestConfigBase.privDefaultParams = {
        apiVersion: "api-version",
        authorization: "Authorization",
        clientAppId: "X-ClientAppId",
        contentTypeKey: "Content-Type",
        correlationId: "X-CorrelationId",
        languageCode: "language",
        nickname: "nickname",
        profanity: "profanity",
        requestId: "X-RequestId",
        roomId: "roomid",
        sessionToken: "token",
        subscriptionKey: "Ocp-Apim-Subscription-Key",
        subscriptionRegion: "Ocp-Apim-Subscription-Region",
        token: "X-CapitoToken"
    };
    return RestConfigBase;
}();
exports.RestConfigBase = RestConfigBase;

},{}],"ibb3u":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranslatorRecognizer = exports.ConversationRecognizerFactory = void 0;
// eslint-disable-next-line max-classes-per-file
var Exports_1 = require("45463d2a9cd0e881");
var Exports_2 = require("f7a821cb08aa9add");
var Contracts_1 = require("5ee4407bf965d5ef");
var Exports_3 = require("a511329d7d26468c");
var ConversationConnectionFactory_1 = require("12302ab36406ca7f");
var ConversationServiceAdapter_1 = require("81123e7567d88115");
var ConversationRecognizerFactory = /** @class */ function() {
    function ConversationRecognizerFactory() {}
    ConversationRecognizerFactory.fromConfig = function(conversation, speechConfig, audioConfig) {
        return new ConversationTranslatorRecognizer(conversation, speechConfig, audioConfig);
    };
    return ConversationRecognizerFactory;
}();
exports.ConversationRecognizerFactory = ConversationRecognizerFactory;
/**
 * Sends messages to the Conversation Translator websocket and listens for incoming events containing websocket messages.
 * Based off the recognizers in the SDK folder.
 */ var ConversationTranslatorRecognizer = /** @class */ function(_super) {
    __extends(ConversationTranslatorRecognizer, _super);
    function ConversationTranslatorRecognizer(conversation, speechConfig, audioConfig) {
        var _this = this;
        var serviceConfigImpl = speechConfig;
        Contracts_1.Contracts.throwIfNull(serviceConfigImpl, "speechConfig");
        var conversationImpl = conversation;
        Contracts_1.Contracts.throwIfNull(conversationImpl, "conversationImpl");
        _this = _super.call(this, audioConfig, serviceConfigImpl.properties, new ConversationConnectionFactory_1.ConversationConnectionFactory()) || this;
        _this.privConversation = conversationImpl;
        _this.privIsDisposed = false;
        _this.privProperties = serviceConfigImpl.properties.clone();
        _this.privConnection = Exports_3.Connection.fromRecognizer(_this);
        _this.privSetTimeout = typeof Blob !== "undefined" && typeof Worker !== "undefined" ? Exports_2.Timeout.setTimeout : setTimeout;
        _this.privClearTimeout = typeof Blob !== "undefined" && typeof Worker !== "undefined" ? Exports_2.Timeout.clearTimeout : clearTimeout;
        return _this;
    }
    Object.defineProperty(ConversationTranslatorRecognizer.prototype, "connected", {
        set: function(cb) {
            this.privConnection.connected = cb;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranslatorRecognizer.prototype, "disconnected", {
        set: function(cb) {
            this.privConnection.disconnected = cb;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranslatorRecognizer.prototype, "speechRecognitionLanguage", {
        /**
         * Return the speech language used by the recognizer
         */ get: function() {
            return this.privSpeechRecognitionLanguage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationTranslatorRecognizer.prototype, "properties", {
        /**
         * Return the properties for the recognizer
         */ get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    ConversationTranslatorRecognizer.prototype.isDisposed = function() {
        return this.privIsDisposed;
    };
    /**
     * Connect to the recognizer
     * @param token
     */ ConversationTranslatorRecognizer.prototype.connect = function(token, cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            Contracts_1.Contracts.throwIfNullOrWhitespace(token, "token");
            this.privReco.conversationTranslatorToken = token;
            this.resetConversationTimeout();
            this.privReco.connectAsync(cb, err);
        } catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                } else err(error);
            }
        }
    };
    /**
     * Disconnect from the recognizer
     */ ConversationTranslatorRecognizer.prototype.disconnect = function(cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            if (this.privTimeoutToken !== undefined) // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            this.privClearTimeout(this.privTimeoutToken);
            this.privReco.disconnect().then(function() {
                if (!!cb) cb();
            }, function(error) {
                if (!!err) err(error);
            });
        } catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                } else err(error);
            }
            // Destroy the recognizer.
            this.dispose(true).catch(function(reason) {
                Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));
            });
        }
    };
    /**
     * Send the mute all participants command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */ ConversationTranslatorRecognizer.prototype.sendRequest = function(command, cb, err) {
        try {
            Contracts_1.Contracts.throwIfDisposed(this.privIsDisposed);
            this.sendMessage(command, cb, err);
        } catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                } else err(error);
            }
            // Destroy the recognizer.
            this.dispose(true).catch(function(reason) {
                Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));
            });
        }
    };
    /**
     * Close and dispose the recognizer
     */ ConversationTranslatorRecognizer.prototype.close = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!this.privIsDisposed) return [
                            3 /*break*/ ,
                            2
                        ];
                        if (!!this.privConnection) {
                            this.privConnection.closeConnection();
                            this.privConnection.close();
                        }
                        this.privConnection = undefined;
                        return [
                            4 /*yield*/ ,
                            this.dispose(true)
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Dispose the recognizer
     * @param disposing
     */ ConversationTranslatorRecognizer.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privIsDisposed) return [
                            2 /*return*/ 
                        ];
                        if (!disposing) return [
                            3 /*break*/ ,
                            2
                        ];
                        if (this.privTimeoutToken !== undefined) // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                        this.privClearTimeout(this.privTimeoutToken);
                        this.privIsDisposed = true;
                        if (!!this.privConnection) {
                            this.privConnection.closeConnection();
                            this.privConnection.close();
                            this.privConnection = undefined;
                        }
                        return [
                            4 /*yield*/ ,
                            _super.prototype.dispose.call(this, disposing)
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Create the config for the recognizer
     * @param speechConfig
     */ ConversationTranslatorRecognizer.prototype.createRecognizerConfig = function(speechConfig) {
        return new Exports_1.RecognizerConfig(speechConfig, this.privProperties);
    };
    /**
     * Create the service recognizer.
     * The audio source is redundnant here but is required by the implementation.
     * @param authentication
     * @param connectionFactory
     * @param audioConfig
     * @param recognizerConfig
     */ ConversationTranslatorRecognizer.prototype.createServiceRecognizer = function(authentication, connectionFactory, audioConfig, recognizerConfig) {
        var audioSource = audioConfig;
        return new ConversationServiceAdapter_1.ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);
    };
    ConversationTranslatorRecognizer.prototype.sendMessage = function(msg, cb, err) {
        var withAsync = this.privReco;
        var PromiseToEmptyCallback = function(promise, cb, err) {
            if (promise !== undefined) promise.then(function() {
                try {
                    if (!!cb) cb();
                } catch (e) {
                    if (!!err) err("'Unhandled error on promise callback: " + e + "'");
                }
            }, function(reason) {
                try {
                    if (!!err) err(reason);
                // eslint-disable-next-line no-empty
                } catch (error) {}
            });
            else if (!!err) err("Null promise");
        };
        PromiseToEmptyCallback(withAsync.sendMessageAsync(msg), cb, err);
        this.resetConversationTimeout();
    };
    ConversationTranslatorRecognizer.prototype.resetConversationTimeout = function() {
        var _this = this;
        if (this.privTimeoutToken !== undefined) // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        this.privClearTimeout(this.privTimeoutToken);
        this.privTimeoutToken = this.privSetTimeout(function() {
            _this.sendRequest(_this.privConversation.getKeepAlive());
        }, 60000);
    };
    return ConversationTranslatorRecognizer;
}(Exports_3.Recognizer);
exports.ConversationTranslatorRecognizer = ConversationTranslatorRecognizer;

},{"45463d2a9cd0e881":"7Qpvn","f7a821cb08aa9add":"5Bedw","5ee4407bf965d5ef":"4jwu5","a511329d7d26468c":"hxkc3","12302ab36406ca7f":"al0EX","81123e7567d88115":"7zrLb"}],"al0EX":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationConnectionFactory = void 0;
var Exports_1 = require("60afb1033b34fd88");
var Exports_2 = require("d101829a367d204c");
var Contracts_1 = require("a5f64da8cac52163");
var Exports_3 = require("78c9fa30196146b4");
var ConnectionFactoryBase_1 = require("a700c52ba9827e77");
var ConversationConnectionConfig_1 = require("c325446c6e0e47c4");
var ConversationWebsocketMessageFormatter_1 = require("3ed4f280aa6cbaab");
/**
 * Create a connection to the Conversation Translator websocket for sending instant messages and commands, and for receiving translated messages.
 * The conversation must already have been started or joined.
 */ var ConversationConnectionFactory = /** @class */ function(_super) {
    __extends(ConversationConnectionFactory, _super);
    function ConversationConnectionFactory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ConversationConnectionFactory.prototype.create = function(config, authInfo, connectionId) {
        var endpointHost = config.parameters.getProperty(Exports_3.PropertyId.ConversationTranslator_Host, ConversationConnectionConfig_1.ConversationConnectionConfig.host);
        var correlationId = config.parameters.getProperty(Exports_3.PropertyId.ConversationTranslator_CorrelationId, Exports_2.createGuid());
        var endpoint = "wss://" + endpointHost + ConversationConnectionConfig_1.ConversationConnectionConfig.webSocketPath;
        var token = config.parameters.getProperty(Exports_3.PropertyId.ConversationTranslator_Token, undefined);
        Contracts_1.Contracts.throwIfNullOrUndefined(token, "token");
        var queryParams = {};
        queryParams[ConversationConnectionConfig_1.ConversationConnectionConfig.configParams.apiVersion] = ConversationConnectionConfig_1.ConversationConnectionConfig.apiVersion;
        queryParams[ConversationConnectionConfig_1.ConversationConnectionConfig.configParams.token] = token;
        queryParams[ConversationConnectionConfig_1.ConversationConnectionConfig.configParams.correlationId] = correlationId;
        var enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
        return new Exports_1.WebsocketConnection(endpoint, queryParams, {}, new ConversationWebsocketMessageFormatter_1.ConversationWebsocketMessageFormatter(), Exports_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    };
    return ConversationConnectionFactory;
}(ConnectionFactoryBase_1.ConnectionFactoryBase);
exports.ConversationConnectionFactory = ConversationConnectionFactory;

},{"60afb1033b34fd88":"9oZeQ","d101829a367d204c":"5Bedw","a5f64da8cac52163":"4jwu5","78c9fa30196146b4":"hxkc3","a700c52ba9827e77":"hvoIt","c325446c6e0e47c4":"4maUi","3ed4f280aa6cbaab":"1lHmM"}],"1lHmM":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationWebsocketMessageFormatter = void 0;
var Exports_1 = require("4008e68fb6471ff3");
var ConversationConnectionMessage_1 = require("56b45c0b9e3bd4cf");
/**
 * Based off WebsocketMessageFormatter. The messages for Conversation Translator have some variations from the Speech messages.
 */ var ConversationWebsocketMessageFormatter = /** @class */ function() {
    function ConversationWebsocketMessageFormatter() {}
    /**
     * Format incoming messages: text (speech partial/final, IM) or binary (tts)
     */ ConversationWebsocketMessageFormatter.prototype.toConnectionMessage = function(message) {
        var deferral = new Exports_1.Deferred();
        try {
            if (message.messageType === Exports_1.MessageType.Text) {
                var incomingMessage = new ConversationConnectionMessage_1.ConversationConnectionMessage(message.messageType, message.textContent, {}, message.id);
                deferral.resolve(incomingMessage);
            } else if (message.messageType === Exports_1.MessageType.Binary) deferral.resolve(new ConversationConnectionMessage_1.ConversationConnectionMessage(message.messageType, message.binaryContent, undefined, message.id));
        } catch (e) {
            deferral.reject("Error formatting the message. Error: " + e);
        }
        return deferral.promise;
    };
    /**
     * Format outgoing messages: text (commands or IM)
     */ ConversationWebsocketMessageFormatter.prototype.fromConnectionMessage = function(message) {
        var deferral = new Exports_1.Deferred();
        try {
            if (message.messageType === Exports_1.MessageType.Text) {
                var payload = "" + (message.textBody ? message.textBody : "");
                deferral.resolve(new Exports_1.RawWebsocketMessage(Exports_1.MessageType.Text, payload, message.id));
            }
        } catch (e) {
            deferral.reject("Error formatting the message. " + e);
        }
        return deferral.promise;
    };
    return ConversationWebsocketMessageFormatter;
}();
exports.ConversationWebsocketMessageFormatter = ConversationWebsocketMessageFormatter;

},{"4008e68fb6471ff3":"5Bedw","56b45c0b9e3bd4cf":"fyOjD"}],"fyOjD":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationConnectionMessage = void 0;
var Exports_1 = require("bca756202c537aa7");
var ConversationConnectionMessage = /** @class */ function(_super) {
    __extends(ConversationConnectionMessage, _super);
    function ConversationConnectionMessage(messageType, body, headers, id) {
        var _this = _super.call(this, messageType, body, headers, id) || this;
        var json = JSON.parse(_this.textBody);
        if (json.type !== undefined) _this.privConversationMessageType = json.type;
        return _this;
    }
    Object.defineProperty(ConversationConnectionMessage.prototype, "conversationMessageType", {
        get: function() {
            return this.privConversationMessageType;
        },
        enumerable: false,
        configurable: true
    });
    return ConversationConnectionMessage;
}(Exports_1.ConnectionMessage);
exports.ConversationConnectionMessage = ConversationConnectionMessage;

},{"bca756202c537aa7":"5Bedw"}],"7zrLb":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationServiceAdapter = void 0;
var Exports_1 = require("5a6312ff708c798f");
var Exports_2 = require("a81f6e80ab56df41");
var Exports_3 = require("816126d542ce9bf6");
var ConversationConnectionMessage_1 = require("6361ebba1409411a");
var ConversationRequestSession_1 = require("38095cda4c94a9cf");
var ConversationTranslatorEventArgs_1 = require("ba8a087bb904f35d");
var ConversationTranslatorInterfaces_1 = require("2920f03dd127e8");
var Exports_4 = require("c5731985e24762f9");
/**
 * The service adapter handles sending and receiving messages to the Conversation Translator websocket.
 */ var ConversationServiceAdapter = /** @class */ function(_super) {
    __extends(ConversationServiceAdapter, _super);
    function ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {
        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) || this;
        _this.privConnectionConfigPromise = undefined;
        _this.privLastPartialUtteranceId = "";
        _this.privConversationServiceConnector = conversationServiceConnector;
        _this.privConversationAuthentication = authentication;
        _this.receiveMessageOverride = function() {
            return _this.receiveConversationMessageOverride();
        };
        _this.recognizeOverride = function() {
            return _this.noOp();
        };
        _this.postConnectImplOverride = function(connection) {
            return _this.conversationConnectImpl(connection);
        };
        _this.configConnectionOverride = function() {
            return _this.configConnection();
        };
        _this.disconnectOverride = function() {
            return _this.privDisconnect();
        };
        _this.privConversationRequestSession = new ConversationRequestSession_1.ConversationRequestSession(Exports_1.createNoDashGuid());
        _this.privConversationConnectionFactory = connectionFactory;
        _this.privConversationIsDisposed = false;
        return _this;
    }
    ConversationServiceAdapter.prototype.isDisposed = function() {
        return _super.prototype.isDisposed.call(this) || this.privConversationIsDisposed;
    };
    ConversationServiceAdapter.prototype.dispose = function(reason) {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.privConversationIsDisposed = true;
                        if (!(this.privConnectionConfigPromise !== undefined)) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privConnectionConfigPromise
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            connection.dispose(reason)
                        ];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        return [
                            4 /*yield*/ ,
                            _super.prototype.dispose.call(this, reason)
                        ];
                    case 4:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ConversationServiceAdapter.prototype.sendMessage = function(message) {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            2 /*return*/ ,
                            connection.send(new ConversationConnectionMessage_1.ConversationConnectionMessage(Exports_1.MessageType.Text, message))
                        ];
                }
            });
        });
    };
    ConversationServiceAdapter.prototype.sendMessageAsync = function(message) {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            connection.send(new ConversationConnectionMessage_1.ConversationConnectionMessage(Exports_1.MessageType.Text, message))
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ConversationServiceAdapter.prototype.privDisconnect = function() {
        if (this.terminateMessageLoop) return;
        this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, Exports_2.CancellationReason.Error, Exports_2.CancellationErrorCode.NoError, "Disconnecting");
        this.terminateMessageLoop = true;
        return Promise.resolve();
    };
    // eslint-disable-next-line @typescript-eslint/require-await
    ConversationServiceAdapter.prototype.processTypeSpecificMessages = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                return [
                    2 /*return*/ ,
                    true
                ];
            });
        });
    };
    // Cancels recognition.
    ConversationServiceAdapter.prototype.cancelRecognition = function(sessionId, requestId, cancellationReason, errorCode, error) {
        this.terminateMessageLoop = true;
        var cancelEvent = new Exports_2.ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
        try {
            if (!!this.privConversationServiceConnector.canceled) this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);
        } catch (_a) {
        // continue on error
        }
    };
    /**
     * Establishes a websocket connection to the end point.
     */ ConversationServiceAdapter.prototype.conversationConnectImpl = function(connection) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                this.privConnectionLoop = this.startMessageLoop();
                return [
                    2 /*return*/ ,
                    connection
                ];
            });
        });
    };
    /**
     * Process incoming websocket messages
     */ ConversationServiceAdapter.prototype.receiveConversationMessageOverride = function() {
        return __awaiter(this, void 0, void 0, function() {
            var communicationCustodian, connection, message, sessionId, conversationMessageType, sendFinal, commandPayload_1, participantsPayload, participantsResult, joinParticipantPayload, joiningParticipant, leavingParticipant, disconnectParticipant, token, speechPayload, conversationResultReason, speechResult, textPayload, textResult, e_1;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.isDisposed() || this.terminateMessageLoop) return [
                            2 /*return*/ ,
                            Promise.resolve()
                        ];
                        communicationCustodian = new Exports_1.Deferred();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            4,
                            ,
                            5
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 2:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            connection.read()
                        ];
                    case 3:
                        message = _a.sent();
                        if (this.isDisposed() || this.terminateMessageLoop) {
                            // We're done.
                            communicationCustodian.resolve();
                            return [
                                2 /*return*/ ,
                                Promise.resolve()
                            ];
                        }
                        if (!message) return [
                            2 /*return*/ ,
                            this.receiveConversationMessageOverride()
                        ];
                        sessionId = this.privConversationRequestSession.sessionId;
                        conversationMessageType = message.conversationMessageType.toLowerCase();
                        sendFinal = false;
                        try {
                            switch(conversationMessageType){
                                case "info":
                                case "participant_command":
                                case "command":
                                    commandPayload_1 = Exports_4.CommandResponsePayload.fromJSON(message.textBody);
                                    switch(commandPayload_1.command.toLowerCase()){
                                        /**
                                         * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.
                                         * The consuming client must wait for this message to arrive
                                         * before starting to send their own data.
                                         */ case "participantlist":
                                            participantsPayload = Exports_4.ParticipantsListPayloadResponse.fromJSON(message.textBody);
                                            participantsResult = participantsPayload.participants.map(function(p) {
                                                var participant = {
                                                    avatar: p.avatar,
                                                    displayName: p.nickname,
                                                    id: p.participantId,
                                                    isHost: p.ishost,
                                                    isMuted: p.ismuted,
                                                    isUsingTts: p.usetts,
                                                    preferredLanguage: p.locale
                                                };
                                                return participant;
                                            });
                                            if (!!this.privConversationServiceConnector.participantsListReceived) this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));
                                            break;
                                        /**
                                         * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).
                                         * This is sent at the start of the Conversation
                                         */ case "settranslatetolanguages":
                                            if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload_1.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload_1.value, sessionId));
                                            break;
                                        /**
                                         * 'SetProfanityFiltering' lets the client set the level of profanity filtering.
                                         * If sent by the participant the setting will effect only their own profanity level.
                                         * If sent by the host, the setting will effect all participants including the host.
                                         * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'
                                         */ case "setprofanityfiltering":
                                            if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload_1.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload_1.value, sessionId));
                                            break;
                                        /**
                                         * 'SetMute' is sent if the participant has been muted by the host.
                                         * Check the 'participantId' to determine if the current user has been muted.
                                         */ case "setmute":
                                            if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload_1.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setMute, commandPayload_1.value, sessionId));
                                            break;
                                        /**
                                         * 'SetMuteAll' is sent if the Conversation has been muted by the host.
                                         */ case "setmuteall":
                                            if (!!this.privConversationServiceConnector.muteAllCommandReceived) this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.MuteAllEventArgs(commandPayload_1.value, sessionId));
                                            break;
                                        /**
                                         * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.
                                         */ case "roomexpirationwarning":
                                            if (!!this.privConversationServiceConnector.conversationExpiration) this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new Exports_2.ConversationExpirationEventArgs(commandPayload_1.value, this.privConversationRequestSession.sessionId));
                                            break;
                                        /**
                                         * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.
                                         */ case "setusetts":
                                            if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload_1.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setUseTTS, commandPayload_1.value, sessionId));
                                            break;
                                        /**
                                         * 'SetLockState' is set if the host has locked or unlocked the Conversation.
                                         */ case "setlockstate":
                                            if (!!this.privConversationServiceConnector.lockRoomCommandReceived) this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.LockRoomEventArgs(commandPayload_1.value, sessionId));
                                            break;
                                        /**
                                         * 'ChangeNickname' is received if a user changes their display name.
                                         * Any cached particpiants list should be updated to reflect the display name.
                                         */ case "changenickname":
                                            if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload_1.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.changeNickname, commandPayload_1.value, sessionId));
                                            break;
                                        /**
                                         * 'JoinSession' is sent when a user joins the Conversation.
                                         */ case "joinsession":
                                            joinParticipantPayload = Exports_4.ParticipantPayloadResponse.fromJSON(message.textBody);
                                            joiningParticipant = {
                                                avatar: joinParticipantPayload.avatar,
                                                displayName: joinParticipantPayload.nickname,
                                                id: joinParticipantPayload.participantId,
                                                isHost: joinParticipantPayload.ishost,
                                                isMuted: joinParticipantPayload.ismuted,
                                                isUsingTts: joinParticipantPayload.usetts,
                                                preferredLanguage: joinParticipantPayload.locale
                                            };
                                            if (!!this.privConversationServiceConnector.participantJoinCommandReceived) this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantEventArgs(joiningParticipant, sessionId));
                                            break;
                                        /**
                                         * 'LeaveSession' is sent when a user leaves the Conversation'.
                                         */ case "leavesession":
                                            leavingParticipant = {
                                                id: commandPayload_1.participantId
                                            };
                                            if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantEventArgs(leavingParticipant, sessionId));
                                            break;
                                        /**
                                         * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).
                                         * Check the 'ParticipantId' to check whether the message is for the current user.
                                         */ case "disconnectsession":
                                            disconnectParticipant = {
                                                id: commandPayload_1.participantId
                                            };
                                            break;
                                        case "token":
                                            token = new Exports_3.CognitiveTokenAuthentication(function() {
                                                var authorizationToken = commandPayload_1.token;
                                                return Promise.resolve(authorizationToken);
                                            }, function() {
                                                var authorizationToken = commandPayload_1.token;
                                                return Promise.resolve(authorizationToken);
                                            });
                                            this.authentication = token;
                                            break;
                                        /**
                                         * Message not recognized.
                                         */ default:
                                            break;
                                    }
                                    break;
                                /**
                                 * 'partial' (or 'hypothesis') represents a unfinalized speech message.
                                 */ case "partial":
                                /**
                                 * 'final' (or 'phrase') represents a finalized speech message.
                                 */ case "final":
                                    speechPayload = Exports_4.SpeechResponsePayload.fromJSON(message.textBody);
                                    conversationResultReason = conversationMessageType === "final" ? Exports_2.ResultReason.TranslatedParticipantSpeech : Exports_2.ResultReason.TranslatingParticipantSpeech;
                                    speechResult = new Exports_2.ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, speechPayload.id, conversationResultReason, speechPayload.recognition, undefined, undefined, message.textBody, undefined);
                                    if (speechPayload.isFinal) {
                                        // check the length, sometimes empty finals are returned
                                        if (speechResult.text !== undefined && speechResult.text.length > 0) sendFinal = true;
                                        else if (speechPayload.id === this.privLastPartialUtteranceId) // send final as normal. We had a non-empty partial for this same utterance
                                        // so sending the empty final is important
                                        sendFinal = true;
                                        if (sendFinal) {
                                            if (!!this.privConversationServiceConnector.translationReceived) this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.final, speechResult, sessionId));
                                        }
                                    } else if (speechResult.text !== undefined) {
                                        this.privLastPartialUtteranceId = speechPayload.id;
                                        if (!!this.privConversationServiceConnector.translationReceived) this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.partial, speechResult, sessionId));
                                    }
                                    break;
                                /**
                                 * "translated_message" is a text message or instant message (IM).
                                 */ case "translated_message":
                                    textPayload = Exports_4.TextResponsePayload.fromJSON(message.textBody);
                                    textResult = new Exports_2.ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);
                                    if (!!this.privConversationServiceConnector.translationReceived) this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));
                                    break;
                                default:
                                    break;
                            }
                        } catch (e) {
                        // continue
                        }
                        return [
                            2 /*return*/ ,
                            this.receiveConversationMessageOverride()
                        ];
                    case 4:
                        e_1 = _a.sent();
                        this.terminateMessageLoop = true;
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 5:
                        return [
                            2 /*return*/ ,
                            communicationCustodian.promise
                        ];
                }
            });
        });
    };
    ConversationServiceAdapter.prototype.startMessageLoop = function() {
        return __awaiter(this, void 0, void 0, function() {
            var messageRetrievalPromise, r, error_1;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.isDisposed()) return [
                            2 /*return*/ ,
                            Promise.resolve()
                        ];
                        this.terminateMessageLoop = false;
                        messageRetrievalPromise = this.receiveConversationMessageOverride();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            3,
                            ,
                            4
                        ]);
                        return [
                            4 /*yield*/ ,
                            messageRetrievalPromise
                        ];
                    case 2:
                        r = _a.sent();
                        return [
                            2 /*return*/ ,
                            r
                        ];
                    case 3:
                        error_1 = _a.sent();
                        this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : "", this.privRequestSession ? this.privRequestSession.requestId : "", Exports_2.CancellationReason.Error, Exports_2.CancellationErrorCode.RuntimeError, error_1);
                        return [
                            2 /*return*/ ,
                            null
                        ];
                    case 4:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    // Takes an established websocket connection to the endpoint
    ConversationServiceAdapter.prototype.configConnection = function() {
        var _this = this;
        if (this.isDisposed()) return Promise.resolve(undefined);
        if (this.privConnectionConfigPromise !== undefined) return this.privConnectionConfigPromise.then(function(connection) {
            if (connection.state() === Exports_1.ConnectionState.Disconnected) {
                _this.privConnectionId = null;
                _this.privConnectionConfigPromise = undefined;
                return _this.configConnection();
            }
            return _this.privConnectionConfigPromise;
        }, function() {
            _this.privConnectionId = null;
            _this.privConnectionConfigPromise = undefined;
            return _this.configConnection();
        });
        if (this.terminateMessageLoop) return Promise.resolve(undefined);
        this.privConnectionConfigPromise = this.connectImpl().then(function(connection) {
            return connection;
        });
        return this.privConnectionConfigPromise;
    };
    ConversationServiceAdapter.prototype.getTranslations = function(serviceResultTranslations) {
        var translations;
        if (undefined !== serviceResultTranslations) {
            translations = new Exports_2.Translations();
            for(var _i = 0, serviceResultTranslations_1 = serviceResultTranslations; _i < serviceResultTranslations_1.length; _i++){
                var translation = serviceResultTranslations_1[_i];
                translations.set(translation.lang, translation.translation);
            }
        }
        return translations;
    };
    return ConversationServiceAdapter;
}(Exports_3.ServiceRecognizerBase);
exports.ConversationServiceAdapter = ConversationServiceAdapter;

},{"5a6312ff708c798f":"5Bedw","a81f6e80ab56df41":"hxkc3","816126d542ce9bf6":"7Qpvn","6361ebba1409411a":"fyOjD","38095cda4c94a9cf":"kjT4n","ba8a087bb904f35d":"canv9","2920f03dd127e8":"XmN3G","c5731985e24762f9":"7RXpf"}],"kjT4n":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationRequestSession = void 0;
var Exports_1 = require("71ae0234419aa9de");
/**
 * Placeholder class for the Conversation Request Session. Based off RequestSession.
 * TODO: define what telemetry is required.
 */ var ConversationRequestSession = /** @class */ function() {
    function ConversationRequestSession(sessionId) {
        this.privIsDisposed = false;
        this.privDetachables = new Array();
        this.privSessionId = sessionId;
        this.privRequestId = Exports_1.createNoDashGuid();
        this.privRequestCompletionDeferral = new Exports_1.Deferred();
    }
    Object.defineProperty(ConversationRequestSession.prototype, "sessionId", {
        get: function() {
            return this.privSessionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationRequestSession.prototype, "requestId", {
        get: function() {
            return this.privRequestId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationRequestSession.prototype, "completionPromise", {
        get: function() {
            return this.privRequestCompletionDeferral.promise;
        },
        enumerable: false,
        configurable: true
    });
    ConversationRequestSession.prototype.onPreConnectionStart = function(authFetchEventId, connectionId) {
        this.privSessionId = connectionId;
    };
    ConversationRequestSession.prototype.onAuthCompleted = function(isError) {
        if (isError) this.onComplete();
    };
    ConversationRequestSession.prototype.onConnectionEstablishCompleted = function(statusCode) {
        if (statusCode === 200) return;
        else if (statusCode === 403) this.onComplete();
    };
    ConversationRequestSession.prototype.onServiceTurnEndResponse = function(continuousRecognition) {
        if (!continuousRecognition) this.onComplete();
        else this.privRequestId = Exports_1.createNoDashGuid();
    };
    ConversationRequestSession.prototype.dispose = function() {
        return __awaiter(this, void 0, void 0, function() {
            var _i, _a, detachable;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        if (!!this.privIsDisposed) return [
                            3 /*break*/ ,
                            4
                        ];
                        // we should have completed by now. If we did not its an unknown error.
                        this.privIsDisposed = true;
                        _i = 0, _a = this.privDetachables;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [
                            3 /*break*/ ,
                            4
                        ];
                        detachable = _a[_i];
                        return [
                            4 /*yield*/ ,
                            detachable.detach()
                        ];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [
                            3 /*break*/ ,
                            1
                        ];
                    case 4:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    ConversationRequestSession.prototype.onComplete = function() {
    //
    };
    return ConversationRequestSession;
}();
exports.ConversationRequestSession = ConversationRequestSession;

},{"71ae0234419aa9de":"5Bedw"}],"canv9":[function(require,module,exports) {
"use strict";
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationReceivedTranslationEventArgs = exports.ParticipantsListEventArgs = exports.ParticipantAttributeEventArgs = exports.ParticipantEventArgs = exports.LockRoomEventArgs = exports.MuteAllEventArgs = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/* eslint-disable max-classes-per-file */ var Exports_1 = require("71546fca60a6cedb");
var MuteAllEventArgs = /** @class */ function(_super) {
    __extends(MuteAllEventArgs, _super);
    function MuteAllEventArgs(isMuted, sessionId) {
        var _this = _super.call(this, sessionId) || this;
        _this.privIsMuted = isMuted;
        return _this;
    }
    Object.defineProperty(MuteAllEventArgs.prototype, "isMuted", {
        get: function() {
            return this.privIsMuted;
        },
        enumerable: false,
        configurable: true
    });
    return MuteAllEventArgs;
}(Exports_1.SessionEventArgs);
exports.MuteAllEventArgs = MuteAllEventArgs;
var LockRoomEventArgs = /** @class */ function(_super) {
    __extends(LockRoomEventArgs, _super);
    function LockRoomEventArgs(isLocked, sessionId) {
        var _this = _super.call(this, sessionId) || this;
        _this.privIsLocked = isLocked;
        return _this;
    }
    Object.defineProperty(LockRoomEventArgs.prototype, "isMuted", {
        get: function() {
            return this.privIsLocked;
        },
        enumerable: false,
        configurable: true
    });
    return LockRoomEventArgs;
}(Exports_1.SessionEventArgs);
exports.LockRoomEventArgs = LockRoomEventArgs;
var ParticipantEventArgs = /** @class */ function(_super) {
    __extends(ParticipantEventArgs, _super);
    function ParticipantEventArgs(participant, sessionId) {
        var _this = _super.call(this, sessionId) || this;
        _this.privParticipant = participant;
        return _this;
    }
    Object.defineProperty(ParticipantEventArgs.prototype, "participant", {
        get: function() {
            return this.privParticipant;
        },
        enumerable: false,
        configurable: true
    });
    return ParticipantEventArgs;
}(Exports_1.SessionEventArgs);
exports.ParticipantEventArgs = ParticipantEventArgs;
var ParticipantAttributeEventArgs = /** @class */ function(_super) {
    __extends(ParticipantAttributeEventArgs, _super);
    function ParticipantAttributeEventArgs(participantId, key, value, sessionId) {
        var _this = _super.call(this, sessionId) || this;
        _this.privKey = key;
        _this.privValue = value;
        _this.privParticipantId = participantId;
        return _this;
    }
    Object.defineProperty(ParticipantAttributeEventArgs.prototype, "value", {
        get: function() {
            return this.privValue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantAttributeEventArgs.prototype, "key", {
        get: function() {
            return this.privKey;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantAttributeEventArgs.prototype, "id", {
        get: function() {
            return this.privParticipantId;
        },
        enumerable: false,
        configurable: true
    });
    return ParticipantAttributeEventArgs;
}(Exports_1.SessionEventArgs);
exports.ParticipantAttributeEventArgs = ParticipantAttributeEventArgs;
var ParticipantsListEventArgs = /** @class */ function(_super) {
    __extends(ParticipantsListEventArgs, _super);
    function ParticipantsListEventArgs(conversationId, token, translateTo, profanityFilter, roomProfanityFilter, isRoomLocked, isMuteAll, participants, sessionId) {
        var _this = _super.call(this, sessionId) || this;
        _this.privRoomId = conversationId;
        _this.privSessionToken = token;
        _this.privTranslateTo = translateTo;
        _this.privProfanityFilter = profanityFilter;
        _this.privRoomProfanityFilter = roomProfanityFilter;
        _this.privIsRoomLocked = isRoomLocked;
        _this.privIsRoomLocked = isMuteAll;
        _this.privParticipants = participants;
        return _this;
    }
    Object.defineProperty(ParticipantsListEventArgs.prototype, "sessionToken", {
        get: function() {
            return this.privSessionToken;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListEventArgs.prototype, "conversationId", {
        get: function() {
            return this.privRoomId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListEventArgs.prototype, "translateTo", {
        get: function() {
            return this.privTranslateTo;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListEventArgs.prototype, "profanityFilter", {
        get: function() {
            return this.privProfanityFilter;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListEventArgs.prototype, "roomProfanityFilter", {
        get: function() {
            return this.privRoomProfanityFilter;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListEventArgs.prototype, "isRoomLocked", {
        get: function() {
            return this.privIsRoomLocked;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListEventArgs.prototype, "isMuteAll", {
        get: function() {
            return this.privIsMuteAll;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListEventArgs.prototype, "participants", {
        get: function() {
            return this.privParticipants;
        },
        enumerable: false,
        configurable: true
    });
    return ParticipantsListEventArgs;
}(Exports_1.SessionEventArgs);
exports.ParticipantsListEventArgs = ParticipantsListEventArgs;
var ConversationReceivedTranslationEventArgs = /** @class */ function() {
    function ConversationReceivedTranslationEventArgs(command, payload, sessionId) {
        this.privPayload = payload;
        this.privCommand = command;
        this.privSessionId = sessionId;
    }
    Object.defineProperty(ConversationReceivedTranslationEventArgs.prototype, "payload", {
        get: function() {
            return this.privPayload;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationReceivedTranslationEventArgs.prototype, "command", {
        get: function() {
            return this.privCommand;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConversationReceivedTranslationEventArgs.prototype, "sessionId", {
        get: function() {
            return this.privSessionId;
        },
        enumerable: false,
        configurable: true
    });
    return ConversationReceivedTranslationEventArgs;
}();
exports.ConversationReceivedTranslationEventArgs = ConversationReceivedTranslationEventArgs;

},{"71546fca60a6cedb":"hxkc3"}],"XmN3G":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConversationTranslatorCommandTypes = exports.ConversationTranslatorMessageTypes = exports.InternalParticipants = void 0;
/** Users participating in the conversation */ var InternalParticipants = /** @class */ function() {
    function InternalParticipants(participants, meId) {
        if (participants === void 0) participants = [];
        this.participants = participants;
        this.meId = meId;
    }
    /**
     * Add or update a participant
     * @param value
     */ InternalParticipants.prototype.addOrUpdateParticipant = function(value) {
        if (value === undefined) return;
        var exists = this.getParticipantIndex(value.id);
        if (exists > -1) this.participants.splice(exists, 1, value);
        else this.participants.push(value);
        // ensure it was added ok
        return this.getParticipant(value.id);
    };
    /**
     * Find the participant's position in the participants list.
     * @param id
     */ InternalParticipants.prototype.getParticipantIndex = function(id) {
        return this.participants.findIndex(function(p) {
            return p.id === id;
        });
    };
    /**
     * Find the participant by id.
     * @param id
     */ InternalParticipants.prototype.getParticipant = function(id) {
        return this.participants.find(function(p) {
            return p.id === id;
        });
    };
    /**
     * Remove a participant from the participants list.
     */ InternalParticipants.prototype.deleteParticipant = function(id) {
        this.participants = this.participants.filter(function(p) {
            return p.id !== id;
        });
    };
    Object.defineProperty(InternalParticipants.prototype, "host", {
        /**
         * Helper to return the conversation host.
         */ get: function() {
            return this.participants.find(function(p) {
                return p.isHost === true;
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InternalParticipants.prototype, "me", {
        /**
         * Helper to return the current user.
         */ get: function() {
            return this.getParticipant(this.meId);
        },
        enumerable: false,
        configurable: true
    });
    return InternalParticipants;
}();
exports.InternalParticipants = InternalParticipants;
/**
 * List of command message types
 */ exports.ConversationTranslatorMessageTypes = {
    command: "command",
    final: "final",
    info: "info",
    instantMessage: "instant_message",
    keepAlive: "keep_alive",
    partial: "partial",
    participantCommand: "participant_command",
    translatedMessage: "translated_message"
};
/**
 * List of command types
 */ exports.ConversationTranslatorCommandTypes = {
    changeNickname: "ChangeNickname",
    disconnectSession: "DisconnectSession",
    ejectParticipant: "EjectParticipant",
    instant_message: "instant_message",
    joinSession: "JoinSession",
    leaveSession: "LeaveSession",
    participantList: "ParticipantList",
    roomExpirationWarning: "RoomExpirationWarning",
    setLockState: "SetLockState",
    setMute: "SetMute",
    setMuteAll: "SetMuteAll",
    setProfanityFiltering: "SetProfanityFiltering",
    setTranslateToLanguages: "SetTranslateToLanguages",
    setUseTTS: "SetUseTTS"
};

},{}],"7RXpf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var CommandResponsePayload_1 = require("ef86f1c0ca239100");
Object.defineProperty(exports, "CommandResponsePayload", {
    enumerable: true,
    get: function() {
        return CommandResponsePayload_1.CommandResponsePayload;
    }
});
var ParticipantResponsePayload_1 = require("5595d5f0b1279bf");
Object.defineProperty(exports, "ParticipantsListPayloadResponse", {
    enumerable: true,
    get: function() {
        return ParticipantResponsePayload_1.ParticipantsListPayloadResponse;
    }
});
Object.defineProperty(exports, "ParticipantPayloadResponse", {
    enumerable: true,
    get: function() {
        return ParticipantResponsePayload_1.ParticipantPayloadResponse;
    }
});
var TranslationResponsePayload_1 = require("54951a0ac8a11b53");
Object.defineProperty(exports, "SpeechResponsePayload", {
    enumerable: true,
    get: function() {
        return TranslationResponsePayload_1.SpeechResponsePayload;
    }
});
Object.defineProperty(exports, "TextResponsePayload", {
    enumerable: true,
    get: function() {
        return TranslationResponsePayload_1.TextResponsePayload;
    }
});

},{"ef86f1c0ca239100":"QEvAJ","5595d5f0b1279bf":"atyTj","54951a0ac8a11b53":"25U5M"}],"QEvAJ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CommandResponsePayload = void 0;
var parseCommandResponse = function(json) {
    return JSON.parse(json);
};
var CommandResponsePayload = /** @class */ function() {
    function CommandResponsePayload(json) {
        this.privCommandResponse = parseCommandResponse(json);
    }
    Object.defineProperty(CommandResponsePayload.prototype, "type", {
        get: function() {
            return this.privCommandResponse.type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommandResponsePayload.prototype, "command", {
        get: function() {
            return this.privCommandResponse.command;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommandResponsePayload.prototype, "id", {
        get: function() {
            return this.privCommandResponse.id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommandResponsePayload.prototype, "nickname", {
        get: function() {
            return this.privCommandResponse.nickname;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommandResponsePayload.prototype, "participantId", {
        get: function() {
            return this.privCommandResponse.participantId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommandResponsePayload.prototype, "roomid", {
        get: function() {
            return this.privCommandResponse.roomid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommandResponsePayload.prototype, "value", {
        get: function() {
            return this.privCommandResponse.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommandResponsePayload.prototype, "token", {
        get: function() {
            return this.privCommandResponse.token;
        },
        enumerable: false,
        configurable: true
    });
    CommandResponsePayload.fromJSON = function(json) {
        return new CommandResponsePayload(json);
    };
    return CommandResponsePayload;
}();
exports.CommandResponsePayload = CommandResponsePayload;

},{}],"atyTj":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParticipantPayloadResponse = exports.ParticipantsListPayloadResponse = void 0;
var parseListResponse = function(json) {
    return JSON.parse(json);
};
var parseParticipantResponse = function(json) {
    return JSON.parse(json);
};
var ParticipantsListPayloadResponse = /** @class */ function() {
    function ParticipantsListPayloadResponse(json) {
        this.privParticipantsPayloadResponse = parseListResponse(json);
    }
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "roomid", {
        get: function() {
            return this.privParticipantsPayloadResponse.roomid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "id", {
        get: function() {
            return this.privParticipantsPayloadResponse.id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "command", {
        get: function() {
            return this.privParticipantsPayloadResponse.command;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "participants", {
        get: function() {
            return this.privParticipantsPayloadResponse.participants;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "token", {
        get: function() {
            return this.privParticipantsPayloadResponse.token;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "translateTo", {
        get: function() {
            return this.privParticipantsPayloadResponse.translateTo;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "profanityFilter", {
        get: function() {
            return this.privParticipantsPayloadResponse.profanityFilter;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "roomProfanityFilter", {
        get: function() {
            return this.privParticipantsPayloadResponse.roomProfanityFilter;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "roomLocked", {
        get: function() {
            return this.privParticipantsPayloadResponse.roomLocked;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "muteAll", {
        get: function() {
            return this.privParticipantsPayloadResponse.muteAll;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantsListPayloadResponse.prototype, "type", {
        get: function() {
            return this.privParticipantsPayloadResponse.type;
        },
        enumerable: false,
        configurable: true
    });
    ParticipantsListPayloadResponse.fromJSON = function(json) {
        return new ParticipantsListPayloadResponse(json);
    };
    return ParticipantsListPayloadResponse;
}();
exports.ParticipantsListPayloadResponse = ParticipantsListPayloadResponse;
var ParticipantPayloadResponse = /** @class */ function() {
    function ParticipantPayloadResponse(json) {
        this.privParticipantPayloadResponse = parseParticipantResponse(json);
    }
    Object.defineProperty(ParticipantPayloadResponse.prototype, "nickname", {
        get: function() {
            return this.privParticipantPayloadResponse.nickname;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantPayloadResponse.prototype, "locale", {
        get: function() {
            return this.privParticipantPayloadResponse.locale;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantPayloadResponse.prototype, "usetts", {
        get: function() {
            return this.privParticipantPayloadResponse.usetts;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantPayloadResponse.prototype, "ismuted", {
        get: function() {
            return this.privParticipantPayloadResponse.ismuted;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantPayloadResponse.prototype, "ishost", {
        get: function() {
            return this.privParticipantPayloadResponse.ishost;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantPayloadResponse.prototype, "participantId", {
        get: function() {
            return this.privParticipantPayloadResponse.participantId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantPayloadResponse.prototype, "avatar", {
        get: function() {
            return this.privParticipantPayloadResponse.avatar;
        },
        enumerable: false,
        configurable: true
    });
    ParticipantPayloadResponse.fromJSON = function(json) {
        return new ParticipantPayloadResponse(json);
    };
    return ParticipantPayloadResponse;
}();
exports.ParticipantPayloadResponse = ParticipantPayloadResponse;

},{}],"25U5M":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextResponsePayload = exports.SpeechResponsePayload = void 0;
var parseSpeechResponse = function(json) {
    return JSON.parse(json);
};
var parseTextResponse = function(json) {
    return JSON.parse(json);
};
var SpeechResponsePayload = /** @class */ function() {
    function SpeechResponsePayload(json) {
        this.privSpeechResponse = parseSpeechResponse(json);
    }
    Object.defineProperty(SpeechResponsePayload.prototype, "recognition", {
        get: function() {
            return this.privSpeechResponse.recognition;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechResponsePayload.prototype, "translations", {
        get: function() {
            return this.privSpeechResponse.translations;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechResponsePayload.prototype, "id", {
        get: function() {
            return this.privSpeechResponse.id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechResponsePayload.prototype, "language", {
        get: function() {
            return this.privSpeechResponse.language;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechResponsePayload.prototype, "nickname", {
        get: function() {
            return this.privSpeechResponse.nickname;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechResponsePayload.prototype, "participantId", {
        get: function() {
            return this.privSpeechResponse.participantId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechResponsePayload.prototype, "roomid", {
        get: function() {
            return this.privSpeechResponse.roomid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechResponsePayload.prototype, "timestamp", {
        get: function() {
            return this.privSpeechResponse.timestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechResponsePayload.prototype, "type", {
        get: function() {
            return this.privSpeechResponse.type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeechResponsePayload.prototype, "isFinal", {
        get: function() {
            return this.privSpeechResponse.type === "final";
        },
        enumerable: false,
        configurable: true
    });
    SpeechResponsePayload.fromJSON = function(json) {
        return new SpeechResponsePayload(json);
    };
    return SpeechResponsePayload;
}();
exports.SpeechResponsePayload = SpeechResponsePayload;
var TextResponsePayload = /** @class */ function() {
    function TextResponsePayload(json) {
        this.privTextResponse = parseTextResponse(json);
    }
    Object.defineProperty(TextResponsePayload.prototype, "originalText", {
        get: function() {
            return this.privTextResponse.originalText;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextResponsePayload.prototype, "translations", {
        get: function() {
            return this.privTextResponse.translations;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextResponsePayload.prototype, "id", {
        get: function() {
            return this.privTextResponse.id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextResponsePayload.prototype, "language", {
        get: function() {
            return this.privTextResponse.language;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextResponsePayload.prototype, "nickname", {
        get: function() {
            return this.privTextResponse.nickname;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextResponsePayload.prototype, "participantId", {
        get: function() {
            return this.privTextResponse.participantId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextResponsePayload.prototype, "roomid", {
        get: function() {
            return this.privTextResponse.roomid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextResponsePayload.prototype, "timestamp", {
        get: function() {
            return this.privTextResponse.timestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextResponsePayload.prototype, "type", {
        get: function() {
            return this.privTextResponse.type;
        },
        enumerable: false,
        configurable: true
    });
    TextResponsePayload.fromJSON = function(json) {
        return new TextResponsePayload(json);
    };
    return TextResponsePayload;
}();
exports.TextResponsePayload = TextResponsePayload;

},{}],"d1Czv":[function(require,module,exports) {
"use strict";
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranscriberRecognizer = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var Exports_1 = require("484ef3dc6e396952");
var Contracts_1 = require("bcafcece8dd7855a");
var Exports_2 = require("3a8a9412f5d11be4");
var Exports_3 = require("36116c94eb5f8a37");
var TranscriberRecognizer = /** @class */ function(_super) {
    __extends(TranscriberRecognizer, _super);
    /**
     * TranscriberRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - Non-audio configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An audio configuration associated with the recognizer
     */ function TranscriberRecognizer(speechTranslationConfig, audioConfig) {
        var _this = this;
        var speechTranslationConfigImpl = speechTranslationConfig;
        Contracts_1.Contracts.throwIfNull(speechTranslationConfigImpl, "speechTranslationConfig");
        var audioConfigImpl = audioConfig;
        Contracts_1.Contracts.throwIfNull(audioConfigImpl, "audioConfigImpl");
        Contracts_1.Contracts.throwIfNullOrWhitespace(speechTranslationConfigImpl.speechRecognitionLanguage, Exports_2.PropertyId[Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage]);
        _this = _super.call(this, audioConfig, speechTranslationConfigImpl.properties, new Exports_3.TranscriberConnectionFactory()) || this;
        _this.privDisposedRecognizer = false;
        _this.isMeetingRecognizer = false;
        return _this;
    }
    Object.defineProperty(TranscriberRecognizer.prototype, "speechRecognitionLanguage", {
        get: function() {
            Contracts_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
            return this.properties.getProperty(Exports_2.PropertyId.SpeechServiceConnection_RecoLanguage);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranscriberRecognizer.prototype, "properties", {
        get: function() {
            return this.privProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranscriberRecognizer.prototype, "authorizationToken", {
        get: function() {
            return this.properties.getProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token);
        },
        set: function(token) {
            Contracts_1.Contracts.throwIfNullOrWhitespace(token, "token");
            this.properties.setProperty(Exports_2.PropertyId.SpeechServiceAuthorization_Token, token);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TranscriberRecognizer.prototype, "conversation", {
        set: function(c) {
            Contracts_1.Contracts.throwIfNullOrUndefined(c, "Conversation");
            this.isMeetingRecognizer = false;
            this.privConversation = c;
        },
        enumerable: false,
        configurable: true
    });
    TranscriberRecognizer.prototype.getConversationInfo = function() {
        Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation, "Conversation");
        return this.privConversation.conversationInfo;
    };
    Object.defineProperty(TranscriberRecognizer.prototype, "meeting", {
        set: function(m) {
            Contracts_1.Contracts.throwIfNullOrUndefined(m, "Meeting");
            this.isMeetingRecognizer = true;
            this.privMeeting = m;
        },
        enumerable: false,
        configurable: true
    });
    TranscriberRecognizer.prototype.getMeetingInfo = function() {
        Contracts_1.Contracts.throwIfNullOrUndefined(this.privMeeting, "Meeting");
        return this.privMeeting.meetingInfo;
    };
    TranscriberRecognizer.prototype.IsMeetingRecognizer = function() {
        return this.isMeetingRecognizer;
    };
    TranscriberRecognizer.prototype.startContinuousRecognitionAsync = function(cb, err) {
        Exports_1.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_3.RecognitionMode.Conversation), cb, err);
    };
    TranscriberRecognizer.prototype.stopContinuousRecognitionAsync = function(cb, err) {
        Exports_1.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
    };
    TranscriberRecognizer.prototype.close = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!this.privDisposedRecognizer) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.dispose(true)
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    // Push async join/leave conversation message via serviceRecognizer
    TranscriberRecognizer.prototype.pushConversationEvent = function(conversationInfo, command) {
        return __awaiter(this, void 0, void 0, function() {
            var reco;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        reco = this.privReco;
                        Contracts_1.Contracts.throwIfNullOrUndefined(reco, "serviceRecognizer");
                        return [
                            4 /*yield*/ ,
                            reco.sendSpeechEventAsync(conversationInfo, command)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    // Push async join/leave meeting message via serviceRecognizer
    TranscriberRecognizer.prototype.pushMeetingEvent = function(meetingInfo, command) {
        return __awaiter(this, void 0, void 0, function() {
            var reco;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        reco = this.privReco;
                        Contracts_1.Contracts.throwIfNullOrUndefined(reco, "serviceRecognizer");
                        return [
                            4 /*yield*/ ,
                            reco.sendMeetingSpeechEventAsync(meetingInfo, command)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    TranscriberRecognizer.prototype.enforceAudioGating = function() {
        return __awaiter(this, void 0, void 0, function() {
            var audioConfigImpl, format, channels;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        audioConfigImpl = this.audioConfig;
                        return [
                            4 /*yield*/ ,
                            audioConfigImpl.format
                        ];
                    case 1:
                        format = _a.sent();
                        channels = format.channels;
                        if (channels === 1) {
                            if (this.properties.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() !== "true") throw new Error("Single channel audio configuration for MeetingTranscriber is currently under private preview, please contact diarizationrequest@microsoft.com for more details");
                        } else if (channels !== 8) throw new Error("Unsupported audio configuration: Detected " + channels + "-channel audio");
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    TranscriberRecognizer.prototype.connectMeetingCallbacks = function(transcriber) {
        this.isMeetingRecognizer = true;
        this.canceled = function(s, e) {
            if (!!transcriber.canceled) transcriber.canceled(transcriber, e);
        };
        this.recognizing = function(s, e) {
            if (!!transcriber.transcribing) transcriber.transcribing(transcriber, e);
        };
        this.recognized = function(s, e) {
            if (!!transcriber.transcribed) transcriber.transcribed(transcriber, e);
        };
        this.sessionStarted = function(s, e) {
            if (!!transcriber.sessionStarted) transcriber.sessionStarted(transcriber, e);
        };
        this.sessionStopped = function(s, e) {
            if (!!transcriber.sessionStopped) transcriber.sessionStopped(transcriber, e);
        };
    };
    TranscriberRecognizer.prototype.disconnectCallbacks = function() {
        this.canceled = undefined;
        this.recognizing = undefined;
        this.recognized = undefined;
        this.sessionStarted = undefined;
        this.sessionStopped = undefined;
    };
    /**
     * Disposes any resources held by the object.
     * @member ConversationTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */ TranscriberRecognizer.prototype.dispose = function(disposing) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privDisposedRecognizer) return [
                            2 /*return*/ 
                        ];
                        if (!disposing) return [
                            3 /*break*/ ,
                            2
                        ];
                        this.privDisposedRecognizer = true;
                        return [
                            4 /*yield*/ ,
                            this.implRecognizerStop()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            4 /*yield*/ ,
                            _super.prototype.dispose.call(this, disposing)
                        ];
                    case 3:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    TranscriberRecognizer.prototype.createRecognizerConfig = function(speechConfig) {
        return new Exports_3.RecognizerConfig(speechConfig, this.properties);
    };
    TranscriberRecognizer.prototype.createServiceRecognizer = function(authentication, connectionFactory, audioConfig, recognizerConfig) {
        var configImpl = audioConfig;
        return new Exports_3.TranscriptionServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
    };
    return TranscriberRecognizer;
}(Exports_2.Recognizer);
exports.TranscriberRecognizer = TranscriberRecognizer;

},{"484ef3dc6e396952":"5Bedw","bcafcece8dd7855a":"4jwu5","3a8a9412f5d11be4":"hxkc3","36116c94eb5f8a37":"7Qpvn"}],"gpb6A":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SynthesisAudioMetadata = exports.MetadataType = void 0;
var MetadataType;
(function(MetadataType) {
    MetadataType["WordBoundary"] = "WordBoundary";
    MetadataType["Bookmark"] = "Bookmark";
    MetadataType["Viseme"] = "Viseme";
    MetadataType["SentenceBoundary"] = "SentenceBoundary";
    MetadataType["SessionEnd"] = "SessionEnd";
})(MetadataType = exports.MetadataType || (exports.MetadataType = {}));
var SynthesisAudioMetadata = /** @class */ function() {
    function SynthesisAudioMetadata(json) {
        this.privSynthesisAudioMetadata = JSON.parse(json);
    }
    SynthesisAudioMetadata.fromJSON = function(json) {
        return new SynthesisAudioMetadata(json);
    };
    Object.defineProperty(SynthesisAudioMetadata.prototype, "Metadata", {
        get: function() {
            return this.privSynthesisAudioMetadata.Metadata;
        },
        enumerable: false,
        configurable: true
    });
    return SynthesisAudioMetadata;
}();
exports.SynthesisAudioMetadata = SynthesisAudioMetadata;

},{}],"dekBZ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SynthesisTurn = void 0;
var Exports_1 = require("760b584a81d987fc");
var AudioOutputStream_1 = require("94fab3b18aa442a6");
var SynthesisAudioMetadata_1 = require("21b3eb42691f5495");
var SynthesisAdapterBase_1 = require("119714ad8965a29d");
var SynthesisEvents_1 = require("5381ccf581986bf5");
var SynthesisTurn = /** @class */ function() {
    function SynthesisTurn() {
        this.privIsDisposed = false;
        this.privIsSynthesizing = false;
        this.privIsSynthesisEnded = false;
        this.privBytesReceived = 0;
        this.privInTurn = false;
        this.privTextOffset = 0;
        this.privNextSearchTextIndex = 0;
        this.privSentenceOffset = 0;
        this.privNextSearchSentenceIndex = 0;
        this.privRequestId = Exports_1.createNoDashGuid();
        this.privTurnDeferral = new Exports_1.Deferred();
        // We're not in a turn, so resolve.
        this.privTurnDeferral.resolve();
    }
    Object.defineProperty(SynthesisTurn.prototype, "requestId", {
        get: function() {
            return this.privRequestId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "streamId", {
        get: function() {
            return this.privStreamId;
        },
        set: function(value) {
            this.privStreamId = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "audioOutputFormat", {
        get: function() {
            return this.privAudioOutputFormat;
        },
        set: function(format) {
            this.privAudioOutputFormat = format;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "turnCompletionPromise", {
        get: function() {
            return this.privTurnDeferral.promise;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "isSynthesisEnded", {
        get: function() {
            return this.privIsSynthesisEnded;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "isSynthesizing", {
        get: function() {
            return this.privIsSynthesizing;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "currentTextOffset", {
        get: function() {
            return this.privTextOffset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "currentSentenceOffset", {
        get: function() {
            return this.privSentenceOffset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "bytesReceived", {
        // The number of bytes received for current turn
        get: function() {
            return this.privBytesReceived;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisTurn.prototype, "audioDuration", {
        get: function() {
            return this.privAudioDuration;
        },
        enumerable: false,
        configurable: true
    });
    SynthesisTurn.prototype.getAllReceivedAudio = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!this.privReceivedAudio) return [
                            2 /*return*/ ,
                            Promise.resolve(this.privReceivedAudio)
                        ];
                        if (!this.privIsSynthesisEnded) return [
                            2 /*return*/ ,
                            null
                        ];
                        return [
                            4 /*yield*/ ,
                            this.readAllAudioFromStream()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            Promise.resolve(this.privReceivedAudio)
                        ];
                }
            });
        });
    };
    SynthesisTurn.prototype.getAllReceivedAudioWithHeader = function() {
        return __awaiter(this, void 0, void 0, function() {
            var audio;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!!this.privReceivedAudioWithHeader) return [
                            2 /*return*/ ,
                            this.privReceivedAudioWithHeader
                        ];
                        if (!this.privIsSynthesisEnded) return [
                            2 /*return*/ ,
                            null
                        ];
                        if (!this.audioOutputFormat.hasHeader) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.getAllReceivedAudio()
                        ];
                    case 1:
                        audio = _a.sent();
                        this.privReceivedAudioWithHeader = SynthesisAdapterBase_1.SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat);
                        return [
                            2 /*return*/ ,
                            this.privReceivedAudioWithHeader
                        ];
                    case 2:
                        return [
                            2 /*return*/ ,
                            this.getAllReceivedAudio()
                        ];
                }
            });
        });
    };
    SynthesisTurn.prototype.startNewSynthesis = function(requestId, rawText, isSSML, audioDestination) {
        this.privIsSynthesisEnded = false;
        this.privIsSynthesizing = true;
        this.privRequestId = requestId;
        this.privRawText = rawText;
        this.privIsSSML = isSSML;
        this.privAudioOutputStream = new AudioOutputStream_1.PullAudioOutputStreamImpl();
        this.privAudioOutputStream.format = this.privAudioOutputFormat;
        this.privReceivedAudio = null;
        this.privReceivedAudioWithHeader = null;
        this.privBytesReceived = 0;
        this.privTextOffset = 0;
        this.privNextSearchTextIndex = 0;
        this.privSentenceOffset = 0;
        this.privNextSearchSentenceIndex = 0;
        this.privPartialVisemeAnimation = "";
        if (audioDestination !== undefined) {
            this.privTurnAudioDestination = audioDestination;
            this.privTurnAudioDestination.format = this.privAudioOutputFormat;
        }
        this.onEvent(new SynthesisEvents_1.SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));
    };
    SynthesisTurn.prototype.onPreConnectionStart = function(authFetchEventId) {
        this.privAuthFetchEventId = authFetchEventId;
        this.onEvent(new SynthesisEvents_1.ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));
    };
    SynthesisTurn.prototype.onAuthCompleted = function(isError) {
        if (isError) this.onComplete();
    };
    SynthesisTurn.prototype.onConnectionEstablishCompleted = function(statusCode) {
        if (statusCode === 200) {
            this.onEvent(new SynthesisEvents_1.SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));
            this.privBytesReceived = 0;
            return;
        } else if (statusCode === 403) this.onComplete();
    };
    SynthesisTurn.prototype.onServiceResponseMessage = function(responseJson) {
        var response = JSON.parse(responseJson);
        this.streamId = response.audio.streamId;
    };
    SynthesisTurn.prototype.onServiceTurnEndResponse = function() {
        this.privInTurn = false;
        this.privTurnDeferral.resolve();
        this.onComplete();
    };
    SynthesisTurn.prototype.onServiceTurnStartResponse = function() {
        if (!!this.privTurnDeferral && !!this.privInTurn) {
            // What? How are we starting a turn with another not done?
            this.privTurnDeferral.reject("Another turn started before current completed.");
            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            this.privTurnDeferral.promise.then().catch(function() {});
        }
        this.privInTurn = true;
        this.privTurnDeferral = new Exports_1.Deferred();
    };
    SynthesisTurn.prototype.onAudioChunkReceived = function(data) {
        if (this.isSynthesizing) {
            this.privAudioOutputStream.write(data);
            this.privBytesReceived += data.byteLength;
            if (this.privTurnAudioDestination !== undefined) this.privTurnAudioDestination.write(data);
        }
    };
    SynthesisTurn.prototype.onTextBoundaryEvent = function(metadata) {
        this.updateTextOffset(metadata.Data.text.Text, metadata.Type);
    };
    SynthesisTurn.prototype.onVisemeMetadataReceived = function(metadata) {
        if (metadata.Data.AnimationChunk !== undefined) this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;
    };
    SynthesisTurn.prototype.onSessionEnd = function(metadata) {
        this.privAudioDuration = metadata.Data.Offset;
    };
    SynthesisTurn.prototype.dispose = function() {
        if (!this.privIsDisposed) // we should have completed by now. If we did not its an unknown error.
        this.privIsDisposed = true;
    };
    SynthesisTurn.prototype.onStopSynthesizing = function() {
        this.onComplete();
    };
    /**
     * Gets the viseme animation string (merged from animation chunk), and clears the internal
     * partial animation.
     */ SynthesisTurn.prototype.getAndClearVisemeAnimation = function() {
        var animation = this.privPartialVisemeAnimation;
        this.privPartialVisemeAnimation = "";
        return animation;
    };
    SynthesisTurn.prototype.onEvent = function(event) {
        Exports_1.Events.instance.onEvent(event);
    };
    /**
     * Check if the text is an XML(SSML) tag
     * @param text
     * @private
     */ SynthesisTurn.isXmlTag = function(text) {
        return text.length >= 2 && text[0] === "<" && text[text.length - 1] === ">";
    };
    SynthesisTurn.prototype.updateTextOffset = function(text, type) {
        if (type === SynthesisAudioMetadata_1.MetadataType.WordBoundary) {
            this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);
            if (this.privTextOffset >= 0) {
                this.privNextSearchTextIndex = this.privTextOffset + text.length;
                if (this.privIsSSML) {
                    if (this.withinXmlTag(this.privTextOffset) && !SynthesisTurn.isXmlTag(text)) this.updateTextOffset(text, type);
                }
            }
        } else {
            this.privSentenceOffset = this.privRawText.indexOf(text, this.privNextSearchSentenceIndex);
            if (this.privSentenceOffset >= 0) {
                this.privNextSearchSentenceIndex = this.privSentenceOffset + text.length;
                if (this.privIsSSML) {
                    if (this.withinXmlTag(this.privSentenceOffset) && !SynthesisTurn.isXmlTag(text)) this.updateTextOffset(text, type);
                }
            }
        }
    };
    SynthesisTurn.prototype.onComplete = function() {
        if (this.privIsSynthesizing) {
            this.privIsSynthesizing = false;
            this.privIsSynthesisEnded = true;
            this.privAudioOutputStream.close();
            this.privInTurn = false;
            if (this.privTurnAudioDestination !== undefined) {
                this.privTurnAudioDestination.close();
                this.privTurnAudioDestination = undefined;
            }
        }
    };
    SynthesisTurn.prototype.readAllAudioFromStream = function() {
        return __awaiter(this, void 0, void 0, function() {
            var e_1;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!this.privIsSynthesisEnded) return [
                            3 /*break*/ ,
                            4
                        ];
                        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            3,
                            ,
                            4
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.privAudioOutputStream.read(this.privReceivedAudio)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            4
                        ];
                    case 3:
                        e_1 = _a.sent();
                        this.privReceivedAudio = new ArrayBuffer(0);
                        return [
                            3 /*break*/ ,
                            4
                        ];
                    case 4:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    /**
     * Check if current idx is in XML(SSML) tag
     * @param idx
     * @private
     */ SynthesisTurn.prototype.withinXmlTag = function(idx) {
        return this.privRawText.indexOf("<", idx + 1) > this.privRawText.indexOf(">", idx + 1);
    };
    return SynthesisTurn;
}();
exports.SynthesisTurn = SynthesisTurn;

},{"760b584a81d987fc":"5Bedw","94fab3b18aa442a6":"budsd","21b3eb42691f5495":"gpb6A","119714ad8965a29d":"2IlJz","5381ccf581986bf5":"aeJmp"}],"2IlJz":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SynthesisAdapterBase = void 0;
var Exports_1 = require("2d83348de6f9c8f0");
var Exports_2 = require("161bab8158afb62");
var Exports_3 = require("b804f9330adecf08");
var SpeechConnectionMessage_Internal_1 = require("2a8a80436ce21770");
var SynthesisAdapterBase = /** @class */ function() {
    function SynthesisAdapterBase(authentication, connectionFactory, synthesizerConfig, speechSynthesizer, audioDestination) {
        var _this = this;
        this.speakOverride = undefined;
        this.receiveMessageOverride = undefined;
        this.connectImplOverride = undefined;
        this.configConnectionOverride = undefined;
        // A promise for a configured connection.
        // Do not consume directly, call fetchConnection instead.
        this.privConnectionConfigurationPromise = undefined;
        if (!authentication) throw new Exports_1.ArgumentNullError("authentication");
        if (!connectionFactory) throw new Exports_1.ArgumentNullError("connectionFactory");
        if (!synthesizerConfig) throw new Exports_1.ArgumentNullError("synthesizerConfig");
        this.privAuthentication = authentication;
        this.privConnectionFactory = connectionFactory;
        this.privSynthesizerConfig = synthesizerConfig;
        this.privIsDisposed = false;
        this.privSpeechSynthesizer = speechSynthesizer;
        this.privSessionAudioDestination = audioDestination;
        this.privSynthesisTurn = new Exports_3.SynthesisTurn();
        this.privConnectionEvents = new Exports_1.EventSource();
        this.privServiceEvents = new Exports_1.EventSource();
        this.privSynthesisContext = new Exports_3.SynthesisContext(this.privSpeechSynthesizer);
        this.privAgentConfig = new Exports_3.AgentConfig();
        this.connectionEvents.attach(function(connectionEvent) {
            if (connectionEvent.name === "ConnectionClosedEvent") {
                var connectionClosedEvent = connectionEvent;
                if (connectionClosedEvent.statusCode !== 1000) _this.cancelSynthesisLocal(Exports_2.CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? Exports_2.CancellationErrorCode.BadRequestParameters : Exports_2.CancellationErrorCode.ConnectionFailure, connectionClosedEvent.reason + " websocket error code: " + connectionClosedEvent.statusCode);
            }
        });
    }
    Object.defineProperty(SynthesisAdapterBase.prototype, "synthesisContext", {
        get: function() {
            return this.privSynthesisContext;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisAdapterBase.prototype, "agentConfig", {
        get: function() {
            return this.privAgentConfig;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisAdapterBase.prototype, "connectionEvents", {
        get: function() {
            return this.privConnectionEvents;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisAdapterBase.prototype, "serviceEvents", {
        get: function() {
            return this.privServiceEvents;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisAdapterBase.prototype, "activityTemplate", {
        get: function() {
            return this.privActivityTemplate;
        },
        set: function(messagePayload) {
            this.privActivityTemplate = messagePayload;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisAdapterBase.prototype, "audioOutputFormat", {
        set: function(format) {
            this.privAudioOutputFormat = format;
            this.privSynthesisTurn.audioOutputFormat = format;
            if (this.privSessionAudioDestination !== undefined) this.privSessionAudioDestination.format = format;
            if (this.synthesisContext !== undefined) this.synthesisContext.audioOutputFormat = format;
        },
        enumerable: false,
        configurable: true
    });
    SynthesisAdapterBase.addHeader = function(audio, format) {
        if (!format.hasHeader) return audio;
        format.updateHeader(audio.byteLength);
        var tmp = new Uint8Array(audio.byteLength + format.header.byteLength);
        tmp.set(new Uint8Array(format.header), 0);
        tmp.set(new Uint8Array(audio), format.header.byteLength);
        return tmp.buffer;
    };
    SynthesisAdapterBase.prototype.isDisposed = function() {
        return this.privIsDisposed;
    };
    SynthesisAdapterBase.prototype.dispose = function(reason) {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.privIsDisposed = true;
                        if (this.privSessionAudioDestination !== undefined) this.privSessionAudioDestination.close();
                        if (!(this.privConnectionConfigurationPromise !== undefined)) return [
                            3 /*break*/ ,
                            3
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privConnectionConfigurationPromise
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            connection.dispose(reason)
                        ];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SynthesisAdapterBase.prototype.connect = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.connectImpl()
                        ];
                    case 1:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SynthesisAdapterBase.prototype.sendNetworkMessage = function(path, payload) {
        return __awaiter(this, void 0, void 0, function() {
            var type, contentType, connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        type = typeof payload === "string" ? Exports_1.MessageType.Text : Exports_1.MessageType.Binary;
                        contentType = typeof payload === "string" ? "application/json" : "";
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            2 /*return*/ ,
                            connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload))
                        ];
                }
            });
        });
    };
    SynthesisAdapterBase.prototype.Speak = function(text, isSSML, requestId, successCallback, errorCallBack, audioDestination) {
        return __awaiter(this, void 0, void 0, function() {
            var ssml, connection, synthesisStartEventArgs, e_1;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (isSSML) ssml = text;
                        else ssml = this.privSpeechSynthesizer.buildSsml(text);
                        if (this.speakOverride !== undefined) return [
                            2 /*return*/ ,
                            this.speakOverride(ssml, requestId, successCallback, errorCallBack)
                        ];
                        this.privSuccessCallback = successCallback;
                        this.privErrorCallback = errorCallBack;
                        this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            6,
                            ,
                            7
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.connectImpl()
                        ];
                    case 2:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 3:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendSynthesisContext(connection)
                        ];
                    case 4:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendSsmlMessage(connection, ssml, requestId)
                        ];
                    case 5:
                        _a.sent();
                        synthesisStartEventArgs = new Exports_2.SpeechSynthesisEventArgs(new Exports_2.SpeechSynthesisResult(requestId, Exports_2.ResultReason.SynthesizingAudioStarted));
                        if (!!this.privSpeechSynthesizer.synthesisStarted) this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);
                        this.receiveMessage();
                        return [
                            3 /*break*/ ,
                            7
                        ];
                    case 6:
                        e_1 = _a.sent();
                        this.cancelSynthesisLocal(Exports_2.CancellationReason.Error, Exports_2.CancellationErrorCode.ConnectionFailure, e_1);
                        return [
                            2 /*return*/ ,
                            Promise.reject(e_1)
                        ];
                    case 7:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    // Cancels synthesis.
    SynthesisAdapterBase.prototype.cancelSynthesis = function(requestId, cancellationReason, errorCode, error) {
        var properties = new Exports_2.PropertyCollection();
        properties.setProperty(Exports_3.CancellationErrorCodePropertyName, Exports_2.CancellationErrorCode[errorCode]);
        var result = new Exports_2.SpeechSynthesisResult(requestId, Exports_2.ResultReason.Canceled, undefined, error, properties);
        if (!!this.privSpeechSynthesizer.SynthesisCanceled) {
            var cancelEvent = new Exports_2.SpeechSynthesisEventArgs(result);
            try {
                this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);
            /* eslint-disable no-empty */ } catch (_a) {}
        }
        if (!!this.privSuccessCallback) try {
            this.privSuccessCallback(result);
        /* eslint-disable no-empty */ } catch (_b) {}
    };
    // Cancels synthesis.
    SynthesisAdapterBase.prototype.cancelSynthesisLocal = function(cancellationReason, errorCode, error) {
        if (!!this.privSynthesisTurn.isSynthesizing) {
            this.privSynthesisTurn.onStopSynthesizing();
            this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error);
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    SynthesisAdapterBase.prototype.processTypeSpecificMessages = function(connectionMessage) {
        return true;
    };
    SynthesisAdapterBase.prototype.receiveMessage = function() {
        return __awaiter(this, void 0, void 0, function() {
            var connection, message, connectionMessage, _a, audioWithHeader, ev, metadataList, _i, metadataList_1, metadata, wordBoundaryEventArgs, bookmarkEventArgs, visemeEventArgs, result, audioBuffer, error_1, e_2;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _b.trys.push([
                            0,
                            14,
                            ,
                            15
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _b.sent();
                        return [
                            4 /*yield*/ ,
                            connection.read()
                        ];
                    case 2:
                        message = _b.sent();
                        if (this.receiveMessageOverride !== undefined) return [
                            2 /*return*/ ,
                            this.receiveMessageOverride()
                        ];
                        if (this.privIsDisposed) // We're done.
                        return [
                            2 /*return*/ 
                        ];
                        // indicates we are draining the queue and it came with no message;
                        if (!message) {
                            if (!this.privSynthesisTurn.isSynthesizing) return [
                                2 /*return*/ 
                            ];
                            else return [
                                2 /*return*/ ,
                                this.receiveMessage()
                            ];
                        }
                        connectionMessage = SpeechConnectionMessage_Internal_1.SpeechConnectionMessage.fromConnectionMessage(message);
                        if (!(connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase())) return [
                            3 /*break*/ ,
                            13
                        ];
                        _a = connectionMessage.path.toLowerCase();
                        switch(_a){
                            case "turn.start":
                                return [
                                    3 /*break*/ ,
                                    3
                                ];
                            case "response":
                                return [
                                    3 /*break*/ ,
                                    4
                                ];
                            case "audio":
                                return [
                                    3 /*break*/ ,
                                    5
                                ];
                            case "audio.metadata":
                                return [
                                    3 /*break*/ ,
                                    6
                                ];
                            case "turn.end":
                                return [
                                    3 /*break*/ ,
                                    7
                                ];
                        }
                        return [
                            3 /*break*/ ,
                            12
                        ];
                    case 3:
                        this.privSynthesisTurn.onServiceTurnStartResponse();
                        return [
                            3 /*break*/ ,
                            13
                        ];
                    case 4:
                        this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);
                        return [
                            3 /*break*/ ,
                            13
                        ];
                    case 5:
                        if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase() && !!connectionMessage.binaryBody) {
                            this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);
                            if (!!this.privSpeechSynthesizer.synthesizing) try {
                                audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);
                                ev = new Exports_2.SpeechSynthesisEventArgs(new Exports_2.SpeechSynthesisResult(this.privSynthesisTurn.requestId, Exports_2.ResultReason.SynthesizingAudio, audioWithHeader));
                                this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);
                            } catch (error) {
                            // Not going to let errors in the event handler
                            // trip things up.
                            }
                            if (this.privSessionAudioDestination !== undefined) this.privSessionAudioDestination.write(connectionMessage.binaryBody);
                        }
                        return [
                            3 /*break*/ ,
                            13
                        ];
                    case 6:
                        metadataList = Exports_3.SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;
                        for(_i = 0, metadataList_1 = metadataList; _i < metadataList_1.length; _i++){
                            metadata = metadataList_1[_i];
                            switch(metadata.Type){
                                case Exports_3.MetadataType.WordBoundary:
                                case Exports_3.MetadataType.SentenceBoundary:
                                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);
                                    wordBoundaryEventArgs = new Exports_2.SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.Duration, metadata.Data.text.Text, metadata.Data.text.Length, metadata.Type === Exports_3.MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, metadata.Data.text.BoundaryType);
                                    if (!!this.privSpeechSynthesizer.wordBoundary) try {
                                        this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);
                                    } catch (error) {
                                    // Not going to let errors in the event handler
                                    // trip things up.
                                    }
                                    break;
                                case Exports_3.MetadataType.Bookmark:
                                    bookmarkEventArgs = new Exports_2.SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);
                                    if (!!this.privSpeechSynthesizer.bookmarkReached) try {
                                        this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);
                                    } catch (error) {
                                    // Not going to let errors in the event handler
                                    // trip things up.
                                    }
                                    break;
                                case Exports_3.MetadataType.Viseme:
                                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);
                                    if (metadata.Data.IsLastAnimation) {
                                        visemeEventArgs = new Exports_2.SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());
                                        if (!!this.privSpeechSynthesizer.visemeReceived) try {
                                            this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);
                                        } catch (error) {
                                        // Not going to let errors in the event handler
                                        // trip things up.
                                        }
                                    }
                                    break;
                                case Exports_3.MetadataType.SessionEnd:
                                    this.privSynthesisTurn.onSessionEnd(metadata);
                                    break;
                            }
                        }
                        return [
                            3 /*break*/ ,
                            13
                        ];
                    case 7:
                        this.privSynthesisTurn.onServiceTurnEndResponse();
                        result = void 0;
                        _b.label = 8;
                    case 8:
                        _b.trys.push([
                            8,
                            10,
                            ,
                            11
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.privSynthesisTurn.getAllReceivedAudioWithHeader()
                        ];
                    case 9:
                        audioBuffer = _b.sent();
                        result = new Exports_2.SpeechSynthesisResult(this.privSynthesisTurn.requestId, Exports_2.ResultReason.SynthesizingAudioCompleted, audioBuffer, undefined, undefined, this.privSynthesisTurn.audioDuration);
                        if (!!this.privSuccessCallback) this.privSuccessCallback(result);
                        return [
                            3 /*break*/ ,
                            11
                        ];
                    case 10:
                        error_1 = _b.sent();
                        if (!!this.privErrorCallback) this.privErrorCallback(error_1);
                        return [
                            3 /*break*/ ,
                            11
                        ];
                    case 11:
                        if (this.privSpeechSynthesizer.synthesisCompleted) try {
                            this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new Exports_2.SpeechSynthesisEventArgs(result));
                        } catch (e) {
                        // Not going to let errors in the event handler
                        // trip things up.
                        }
                        return [
                            3 /*break*/ ,
                            13
                        ];
                    case 12:
                        if (!this.processTypeSpecificMessages(connectionMessage)) // here are some messages that the derived class has not processed, dispatch them to connect class
                        {
                            if (!!this.privServiceEvents) this.serviceEvents.onEvent(new Exports_1.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
                        }
                        _b.label = 13;
                    case 13:
                        return [
                            2 /*return*/ ,
                            this.receiveMessage()
                        ];
                    case 14:
                        e_2 = _b.sent();
                        return [
                            3 /*break*/ ,
                            15
                        ];
                    case 15:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SynthesisAdapterBase.prototype.sendSynthesisContext = function(connection) {
        var synthesisContextJson = this.synthesisContext.toJSON();
        if (synthesisContextJson) return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_1.MessageType.Text, "synthesis.context", this.privSynthesisTurn.requestId, "application/json", synthesisContextJson));
        return;
    };
    SynthesisAdapterBase.prototype.connectImpl = function(isUnAuthorized) {
        var _this = this;
        if (isUnAuthorized === void 0) isUnAuthorized = false;
        if (this.privConnectionPromise != null) return this.privConnectionPromise.then(function(connection) {
            if (connection.state() === Exports_1.ConnectionState.Disconnected) {
                _this.privConnectionId = null;
                _this.privConnectionPromise = null;
                return _this.connectImpl();
            }
            return _this.privConnectionPromise;
        }, function() {
            _this.privConnectionId = null;
            _this.privConnectionPromise = null;
            return _this.connectImpl();
        });
        this.privAuthFetchEventId = Exports_1.createNoDashGuid();
        this.privConnectionId = Exports_1.createNoDashGuid();
        this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);
        var authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
        this.privConnectionPromise = authPromise.then(function(result) {
            return __awaiter(_this, void 0, void 0, function() {
                var connection, response;
                var _this = this;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            this.privSynthesisTurn.onAuthCompleted(false);
                            connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);
                            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,
                            // it'll stop sending events.
                            connection.events.attach(function(event) {
                                _this.connectionEvents.onEvent(event);
                            });
                            return [
                                4 /*yield*/ ,
                                connection.open()
                            ];
                        case 1:
                            response = _a.sent();
                            if (response.statusCode === 200) {
                                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);
                                return [
                                    2 /*return*/ ,
                                    Promise.resolve(connection)
                                ];
                            } else if (response.statusCode === 403 && !isUnAuthorized) return [
                                2 /*return*/ ,
                                this.connectImpl(true)
                            ];
                            else {
                                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);
                                return [
                                    2 /*return*/ ,
                                    Promise.reject("Unable to contact server. StatusCode: " + response.statusCode + ", " + this.privSynthesizerConfig.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint) + " Reason: " + response.reason)
                                ];
                            }
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        }, function(error) {
            _this.privSynthesisTurn.onAuthCompleted(true);
            throw new Error(error);
        });
        // Attach an empty handler to allow the promise to run in the background while
        // other startup events happen. It'll eventually be awaited on.
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.privConnectionPromise.catch(function() {});
        return this.privConnectionPromise;
    };
    SynthesisAdapterBase.prototype.sendSpeechServiceConfig = function(connection, SpeechServiceConfigJson) {
        if (SpeechServiceConfigJson) return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_1.MessageType.Text, "speech.config", this.privSynthesisTurn.requestId, "application/json", SpeechServiceConfigJson));
    };
    SynthesisAdapterBase.prototype.sendSsmlMessage = function(connection, ssml, requestId) {
        return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_1.MessageType.Text, "ssml", requestId, "application/ssml+xml", ssml));
    };
    SynthesisAdapterBase.prototype.fetchConnection = function() {
        return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (this.privConnectionConfigurationPromise !== undefined) return [
                            2 /*return*/ ,
                            this.privConnectionConfigurationPromise.then(function(connection) {
                                if (connection.state() === Exports_1.ConnectionState.Disconnected) {
                                    _this.privConnectionId = null;
                                    _this.privConnectionConfigurationPromise = undefined;
                                    return _this.fetchConnection();
                                }
                                return _this.privConnectionConfigurationPromise;
                            }, function() {
                                _this.privConnectionId = null;
                                _this.privConnectionConfigurationPromise = undefined;
                                return _this.fetchConnection();
                            })
                        ];
                        this.privConnectionConfigurationPromise = this.configureConnection();
                        return [
                            4 /*yield*/ ,
                            this.privConnectionConfigurationPromise
                        ];
                    case 1:
                        return [
                            2 /*return*/ ,
                            _a.sent()
                        ];
                }
            });
        });
    };
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    SynthesisAdapterBase.prototype.configureConnection = function() {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.connectImpl()
                        ];
                    case 1:
                        connection = _a.sent();
                        if (this.configConnectionOverride !== undefined) return [
                            2 /*return*/ ,
                            this.configConnectionOverride(connection)
                        ];
                        return [
                            4 /*yield*/ ,
                            this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize())
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            connection
                        ];
                }
            });
        });
    };
    SynthesisAdapterBase.telemetryDataEnabled = true;
    return SynthesisAdapterBase;
}();
exports.SynthesisAdapterBase = SynthesisAdapterBase;

},{"2d83348de6f9c8f0":"5Bedw","161bab8158afb62":"hxkc3","b804f9330adecf08":"7Qpvn","2a8a80436ce21770":"euGGf"}],"aeJmp":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SynthesisStartedEvent = exports.ConnectingToSynthesisServiceEvent = exports.SynthesisTriggeredEvent = exports.SpeechSynthesisEvent = void 0;
/* eslint-disable max-classes-per-file */ var Exports_1 = require("fd9483783c0348a4");
var SpeechSynthesisEvent = /** @class */ function(_super) {
    __extends(SpeechSynthesisEvent, _super);
    function SpeechSynthesisEvent(eventName, requestId, eventType) {
        if (eventType === void 0) eventType = Exports_1.EventType.Info;
        var _this = _super.call(this, eventName, eventType) || this;
        _this.privRequestId = requestId;
        return _this;
    }
    Object.defineProperty(SpeechSynthesisEvent.prototype, "requestId", {
        get: function() {
            return this.privRequestId;
        },
        enumerable: false,
        configurable: true
    });
    return SpeechSynthesisEvent;
}(Exports_1.PlatformEvent);
exports.SpeechSynthesisEvent = SpeechSynthesisEvent;
var SynthesisTriggeredEvent = /** @class */ function(_super) {
    __extends(SynthesisTriggeredEvent, _super);
    function SynthesisTriggeredEvent(requestId, sessionAudioDestinationId, turnAudioDestinationId) {
        var _this = _super.call(this, "SynthesisTriggeredEvent", requestId) || this;
        _this.privSessionAudioDestinationId = sessionAudioDestinationId;
        _this.privTurnAudioDestinationId = turnAudioDestinationId;
        return _this;
    }
    Object.defineProperty(SynthesisTriggeredEvent.prototype, "audioSessionDestinationId", {
        get: function() {
            return this.privSessionAudioDestinationId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesisTriggeredEvent.prototype, "audioTurnDestinationId", {
        get: function() {
            return this.privTurnAudioDestinationId;
        },
        enumerable: false,
        configurable: true
    });
    return SynthesisTriggeredEvent;
}(SpeechSynthesisEvent);
exports.SynthesisTriggeredEvent = SynthesisTriggeredEvent;
var ConnectingToSynthesisServiceEvent = /** @class */ function(_super) {
    __extends(ConnectingToSynthesisServiceEvent, _super);
    function ConnectingToSynthesisServiceEvent(requestId, authFetchEventId) {
        var _this = _super.call(this, "ConnectingToSynthesisServiceEvent", requestId) || this;
        _this.privAuthFetchEventId = authFetchEventId;
        return _this;
    }
    Object.defineProperty(ConnectingToSynthesisServiceEvent.prototype, "authFetchEventId", {
        get: function() {
            return this.privAuthFetchEventId;
        },
        enumerable: false,
        configurable: true
    });
    return ConnectingToSynthesisServiceEvent;
}(SpeechSynthesisEvent);
exports.ConnectingToSynthesisServiceEvent = ConnectingToSynthesisServiceEvent;
var SynthesisStartedEvent = /** @class */ function(_super) {
    __extends(SynthesisStartedEvent, _super);
    function SynthesisStartedEvent(requestId, authFetchEventId) {
        var _this = _super.call(this, "SynthesisStartedEvent", requestId) || this;
        _this.privAuthFetchEventId = authFetchEventId;
        return _this;
    }
    Object.defineProperty(SynthesisStartedEvent.prototype, "authFetchEventId", {
        get: function() {
            return this.privAuthFetchEventId;
        },
        enumerable: false,
        configurable: true
    });
    return SynthesisStartedEvent;
}(SpeechSynthesisEvent);
exports.SynthesisStartedEvent = SynthesisStartedEvent;

},{"fd9483783c0348a4":"5Bedw"}],"a9wm8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SynthesisRestAdapter = void 0;
var Exports_1 = require("adfb0e01966e14c5");
var Exports_2 = require("7ae54d05e3c81ee5");
var ConnectionFactoryBase_1 = require("dd83fd0a69e0c9e0");
var HeaderNames_1 = require("ed3d1cfc3fc44daf");
/**
 * Implements methods for speaker recognition classes, sending requests to endpoint
 * and parsing response into expected format
 * @class SynthesisRestAdapter
 */ var SynthesisRestAdapter = /** @class */ function() {
    function SynthesisRestAdapter(config, authentication) {
        var endpoint = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint, undefined);
        if (!endpoint) {
            var region = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Region, "westus");
            var hostSuffix = ConnectionFactoryBase_1.ConnectionFactoryBase.getHostSuffix(region);
            endpoint = config.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Host, "https://" + region + ".tts.speech" + hostSuffix);
        }
        this.privUri = endpoint + "/cognitiveservices/voices/list";
        var options = Exports_1.RestConfigBase.requestOptions;
        this.privRestAdapter = new Exports_1.RestMessageAdapter(options);
        this.privAuthentication = authentication;
    }
    /**
     * Sends list voices request to endpoint.
     * @function
     * @public
     * @param connectionId - guid for connectionId
     * @returns {Promise<IRestResponse>} rest response to status request
     */ SynthesisRestAdapter.prototype.getVoicesList = function(connectionId) {
        var _this = this;
        this.privRestAdapter.setHeaders(HeaderNames_1.HeaderNames.ConnectionId, connectionId);
        return this.privAuthentication.fetch(connectionId).then(function(authInfo) {
            _this.privRestAdapter.setHeaders(authInfo.headerName, authInfo.token);
            return _this.privRestAdapter.request(Exports_1.RestRequestType.Get, _this.privUri);
        });
    };
    return SynthesisRestAdapter;
}();
exports.SynthesisRestAdapter = SynthesisRestAdapter;

},{"adfb0e01966e14c5":"9oZeQ","7ae54d05e3c81ee5":"hxkc3","dd83fd0a69e0c9e0":"hvoIt","ed3d1cfc3fc44daf":"bNYHA"}],"7AtoI":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SynthesizerConfig = exports.SynthesisServiceType = void 0;
var Exports_1 = require("6473b565fc3de12e");
var SynthesisServiceType;
(function(SynthesisServiceType) {
    SynthesisServiceType[SynthesisServiceType["Standard"] = 0] = "Standard";
    SynthesisServiceType[SynthesisServiceType["Custom"] = 1] = "Custom";
})(SynthesisServiceType = exports.SynthesisServiceType || (exports.SynthesisServiceType = {}));
var SynthesizerConfig = /** @class */ function() {
    function SynthesizerConfig(speechServiceConfig, parameters) {
        this.privSynthesisServiceType = SynthesisServiceType.Standard;
        this.privSpeechServiceConfig = speechServiceConfig ? speechServiceConfig : new Exports_1.SpeechServiceConfig(new Exports_1.Context(null));
        this.privParameters = parameters;
    }
    Object.defineProperty(SynthesizerConfig.prototype, "parameters", {
        get: function() {
            return this.privParameters;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesizerConfig.prototype, "synthesisServiceType", {
        get: function() {
            return this.privSynthesisServiceType;
        },
        set: function(value) {
            this.privSynthesisServiceType = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SynthesizerConfig.prototype, "SpeechServiceConfig", {
        get: function() {
            return this.privSpeechServiceConfig;
        },
        enumerable: false,
        configurable: true
    });
    return SynthesizerConfig;
}();
exports.SynthesizerConfig = SynthesizerConfig;

},{"6473b565fc3de12e":"7Qpvn"}],"gI7gQ":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SynthesisContext = void 0;
var Exports_1 = require("b48cf0f3618e906a");
/**
 * Represents the JSON used in the synthesis.context message sent to the speech service.
 * The dynamic grammar is always refreshed from the encapsulated dynamic grammar object.
 */ var SynthesisContext = /** @class */ function() {
    function SynthesisContext(speechSynthesizer) {
        this.privContext = {};
        this.privSpeechSynthesizer = speechSynthesizer;
    }
    /**
     * Adds a section to the synthesis.context object.
     * @param sectionName Name of the section to add.
     * @param value JSON serializable object that represents the value.
     */ SynthesisContext.prototype.setSection = function(sectionName, value) {
        this.privContext[sectionName] = value;
    };
    Object.defineProperty(SynthesisContext.prototype, "audioOutputFormat", {
        /**
         * Sets the audio output format for synthesis context generation.
         * @param format {AudioOutputFormatImpl} the output format
         */ set: function(format) {
            this.privAudioOutputFormat = format;
        },
        enumerable: false,
        configurable: true
    });
    SynthesisContext.prototype.toJSON = function() {
        var synthesisSection = this.buildSynthesisContext();
        this.setSection("synthesis", synthesisSection);
        return JSON.stringify(this.privContext);
    };
    SynthesisContext.prototype.buildSynthesisContext = function() {
        return {
            audio: {
                metadataOptions: {
                    bookmarkEnabled: !!this.privSpeechSynthesizer.bookmarkReached,
                    punctuationBoundaryEnabled: this.privSpeechSynthesizer.properties.getProperty(Exports_1.PropertyId.SpeechServiceResponse_RequestPunctuationBoundary, !!this.privSpeechSynthesizer.wordBoundary),
                    sentenceBoundaryEnabled: this.privSpeechSynthesizer.properties.getProperty(Exports_1.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, false),
                    sessionEndEnabled: true,
                    visemeEnabled: !!this.privSpeechSynthesizer.visemeReceived,
                    wordBoundaryEnabled: this.privSpeechSynthesizer.properties.getProperty(Exports_1.PropertyId.SpeechServiceResponse_RequestWordBoundary, !!this.privSpeechSynthesizer.wordBoundary)
                },
                outputFormat: this.privAudioOutputFormat.requestAudioFormatString
            },
            language: {
                autoDetection: this.privSpeechSynthesizer.autoDetectSourceLanguage
            }
        };
    };
    return SynthesisContext;
}();
exports.SynthesisContext = SynthesisContext;

},{"b48cf0f3618e906a":"hxkc3"}],"36zGl":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeakerRecognitionConfig = void 0;
var Exports_1 = require("d7fb13afb819666b");
var SpeakerRecognitionConfig = /** @class */ function() {
    function SpeakerRecognitionConfig(context, parameters) {
        this.privContext = context ? context : new Exports_1.Context(null);
        this.privParameters = parameters;
    }
    Object.defineProperty(SpeakerRecognitionConfig.prototype, "parameters", {
        get: function() {
            return this.privParameters;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpeakerRecognitionConfig.prototype, "Context", {
        get: function() {
            return this.privContext;
        },
        enumerable: false,
        configurable: true
    });
    return SpeakerRecognitionConfig;
}();
exports.SpeakerRecognitionConfig = SpeakerRecognitionConfig;

},{"d7fb13afb819666b":"7Qpvn"}],"9mgJt":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpeakerServiceRecognizer = void 0;
var Exports_1 = require("5f04513e9fd9d107");
var Exports_2 = require("81609ebde013d198");
var Exports_3 = require("16b7d3e40ef365c3");
var Exports_4 = require("753bd097f6175c2");
var SpeechConnectionMessage_Internal_1 = require("b11f8f859a8985d8");
// eslint-disable-next-line max-classes-per-file
var SpeakerServiceRecognizer = /** @class */ function(_super) {
    __extends(SpeakerServiceRecognizer, _super);
    function SpeakerServiceRecognizer(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, recognizer) || this;
        _this.privSpeakerRecognizer = recognizer;
        _this.privSpeakerAudioSource = audioSource;
        _this.recognizeSpeaker = function(model) {
            return _this.recognizeSpeakerOnce(model);
        };
        _this.sendPrePayloadJSONOverride = function() {
            return _this.noOp();
        };
        return _this;
    }
    SpeakerServiceRecognizer.prototype.processTypeSpecificMessages = function(connectionMessage) {
        var processed = false;
        var resultProps = new Exports_3.PropertyCollection();
        if (connectionMessage.messageType === Exports_2.MessageType.Text) resultProps.setProperty(Exports_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
        switch(connectionMessage.path.toLowerCase()){
            case "speaker.response":
                var response = JSON.parse(connectionMessage.textBody);
                var result = void 0;
                if (response.status.statusCode.toLowerCase() !== "success") result = new Exports_3.SpeakerRecognitionResult(response, Exports_3.ResultReason.Canceled, Exports_3.CancellationErrorCode.ServiceError, response.status.reason);
                else result = new Exports_3.SpeakerRecognitionResult(response, Exports_3.ResultReason.RecognizedSpeaker);
                if (!!this.privResultDeferral) this.privResultDeferral.resolve(result);
                processed = true;
                break;
            default:
                break;
        }
        var defferal = new Exports_2.Deferred();
        defferal.resolve(processed);
        return defferal.promise;
    };
    // Cancels recognition.
    SpeakerServiceRecognizer.prototype.cancelRecognition = function(sessionId, requestId, cancellationReason, errorCode, error) {
        var properties = new Exports_3.PropertyCollection();
        properties.setProperty(Exports_4.CancellationErrorCodePropertyName, Exports_3.CancellationErrorCode[errorCode]);
        if (!!this.privResultDeferral) {
            var result = new Exports_3.SpeakerRecognitionResult({
                scenario: this.privSpeakerModel.scenario,
                status: {
                    statusCode: error,
                    reason: error
                }
            }, Exports_3.ResultReason.Canceled, errorCode, error);
            try {
                this.privResultDeferral.resolve(result);
            } catch (error) {
                this.privResultDeferral.reject(error);
            }
        }
    };
    SpeakerServiceRecognizer.prototype.recognizeSpeakerOnce = function(model) {
        return __awaiter(this, void 0, void 0, function() {
            var conPromise, preAudioPromise, node, format, deviceInfo, audioNode, err_1, sessionStartEventArgs, audioSendPromise;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.privSpeakerModel = model;
                        this.voiceProfileType = model.scenario;
                        if (!this.privResultDeferral) this.privResultDeferral = new Exports_2.Deferred();
                        this.privRequestSession.startNewRecognition();
                        this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events);
                        this.privRecognizerConfig.parameters.setProperty(Exports_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
                        conPromise = this.connectImpl();
                        preAudioPromise = this.sendPreAudioMessages(this.extractSpeakerContext(model));
                        return [
                            4 /*yield*/ ,
                            this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId)
                        ];
                    case 1:
                        node = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privSpeakerAudioSource.format
                        ];
                    case 2:
                        format = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privSpeakerAudioSource.deviceInfo
                        ];
                    case 3:
                        deviceInfo = _a.sent();
                        audioNode = new Exports_1.ReplayableAudioNode(node, format.avgBytesPerSec);
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false)
                        ];
                    case 4:
                        _a.sent();
                        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {
                            source: deviceInfo
                        };
                        _a.label = 5;
                    case 5:
                        _a.trys.push([
                            5,
                            8,
                            ,
                            9
                        ]);
                        return [
                            4 /*yield*/ ,
                            conPromise
                        ];
                    case 6:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            preAudioPromise
                        ];
                    case 7:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            9
                        ];
                    case 8:
                        err_1 = _a.sent();
                        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.ConnectionFailure, err_1);
                        return [
                            3 /*break*/ ,
                            9
                        ];
                    case 9:
                        sessionStartEventArgs = new Exports_3.SessionEventArgs(this.privRequestSession.sessionId);
                        if (!!this.privRecognizer.sessionStarted) this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
                        this.receiveMessage();
                        audioSendPromise = this.sendAudio(audioNode);
                        // /* eslint-disable no-empty */
                        audioSendPromise.then(function() {}, function(error) {
                            _this.cancelRecognition(_this.privRequestSession.sessionId, _this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error);
                        });
                        return [
                            2 /*return*/ ,
                            this.privResultDeferral.promise
                        ];
                }
            });
        });
    };
    SpeakerServiceRecognizer.prototype.sendPreAudioMessages = function(context) {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendSpeakerRecognition(connection, context)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    SpeakerServiceRecognizer.prototype.sendSpeakerRecognition = function(connection, context) {
        return __awaiter(this, void 0, void 0, function() {
            var speakerContextJson;
            return __generator(this, function(_a) {
                speakerContextJson = JSON.stringify(context);
                return [
                    2 /*return*/ ,
                    connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, "speaker.context", this.privRequestSession.requestId, "application/json; charset=utf-8", speakerContextJson))
                ];
            });
        });
    };
    SpeakerServiceRecognizer.prototype.extractSpeakerContext = function(model) {
        return {
            features: {
                interimResult: "enabled",
                progressiveDetection: "disabled"
            },
            profileIds: model.profileIds,
            scenario: model.scenario
        };
    };
    return SpeakerServiceRecognizer;
}(Exports_4.ServiceRecognizerBase);
exports.SpeakerServiceRecognizer = SpeakerServiceRecognizer;

},{"5f04513e9fd9d107":"9oZeQ","81609ebde013d198":"5Bedw","16b7d3e40ef365c3":"hxkc3","753bd097f6175c2":"7Qpvn","b11f8f859a8985d8":"euGGf"}],"fHZDC":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoiceServiceRecognizer = void 0;
var Exports_1 = require("9c2390fe211954dd");
var Exports_2 = require("81be8b126e20514d");
var Exports_3 = require("8c4e6dd6231b5e91");
var Exports_4 = require("f71e2e7b431d16d7");
var SpeechConnectionMessage_Internal_1 = require("4ab48c864ed1b8ce");
// eslint-disable-next-line max-classes-per-file
var VoiceServiceRecognizer = /** @class */ function(_super) {
    __extends(VoiceServiceRecognizer, _super);
    function VoiceServiceRecognizer(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
        var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, recognizer) || this;
        _this.privDeferralMap = new Exports_2.DeferralMap();
        _this.privSpeakerAudioSource = audioSource;
        _this.sendPrePayloadJSONOverride = function() {
            return _this.noOp();
        };
        return _this;
    }
    Object.defineProperty(VoiceServiceRecognizer.prototype, "SpeakerAudioSource", {
        set: function(audioSource) {
            this.privSpeakerAudioSource = audioSource;
        },
        enumerable: false,
        configurable: true
    });
    VoiceServiceRecognizer.prototype.processTypeSpecificMessages = function(connectionMessage) {
        var processed = false;
        var resultProps = new Exports_3.PropertyCollection();
        if (connectionMessage.messageType === Exports_2.MessageType.Text) resultProps.setProperty(Exports_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
        switch(connectionMessage.path.toLowerCase()){
            // Profile management response for create, fetch, delete, reset
            case "speaker.profiles":
                var response = JSON.parse(connectionMessage.textBody);
                switch(response.operation.toLowerCase()){
                    case "create":
                        this.handleCreateResponse(response, connectionMessage.requestId);
                        break;
                    case "delete":
                    case "reset":
                        this.handleResultResponse(response, connectionMessage.requestId);
                        break;
                    case "fetch":
                        var enrollmentResponse_1 = JSON.parse(connectionMessage.textBody);
                        this.handleFetchResponse(enrollmentResponse_1, connectionMessage.requestId);
                        break;
                    default:
                        break;
                }
                processed = true;
                break;
            // Activation and authorization phrase response
            case "speaker.phrases":
                var phraseResponse = JSON.parse(connectionMessage.textBody);
                this.handlePhrasesResponse(phraseResponse, connectionMessage.requestId);
                processed = true;
                break;
            // Enrollment response
            case "speaker.profile.enrollment":
                var enrollmentResponse = JSON.parse(connectionMessage.textBody);
                var result = new Exports_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(!!enrollmentResponse.enrollment ? enrollmentResponse.enrollment.enrollmentStatus : enrollmentResponse.status.statusCode), !!enrollmentResponse.enrollment ? JSON.stringify(enrollmentResponse.enrollment) : undefined, enrollmentResponse.status.reason);
                if (!!this.privDeferralMap.getId(connectionMessage.requestId)) this.privDeferralMap.complete(connectionMessage.requestId, result);
                this.privRequestSession.onSpeechEnded();
                processed = true;
                break;
            default:
                break;
        }
        var defferal = new Exports_2.Deferred();
        defferal.resolve(processed);
        return defferal.promise;
    };
    // Cancels recognition.
    VoiceServiceRecognizer.prototype.cancelRecognition = function(sessionId, requestId, cancellationReason, errorCode, error) {
        var properties = new Exports_3.PropertyCollection();
        // const enrollmentResponse: EnrollmentResponse = JSON.parse(connectionMessage.textBody) as EnrollmentResponse;
        properties.setProperty(Exports_4.CancellationErrorCodePropertyName, Exports_3.CancellationErrorCode[errorCode]);
        var result = new Exports_3.VoiceProfileEnrollmentResult(Exports_3.ResultReason.Canceled, error, error);
        if (!!this.privDeferralMap.getId(requestId)) this.privDeferralMap.complete(requestId, result);
    };
    VoiceServiceRecognizer.prototype.createProfile = function(profileType, locale) {
        return __awaiter(this, void 0, void 0, function() {
            var conPromise, createProfileDeferral, err_1;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().
                        this.voiceProfileType = profileType.toString();
                        conPromise = this.connectImpl();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            4,
                            ,
                            5
                        ]);
                        createProfileDeferral = new Exports_2.Deferred();
                        return [
                            4 /*yield*/ ,
                            conPromise
                        ];
                    case 2:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendCreateProfile(createProfileDeferral, profileType, locale)
                        ];
                    case 3:
                        _a.sent();
                        this.receiveMessage();
                        return [
                            2 /*return*/ ,
                            createProfileDeferral.promise
                        ];
                    case 4:
                        err_1 = _a.sent();
                        throw err_1;
                    case 5:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    VoiceServiceRecognizer.prototype.resetProfile = function(profile) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                this.voiceProfileType = profile.profileType.toString();
                return [
                    2 /*return*/ ,
                    this.sendCommonRequest("reset", profile.profileType, profile)
                ];
            });
        });
    };
    VoiceServiceRecognizer.prototype.deleteProfile = function(profile) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                this.voiceProfileType = profile.profileType.toString();
                return [
                    2 /*return*/ ,
                    this.sendCommonRequest("delete", profile.profileType, profile)
                ];
            });
        });
    };
    VoiceServiceRecognizer.prototype.retrieveEnrollmentResult = function(profile) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                this.voiceProfileType = profile.profileType.toString();
                this.privExpectedProfileId = profile.profileId;
                return [
                    2 /*return*/ ,
                    this.sendCommonRequest("fetch", profile.profileType, profile)
                ];
            });
        });
    };
    VoiceServiceRecognizer.prototype.getAllProfiles = function(profileType) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                this.voiceProfileType = profileType.toString();
                return [
                    2 /*return*/ ,
                    this.sendCommonRequest("fetch", profileType)
                ];
            });
        });
    };
    VoiceServiceRecognizer.prototype.getActivationPhrases = function(profileType, lang) {
        return __awaiter(this, void 0, void 0, function() {
            var conPromise, getPhrasesDeferral, err_2;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.voiceProfileType = profileType.toString();
                        conPromise = this.connectImpl();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            4,
                            ,
                            5
                        ]);
                        getPhrasesDeferral = new Exports_2.Deferred();
                        return [
                            4 /*yield*/ ,
                            conPromise
                        ];
                    case 2:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.sendPhrasesRequest(getPhrasesDeferral, profileType, lang)
                        ];
                    case 3:
                        _a.sent();
                        this.receiveMessage();
                        return [
                            2 /*return*/ ,
                            getPhrasesDeferral.promise
                        ];
                    case 4:
                        err_2 = _a.sent();
                        throw err_2;
                    case 5:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    VoiceServiceRecognizer.prototype.enrollProfile = function(profile) {
        return __awaiter(this, void 0, void 0, function() {
            var enrollmentDeferral, conPromise, preAudioPromise, node, format, deviceInfo, audioNode, err_3, sessionStartEventArgs, audioSendPromise;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.voiceProfileType = profile.profileType.toString();
                        enrollmentDeferral = new Exports_2.Deferred();
                        this.privRequestSession.startNewRecognition();
                        this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events);
                        this.privRecognizerConfig.parameters.setProperty(Exports_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
                        conPromise = this.connectImpl();
                        preAudioPromise = this.sendPreAudioMessages(profile, enrollmentDeferral);
                        return [
                            4 /*yield*/ ,
                            this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId)
                        ];
                    case 1:
                        node = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privSpeakerAudioSource.format
                        ];
                    case 2:
                        format = _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privSpeakerAudioSource.deviceInfo
                        ];
                    case 3:
                        deviceInfo = _a.sent();
                        audioNode = new Exports_1.ReplayableAudioNode(node, format.avgBytesPerSec);
                        return [
                            4 /*yield*/ ,
                            this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false)
                        ];
                    case 4:
                        _a.sent();
                        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {
                            source: deviceInfo
                        };
                        _a.label = 5;
                    case 5:
                        _a.trys.push([
                            5,
                            8,
                            ,
                            9
                        ]);
                        return [
                            4 /*yield*/ ,
                            conPromise
                        ];
                    case 6:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            preAudioPromise
                        ];
                    case 7:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            9
                        ];
                    case 8:
                        err_3 = _a.sent();
                        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.ConnectionFailure, err_3);
                        return [
                            3 /*break*/ ,
                            9
                        ];
                    case 9:
                        sessionStartEventArgs = new Exports_3.SessionEventArgs(this.privRequestSession.sessionId);
                        if (!!this.privRecognizer.sessionStarted) this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
                        this.receiveMessage();
                        audioSendPromise = this.sendAudio(audioNode);
                        // /* eslint-disable no-empty */
                        audioSendPromise.then(function() {}, function(error) {
                            _this.cancelRecognition(_this.privRequestSession.sessionId, _this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error);
                        });
                        return [
                            2 /*return*/ ,
                            enrollmentDeferral.promise
                        ];
                }
            });
        });
    };
    VoiceServiceRecognizer.prototype.sendPreAudioMessages = function(profile, enrollmentDeferral) {
        return __awaiter(this, void 0, void 0, function() {
            var connection;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        this.privRequestSession.onSpeechContext();
                        this.privDeferralMap.add(this.privRequestSession.requestId, enrollmentDeferral);
                        return [
                            4 /*yield*/ ,
                            this.sendBaseRequest(connection, "enroll", this.scenarioFrom(profile.profileType), profile)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    VoiceServiceRecognizer.prototype.sendPhrasesRequest = function(getPhrasesDeferral, profileType, locale) {
        return __awaiter(this, void 0, void 0, function() {
            var connection, scenario, profileCreateRequest;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        this.privRequestSession.onSpeechContext();
                        this.privDeferralMap.add(this.privRequestSession.requestId, getPhrasesDeferral);
                        scenario = this.scenarioFrom(profileType);
                        profileCreateRequest = {
                            locale: locale,
                            scenario: scenario
                        };
                        return [
                            2 /*return*/ ,
                            connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, "speaker.profile.phrases", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(profileCreateRequest)))
                        ];
                }
            });
        });
    };
    VoiceServiceRecognizer.prototype.sendCreateProfile = function(createProfileDeferral, profileType, locale) {
        return __awaiter(this, void 0, void 0, function() {
            var connection, scenario, profileCreateRequest;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 1:
                        connection = _a.sent();
                        this.privRequestSession.onSpeechContext();
                        this.privDeferralMap.add(this.privRequestSession.requestId, createProfileDeferral);
                        scenario = profileType === Exports_3.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : profileType === Exports_3.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
                        profileCreateRequest = {
                            locale: locale,
                            number: "1",
                            scenario: scenario
                        };
                        return [
                            2 /*return*/ ,
                            connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, "speaker.profile.create", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(profileCreateRequest)))
                        ];
                }
            });
        });
    };
    VoiceServiceRecognizer.prototype.sendCommonRequest = function(operation, profileType, profile) {
        if (profile === void 0) profile = undefined;
        return __awaiter(this, void 0, void 0, function() {
            var conPromise, deferral, connection, err_4;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        conPromise = this.connectImpl();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            5,
                            ,
                            6
                        ]);
                        deferral = new Exports_2.Deferred();
                        this.privRequestSession.onSpeechContext();
                        return [
                            4 /*yield*/ ,
                            conPromise
                        ];
                    case 2:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.fetchConnection()
                        ];
                    case 3:
                        connection = _a.sent();
                        this.privDeferralMap.add(this.privRequestSession.requestId, deferral);
                        return [
                            4 /*yield*/ ,
                            this.sendBaseRequest(connection, operation, this.scenarioFrom(profileType), profile)
                        ];
                    case 4:
                        _a.sent();
                        this.receiveMessage();
                        return [
                            2 /*return*/ ,
                            deferral.promise
                        ];
                    case 5:
                        err_4 = _a.sent();
                        throw err_4;
                    case 6:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    VoiceServiceRecognizer.prototype.sendBaseRequest = function(connection, operation, scenario, profile) {
        return __awaiter(this, void 0, void 0, function() {
            var profileRequest;
            return __generator(this, function(_a) {
                profileRequest = {
                    scenario: scenario
                };
                if (!!profile) profileRequest.profileIds = [
                    profile.profileId
                ];
                else profileRequest.maxPageSize = -1;
                return [
                    2 /*return*/ ,
                    connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, "speaker.profile." + operation, this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(profileRequest)))
                ];
            });
        });
    };
    VoiceServiceRecognizer.prototype.extractSpeakerContext = function(model) {
        return {
            features: {
                interimResult: "enabled",
                progressiveDetection: "disabled"
            },
            profileIds: model.profileIds,
            scenario: model.scenario
        };
    };
    VoiceServiceRecognizer.prototype.handlePhrasesResponse = function(response, requestId) {
        if (!!this.privDeferralMap.getId(requestId)) {
            if (response.status.statusCode.toLowerCase() !== "success") {
                var reason = Exports_3.ResultReason.Canceled;
                var result = new Exports_3.VoiceProfilePhraseResult(reason, response.status.statusCode, response.passPhraseType, []);
                this.privDeferralMap.complete(requestId, result);
            } else if (!!response.phrases && response.phrases.length > 0) {
                var reason = Exports_3.ResultReason.EnrollingVoiceProfile;
                var result = new Exports_3.VoiceProfilePhraseResult(reason, response.status.statusCode, response.passPhraseType, response.phrases);
                this.privDeferralMap.complete(requestId, result);
            } else throw new Error("Voice Profile get activation phrases failed, no phrases received");
        } else throw new Error("Voice Profile get activation phrases request for requestID " + requestId + " not found");
    };
    VoiceServiceRecognizer.prototype.handleCreateResponse = function(response, requestId) {
        if (!!response.profiles && response.profiles.length > 0) {
            if (!!this.privDeferralMap.getId(requestId)) {
                var profileIds = response.profiles.map(function(profile) {
                    return profile.profileId;
                });
                this.privDeferralMap.complete(requestId, profileIds);
            } else throw new Error("Voice Profile create request for requestID " + requestId + " not found");
        } else throw new Error("Voice Profile create failed, no profile id received");
    };
    VoiceServiceRecognizer.prototype.handleResultResponse = function(response, requestId) {
        if (!!this.privDeferralMap.getId(requestId)) {
            var successReason = response.operation.toLowerCase() === "delete" ? Exports_3.ResultReason.DeletedVoiceProfile : Exports_3.ResultReason.ResetVoiceProfile;
            var reason = response.status.statusCode.toLowerCase() === "success" ? successReason : Exports_3.ResultReason.Canceled;
            var result = new Exports_3.VoiceProfileResult(reason, "statusCode: " + response.status.statusCode + ", errorDetails: " + response.status.reason);
            this.privDeferralMap.complete(requestId, result);
        } else throw new Error("Voice Profile create request for requestID " + requestId + " not found");
    };
    VoiceServiceRecognizer.prototype.handleFetchResponse = function(enrollmentResponse, requestId) {
        if (!!this.privDeferralMap.getId(requestId) && !!enrollmentResponse.profiles[0]) {
            if (!!this.privExpectedProfileId && enrollmentResponse.profiles.length === 1 && enrollmentResponse.profiles[0].profileId === this.privExpectedProfileId) {
                this.privExpectedProfileId = undefined;
                var profileInfo = enrollmentResponse.profiles[0];
                var result = new Exports_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(profileInfo.enrollmentStatus), JSON.stringify(profileInfo), enrollmentResponse.status.reason);
                this.privDeferralMap.complete(requestId, result);
            } else if (enrollmentResponse.profiles.length > 0) {
                var iProfiles = enrollmentResponse.profiles;
                var profileResults = [];
                for(var _i = 0, iProfiles_1 = iProfiles; _i < iProfiles_1.length; _i++){
                    var profile = iProfiles_1[_i];
                    profileResults.push(new Exports_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(profile.enrollmentStatus), JSON.stringify(profile), enrollmentResponse.status.reason));
                }
                this.privDeferralMap.complete(requestId, profileResults);
            }
        } else throw new Error("Voice Profile fetch request for requestID " + requestId + " not found");
    };
    VoiceServiceRecognizer.prototype.enrollmentReasonFrom = function(statusCode) {
        switch(statusCode.toLowerCase()){
            case "enrolled":
                return Exports_3.ResultReason.EnrolledVoiceProfile;
            case "invalidlocale":
            case "invalidphrase":
            case "invalidaudioformat":
            case "invalidscenario":
            case "invalidprofilecount":
            case "invalidoperation":
            case "audiotooshort":
            case "audiotoolong":
            case "toomanyenrollments":
            case "storageconflict":
            case "profilenotfound":
            case "incompatibleprofiles":
            case "incompleteenrollment":
                return Exports_3.ResultReason.Canceled;
            default:
                return Exports_3.ResultReason.EnrollingVoiceProfile;
        }
    };
    VoiceServiceRecognizer.prototype.scenarioFrom = function(profileType) {
        return profileType === Exports_3.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : profileType === Exports_3.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
    };
    return VoiceServiceRecognizer;
}(Exports_4.ServiceRecognizerBase);
exports.VoiceServiceRecognizer = VoiceServiceRecognizer;

},{"9c2390fe211954dd":"9oZeQ","81be8b126e20514d":"5Bedw","8c4e6dd6231b5e91":"hxkc3","f71e2e7b431d16d7":"7Qpvn","4ab48c864ed1b8ce":"euGGf"}],"bXen4":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileAudioSource = void 0;
var Exports_1 = require("c98e3f363a112a54");
var Exports_2 = require("5545da95799af169");
var AudioStreamFormat_1 = require("1af19aae6316bfb2");
var FileAudioSource = /** @class */ function() {
    function FileAudioSource(file, filename, audioSourceId) {
        this.privStreams = {};
        this.privHeaderEnd = 44;
        this.privId = audioSourceId ? audioSourceId : Exports_2.createNoDashGuid();
        this.privEvents = new Exports_2.EventSource();
        this.privSource = file;
        if (typeof window !== "undefined" && typeof Blob !== "undefined" && this.privSource instanceof Blob) this.privFilename = file.name;
        else this.privFilename = filename || "unknown.wav";
        // Read the header.
        this.privAudioFormatPromise = this.readHeader();
    }
    Object.defineProperty(FileAudioSource.prototype, "format", {
        get: function() {
            return this.privAudioFormatPromise;
        },
        enumerable: false,
        configurable: true
    });
    FileAudioSource.prototype.turnOn = function() {
        if (this.privFilename.lastIndexOf(".wav") !== this.privFilename.length - 4) {
            var errorMsg = this.privFilename + " is not supported. Only WAVE files are allowed at the moment.";
            this.onEvent(new Exports_2.AudioSourceErrorEvent(errorMsg, ""));
            return Promise.reject(errorMsg);
        }
        this.onEvent(new Exports_2.AudioSourceInitializingEvent(this.privId)); // no stream id
        this.onEvent(new Exports_2.AudioSourceReadyEvent(this.privId));
        return;
    };
    FileAudioSource.prototype.id = function() {
        return this.privId;
    };
    FileAudioSource.prototype.attach = function(audioNodeId) {
        return __awaiter(this, void 0, void 0, function() {
            var stream;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.onEvent(new Exports_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
                        return [
                            4 /*yield*/ ,
                            this.upload(audioNodeId)
                        ];
                    case 1:
                        stream = _a.sent();
                        this.onEvent(new Exports_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
                        return [
                            2 /*return*/ ,
                            Promise.resolve({
                                detach: function() {
                                    return __awaiter(_this, void 0, void 0, function() {
                                        return __generator(this, function(_a) {
                                            switch(_a.label){
                                                case 0:
                                                    stream.readEnded();
                                                    delete this.privStreams[audioNodeId];
                                                    this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
                                                    return [
                                                        4 /*yield*/ ,
                                                        this.turnOff()
                                                    ];
                                                case 1:
                                                    _a.sent();
                                                    return [
                                                        2 /*return*/ 
                                                    ];
                                            }
                                        });
                                    });
                                },
                                id: function() {
                                    return audioNodeId;
                                },
                                read: function() {
                                    return stream.read();
                                }
                            })
                        ];
                }
            });
        });
    };
    FileAudioSource.prototype.detach = function(audioNodeId) {
        if (audioNodeId && this.privStreams[audioNodeId]) {
            this.privStreams[audioNodeId].close();
            delete this.privStreams[audioNodeId];
            this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
        }
    };
    FileAudioSource.prototype.turnOff = function() {
        for(var streamId in this.privStreams)if (streamId) {
            var stream = this.privStreams[streamId];
            if (stream && !stream.isClosed) stream.close();
        }
        this.onEvent(new Exports_2.AudioSourceOffEvent(this.privId)); // no stream now
        return Promise.resolve();
    };
    Object.defineProperty(FileAudioSource.prototype, "events", {
        get: function() {
            return this.privEvents;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FileAudioSource.prototype, "deviceInfo", {
        get: function() {
            return this.privAudioFormatPromise.then(function(result) {
                return Promise.resolve({
                    bitspersample: result.bitsPerSample,
                    channelcount: result.channels,
                    connectivity: Exports_1.connectivity.Unknown,
                    manufacturer: "Speech SDK",
                    model: "File",
                    samplerate: result.samplesPerSec,
                    type: Exports_1.type.File
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    FileAudioSource.prototype.readHeader = function() {
        var _this = this;
        // Read the wave header.
        var maxHeaderSize = 4296;
        var header = this.privSource.slice(0, maxHeaderSize);
        var headerResult = new Exports_2.Deferred();
        var processHeader = function(header) {
            var view = new DataView(header);
            var getWord = function(index) {
                return String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));
            };
            // RIFF 4 bytes.
            if ("RIFF" !== getWord(0)) {
                headerResult.reject("Invalid WAV header in file, RIFF was not found");
                return;
            }
            // length, 4 bytes
            // RIFF Type & fmt 8 bytes
            if ("WAVE" !== getWord(8) || "fmt " !== getWord(12)) {
                headerResult.reject("Invalid WAV header in file, WAVEfmt was not found");
                return;
            }
            var formatSize = view.getInt32(16, true);
            var channelCount = view.getUint16(22, true);
            var sampleRate = view.getUint32(24, true);
            var bitsPerSample = view.getUint16(34, true);
            // Confirm if header is 44 bytes long.
            var pos = 36 + Math.max(formatSize - 16, 0);
            for(; getWord(pos) !== "data"; pos += 2)if (pos > maxHeaderSize - 8) {
                headerResult.reject("Invalid WAV header in file, data block was not found");
                return;
            }
            _this.privHeaderEnd = pos + 8;
            headerResult.resolve(AudioStreamFormat_1.AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));
        };
        if (typeof window !== "undefined" && typeof Blob !== "undefined" && header instanceof Blob) {
            var reader = new FileReader();
            reader.onload = function(event) {
                var header = event.target.result;
                processHeader(header);
            };
            reader.readAsArrayBuffer(header);
        } else {
            var h = header;
            processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));
        }
        return headerResult.promise;
    };
    FileAudioSource.prototype.upload = function(audioNodeId) {
        return __awaiter(this, void 0, void 0, function() {
            var onerror, format, stream_1, chunk, processFile_1, reader, c, e_1;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        onerror = function(error) {
                            var errorMsg = "Error occurred while processing '" + _this.privFilename + "'. " + error;
                            _this.onEvent(new Exports_2.AudioStreamNodeErrorEvent(_this.privId, audioNodeId, errorMsg));
                            throw new Error(errorMsg);
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            4,
                            ,
                            5
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.turnOn()
                        ];
                    case 2:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privAudioFormatPromise
                        ];
                    case 3:
                        format = _a.sent();
                        stream_1 = new Exports_2.ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);
                        this.privStreams[audioNodeId] = stream_1;
                        chunk = this.privSource.slice(this.privHeaderEnd);
                        processFile_1 = function(buff) {
                            if (stream_1.isClosed) return; // output stream was closed (somebody called TurnOff). We're done here.
                            stream_1.writeStreamChunk({
                                buffer: buff,
                                isEnd: false,
                                timeReceived: Date.now()
                            });
                            stream_1.close();
                        };
                        if (typeof window !== "undefined" && typeof Blob !== "undefined" && chunk instanceof Blob) {
                            reader = new FileReader();
                            reader.onerror = function(ev) {
                                return onerror(ev.toString());
                            };
                            reader.onload = function(event) {
                                var fileBuffer = event.target.result;
                                processFile_1(fileBuffer);
                            };
                            reader.readAsArrayBuffer(chunk);
                        } else {
                            c = chunk;
                            processFile_1(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));
                        }
                        return [
                            2 /*return*/ ,
                            stream_1
                        ];
                    case 4:
                        e_1 = _a.sent();
                        onerror(e_1);
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 5:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    FileAudioSource.prototype.onEvent = function(event) {
        this.privEvents.onEvent(event);
        Exports_2.Events.instance.onEvent(event);
    };
    return FileAudioSource;
}();
exports.FileAudioSource = FileAudioSource;

},{"c98e3f363a112a54":"7Qpvn","5545da95799af169":"5Bedw","1af19aae6316bfb2":"8hTlD"}],"2qbKj":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PcmRecorder = void 0;
var Exports_1 = require("c4eb0468a1b1bf40");
var PcmRecorder = /** @class */ function() {
    function PcmRecorder(stopInputOnRelease) {
        this.privStopInputOnRelease = stopInputOnRelease;
    }
    PcmRecorder.prototype.record = function(context, mediaStream, outputStream) {
        var _this = this;
        var desiredSampleRate = 16000;
        var waveStreamEncoder = new Exports_1.RiffPcmEncoder(context.sampleRate, desiredSampleRate);
        var micInput = context.createMediaStreamSource(mediaStream);
        var attachScriptProcessor = function() {
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            var scriptNode = function() {
                var bufferSize = 0;
                try {
                    return context.createScriptProcessor(bufferSize, 1, 1);
                } catch (error) {
                    // Webkit (<= version 31) requires a valid bufferSize.
                    bufferSize = 2048;
                    var audioSampleRate = context.sampleRate;
                    while(bufferSize < 16384 && audioSampleRate >= 2 * desiredSampleRate){
                        bufferSize <<= 1;
                        audioSampleRate >>= 1;
                    }
                    return context.createScriptProcessor(bufferSize, 1, 1);
                }
            }();
            scriptNode.onaudioprocess = function(event) {
                var inputFrame = event.inputBuffer.getChannelData(0);
                if (outputStream && !outputStream.isClosed) {
                    var waveFrame = waveStreamEncoder.encode(inputFrame);
                    if (!!waveFrame) outputStream.writeStreamChunk({
                        buffer: waveFrame,
                        isEnd: false,
                        timeReceived: Date.now()
                    });
                }
            };
            micInput.connect(scriptNode);
            scriptNode.connect(context.destination);
            _this.privMediaResources = {
                scriptProcessorNode: scriptNode,
                source: micInput,
                stream: mediaStream
            };
        };
        // https://webaudio.github.io/web-audio-api/#audioworklet
        // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread
        if (!!context.audioWorklet) {
            if (!this.privSpeechProcessorScript) {
                var workletScript = "class SP extends AudioWorkletProcessor {\n                    constructor(options) {\n                      super(options);\n                    }\n                    process(inputs, outputs) {\n                      const input = inputs[0];\n                      const output = [];\n                      for (let channel = 0; channel < input.length; channel += 1) {\n                        output[channel] = input[channel];\n                      }\n                      this.port.postMessage(output[0]);\n                      return true;\n                    }\n                  }\n                  registerProcessor('speech-processor', SP);";
                var blob = new Blob([
                    workletScript
                ], {
                    type: "application/javascript; charset=utf-8"
                });
                this.privSpeechProcessorScript = URL.createObjectURL(blob);
            }
            context.audioWorklet.addModule(this.privSpeechProcessorScript).then(function() {
                var workletNode = new AudioWorkletNode(context, "speech-processor");
                workletNode.port.onmessage = function(ev) {
                    var inputFrame = ev.data;
                    if (outputStream && !outputStream.isClosed) {
                        var waveFrame = waveStreamEncoder.encode(inputFrame);
                        if (!!waveFrame) outputStream.writeStreamChunk({
                            buffer: waveFrame,
                            isEnd: false,
                            timeReceived: Date.now()
                        });
                    }
                };
                micInput.connect(workletNode);
                workletNode.connect(context.destination);
                _this.privMediaResources = {
                    scriptProcessorNode: workletNode,
                    source: micInput,
                    stream: mediaStream
                };
            }).catch(function() {
                attachScriptProcessor();
            });
        } else try {
            attachScriptProcessor();
        } catch (err) {
            throw new Error("Unable to start audio worklet node for PCMRecorder: " + err);
        }
    };
    PcmRecorder.prototype.releaseMediaResources = function(context) {
        if (this.privMediaResources) {
            if (this.privMediaResources.scriptProcessorNode) {
                this.privMediaResources.scriptProcessorNode.disconnect(context.destination);
                this.privMediaResources.scriptProcessorNode = null;
            }
            if (this.privMediaResources.source) {
                this.privMediaResources.source.disconnect();
                if (this.privStopInputOnRelease) this.privMediaResources.stream.getTracks().forEach(function(track) {
                    return track.stop();
                });
                this.privMediaResources.source = null;
            }
        }
    };
    PcmRecorder.prototype.setWorkletUrl = function(url) {
        this.privSpeechProcessorScript = url;
    };
    return PcmRecorder;
}();
exports.PcmRecorder = PcmRecorder;

},{"c4eb0468a1b1bf40":"5Bedw"}],"bs0H1":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebsocketConnection = void 0;
var Exports_1 = require("c8d0f076274d1e7");
var WebsocketMessageAdapter_1 = require("19710e5d8a0b6a72");
var WebsocketConnection = /** @class */ function() {
    function WebsocketConnection(uri, queryParameters, headers, messageFormatter, proxyInfo, enableCompression, connectionId) {
        if (enableCompression === void 0) enableCompression = false;
        this.privIsDisposed = false;
        if (!uri) throw new Exports_1.ArgumentNullError("uri");
        if (!messageFormatter) throw new Exports_1.ArgumentNullError("messageFormatter");
        this.privMessageFormatter = messageFormatter;
        var queryParams = "";
        var i = 0;
        if (queryParameters) {
            for(var paramName in queryParameters)if (paramName) {
                queryParams += i === 0 && uri.indexOf("?") === -1 ? "?" : "&";
                var key = encodeURIComponent(paramName);
                queryParams += key;
                var val = queryParameters[paramName];
                if (val) {
                    val = encodeURIComponent(val);
                    queryParams += "=" + val;
                }
                i++;
            }
        }
        if (headers) {
            for(var headerName in headers)if (headerName) {
                queryParams += i === 0 && uri.indexOf("?") === -1 ? "?" : "&";
                var val = encodeURIComponent(headers[headerName]);
                queryParams += headerName + "=" + val;
                i++;
            }
        }
        this.privUri = uri + queryParams;
        this.privId = connectionId ? connectionId : Exports_1.createNoDashGuid();
        this.privConnectionMessageAdapter = new WebsocketMessageAdapter_1.WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, proxyInfo, headers, enableCompression);
    }
    WebsocketConnection.prototype.dispose = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.privIsDisposed = true;
                        if (!this.privConnectionMessageAdapter) return [
                            3 /*break*/ ,
                            2
                        ];
                        return [
                            4 /*yield*/ ,
                            this.privConnectionMessageAdapter.close()
                        ];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    WebsocketConnection.prototype.isDisposed = function() {
        return this.privIsDisposed;
    };
    Object.defineProperty(WebsocketConnection.prototype, "id", {
        get: function() {
            return this.privId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebsocketConnection.prototype, "uri", {
        get: function() {
            return this.privUri;
        },
        enumerable: false,
        configurable: true
    });
    WebsocketConnection.prototype.state = function() {
        return this.privConnectionMessageAdapter.state;
    };
    WebsocketConnection.prototype.open = function() {
        return this.privConnectionMessageAdapter.open();
    };
    WebsocketConnection.prototype.send = function(message) {
        return this.privConnectionMessageAdapter.send(message);
    };
    WebsocketConnection.prototype.read = function() {
        return this.privConnectionMessageAdapter.read();
    };
    Object.defineProperty(WebsocketConnection.prototype, "events", {
        get: function() {
            return this.privConnectionMessageAdapter.events;
        },
        enumerable: false,
        configurable: true
    });
    return WebsocketConnection;
}();
exports.WebsocketConnection = WebsocketConnection;

},{"c8d0f076274d1e7":"5Bedw","19710e5d8a0b6a72":"9VGwj"}],"9VGwj":[function(require,module,exports) {
var Buffer = require("656f8a03d79ae67c").Buffer;
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebsocketMessageAdapter = void 0;
var net = __importStar(require("9210276afd6f31bd"));
var tls = __importStar(require("6c571fbc5326012e"));
var agent_base_1 = __importDefault(require("970a83ff70cc3674"));
var https_proxy_agent_1 = __importDefault(require("25f7940df6555e4c"));
var ws_1 = __importDefault(require("9ff7cf924f5c92b6"));
var HeaderNames_1 = require("135a9889fe5ca436");
var Exports_1 = require("1db6ee6d7104a51f");
var WebsocketMessageAdapter = /** @class */ function() {
    function WebsocketMessageAdapter(uri, connectionId, messageFormatter, proxyInfo, headers, enableCompression) {
        if (!uri) throw new Exports_1.ArgumentNullError("uri");
        if (!messageFormatter) throw new Exports_1.ArgumentNullError("messageFormatter");
        this.proxyInfo = proxyInfo;
        this.privConnectionEvents = new Exports_1.EventSource();
        this.privConnectionId = connectionId;
        this.privMessageFormatter = messageFormatter;
        this.privConnectionState = Exports_1.ConnectionState.None;
        this.privUri = uri;
        this.privHeaders = headers;
        this.privEnableCompression = enableCompression;
        // Add the connection ID to the headers
        this.privHeaders[HeaderNames_1.HeaderNames.ConnectionId] = this.privConnectionId;
        this.privLastErrorReceived = "";
    }
    Object.defineProperty(WebsocketMessageAdapter.prototype, "state", {
        get: function() {
            return this.privConnectionState;
        },
        enumerable: false,
        configurable: true
    });
    WebsocketMessageAdapter.prototype.open = function() {
        var _this = this;
        if (this.privConnectionState === Exports_1.ConnectionState.Disconnected) return Promise.reject("Cannot open a connection that is in " + this.privConnectionState + " state");
        if (this.privConnectionEstablishDeferral) return this.privConnectionEstablishDeferral.promise;
        this.privConnectionEstablishDeferral = new Exports_1.Deferred();
        this.privCertificateValidatedDeferral = new Exports_1.Deferred();
        this.privConnectionState = Exports_1.ConnectionState.Connecting;
        try {
            if (typeof WebSocket !== "undefined" && !WebsocketMessageAdapter.forceNpmWebSocket) {
                // Browser handles cert checks.
                this.privCertificateValidatedDeferral.resolve();
                this.privWebsocketClient = new WebSocket(this.privUri);
            } else {
                var options = {
                    headers: this.privHeaders,
                    perMessageDeflate: this.privEnableCompression
                };
                // The ocsp library will handle validation for us and fail the connection if needed.
                this.privCertificateValidatedDeferral.resolve();
                options.agent = this.getAgent();
                // Workaround for https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/465
                // Which is root caused by https://github.com/TooTallNate/node-agent-base/issues/61
                var uri = new URL(this.privUri);
                var protocol = uri.protocol;
                if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === "wss:") protocol = "https:";
                else if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === "ws:") protocol = "http:";
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                options.agent.protocol = protocol;
                this.privWebsocketClient = new ws_1.default(this.privUri, options);
            }
            this.privWebsocketClient.binaryType = "arraybuffer";
            this.privReceivingMessageQueue = new Exports_1.Queue();
            this.privDisconnectDeferral = new Exports_1.Deferred();
            this.privSendMessageQueue = new Exports_1.Queue();
            this.processSendQueue().catch(function(reason) {
                Exports_1.Events.instance.onEvent(new Exports_1.BackgroundEvent(reason));
            });
        } catch (error) {
            this.privConnectionEstablishDeferral.resolve(new Exports_1.ConnectionOpenResponse(500, error));
            return this.privConnectionEstablishDeferral.promise;
        }
        this.onEvent(new Exports_1.ConnectionStartEvent(this.privConnectionId, this.privUri));
        this.privWebsocketClient.onopen = function() {
            _this.privCertificateValidatedDeferral.promise.then(function() {
                _this.privConnectionState = Exports_1.ConnectionState.Connected;
                _this.onEvent(new Exports_1.ConnectionEstablishedEvent(_this.privConnectionId));
                _this.privConnectionEstablishDeferral.resolve(new Exports_1.ConnectionOpenResponse(200, ""));
            }, function(error) {
                _this.privConnectionEstablishDeferral.reject(error);
            });
        };
        this.privWebsocketClient.onerror = function(e) {
            _this.onEvent(new Exports_1.ConnectionErrorEvent(_this.privConnectionId, e.message, e.type));
            _this.privLastErrorReceived = e.message;
        };
        this.privWebsocketClient.onclose = function(e) {
            if (_this.privConnectionState === Exports_1.ConnectionState.Connecting) {
                _this.privConnectionState = Exports_1.ConnectionState.Disconnected;
                // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));
                _this.privConnectionEstablishDeferral.resolve(new Exports_1.ConnectionOpenResponse(e.code, e.reason + " " + _this.privLastErrorReceived));
            } else {
                _this.privConnectionState = Exports_1.ConnectionState.Disconnected;
                _this.privWebsocketClient = null;
                _this.onEvent(new Exports_1.ConnectionClosedEvent(_this.privConnectionId, e.code, e.reason));
            }
            _this.onClose(e.code, e.reason).catch(function(reason) {
                Exports_1.Events.instance.onEvent(new Exports_1.BackgroundEvent(reason));
            });
        };
        this.privWebsocketClient.onmessage = function(e) {
            var networkReceivedTime = new Date().toISOString();
            if (_this.privConnectionState === Exports_1.ConnectionState.Connected) {
                var deferred_1 = new Exports_1.Deferred();
                // let id = ++this.idCounter;
                _this.privReceivingMessageQueue.enqueueFromPromise(deferred_1.promise);
                if (e.data instanceof ArrayBuffer) {
                    var rawMessage = new Exports_1.RawWebsocketMessage(Exports_1.MessageType.Binary, e.data);
                    _this.privMessageFormatter.toConnectionMessage(rawMessage).then(function(connectionMessage) {
                        _this.onEvent(new Exports_1.ConnectionMessageReceivedEvent(_this.privConnectionId, networkReceivedTime, connectionMessage));
                        deferred_1.resolve(connectionMessage);
                    }, function(error) {
                        // TODO: Events for these ?
                        deferred_1.reject("Invalid binary message format. Error: " + error);
                    });
                } else {
                    var rawMessage = new Exports_1.RawWebsocketMessage(Exports_1.MessageType.Text, e.data);
                    _this.privMessageFormatter.toConnectionMessage(rawMessage).then(function(connectionMessage) {
                        _this.onEvent(new Exports_1.ConnectionMessageReceivedEvent(_this.privConnectionId, networkReceivedTime, connectionMessage));
                        deferred_1.resolve(connectionMessage);
                    }, function(error) {
                        // TODO: Events for these ?
                        deferred_1.reject("Invalid text message format. Error: " + error);
                    });
                }
            }
        };
        return this.privConnectionEstablishDeferral.promise;
    };
    WebsocketMessageAdapter.prototype.send = function(message) {
        if (this.privConnectionState !== Exports_1.ConnectionState.Connected) return Promise.reject("Cannot send on connection that is in " + Exports_1.ConnectionState[this.privConnectionState] + " state");
        var messageSendStatusDeferral = new Exports_1.Deferred();
        var messageSendDeferral = new Exports_1.Deferred();
        this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);
        this.privMessageFormatter.fromConnectionMessage(message).then(function(rawMessage) {
            messageSendDeferral.resolve({
                Message: message,
                RawWebsocketMessage: rawMessage,
                sendStatusDeferral: messageSendStatusDeferral
            });
        }, function(error) {
            messageSendDeferral.reject("Error formatting the message. " + error);
        });
        return messageSendStatusDeferral.promise;
    };
    WebsocketMessageAdapter.prototype.read = function() {
        if (this.privConnectionState !== Exports_1.ConnectionState.Connected) return Promise.reject("Cannot read on connection that is in " + this.privConnectionState + " state");
        return this.privReceivingMessageQueue.dequeue();
    };
    WebsocketMessageAdapter.prototype.close = function(reason) {
        if (this.privWebsocketClient) {
            if (this.privConnectionState !== Exports_1.ConnectionState.Disconnected) this.privWebsocketClient.close(1000, reason ? reason : "Normal closure by client");
        } else return Promise.resolve();
        return this.privDisconnectDeferral.promise;
    };
    Object.defineProperty(WebsocketMessageAdapter.prototype, "events", {
        get: function() {
            return this.privConnectionEvents;
        },
        enumerable: false,
        configurable: true
    });
    WebsocketMessageAdapter.prototype.sendRawMessage = function(sendItem) {
        try {
            // indicates we are draining the queue and it came with no message;
            if (!sendItem) return Promise.resolve();
            this.onEvent(new Exports_1.ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message));
            // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing
            if (this.isWebsocketOpen) // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);
            else return Promise.reject("websocket send error: Websocket not ready " + this.privConnectionId + " " + sendItem.Message.id + " " + new Error().stack);
            return Promise.resolve();
        } catch (e) {
            return Promise.reject("websocket send error: " + e);
        }
    };
    WebsocketMessageAdapter.prototype.onClose = function(code, reason) {
        return __awaiter(this, void 0, void 0, function() {
            var closeReason;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        closeReason = "Connection closed. " + code + ": " + reason;
                        this.privConnectionState = Exports_1.ConnectionState.Disconnected;
                        this.privDisconnectDeferral.resolve();
                        return [
                            4 /*yield*/ ,
                            this.privReceivingMessageQueue.drainAndDispose(function() {
                            // TODO: Events for these ?
                            // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));
                            }, closeReason)
                        ];
                    case 1:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            this.privSendMessageQueue.drainAndDispose(function(pendingSendItem) {
                                pendingSendItem.sendStatusDeferral.reject(closeReason);
                            }, closeReason)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    WebsocketMessageAdapter.prototype.processSendQueue = function() {
        return __awaiter(this, void 0, void 0, function() {
            var itemToSend, sendItem, sendError_1;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        itemToSend = this.privSendMessageQueue.dequeue();
                        return [
                            4 /*yield*/ ,
                            itemToSend
                        ];
                    case 1:
                        sendItem = _a.sent();
                        // indicates we are draining the queue and it came with no message;
                        if (!sendItem) return [
                            2 /*return*/ 
                        ];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([
                            2,
                            4,
                            ,
                            5
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.sendRawMessage(sendItem)
                        ];
                    case 3:
                        _a.sent();
                        sendItem.sendStatusDeferral.resolve();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 4:
                        sendError_1 = _a.sent();
                        sendItem.sendStatusDeferral.reject(sendError_1);
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 5:
                        return [
                            3 /*break*/ ,
                            0
                        ];
                    case 6:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    WebsocketMessageAdapter.prototype.onEvent = function(event) {
        this.privConnectionEvents.onEvent(event);
        Exports_1.Events.instance.onEvent(event);
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    WebsocketMessageAdapter.prototype.getAgent = function() {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var agent = new agent_base_1.default.Agent(this.createConnection);
        if (this.proxyInfo !== undefined && this.proxyInfo.HostName !== undefined && this.proxyInfo.Port > 0) agent.proxyInfo = this.proxyInfo;
        return agent;
    };
    WebsocketMessageAdapter.GetProxyAgent = function(proxyInfo) {
        var httpProxyOptions = {
            host: proxyInfo.HostName,
            port: proxyInfo.Port
        };
        if (!!proxyInfo.UserName) httpProxyOptions.headers = {
            "Proxy-Authentication": "Basic " + new Buffer(proxyInfo.UserName + ":" + (proxyInfo.Password === undefined ? "" : proxyInfo.Password)).toString("base64")
        };
        else httpProxyOptions.headers = {};
        httpProxyOptions.headers.requestOCSP = "true";
        var httpProxyAgent = new https_proxy_agent_1.default(httpProxyOptions);
        return httpProxyAgent;
    };
    WebsocketMessageAdapter.prototype.createConnection = function(request, options) {
        var socketPromise;
        options = __assign(__assign({}, options), {
            requestOCSP: true,
            servername: options.host
        });
        if (!!this.proxyInfo) {
            var httpProxyAgent = WebsocketMessageAdapter.GetProxyAgent(this.proxyInfo);
            var baseAgent_1 = httpProxyAgent;
            socketPromise = new Promise(function(resolve, reject) {
                baseAgent_1.callback(request, options, function(error, socket) {
                    if (!!error) reject(error);
                    else resolve(socket);
                });
            });
        } else if (!!options.secureEndpoint) socketPromise = Promise.resolve(tls.connect(options));
        else socketPromise = Promise.resolve(net.connect(options));
        return socketPromise;
    };
    Object.defineProperty(WebsocketMessageAdapter.prototype, "isWebsocketOpen", {
        get: function() {
            return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;
        },
        enumerable: false,
        configurable: true
    });
    WebsocketMessageAdapter.forceNpmWebSocket = false;
    return WebsocketMessageAdapter;
}();
exports.WebsocketMessageAdapter = WebsocketMessageAdapter;

},{"656f8a03d79ae67c":"fYxS4","9210276afd6f31bd":"jhUEF","6c571fbc5326012e":"jhUEF","970a83ff70cc3674":"jhUEF","25f7940df6555e4c":"jhUEF","9ff7cf924f5c92b6":"jhUEF","135a9889fe5ca436":"bNYHA","1db6ee6d7104a51f":"5Bedw"}],"a8xgF":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReplayableAudioNode = void 0;
var ReplayableAudioNode = /** @class */ function() {
    function ReplayableAudioNode(audioSource, bytesPerSecond) {
        this.privBuffers = [];
        this.privReplayOffset = 0;
        this.privLastShrinkOffset = 0;
        this.privBufferStartOffset = 0;
        this.privBufferSerial = 0;
        this.privBufferedBytes = 0;
        this.privReplay = false;
        this.privLastChunkAcquiredTime = 0;
        this.privAudioNode = audioSource;
        this.privBytesPerSecond = bytesPerSecond;
    }
    ReplayableAudioNode.prototype.id = function() {
        return this.privAudioNode.id();
    };
    // Reads and returns the next chunk of audio buffer.
    // If replay of existing buffers are needed, read() will first seek and replay
    // existing content, and upoin completion it will read new content from the underlying
    // audio node, saving that content into the replayable buffers.
    ReplayableAudioNode.prototype.read = function() {
        var _this = this;
        // if there is a replay request to honor.
        if (!!this.privReplay && this.privBuffers.length !== 0) {
            // Find the start point in the buffers.
            // Offsets are in 100ns increments.
            // So how many bytes do we need to seek to get the right offset?
            var offsetToSeek = this.privReplayOffset - this.privBufferStartOffset;
            var bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);
            if (0 !== bytesToSeek % 2) bytesToSeek++;
            var i = 0;
            while(i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength)bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;
            if (i < this.privBuffers.length) {
                var retVal = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);
                this.privReplayOffset += retVal.byteLength / this.privBytesPerSecond * 1e+7;
                // If we've reached the end of the buffers, stop replaying.
                if (i === this.privBuffers.length - 1) this.privReplay = false;
                return Promise.resolve({
                    buffer: retVal,
                    isEnd: false,
                    timeReceived: this.privBuffers[i].chunk.timeReceived
                });
            }
        }
        return this.privAudioNode.read().then(function(result) {
            if (result && result.buffer) {
                _this.privBuffers.push(new BufferEntry(result, _this.privBufferSerial++, _this.privBufferedBytes));
                _this.privBufferedBytes += result.buffer.byteLength;
            }
            return result;
        });
    };
    ReplayableAudioNode.prototype.detach = function() {
        this.privBuffers = undefined;
        return this.privAudioNode.detach();
    };
    ReplayableAudioNode.prototype.replay = function() {
        if (this.privBuffers && 0 !== this.privBuffers.length) {
            this.privReplay = true;
            this.privReplayOffset = this.privLastShrinkOffset;
        }
    };
    // Shrinks the existing audio buffers to start at the new offset, or at the
    // beginning of the buffer closest to the requested offset.
    // A replay request will start from the last shrink point.
    ReplayableAudioNode.prototype.shrinkBuffers = function(offset) {
        if (this.privBuffers === undefined || this.privBuffers.length === 0) return;
        this.privLastShrinkOffset = offset;
        // Find the start point in the buffers.
        // Offsets are in 100ns increments.
        // So how many bytes do we need to seek to get the right offset?
        var offsetToSeek = offset - this.privBufferStartOffset;
        var bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);
        var i = 0;
        while(i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength)bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;
        this.privBufferStartOffset = Math.round(offset - bytesToSeek / this.privBytesPerSecond * 1e+7);
        this.privBuffers = this.privBuffers.slice(i);
    };
    // Finds the time a buffer of audio was first seen by offset.
    ReplayableAudioNode.prototype.findTimeAtOffset = function(offset) {
        if (offset < this.privBufferStartOffset || this.privBuffers === undefined) return 0;
        for(var _i = 0, _a = this.privBuffers; _i < _a.length; _i++){
            var value = _a[_i];
            var startOffset = value.byteOffset / this.privBytesPerSecond * 1e7;
            var endOffset = startOffset + value.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;
            if (offset >= startOffset && offset <= endOffset) return value.chunk.timeReceived;
        }
        return 0;
    };
    return ReplayableAudioNode;
}();
exports.ReplayableAudioNode = ReplayableAudioNode;
// Primary use of this class is to help debugging problems with the replay
// code. If the memory cost of alloc / dealloc gets too much, drop it and just use
// the ArrayBuffer directly.
var BufferEntry = /** @class */ function() {
    function BufferEntry(chunk, serial, byteOffset) {
        this.chunk = chunk;
        this.serial = serial;
        this.byteOffset = byteOffset;
    }
    return BufferEntry;
}();

},{}],"jQVwA":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProxyInfo = void 0;
var Exports_1 = require("7bd334d8f2eb5ca8");
var ProxyInfo = /** @class */ function() {
    function ProxyInfo(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
        this.privProxyHostName = proxyHostName;
        this.privProxyPort = proxyPort;
        this.privProxyUserName = proxyUserName;
        this.privProxyPassword = proxyPassword;
    }
    ProxyInfo.fromParameters = function(parameters) {
        return new ProxyInfo(parameters.getProperty(Exports_1.PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(parameters.getProperty(Exports_1.PropertyId.SpeechServiceConnection_ProxyPort), 10), parameters.getProperty(Exports_1.PropertyId.SpeechServiceConnection_ProxyUserName), parameters.getProperty(Exports_1.PropertyId.SpeechServiceConnection_ProxyPassword));
    };
    ProxyInfo.fromRecognizerConfig = function(config) {
        return this.fromParameters(config.parameters);
    };
    Object.defineProperty(ProxyInfo.prototype, "HostName", {
        get: function() {
            return this.privProxyHostName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ProxyInfo.prototype, "Port", {
        get: function() {
            return this.privProxyPort;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ProxyInfo.prototype, "UserName", {
        get: function() {
            return this.privProxyUserName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ProxyInfo.prototype, "Password", {
        get: function() {
            return this.privProxyPassword;
        },
        enumerable: false,
        configurable: true
    });
    return ProxyInfo;
}();
exports.ProxyInfo = ProxyInfo;

},{"7bd334d8f2eb5ca8":"hxkc3"}],"dZptl":[function(require,module,exports) {
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RestMessageAdapter = exports.RestRequestType = void 0;
var bent_1 = __importDefault(require("9dae408812694e1c"));
var Exports_1 = require("72939a64a4a57535");
var RestRequestType;
(function(RestRequestType) {
    RestRequestType["Get"] = "GET";
    RestRequestType["Post"] = "POST";
    RestRequestType["Delete"] = "DELETE";
    RestRequestType["File"] = "file";
})(RestRequestType = exports.RestRequestType || (exports.RestRequestType = {}));
// accept rest operations via request method and return abstracted objects from server response
var RestMessageAdapter = /** @class */ function() {
    function RestMessageAdapter(configParams) {
        if (!configParams) throw new Exports_1.ArgumentNullError("configParams");
        this.privHeaders = configParams.headers;
        this.privIgnoreCache = configParams.ignoreCache;
    }
    RestMessageAdapter.extractHeaderValue = function(headerKey, headers) {
        var headerValue = "";
        try {
            var arr = headers.trim().split(/[\r\n]+/);
            var headerMap_1 = {};
            arr.forEach(function(line) {
                var parts = line.split(": ");
                var header = parts.shift().toLowerCase();
                var value = parts.join(": ");
                headerMap_1[header] = value;
            });
            headerValue = headerMap_1[headerKey.toLowerCase()];
        } catch (e) {
        // ignore the error
        }
        return headerValue;
    };
    Object.defineProperty(RestMessageAdapter.prototype, "options", {
        set: function(configParams) {
            this.privHeaders = configParams.headers;
            this.privIgnoreCache = configParams.ignoreCache;
        },
        enumerable: false,
        configurable: true
    });
    RestMessageAdapter.prototype.setHeaders = function(key, value) {
        this.privHeaders[key] = value;
    };
    RestMessageAdapter.prototype.request = function(method, uri, queryParams, body) {
        var _this = this;
        if (queryParams === void 0) queryParams = {};
        if (body === void 0) body = null;
        var responseReceivedDeferral = new Exports_1.Deferred();
        var requestCommand = method === RestRequestType.File ? "POST" : method;
        var handleRestResponse = function(data, j) {
            if (j === void 0) j = {};
            var d = data;
            return {
                data: JSON.stringify(j),
                headers: JSON.stringify(data.headers),
                json: j,
                ok: data.statusCode >= 200 && data.statusCode < 300,
                status: data.statusCode,
                statusText: j.error ? j.error.message : d.statusText ? d.statusText : d.statusMessage
            };
        };
        var send = function(postData) {
            var sendRequest = bent_1.default(uri, requestCommand, _this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404);
            var params = _this.queryParams(queryParams) === "" ? "" : "?" + _this.queryParams(queryParams);
            sendRequest(params, postData).then(function(data) {
                return __awaiter(_this, void 0, void 0, function() {
                    var j, _a;
                    return __generator(this, function(_b) {
                        switch(_b.label){
                            case 0:
                                if (!(method === RestRequestType.Delete || data.statusCode === 204)) return [
                                    3 /*break*/ ,
                                    1
                                ];
                                // No JSON from Delete and reset (204) operations
                                responseReceivedDeferral.resolve(handleRestResponse(data));
                                return [
                                    3 /*break*/ ,
                                    4
                                ];
                            case 1:
                                _b.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                return [
                                    4 /*yield*/ ,
                                    data.json()
                                ];
                            case 2:
                                j = _b.sent();
                                responseReceivedDeferral.resolve(handleRestResponse(data, j));
                                return [
                                    3 /*break*/ ,
                                    4
                                ];
                            case 3:
                                _a = _b.sent();
                                responseReceivedDeferral.resolve(handleRestResponse(data));
                                return [
                                    3 /*break*/ ,
                                    4
                                ];
                            case 4:
                                return [
                                    2 /*return*/ 
                                ];
                        }
                    });
                });
            }).catch(function(error) {
                responseReceivedDeferral.reject(error);
            });
        };
        if (this.privIgnoreCache) this.privHeaders["Cache-Control"] = "no-cache";
        if (method === RestRequestType.Post && body) {
            this.privHeaders["content-type"] = "application/json";
            this.privHeaders["Content-Type"] = "application/json";
        }
        send(body);
        return responseReceivedDeferral.promise;
    };
    RestMessageAdapter.prototype.queryParams = function(params) {
        if (params === void 0) params = {};
        return Object.keys(params).map(function(k) {
            return encodeURIComponent(k) + "=" + encodeURIComponent(params[k]);
        }).join("&");
    };
    return RestMessageAdapter;
}();
exports.RestMessageAdapter = RestMessageAdapter;

},{"9dae408812694e1c":"gwJmm","72939a64a4a57535":"5Bedw"}],"gwJmm":[function(require,module,exports) {
"use strict";
/* global fetch, btoa, Headers */ const core = require("d383699627ffef3a");
class StatusError extends Error {
    constructor(res, ...params){
        super(...params);
        if (Error.captureStackTrace) Error.captureStackTrace(this, StatusError);
        this.name = "StatusError";
        this.message = res.statusMessage;
        this.statusCode = res.status;
        this.res = res;
        this.json = res.json.bind(res);
        this.text = res.text.bind(res);
        this.arrayBuffer = res.arrayBuffer.bind(res);
        let buffer;
        const get = ()=>{
            if (!buffer) buffer = this.arrayBuffer();
            return buffer;
        };
        Object.defineProperty(this, "responseBody", {
            get
        });
        // match Node.js headers object
        this.headers = {};
        for (const [key, value] of res.headers.entries())this.headers[key.toLowerCase()] = value;
    }
}
const mkrequest = (statusCodes, method, encoding, headers, baseurl)=>async (_url, body, _headers = {})=>{
        _url = baseurl + (_url || "");
        let parsed = new URL(_url);
        if (!headers) headers = {};
        if (parsed.username) {
            headers.Authorization = "Basic " + btoa(parsed.username + ":" + parsed.password);
            parsed = new URL(parsed.protocol + "//" + parsed.host + parsed.pathname + parsed.search);
        }
        if (parsed.protocol !== "https:" && parsed.protocol !== "http:") throw new Error(`Unknown protocol, ${parsed.protocol}`);
        if (body) {
            if (body instanceof ArrayBuffer || ArrayBuffer.isView(body) || typeof body === "string") ;
            else if (typeof body === "object") {
                body = JSON.stringify(body);
                headers["Content-Type"] = "application/json";
            } else throw new Error("Unknown body type.");
        }
        _headers = new Headers({
            ...headers || {},
            ..._headers
        });
        const resp = await fetch(parsed, {
            method,
            headers: _headers,
            body
        });
        resp.statusCode = resp.status;
        if (!statusCodes.has(resp.status)) throw new StatusError(resp);
        if (encoding === "json") return resp.json();
        else if (encoding === "buffer") return resp.arrayBuffer();
        else if (encoding === "string") return resp.text();
        else return resp;
    };
module.exports = core(mkrequest);

},{"d383699627ffef3a":"lsYKK"}],"lsYKK":[function(require,module,exports) {
"use strict";
const encodings = new Set([
    "json",
    "buffer",
    "string"
]);
module.exports = (mkrequest)=>(...args)=>{
        const statusCodes = new Set();
        let method;
        let encoding;
        let headers;
        let baseurl = "";
        args.forEach((arg)=>{
            if (typeof arg === "string") {
                if (arg.toUpperCase() === arg) {
                    if (method) {
                        const msg = `Can't set method to ${arg}, already set to ${method}.`;
                        throw new Error(msg);
                    } else method = arg;
                } else if (arg.startsWith("http:") || arg.startsWith("https:")) baseurl = arg;
                else {
                    if (encodings.has(arg)) encoding = arg;
                    else throw new Error(`Unknown encoding, ${arg}`);
                }
            } else if (typeof arg === "number") statusCodes.add(arg);
            else if (typeof arg === "object") {
                if (Array.isArray(arg) || arg instanceof Set) arg.forEach((code)=>statusCodes.add(code));
                else {
                    if (headers) throw new Error("Cannot set headers twice.");
                    headers = arg;
                }
            } else throw new Error(`Unknown type: ${typeof arg}`);
        });
        if (!method) method = "GET";
        if (statusCodes.size === 0) statusCodes.add(200);
        return mkrequest(statusCodes, method, encoding, headers, baseurl);
    };

},{}],"58iBd":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("469113402c337680");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _default;
var _pDeferEs = _interopRequireDefault(require("7d7fd2259918e43e"));
function _default() {
    var shiftDeferred;
    var queue = [];
    var push = function push(value) {
        if (shiftDeferred) {
            var _shiftDeferred = shiftDeferred, resolve = _shiftDeferred.resolve;
            shiftDeferred = null;
            resolve(value);
        } else queue.push(value);
    };
    var shift = function shift() {
        if (queue.length) return Promise.resolve(queue.shift());
        return (shiftDeferred || (shiftDeferred = (0, _pDeferEs.default)())).promise;
    };
    return {
        push: push,
        shift: shift
    };
}

},{"469113402c337680":"1hUHf","7d7fd2259918e43e":"dhDU2"}],"9CYwx":[function(require,module,exports) {
"use strict";
var _interopRequireDefault = require("c50352174de1ff77");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("6a993dfe0508a479"));
var _createClass2 = _interopRequireDefault(require("417263266a82568d"));
/* eslint class-methods-use-this: "off" */ var _default = /*#__PURE__*/ function() {
    function _default() {
        (0, _classCallCheck2.default)(this, _default);
        this._phrases = [];
    }
    (0, _createClass2.default)(_default, [
        {
            key: "addFromString",
            value: function addFromString() {
                throw new Error("JSGF is not supported");
            }
        },
        {
            key: "phrases",
            get: function get() {
                return this._phrases;
            },
            set: function set(value) {
                if (Array.isArray(value)) this._phrases = value;
                else if (typeof value === "string") this._phrases = [
                    value
                ];
                else throw new Error("The provided value is not an array or of type 'string'");
            }
        }
    ]);
    return _default;
}();
exports.default = _default;

},{"c50352174de1ff77":"1hUHf","6a993dfe0508a479":"7zlNi","417263266a82568d":"b694u"}]},["2oZg2","h7u1C"], "h7u1C", "parcelRequireee0b")

//# sourceMappingURL=index.b71e74eb.js.map
